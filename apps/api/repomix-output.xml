This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: apps/api
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
apps/
  api/
    migrations/
      meta/
        _journal.json
        0000_snapshot.json
      0000_bumpy_chat.sql
    src/
      rest/
        middleware/
          auth.ts
          db.ts
          index.ts
          primary-read-after-write.ts
          scope.ts
        routers/
          bank-accounts.ts
          customers.ts
          documents.ts
          inbox.ts
          index.ts
          invoices.ts
          notifications.ts
          oauth.ts
          reports.ts
          search.ts
          tags.ts
          teams.ts
          tracker-entries.ts
          tracker-projects.ts
          transactions.ts
          users.ts
        types.ts
      schemas/
        api-keys.ts
        apps.ts
        bank-accounts.ts
        bank-connections.ts
        billing.ts
        customers.ts
        document-tag-assignments.ts
        document-tags.ts
        documents.ts
        inbox-accounts.ts
        inbox.ts
        institutions.ts
        invoice.ts
        notification-settings.ts
        notifications.ts
        oauth-applications.ts
        oauth-flow.ts
        polar.ts
        reports.ts
        search.ts
        short-links.ts
        tags.ts
        team.ts
        tracker-entries.ts
        tracker-projects.ts
        transaction-attachments.ts
        transaction-categories.ts
        transaction-tags.ts
        transactions.ts
        users.ts
      services/
        resend.ts
        supabase.ts
      trpc/
        middleware/
          primary-read-after-write.ts
          team-permission.ts
        routers/
          _app.ts
          api-keys.ts
          apps.ts
          bank-accounts.ts
          bank-connections.ts
          billing.ts
          customers.ts
          document-tag-assignments.ts
          document-tags.ts
          documents.ts
          inbox-accounts.ts
          inbox.ts
          institutions.ts
          invoice-template.ts
          invoice.ts
          notification-settings.ts
          notifications.ts
          oauth-applications.ts
          reports.ts
          search.ts
          short-links.ts
          tags.ts
          team.ts
          tracker-entries.ts
          tracker-projects.ts
          transaction-attachments.ts
          transaction-categories.ts
          transaction-tags.ts
          transactions.ts
          user.ts
        init.ts
      utils/
        auth.ts
        geo.ts
        health.ts
        oauth.ts
        parse.ts
        polar.ts
        scopes.ts
        search-filters.ts
        search.ts
        validate-response.ts
      index.ts
    .dockerignore
    .env-template
    Dockerfile
    fly-preview.yml
    fly.toml
    package.json
    README.md
    tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/api/migrations/meta/_journal.json">
{
  "version": "7",
  "dialect": "postgresql",
  "entries": [
    {
      "idx": 0,
      "version": "7",
      "when": 1747057041667,
      "tag": "0000_bumpy_chat",
      "breakpoints": true
    }
  ]
}
</file>

<file path="apps/api/migrations/meta/0000_snapshot.json">
{
  "id": "00000000-0000-0000-0000-000000000000",
  "prevId": "",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.document_tag_embeddings": {
      "name": "document_tag_embeddings",
      "schema": "",
      "columns": {
        "slug": {
          "name": "slug",
          "type": "text",
          "primaryKey": true,
          "notNull": true
        },
        "embedding": {
          "name": "embedding",
          "type": "vector(1024)",
          "primaryKey": false,
          "notNull": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {
        "document_tag_embeddings_idx": {
          "name": "document_tag_embeddings_idx",
          "columns": [
            {
              "expression": "embedding",
              "asc": true,
              "nulls": "last",
              "opclass": "vector_l2_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "ivfflat",
          "with": {
            "lists": "100"
          }
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {},
      "policies": {
        "Enable insert for authenticated users only": {
          "name": "Enable insert for authenticated users only",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["authenticated"],
          "withCheck": "true"
        }
      },
      "isRLSEnabled": true
    },
    "public.transactions": {
      "name": "transactions",
      "schema": "",
      "columns": {
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "date": {
          "name": "date",
          "type": "date",
          "primaryKey": false,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "method": {
          "name": "method",
          "type": "transactionMethods",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": true
        },
        "amount": {
          "name": "amount",
          "type": "numeric",
          "primaryKey": false,
          "notNull": true
        },
        "currency": {
          "name": "currency",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "assigned_id": {
          "name": "assigned_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "note": {
          "name": "note",
          "type": "varchar",
          "primaryKey": false,
          "notNull": false
        },
        "bank_account_id": {
          "name": "bank_account_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "internal_id": {
          "name": "internal_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "status": {
          "name": "status",
          "type": "transactionStatus",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false,
          "default": "'posted'"
        },
        "category": {
          "name": "category",
          "type": "transactionCategories",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false
        },
        "balance": {
          "name": "balance",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "manual": {
          "name": "manual",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "category_slug": {
          "name": "category_slug",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "base_amount": {
          "name": "base_amount",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "base_currency": {
          "name": "base_currency",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "recurring": {
          "name": "recurring",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false
        },
        "frequency": {
          "name": "frequency",
          "type": "transaction_frequency",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false
        },
        "fts_vector": {
          "name": "fts_vector",
          "type": "tsvector",
          "primaryKey": false,
          "notNull": false,
          "generated": {
            "as": "to_tsvector('english'::regconfig, ((COALESCE(name, ''::text) || ' '::text) || COALESCE(description, ''::text)))",
            "type": "stored"
          }
        },
        "notified": {
          "name": "notified",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "internal": {
          "name": "internal",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        }
      },
      "indexes": {
        "idx_transactions_date": {
          "name": "idx_transactions_date",
          "columns": [
            {
              "expression": "date",
              "asc": true,
              "nulls": "last",
              "opclass": "date_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "idx_transactions_fts": {
          "name": "idx_transactions_fts",
          "columns": [
            {
              "expression": "fts_vector",
              "asc": true,
              "nulls": "last",
              "opclass": "tsvector_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "gin",
          "with": {}
        },
        "idx_transactions_fts_vector": {
          "name": "idx_transactions_fts_vector",
          "columns": [
            {
              "expression": "fts_vector",
              "asc": true,
              "nulls": "last",
              "opclass": "tsvector_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "gin",
          "with": {}
        },
        "idx_transactions_id": {
          "name": "idx_transactions_id",
          "columns": [
            {
              "expression": "id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "idx_transactions_name": {
          "name": "idx_transactions_name",
          "columns": [
            {
              "expression": "name",
              "asc": true,
              "nulls": "last",
              "opclass": "text_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "idx_transactions_name_trigram": {
          "name": "idx_transactions_name_trigram",
          "columns": [
            {
              "expression": "name",
              "asc": true,
              "nulls": "last",
              "opclass": "gin_trgm_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "gin",
          "with": {}
        },
        "idx_transactions_team_id_date_name": {
          "name": "idx_transactions_team_id_date_name",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "date_ops",
              "isExpression": false
            },
            {
              "expression": "date",
              "asc": true,
              "nulls": "last",
              "opclass": "date_ops",
              "isExpression": false
            },
            {
              "expression": "name",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "idx_transactions_team_id_name": {
          "name": "idx_transactions_team_id_name",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            },
            {
              "expression": "name",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "idx_trgm_name": {
          "name": "idx_trgm_name",
          "columns": [
            {
              "expression": "name",
              "asc": true,
              "nulls": "last",
              "opclass": "gist_trgm_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "gist",
          "with": {}
        },
        "transactions_assigned_id_idx": {
          "name": "transactions_assigned_id_idx",
          "columns": [
            {
              "expression": "assigned_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "transactions_bank_account_id_idx": {
          "name": "transactions_bank_account_id_idx",
          "columns": [
            {
              "expression": "bank_account_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "transactions_category_slug_idx": {
          "name": "transactions_category_slug_idx",
          "columns": [
            {
              "expression": "category_slug",
              "asc": true,
              "nulls": "last",
              "opclass": "text_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "transactions_team_id_date_currency_bank_account_id_category_idx": {
          "name": "transactions_team_id_date_currency_bank_account_id_category_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "enum_ops",
              "isExpression": false
            },
            {
              "expression": "date",
              "asc": true,
              "nulls": "last",
              "opclass": "date_ops",
              "isExpression": false
            },
            {
              "expression": "currency",
              "asc": true,
              "nulls": "last",
              "opclass": "text_ops",
              "isExpression": false
            },
            {
              "expression": "bank_account_id",
              "asc": true,
              "nulls": "last",
              "opclass": "date_ops",
              "isExpression": false
            },
            {
              "expression": "category",
              "asc": true,
              "nulls": "last",
              "opclass": "date_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "transactions_team_id_idx": {
          "name": "transactions_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "public_transactions_assigned_id_fkey": {
          "name": "public_transactions_assigned_id_fkey",
          "tableFrom": "transactions",
          "tableTo": "users",
          "schemaTo": "public",
          "columnsFrom": ["assigned_id"],
          "columnsTo": ["id"],
          "onDelete": "set null",
          "onUpdate": "no action"
        },
        "public_transactions_team_id_fkey": {
          "name": "public_transactions_team_id_fkey",
          "tableFrom": "transactions",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "transactions_bank_account_id_fkey": {
          "name": "transactions_bank_account_id_fkey",
          "tableFrom": "transactions",
          "tableTo": "bank_accounts",
          "schemaTo": "public",
          "columnsFrom": ["bank_account_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "transactions_category_slug_team_id_fkey": {
          "name": "transactions_category_slug_team_id_fkey",
          "tableFrom": "transactions",
          "tableTo": "transaction_categories",
          "schemaTo": "public",
          "columnsFrom": ["team_id", "category_slug"],
          "columnsTo": ["team_id", "slug"],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "transactions_internal_id_key": {
          "columns": ["internal_id"],
          "nullsNotDistinct": false,
          "name": "transactions_internal_id_key"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Transactions can be created by a member of the team": {
          "name": "Transactions can be created by a member of the team",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["public"],
          "withCheck": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        },
        "Transactions can be deleted by a member of the team": {
          "name": "Transactions can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["public"]
        },
        "Transactions can be selected by a member of the team": {
          "name": "Transactions can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"]
        },
        "Transactions can be updated by a member of the team": {
          "name": "Transactions can be updated by a member of the team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["public"]
        }
      },
      "isRLSEnabled": true
    },
    "public.tracker_entries": {
      "name": "tracker_entries",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "duration": {
          "name": "duration",
          "type": "bigint",
          "primaryKey": false,
          "notNull": false
        },
        "project_id": {
          "name": "project_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "start": {
          "name": "start",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "stop": {
          "name": "stop",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "assigned_id": {
          "name": "assigned_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "rate": {
          "name": "rate",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "currency": {
          "name": "currency",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "billed": {
          "name": "billed",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "date": {
          "name": "date",
          "type": "date",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {
        "tracker_entries_team_id_idx": {
          "name": "tracker_entries_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "tracker_entries_assigned_id_fkey": {
          "name": "tracker_entries_assigned_id_fkey",
          "tableFrom": "tracker_entries",
          "tableTo": "users",
          "schemaTo": "public",
          "columnsFrom": ["assigned_id"],
          "columnsTo": ["id"],
          "onDelete": "set null",
          "onUpdate": "no action"
        },
        "tracker_entries_project_id_fkey": {
          "name": "tracker_entries_project_id_fkey",
          "tableFrom": "tracker_entries",
          "tableTo": "tracker_projects",
          "schemaTo": "public",
          "columnsFrom": ["project_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "tracker_entries_team_id_fkey": {
          "name": "tracker_entries_team_id_fkey",
          "tableFrom": "tracker_entries",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {},
      "policies": {
        "Entries can be created by a member of the team": {
          "name": "Entries can be created by a member of the team",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["authenticated"],
          "withCheck": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        },
        "Entries can be deleted by a member of the team": {
          "name": "Entries can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["authenticated"]
        },
        "Entries can be selected by a member of the team": {
          "name": "Entries can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["authenticated"]
        },
        "Entries can be updated by a member of the team": {
          "name": "Entries can be updated by a member of the team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["authenticated"]
        }
      },
      "isRLSEnabled": true
    },
    "public.customer_tags": {
      "name": "customer_tags",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "customer_id": {
          "name": "customer_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "tag_id": {
          "name": "tag_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "customer_tags_customer_id_fkey": {
          "name": "customer_tags_customer_id_fkey",
          "tableFrom": "customer_tags",
          "tableTo": "customers",
          "schemaTo": "public",
          "columnsFrom": ["customer_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "customer_tags_tag_id_fkey": {
          "name": "customer_tags_tag_id_fkey",
          "tableFrom": "customer_tags",
          "tableTo": "tags",
          "schemaTo": "public",
          "columnsFrom": ["tag_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "customer_tags_team_id_fkey": {
          "name": "customer_tags_team_id_fkey",
          "tableFrom": "customer_tags",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "unique_customer_tag": {
          "columns": ["customer_id", "tag_id"],
          "nullsNotDistinct": false,
          "name": "unique_customer_tag"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Tags can be handled by a member of the team": {
          "name": "Tags can be handled by a member of the team",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        }
      },
      "isRLSEnabled": true
    },
    "public.inbox_accounts": {
      "name": "inbox_accounts",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "access_token": {
          "name": "access_token",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "refresh_token": {
          "name": "refresh_token",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "last_accessed": {
          "name": "last_accessed",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true
        },
        "provider": {
          "name": "provider",
          "type": "inbox_account_providers",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": true
        },
        "external_id": {
          "name": "external_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "expiry_date": {
          "name": "expiry_date",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true
        },
        "schedule_id": {
          "name": "schedule_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "inbox_accounts_team_id_fkey": {
          "name": "inbox_accounts_team_id_fkey",
          "tableFrom": "inbox_accounts",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "inbox_accounts_email_key": {
          "columns": ["email"],
          "nullsNotDistinct": false,
          "name": "inbox_accounts_email_key"
        },
        "inbox_accounts_external_id_key": {
          "columns": ["external_id"],
          "nullsNotDistinct": false,
          "name": "inbox_accounts_external_id_key"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Inbox accounts can be deleted by a member of the team": {
          "name": "Inbox accounts can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        },
        "Inbox accounts can be selected by a member of the team": {
          "name": "Inbox accounts can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"]
        },
        "Inbox accounts can be updated by a member of the team": {
          "name": "Inbox accounts can be updated by a member of the team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["public"]
        }
      },
      "isRLSEnabled": true
    },
    "public.bank_accounts": {
      "name": "bank_accounts",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "created_by": {
          "name": "created_by",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "currency": {
          "name": "currency",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "bank_connection_id": {
          "name": "bank_connection_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "enabled": {
          "name": "enabled",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true,
          "default": true
        },
        "account_id": {
          "name": "account_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "balance": {
          "name": "balance",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false,
          "default": "'0'"
        },
        "manual": {
          "name": "manual",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "type": {
          "name": "type",
          "type": "account_type",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false
        },
        "base_currency": {
          "name": "base_currency",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "base_balance": {
          "name": "base_balance",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "error_details": {
          "name": "error_details",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "error_retries": {
          "name": "error_retries",
          "type": "smallint",
          "primaryKey": false,
          "notNull": false
        },
        "account_reference": {
          "name": "account_reference",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {
        "bank_accounts_bank_connection_id_idx": {
          "name": "bank_accounts_bank_connection_id_idx",
          "columns": [
            {
              "expression": "bank_connection_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "bank_accounts_created_by_idx": {
          "name": "bank_accounts_created_by_idx",
          "columns": [
            {
              "expression": "created_by",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "bank_accounts_team_id_idx": {
          "name": "bank_accounts_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "bank_accounts_bank_connection_id_fkey": {
          "name": "bank_accounts_bank_connection_id_fkey",
          "tableFrom": "bank_accounts",
          "tableTo": "bank_connections",
          "schemaTo": "public",
          "columnsFrom": ["bank_connection_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "bank_accounts_created_by_fkey": {
          "name": "bank_accounts_created_by_fkey",
          "tableFrom": "bank_accounts",
          "tableTo": "users",
          "schemaTo": "public",
          "columnsFrom": ["created_by"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "public_bank_accounts_team_id_fkey": {
          "name": "public_bank_accounts_team_id_fkey",
          "tableFrom": "bank_accounts",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {},
      "policies": {
        "Bank Accounts can be created by a member of the team": {
          "name": "Bank Accounts can be created by a member of the team",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["public"],
          "withCheck": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        },
        "Bank Accounts can be deleted by a member of the team": {
          "name": "Bank Accounts can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["public"]
        },
        "Bank Accounts can be selected by a member of the team": {
          "name": "Bank Accounts can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"]
        },
        "Bank Accounts can be updated by a member of the team": {
          "name": "Bank Accounts can be updated by a member of the team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["public"]
        }
      },
      "isRLSEnabled": true
    },
    "public.invoices": {
      "name": "invoices",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "due_date": {
          "name": "due_date",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "invoice_number": {
          "name": "invoice_number",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "customer_id": {
          "name": "customer_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "amount": {
          "name": "amount",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "currency": {
          "name": "currency",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "line_items": {
          "name": "line_items",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "payment_details": {
          "name": "payment_details",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "customer_details": {
          "name": "customer_details",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "company_datails": {
          "name": "company_datails",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "note": {
          "name": "note",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "internal_note": {
          "name": "internal_note",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "paid_at": {
          "name": "paid_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "fts": {
          "name": "fts",
          "type": "tsvector",
          "primaryKey": false,
          "notNull": false,
          "generated": {
            "as": "to_tsvector('english'::regconfig, ((COALESCE((amount)::text, ''::text) || ' '::text) || COALESCE(invoice_number, ''::text)))",
            "type": "stored"
          }
        },
        "vat": {
          "name": "vat",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "tax": {
          "name": "tax",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "url": {
          "name": "url",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "file_path": {
          "name": "file_path",
          "type": "text[]",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "invoice_status",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": true,
          "default": "'draft'"
        },
        "viewed_at": {
          "name": "viewed_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "from_details": {
          "name": "from_details",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "issue_date": {
          "name": "issue_date",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "template": {
          "name": "template",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "note_details": {
          "name": "note_details",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "customer_name": {
          "name": "customer_name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "token": {
          "name": "token",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "default": "''"
        },
        "sent_to": {
          "name": "sent_to",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "reminder_sent_at": {
          "name": "reminder_sent_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "discount": {
          "name": "discount",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "file_size": {
          "name": "file_size",
          "type": "bigint",
          "primaryKey": false,
          "notNull": false
        },
        "user_id": {
          "name": "user_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "subtotal": {
          "name": "subtotal",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "top_block": {
          "name": "top_block",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "bottom_block": {
          "name": "bottom_block",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "sent_at": {
          "name": "sent_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "scheduled_at": {
          "name": "scheduled_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "scheduled_job_id": {
          "name": "scheduled_job_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {
        "invoices_created_at_idx": {
          "name": "invoices_created_at_idx",
          "columns": [
            {
              "expression": "created_at",
              "asc": true,
              "nulls": "last",
              "opclass": "timestamptz_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "invoices_fts": {
          "name": "invoices_fts",
          "columns": [
            {
              "expression": "fts",
              "asc": true,
              "nulls": "last",
              "opclass": "tsvector_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "gin",
          "with": {}
        },
        "invoices_team_id_idx": {
          "name": "invoices_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "invoices_created_by_fkey": {
          "name": "invoices_created_by_fkey",
          "tableFrom": "invoices",
          "tableTo": "users",
          "schemaTo": "public",
          "columnsFrom": ["user_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "invoices_customer_id_fkey": {
          "name": "invoices_customer_id_fkey",
          "tableFrom": "invoices",
          "tableTo": "customers",
          "schemaTo": "public",
          "columnsFrom": ["customer_id"],
          "columnsTo": ["id"],
          "onDelete": "set null",
          "onUpdate": "no action"
        },
        "invoices_team_id_fkey": {
          "name": "invoices_team_id_fkey",
          "tableFrom": "invoices",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "invoices_scheduled_job_id_key": {
          "columns": ["scheduled_job_id"],
          "nullsNotDistinct": false,
          "name": "invoices_scheduled_job_id_key"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Invoices can be handled by a member of the team": {
          "name": "Invoices can be handled by a member of the team",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        }
      },
      "isRLSEnabled": true
    },
    "public.customers": {
      "name": "customers",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "country": {
          "name": "country",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "address_line_1": {
          "name": "address_line_1",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "address_line_2": {
          "name": "address_line_2",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "city": {
          "name": "city",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "state": {
          "name": "state",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "zip": {
          "name": "zip",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "note": {
          "name": "note",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "website": {
          "name": "website",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "phone": {
          "name": "phone",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "vat_number": {
          "name": "vat_number",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "country_code": {
          "name": "country_code",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "token": {
          "name": "token",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "default": "''"
        },
        "contact": {
          "name": "contact",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "fts": {
          "name": "fts",
          "type": "tsvector",
          "primaryKey": false,
          "notNull": false,
          "generated": {
            "as": "to_tsvector('english'::regconfig, ((((((((((((((((((COALESCE(name, ''::text) || ' '::text) || COALESCE(contact, ''::text)) || ' '::text) || COALESCE(phone, ''::text)) || ' '::text) || COALESCE(email, ''::text)) || ' '::text) || COALESCE(address_line_1, ''::text)) || ' '::text) || COALESCE(address_line_2, ''::text)) || ' '::text) || COALESCE(city, ''::text)) || ' '::text) || COALESCE(state, ''::text)) || ' '::text) || COALESCE(zip, ''::text)) || ' '::text) || COALESCE(country, ''::text)))",
            "type": "stored"
          }
        }
      },
      "indexes": {
        "customers_fts": {
          "name": "customers_fts",
          "columns": [
            {
              "expression": "fts",
              "asc": true,
              "nulls": "last",
              "opclass": "tsvector_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "gin",
          "with": {}
        }
      },
      "foreignKeys": {
        "customers_team_id_fkey": {
          "name": "customers_team_id_fkey",
          "tableFrom": "customers",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {},
      "policies": {
        "Customers can be handled by members of the team": {
          "name": "Customers can be handled by members of the team",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        }
      },
      "isRLSEnabled": true
    },
    "public.exchange_rates": {
      "name": "exchange_rates",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "base": {
          "name": "base",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "rate": {
          "name": "rate",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "target": {
          "name": "target",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {
        "exchange_rates_base_target_idx": {
          "name": "exchange_rates_base_target_idx",
          "columns": [
            {
              "expression": "base",
              "asc": true,
              "nulls": "last",
              "opclass": "text_ops",
              "isExpression": false
            },
            {
              "expression": "target",
              "asc": true,
              "nulls": "last",
              "opclass": "text_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "unique_rate": {
          "columns": ["base", "target"],
          "nullsNotDistinct": false,
          "name": "unique_rate"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Enable read access for authenticated users": {
          "name": "Enable read access for authenticated users",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"],
          "using": "true"
        }
      },
      "isRLSEnabled": true
    },
    "public.tags": {
      "name": "tags",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {
        "tags_team_id_idx": {
          "name": "tags_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "tags_team_id_fkey": {
          "name": "tags_team_id_fkey",
          "tableFrom": "tags",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "unique_tag_name": {
          "columns": ["team_id", "name"],
          "nullsNotDistinct": false,
          "name": "unique_tag_name"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Tags can be handled by a member of the team": {
          "name": "Tags can be handled by a member of the team",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        }
      },
      "isRLSEnabled": true
    },
    "public.tracker_reports": {
      "name": "tracker_reports",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "link_id": {
          "name": "link_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "short_link": {
          "name": "short_link",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false,
          "default": "gen_random_uuid()"
        },
        "project_id": {
          "name": "project_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false,
          "default": "gen_random_uuid()"
        },
        "created_by": {
          "name": "created_by",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {
        "tracker_reports_team_id_idx": {
          "name": "tracker_reports_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "public_tracker_reports_created_by_fkey": {
          "name": "public_tracker_reports_created_by_fkey",
          "tableFrom": "tracker_reports",
          "tableTo": "users",
          "schemaTo": "public",
          "columnsFrom": ["created_by"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "public_tracker_reports_project_id_fkey": {
          "name": "public_tracker_reports_project_id_fkey",
          "tableFrom": "tracker_reports",
          "tableTo": "tracker_projects",
          "schemaTo": "public",
          "columnsFrom": ["project_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "cascade"
        },
        "tracker_reports_team_id_fkey": {
          "name": "tracker_reports_team_id_fkey",
          "tableFrom": "tracker_reports",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "cascade"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {},
      "policies": {
        "Reports can be handled by a member of the team": {
          "name": "Reports can be handled by a member of the team",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        }
      },
      "isRLSEnabled": true
    },
    "public.invoice_comments": {
      "name": "invoice_comments",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {},
      "policies": {},
      "isRLSEnabled": true
    },
    "public.tracker_project_tags": {
      "name": "tracker_project_tags",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "tracker_project_id": {
          "name": "tracker_project_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "tag_id": {
          "name": "tag_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {
        "tracker_project_tags_team_id_idx": {
          "name": "tracker_project_tags_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "tracker_project_tags_tracker_project_id_tag_id_team_id_idx": {
          "name": "tracker_project_tags_tracker_project_id_tag_id_team_id_idx",
          "columns": [
            {
              "expression": "tracker_project_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            },
            {
              "expression": "tag_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            },
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "project_tags_tag_id_fkey": {
          "name": "project_tags_tag_id_fkey",
          "tableFrom": "tracker_project_tags",
          "tableTo": "tags",
          "schemaTo": "public",
          "columnsFrom": ["tag_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "project_tags_tracker_project_id_fkey": {
          "name": "project_tags_tracker_project_id_fkey",
          "tableFrom": "tracker_project_tags",
          "tableTo": "tracker_projects",
          "schemaTo": "public",
          "columnsFrom": ["tracker_project_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "tracker_project_tags_team_id_fkey": {
          "name": "tracker_project_tags_team_id_fkey",
          "tableFrom": "tracker_project_tags",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "unique_project_tag": {
          "columns": ["tracker_project_id", "tag_id"],
          "nullsNotDistinct": false,
          "name": "unique_project_tag"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Tags can be handled by a member of the team": {
          "name": "Tags can be handled by a member of the team",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        }
      },
      "isRLSEnabled": true
    },
    "public.reports": {
      "name": "reports",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "link_id": {
          "name": "link_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "short_link": {
          "name": "short_link",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "from": {
          "name": "from",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "to": {
          "name": "to",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "type": {
          "name": "type",
          "type": "reportTypes",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false
        },
        "expire_at": {
          "name": "expire_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "currency": {
          "name": "currency",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_by": {
          "name": "created_by",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {
        "reports_team_id_idx": {
          "name": "reports_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "public_reports_created_by_fkey": {
          "name": "public_reports_created_by_fkey",
          "tableFrom": "reports",
          "tableTo": "users",
          "schemaTo": "public",
          "columnsFrom": ["created_by"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "reports_team_id_fkey": {
          "name": "reports_team_id_fkey",
          "tableFrom": "reports",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {},
      "policies": {
        "Reports can be created by a member of the team": {
          "name": "Reports can be created by a member of the team",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["public"],
          "withCheck": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        },
        "Reports can be deleted by a member of the team": {
          "name": "Reports can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["public"]
        },
        "Reports can be selected by a member of the team": {
          "name": "Reports can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"]
        },
        "Reports can be updated by member of team": {
          "name": "Reports can be updated by member of team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["public"]
        }
      },
      "isRLSEnabled": true
    },
    "public.bank_connections": {
      "name": "bank_connections",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "institution_id": {
          "name": "institution_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "expires_at": {
          "name": "expires_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "logo_url": {
          "name": "logo_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "access_token": {
          "name": "access_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "enrollment_id": {
          "name": "enrollment_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "provider": {
          "name": "provider",
          "type": "bank_providers",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false
        },
        "last_accessed": {
          "name": "last_accessed",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "reference_id": {
          "name": "reference_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "connection_status",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false,
          "default": "'connected'"
        },
        "error_details": {
          "name": "error_details",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "error_retries": {
          "name": "error_retries",
          "type": "smallint",
          "primaryKey": false,
          "notNull": false,
          "default": "'0'"
        }
      },
      "indexes": {
        "bank_connections_team_id_idx": {
          "name": "bank_connections_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "bank_connections_team_id_fkey": {
          "name": "bank_connections_team_id_fkey",
          "tableFrom": "bank_connections",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "unique_bank_connections": {
          "columns": ["institution_id", "team_id"],
          "nullsNotDistinct": false,
          "name": "unique_bank_connections"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Bank Connections can be created by a member of the team": {
          "name": "Bank Connections can be created by a member of the team",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["public"],
          "withCheck": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        },
        "Bank Connections can be deleted by a member of the team": {
          "name": "Bank Connections can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["public"]
        },
        "Bank Connections can be selected by a member of the team": {
          "name": "Bank Connections can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"]
        },
        "Bank Connections can be updated by a member of the team": {
          "name": "Bank Connections can be updated by a member of the team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["public"]
        }
      },
      "isRLSEnabled": true
    },
    "public.user_invites": {
      "name": "user_invites",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "role": {
          "name": "role",
          "type": "teamRoles",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false
        },
        "code": {
          "name": "code",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "default": "nanoid(24)"
        },
        "invited_by": {
          "name": "invited_by",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {
        "user_invites_team_id_idx": {
          "name": "user_invites_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "public_user_invites_team_id_fkey": {
          "name": "public_user_invites_team_id_fkey",
          "tableFrom": "user_invites",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "user_invites_invited_by_fkey": {
          "name": "user_invites_invited_by_fkey",
          "tableFrom": "user_invites",
          "tableTo": "users",
          "schemaTo": "public",
          "columnsFrom": ["invited_by"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "unique_team_invite": {
          "columns": ["team_id", "email"],
          "nullsNotDistinct": false,
          "name": "unique_team_invite"
        },
        "user_invites_code_key": {
          "columns": ["code"],
          "nullsNotDistinct": false,
          "name": "user_invites_code_key"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Enable select for users based on email": {
          "name": "Enable select for users based on email",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"],
          "using": "((auth.jwt() ->> 'email'::text) = email)"
        },
        "User Invites can be created by a member of the team": {
          "name": "User Invites can be created by a member of the team",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["public"]
        },
        "User Invites can be deleted by a member of the team": {
          "name": "User Invites can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["public"]
        },
        "User Invites can be deleted by invited email": {
          "name": "User Invites can be deleted by invited email",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["public"]
        },
        "User Invites can be selected by a member of the team": {
          "name": "User Invites can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"]
        },
        "User Invites can be updated by a member of the team": {
          "name": "User Invites can be updated by a member of the team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["public"]
        }
      },
      "isRLSEnabled": true
    },
    "public.document_tags": {
      "name": "document_tags",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "slug": {
          "name": "slug",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "document_tags_team_id_fkey": {
          "name": "document_tags_team_id_fkey",
          "tableFrom": "document_tags",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "unique_slug_per_team": {
          "columns": ["slug", "team_id"],
          "nullsNotDistinct": false,
          "name": "unique_slug_per_team"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Tags can be handled by a member of the team": {
          "name": "Tags can be handled by a member of the team",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        }
      },
      "isRLSEnabled": true
    },
    "public.transaction_tags": {
      "name": "transaction_tags",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "tag_id": {
          "name": "tag_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "transaction_id": {
          "name": "transaction_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {
        "transaction_tags_tag_id_idx": {
          "name": "transaction_tags_tag_id_idx",
          "columns": [
            {
              "expression": "tag_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "transaction_tags_team_id_idx": {
          "name": "transaction_tags_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "transaction_tags_transaction_id_tag_id_team_id_idx": {
          "name": "transaction_tags_transaction_id_tag_id_team_id_idx",
          "columns": [
            {
              "expression": "transaction_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            },
            {
              "expression": "tag_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            },
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "transaction_tags_tag_id_fkey": {
          "name": "transaction_tags_tag_id_fkey",
          "tableFrom": "transaction_tags",
          "tableTo": "tags",
          "schemaTo": "public",
          "columnsFrom": ["tag_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "transaction_tags_team_id_fkey": {
          "name": "transaction_tags_team_id_fkey",
          "tableFrom": "transaction_tags",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "transaction_tags_transaction_id_fkey": {
          "name": "transaction_tags_transaction_id_fkey",
          "tableFrom": "transaction_tags",
          "tableTo": "transactions",
          "schemaTo": "public",
          "columnsFrom": ["transaction_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "unique_tag": {
          "columns": ["tag_id", "transaction_id"],
          "nullsNotDistinct": false,
          "name": "unique_tag"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Transaction Tags can be handled by a member of the team": {
          "name": "Transaction Tags can be handled by a member of the team",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        }
      },
      "isRLSEnabled": true
    },
    "public.transaction_attachments": {
      "name": "transaction_attachments",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "transaction_id": {
          "name": "transaction_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "size": {
          "name": "size",
          "type": "bigint",
          "primaryKey": false,
          "notNull": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "path": {
          "name": "path",
          "type": "text[]",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {
        "transaction_attachments_team_id_idx": {
          "name": "transaction_attachments_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "transaction_attachments_transaction_id_idx": {
          "name": "transaction_attachments_transaction_id_idx",
          "columns": [
            {
              "expression": "transaction_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "public_transaction_attachments_team_id_fkey": {
          "name": "public_transaction_attachments_team_id_fkey",
          "tableFrom": "transaction_attachments",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "public_transaction_attachments_transaction_id_fkey": {
          "name": "public_transaction_attachments_transaction_id_fkey",
          "tableFrom": "transaction_attachments",
          "tableTo": "transactions",
          "schemaTo": "public",
          "columnsFrom": ["transaction_id"],
          "columnsTo": ["id"],
          "onDelete": "set null",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {},
      "policies": {
        "Transaction Attachments can be created by a member of the team": {
          "name": "Transaction Attachments can be created by a member of the team",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["public"],
          "withCheck": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        },
        "Transaction Attachments can be deleted by a member of the team": {
          "name": "Transaction Attachments can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["public"]
        },
        "Transaction Attachments can be selected by a member of the team": {
          "name": "Transaction Attachments can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"]
        },
        "Transaction Attachments can be updated by a member of the team": {
          "name": "Transaction Attachments can be updated by a member of the team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["public"]
        }
      },
      "isRLSEnabled": true
    },
    "public.teams": {
      "name": "teams",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "logo_url": {
          "name": "logo_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "inbox_id": {
          "name": "inbox_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "default": "generate_inbox(10)"
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "inbox_email": {
          "name": "inbox_email",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "inbox_forwarding": {
          "name": "inbox_forwarding",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": true
        },
        "base_currency": {
          "name": "base_currency",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "document_classification": {
          "name": "document_classification",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "flags": {
          "name": "flags",
          "type": "text[]",
          "primaryKey": false,
          "notNull": false
        },
        "canceled_at": {
          "name": "canceled_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false
        },
        "plan": {
          "name": "plan",
          "type": "plans",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": true,
          "default": "'trial'"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "teams_inbox_id_key": {
          "columns": ["inbox_id"],
          "nullsNotDistinct": false,
          "name": "teams_inbox_id_key"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Enable insert for authenticated users only": {
          "name": "Enable insert for authenticated users only",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["authenticated"],
          "withCheck": "true"
        },
        "Invited users can select team if they are invited.": {
          "name": "Invited users can select team if they are invited.",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"]
        },
        "Teams can be deleted by a member of the team": {
          "name": "Teams can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["public"]
        },
        "Teams can be selected by a member of the team": {
          "name": "Teams can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"]
        },
        "Teams can be updated by a member of the team": {
          "name": "Teams can be updated by a member of the team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["public"]
        }
      },
      "isRLSEnabled": true
    },
    "public.documents": {
      "name": "documents",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "metadata": {
          "name": "metadata",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "path_tokens": {
          "name": "path_tokens",
          "type": "text[]",
          "primaryKey": false,
          "notNull": false
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "parent_id": {
          "name": "parent_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "object_id": {
          "name": "object_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "owner_id": {
          "name": "owner_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "tag": {
          "name": "tag",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "body": {
          "name": "body",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "fts": {
          "name": "fts",
          "type": "tsvector",
          "primaryKey": false,
          "notNull": false,
          "generated": {
            "as": "to_tsvector('english'::regconfig, ((title || ' '::text) || body))",
            "type": "stored"
          }
        },
        "summary": {
          "name": "summary",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "content": {
          "name": "content",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "date": {
          "name": "date",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "language": {
          "name": "language",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "processing_status": {
          "name": "processing_status",
          "type": "document_processing_status",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false,
          "default": "'pending'"
        },
        "fts_simple": {
          "name": "fts_simple",
          "type": "tsvector",
          "primaryKey": false,
          "notNull": false
        },
        "fts_english": {
          "name": "fts_english",
          "type": "tsvector",
          "primaryKey": false,
          "notNull": false
        },
        "fts_language": {
          "name": "fts_language",
          "type": "tsvector",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {
        "documents_name_idx": {
          "name": "documents_name_idx",
          "columns": [
            {
              "expression": "name",
              "asc": true,
              "nulls": "last",
              "opclass": "text_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "documents_team_id_idx": {
          "name": "documents_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "documents_team_id_parent_id_idx": {
          "name": "documents_team_id_parent_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "text_ops",
              "isExpression": false
            },
            {
              "expression": "parent_id",
              "asc": true,
              "nulls": "last",
              "opclass": "text_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "idx_documents_fts_english": {
          "name": "idx_documents_fts_english",
          "columns": [
            {
              "expression": "fts_english",
              "asc": true,
              "nulls": "last",
              "opclass": "tsvector_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "gin",
          "with": {}
        },
        "idx_documents_fts_language": {
          "name": "idx_documents_fts_language",
          "columns": [
            {
              "expression": "fts_language",
              "asc": true,
              "nulls": "last",
              "opclass": "tsvector_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "gin",
          "with": {}
        },
        "idx_documents_fts_simple": {
          "name": "idx_documents_fts_simple",
          "columns": [
            {
              "expression": "fts_simple",
              "asc": true,
              "nulls": "last",
              "opclass": "tsvector_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "gin",
          "with": {}
        },
        "idx_gin_documents_title": {
          "name": "idx_gin_documents_title",
          "columns": [
            {
              "expression": "title",
              "asc": true,
              "nulls": "last",
              "opclass": "gin_trgm_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "gin",
          "with": {}
        }
      },
      "foreignKeys": {
        "documents_created_by_fkey": {
          "name": "documents_created_by_fkey",
          "tableFrom": "documents",
          "tableTo": "users",
          "schemaTo": "public",
          "columnsFrom": ["owner_id"],
          "columnsTo": ["id"],
          "onDelete": "set null",
          "onUpdate": "no action"
        },
        "storage_team_id_fkey": {
          "name": "storage_team_id_fkey",
          "tableFrom": "documents",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {},
      "policies": {
        "Documents can be deleted by a member of the team": {
          "name": "Documents can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        },
        "Documents can be selected by a member of the team": {
          "name": "Documents can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"]
        },
        "Documents can be updated by a member of the team": {
          "name": "Documents can be updated by a member of the team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["public"]
        },
        "Enable insert for authenticated users only": {
          "name": "Enable insert for authenticated users only",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["authenticated"]
        }
      },
      "isRLSEnabled": true
    },
    "public.apps": {
      "name": "apps",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false,
          "default": "gen_random_uuid()"
        },
        "config": {
          "name": "config",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "app_id": {
          "name": "app_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "created_by": {
          "name": "created_by",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false,
          "default": "gen_random_uuid()"
        },
        "settings": {
          "name": "settings",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "apps_created_by_fkey": {
          "name": "apps_created_by_fkey",
          "tableFrom": "apps",
          "tableTo": "users",
          "schemaTo": "public",
          "columnsFrom": ["created_by"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "integrations_team_id_fkey": {
          "name": "integrations_team_id_fkey",
          "tableFrom": "apps",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "unique_app_id_team_id": {
          "columns": ["team_id", "app_id"],
          "nullsNotDistinct": false,
          "name": "unique_app_id_team_id"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Apps can be deleted by a member of the team": {
          "name": "Apps can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        },
        "Apps can be inserted by a member of the team": {
          "name": "Apps can be inserted by a member of the team",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["public"]
        },
        "Apps can be selected by a member of the team": {
          "name": "Apps can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"]
        },
        "Apps can be updated by a member of the team": {
          "name": "Apps can be updated by a member of the team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["public"]
        }
      },
      "isRLSEnabled": true
    },
    "public.invoice_templates": {
      "name": "invoice_templates",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "customer_label": {
          "name": "customer_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "from_label": {
          "name": "from_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "invoice_no_label": {
          "name": "invoice_no_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "issue_date_label": {
          "name": "issue_date_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "due_date_label": {
          "name": "due_date_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "description_label": {
          "name": "description_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "price_label": {
          "name": "price_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "quantity_label": {
          "name": "quantity_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "total_label": {
          "name": "total_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "vat_label": {
          "name": "vat_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "tax_label": {
          "name": "tax_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "payment_label": {
          "name": "payment_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "note_label": {
          "name": "note_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "logo_url": {
          "name": "logo_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "currency": {
          "name": "currency",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "payment_details": {
          "name": "payment_details",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "from_details": {
          "name": "from_details",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false
        },
        "size": {
          "name": "size",
          "type": "invoice_size",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false,
          "default": "'a4'"
        },
        "date_format": {
          "name": "date_format",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "include_vat": {
          "name": "include_vat",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false
        },
        "include_tax": {
          "name": "include_tax",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false
        },
        "tax_rate": {
          "name": "tax_rate",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "delivery_type": {
          "name": "delivery_type",
          "type": "invoice_delivery_type",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": true,
          "default": "'create'"
        },
        "discount_label": {
          "name": "discount_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "include_discount": {
          "name": "include_discount",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false
        },
        "include_decimals": {
          "name": "include_decimals",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false
        },
        "include_qr": {
          "name": "include_qr",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false
        },
        "total_summary_label": {
          "name": "total_summary_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "vat_rate": {
          "name": "vat_rate",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "include_units": {
          "name": "include_units",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false
        },
        "subtotal_label": {
          "name": "subtotal_label",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "include_pdf": {
          "name": "include_pdf",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "invoice_settings_team_id_fkey": {
          "name": "invoice_settings_team_id_fkey",
          "tableFrom": "invoice_templates",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "invoice_templates_team_id_key": {
          "columns": ["team_id"],
          "nullsNotDistinct": false,
          "name": "invoice_templates_team_id_key"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Invoice templates can be handled by a member of the team": {
          "name": "Invoice templates can be handled by a member of the team",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        }
      },
      "isRLSEnabled": true
    },
    "public.transaction_enrichments": {
      "name": "transaction_enrichments",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "category_slug": {
          "name": "category_slug",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "system": {
          "name": "system",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        }
      },
      "indexes": {
        "transaction_enrichments_category_slug_team_id_idx": {
          "name": "transaction_enrichments_category_slug_team_id_idx",
          "columns": [
            {
              "expression": "category_slug",
              "asc": true,
              "nulls": "last",
              "opclass": "text_ops",
              "isExpression": false
            },
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "transaction_enrichments_category_slug_team_id_fkey": {
          "name": "transaction_enrichments_category_slug_team_id_fkey",
          "tableFrom": "transaction_enrichments",
          "tableTo": "transaction_categories",
          "schemaTo": "public",
          "columnsFrom": ["team_id", "category_slug"],
          "columnsTo": ["team_id", "slug"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "transaction_enrichments_team_id_fkey": {
          "name": "transaction_enrichments_team_id_fkey",
          "tableFrom": "transaction_enrichments",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "unique_team_name": {
          "columns": ["name", "team_id"],
          "nullsNotDistinct": false,
          "name": "unique_team_name"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Enable insert for authenticated users only": {
          "name": "Enable insert for authenticated users only",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["authenticated"],
          "withCheck": "true"
        },
        "Enable update for authenticated users only": {
          "name": "Enable update for authenticated users only",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["authenticated"]
        }
      },
      "isRLSEnabled": true
    },
    "public.users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true
        },
        "full_name": {
          "name": "full_name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "avatar_url": {
          "name": "avatar_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "locale": {
          "name": "locale",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "default": "'en'"
        },
        "week_starts_on_monday": {
          "name": "week_starts_on_monday",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "timezone": {
          "name": "timezone",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "time_format": {
          "name": "time_format",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false,
          "default": "'24'"
        },
        "date_format": {
          "name": "date_format",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {
        "users_team_id_idx": {
          "name": "users_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "users_id_fkey": {
          "name": "users_id_fkey",
          "tableFrom": "users",
          "tableTo": "users",
          "schemaTo": "auth",
          "columnsFrom": ["id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "users_team_id_fkey": {
          "name": "users_team_id_fkey",
          "tableFrom": "users",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "set null",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {},
      "policies": {
        "Users can insert their own profile.": {
          "name": "Users can insert their own profile.",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["public"],
          "withCheck": "(auth.uid() = id)"
        },
        "Users can select their own profile.": {
          "name": "Users can select their own profile.",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"]
        },
        "Users can select users if they are in the same team": {
          "name": "Users can select users if they are in the same team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["authenticated"]
        },
        "Users can update own profile.": {
          "name": "Users can update own profile.",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["public"]
        }
      },
      "isRLSEnabled": true
    },
    "public.tracker_projects": {
      "name": "tracker_projects",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "rate": {
          "name": "rate",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "currency": {
          "name": "currency",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "trackerStatus",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": true,
          "default": "'in_progress'"
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "billable": {
          "name": "billable",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "estimate": {
          "name": "estimate",
          "type": "bigint",
          "primaryKey": false,
          "notNull": false
        },
        "customer_id": {
          "name": "customer_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "fts": {
          "name": "fts",
          "type": "tsvector",
          "primaryKey": false,
          "notNull": false,
          "generated": {
            "as": "to_tsvector('english'::regconfig, ((COALESCE(name, ''::text) || ' '::text) || COALESCE(description, ''::text)))",
            "type": "stored"
          }
        }
      },
      "indexes": {
        "tracker_projects_fts": {
          "name": "tracker_projects_fts",
          "columns": [
            {
              "expression": "fts",
              "asc": true,
              "nulls": "last",
              "opclass": "tsvector_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "gin",
          "with": {}
        },
        "tracker_projects_team_id_idx": {
          "name": "tracker_projects_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "tracker_projects_customer_id_fkey": {
          "name": "tracker_projects_customer_id_fkey",
          "tableFrom": "tracker_projects",
          "tableTo": "customers",
          "schemaTo": "public",
          "columnsFrom": ["customer_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "tracker_projects_team_id_fkey": {
          "name": "tracker_projects_team_id_fkey",
          "tableFrom": "tracker_projects",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {},
      "policies": {
        "Projects can be created by a member of the team": {
          "name": "Projects can be created by a member of the team",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["authenticated"],
          "withCheck": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        },
        "Projects can be deleted by a member of the team": {
          "name": "Projects can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["authenticated"]
        },
        "Projects can be selected by a member of the team": {
          "name": "Projects can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["authenticated"]
        },
        "Projects can be updated by a member of the team": {
          "name": "Projects can be updated by a member of the team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["authenticated"]
        }
      },
      "isRLSEnabled": true
    },
    "public.inbox": {
      "name": "inbox",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "file_path": {
          "name": "file_path",
          "type": "text[]",
          "primaryKey": false,
          "notNull": false
        },
        "file_name": {
          "name": "file_name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "transaction_id": {
          "name": "transaction_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "amount": {
          "name": "amount",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "currency": {
          "name": "currency",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "content_type": {
          "name": "content_type",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "size": {
          "name": "size",
          "type": "bigint",
          "primaryKey": false,
          "notNull": false
        },
        "attachment_id": {
          "name": "attachment_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "date": {
          "name": "date",
          "type": "date",
          "primaryKey": false,
          "notNull": false
        },
        "forwarded_to": {
          "name": "forwarded_to",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "reference_id": {
          "name": "reference_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "meta": {
          "name": "meta",
          "type": "json",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "inbox_status",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false,
          "default": "'new'"
        },
        "website": {
          "name": "website",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "display_name": {
          "name": "display_name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "fts": {
          "name": "fts",
          "type": "tsvector",
          "primaryKey": false,
          "notNull": false,
          "generated": {
            "as": "generate_inbox_fts(display_name, extract_product_names((meta -> 'products'::text)))",
            "type": "stored"
          }
        },
        "type": {
          "name": "type",
          "type": "inbox_type",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "base_amount": {
          "name": "base_amount",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "base_currency": {
          "name": "base_currency",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "tax_amount": {
          "name": "tax_amount",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "tax_rate": {
          "name": "tax_rate",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "tax_type": {
          "name": "tax_type",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {
        "inbox_attachment_id_idx": {
          "name": "inbox_attachment_id_idx",
          "columns": [
            {
              "expression": "attachment_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "inbox_created_at_idx": {
          "name": "inbox_created_at_idx",
          "columns": [
            {
              "expression": "created_at",
              "asc": true,
              "nulls": "last",
              "opclass": "timestamptz_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "inbox_team_id_idx": {
          "name": "inbox_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "inbox_transaction_id_idx": {
          "name": "inbox_transaction_id_idx",
          "columns": [
            {
              "expression": "transaction_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "inbox_attachment_id_fkey": {
          "name": "inbox_attachment_id_fkey",
          "tableFrom": "inbox",
          "tableTo": "transaction_attachments",
          "schemaTo": "public",
          "columnsFrom": ["attachment_id"],
          "columnsTo": ["id"],
          "onDelete": "set null",
          "onUpdate": "no action"
        },
        "public_inbox_team_id_fkey": {
          "name": "public_inbox_team_id_fkey",
          "tableFrom": "inbox",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "public_inbox_transaction_id_fkey": {
          "name": "public_inbox_transaction_id_fkey",
          "tableFrom": "inbox",
          "tableTo": "transactions",
          "schemaTo": "public",
          "columnsFrom": ["transaction_id"],
          "columnsTo": ["id"],
          "onDelete": "set null",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "inbox_reference_id_key": {
          "columns": ["reference_id"],
          "nullsNotDistinct": false,
          "name": "inbox_reference_id_key"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Inbox can be deleted by a member of the team": {
          "name": "Inbox can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        },
        "Inbox can be selected by a member of the team": {
          "name": "Inbox can be selected by a member of the team",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["public"]
        },
        "Inbox can be updated by a member of the team": {
          "name": "Inbox can be updated by a member of the team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["public"]
        }
      },
      "isRLSEnabled": true
    },
    "public.document_tag_assignments": {
      "name": "document_tag_assignments",
      "schema": "",
      "columns": {
        "document_id": {
          "name": "document_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "tag_id": {
          "name": "tag_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {
        "idx_document_tag_assignments_document_id": {
          "name": "idx_document_tag_assignments_document_id",
          "columns": [
            {
              "expression": "document_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "idx_document_tag_assignments_tag_id": {
          "name": "idx_document_tag_assignments_tag_id",
          "columns": [
            {
              "expression": "tag_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "document_tag_assignments_document_id_fkey": {
          "name": "document_tag_assignments_document_id_fkey",
          "tableFrom": "document_tag_assignments",
          "tableTo": "documents",
          "schemaTo": "public",
          "columnsFrom": ["document_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "document_tag_assignments_tag_id_fkey": {
          "name": "document_tag_assignments_tag_id_fkey",
          "tableFrom": "document_tag_assignments",
          "tableTo": "document_tags",
          "schemaTo": "public",
          "columnsFrom": ["tag_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "document_tag_assignments_team_id_fkey": {
          "name": "document_tag_assignments_team_id_fkey",
          "tableFrom": "document_tag_assignments",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "document_tag_assignments_pkey": {
          "name": "document_tag_assignments_pkey",
          "columns": ["document_id", "tag_id"]
        }
      },
      "uniqueConstraints": {
        "document_tag_assignments_unique": {
          "columns": ["document_id", "tag_id"],
          "nullsNotDistinct": false,
          "name": "document_tag_assignments_unique"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Tags can be handled by a member of the team": {
          "name": "Tags can be handled by a member of the team",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        }
      },
      "isRLSEnabled": true
    },
    "public.users_on_team": {
      "name": "users_on_team",
      "schema": "",
      "columns": {
        "user_id": {
          "name": "user_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "role": {
          "name": "role",
          "type": "teamRoles",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {
        "users_on_team_team_id_idx": {
          "name": "users_on_team_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        },
        "users_on_team_user_id_idx": {
          "name": "users_on_team_user_id_idx",
          "columns": [
            {
              "expression": "user_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "users_on_team_team_id_fkey": {
          "name": "users_on_team_team_id_fkey",
          "tableFrom": "users_on_team",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "cascade"
        },
        "users_on_team_user_id_fkey": {
          "name": "users_on_team_user_id_fkey",
          "tableFrom": "users_on_team",
          "tableTo": "users",
          "schemaTo": "public",
          "columnsFrom": ["user_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "members_pkey": {
          "name": "members_pkey",
          "columns": ["user_id", "team_id", "id"]
        }
      },
      "uniqueConstraints": {},
      "checkConstraints": {},
      "policies": {
        "Enable insert for authenticated users only": {
          "name": "Enable insert for authenticated users only",
          "as": "PERMISSIVE",
          "for": "INSERT",
          "to": ["authenticated"],
          "withCheck": "true"
        },
        "Enable updates for users on team": {
          "name": "Enable updates for users on team",
          "as": "PERMISSIVE",
          "for": "UPDATE",
          "to": ["authenticated"]
        },
        "Select for current user teams": {
          "name": "Select for current user teams",
          "as": "PERMISSIVE",
          "for": "SELECT",
          "to": ["authenticated"]
        },
        "Users on team can be deleted by a member of the team": {
          "name": "Users on team can be deleted by a member of the team",
          "as": "PERMISSIVE",
          "for": "DELETE",
          "to": ["public"]
        }
      },
      "isRLSEnabled": true
    },
    "public.transaction_categories": {
      "name": "transaction_categories",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true,
          "default": "gen_random_uuid()"
        },
        "color": {
          "name": "color",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp with time zone",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "system": {
          "name": "system",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "slug": {
          "name": "slug",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "vat": {
          "name": "vat",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "embedding": {
          "name": "embedding",
          "type": "vector(384)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {
        "transaction_categories_team_id_idx": {
          "name": "transaction_categories_team_id_idx",
          "columns": [
            {
              "expression": "team_id",
              "asc": true,
              "nulls": "last",
              "opclass": "uuid_ops",
              "isExpression": false
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {
        "transaction_categories_team_id_fkey": {
          "name": "transaction_categories_team_id_fkey",
          "tableFrom": "transaction_categories",
          "tableTo": "teams",
          "schemaTo": "public",
          "columnsFrom": ["team_id"],
          "columnsTo": ["id"],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {
        "transaction_categories_pkey": {
          "name": "transaction_categories_pkey",
          "columns": ["team_id", "slug"]
        }
      },
      "uniqueConstraints": {
        "unique_team_slug": {
          "columns": ["team_id", "slug"],
          "nullsNotDistinct": false,
          "name": "unique_team_slug"
        }
      },
      "checkConstraints": {},
      "policies": {
        "Users on team can manage categories": {
          "name": "Users on team can manage categories",
          "as": "PERMISSIVE",
          "for": "ALL",
          "to": ["public"],
          "using": "(team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user))"
        }
      },
      "isRLSEnabled": true
    }
  },
  "enums": {
    "public.account_type": {
      "name": "account_type",
      "values": [
        "depository",
        "credit",
        "other_asset",
        "loan",
        "other_liability"
      ],
      "schema": "public"
    },
    "public.bankProviders": {
      "name": "bankProviders",
      "values": ["gocardless", "plaid", "teller"],
      "schema": "public"
    },
    "public.bank_providers": {
      "name": "bank_providers",
      "values": ["gocardless", "plaid", "teller", "enablebanking", "pluggy"],
      "schema": "public"
    },
    "public.connection_status": {
      "name": "connection_status",
      "values": ["disconnected", "connected", "unknown"],
      "schema": "public"
    },
    "public.document_processing_status": {
      "name": "document_processing_status",
      "values": ["pending", "processing", "completed", "failed"],
      "schema": "public"
    },
    "public.inbox_account_providers": {
      "name": "inbox_account_providers",
      "values": ["gmail"],
      "schema": "public"
    },
    "public.inbox_status": {
      "name": "inbox_status",
      "values": ["processing", "pending", "archived", "new", "deleted", "done"],
      "schema": "public"
    },
    "public.inbox_type": {
      "name": "inbox_type",
      "values": ["invoice", "expense"],
      "schema": "public"
    },
    "public.invoice_delivery_type": {
      "name": "invoice_delivery_type",
      "values": ["create", "create_and_send", "scheduled"],
      "schema": "public"
    },
    "public.invoice_size": {
      "name": "invoice_size",
      "values": ["a4", "letter"],
      "schema": "public"
    },
    "public.invoice_status": {
      "name": "invoice_status",
      "values": ["draft", "overdue", "paid", "unpaid", "canceled"],
      "schema": "public"
    },
    "public.plans": {
      "name": "plans",
      "values": ["trial", "starter", "pro"],
      "schema": "public"
    },
    "public.reportTypes": {
      "name": "reportTypes",
      "values": ["profit", "revenue", "burn_rate", "expense"],
      "schema": "public"
    },
    "public.teamRoles": {
      "name": "teamRoles",
      "values": ["owner", "member"],
      "schema": "public"
    },
    "public.trackerStatus": {
      "name": "trackerStatus",
      "values": ["in_progress", "completed"],
      "schema": "public"
    },
    "public.transactionCategories": {
      "name": "transactionCategories",
      "values": [
        "travel",
        "office_supplies",
        "meals",
        "software",
        "rent",
        "income",
        "equipment",
        "transfer",
        "internet_and_telephone",
        "facilities_expenses",
        "activity",
        "uncategorized",
        "taxes",
        "other",
        "salary",
        "fees"
      ],
      "schema": "public"
    },
    "public.transactionMethods": {
      "name": "transactionMethods",
      "values": [
        "payment",
        "card_purchase",
        "card_atm",
        "transfer",
        "other",
        "unknown",
        "ach",
        "interest",
        "deposit",
        "wire",
        "fee"
      ],
      "schema": "public"
    },
    "public.transactionStatus": {
      "name": "transactionStatus",
      "values": ["posted", "pending", "excluded", "completed", "archived"],
      "schema": "public"
    },
    "public.transaction_frequency": {
      "name": "transaction_frequency",
      "values": [
        "weekly",
        "biweekly",
        "monthly",
        "semi_monthly",
        "annually",
        "irregular",
        "unknown"
      ],
      "schema": "public"
    }
  },
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {
    "public.team_limits_metrics": {
      "name": "team_limits_metrics",
      "schema": "public",
      "columns": {
        "team_id": {
          "name": "team_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": false
        },
        "total_document_size": {
          "name": "total_document_size",
          "type": "numeric",
          "primaryKey": false,
          "notNull": false
        },
        "number_of_users": {
          "name": "number_of_users",
          "type": "bigint",
          "primaryKey": false,
          "notNull": false
        },
        "number_of_bank_connections": {
          "name": "number_of_bank_connections",
          "type": "bigint",
          "primaryKey": false,
          "notNull": false
        },
        "invoices_created_this_month": {
          "name": "invoices_created_this_month",
          "type": "bigint",
          "primaryKey": false,
          "notNull": false
        },
        "inbox_created_this_month": {
          "name": "inbox_created_this_month",
          "type": "bigint",
          "primaryKey": false,
          "notNull": false
        }
      },
      "isExisting": false,
      "definition": "SELECT t.id AS team_id, COALESCE(sum((d.metadata ->> 'size'::text)::bigint), 0::numeric) AS total_document_size, count(DISTINCT u.id) AS number_of_users, count(DISTINCT bc.id) AS number_of_bank_connections, count(DISTINCT i.id) FILTER (WHERE date_trunc('month'::text, i.created_at) = date_trunc('month'::text, CURRENT_DATE::timestamp with time zone)) AS invoices_created_this_month, count(DISTINCT inbox.id) FILTER (WHERE date_trunc('month'::text, inbox.created_at) = date_trunc('month'::text, CURRENT_DATE::timestamp with time zone)) AS inbox_created_this_month FROM teams t LEFT JOIN documents d ON d.team_id = t.id LEFT JOIN users u ON u.team_id = t.id LEFT JOIN bank_connections bc ON bc.team_id = t.id LEFT JOIN invoices i ON i.team_id = t.id LEFT JOIN inbox ON inbox.team_id = t.id GROUP BY t.id",
      "materialized": true
    }
  },
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "tables": {
      "invoices": {
        "columns": {
          "file_path": {
            "isArray": true,
            "dimensions": 1,
            "rawType": "text"
          }
        }
      },
      "bank_connections": {
        "columns": {
          "error_retries": {
            "isDefaultAnExpression": true
          }
        }
      },
      "transaction_attachments": {
        "columns": {
          "path": {
            "isArray": true,
            "dimensions": 1,
            "rawType": "text"
          }
        }
      },
      "teams": {
        "columns": {
          "flags": {
            "isArray": true,
            "dimensions": 1,
            "rawType": "text"
          }
        }
      },
      "documents": {
        "columns": {
          "path_tokens": {
            "isArray": true,
            "dimensions": 1,
            "rawType": "text"
          }
        }
      },
      "inbox": {
        "columns": {
          "file_path": {
            "isArray": true,
            "dimensions": 1,
            "rawType": "text"
          }
        }
      }
    }
  }
}
</file>

<file path="apps/api/migrations/0000_bumpy_chat.sql">
-- Current sql file was generated after introspecting the database
-- If you want to run this migration please uncomment this code before executing migrations
/*
CREATE TYPE "public"."account_type" AS ENUM('depository', 'credit', 'other_asset', 'loan', 'other_liability');--> statement-breakpoint
CREATE TYPE "public"."bankProviders" AS ENUM('gocardless', 'plaid', 'teller');--> statement-breakpoint
CREATE TYPE "public"."bank_providers" AS ENUM('gocardless', 'plaid', 'teller', 'enablebanking', 'pluggy');--> statement-breakpoint
CREATE TYPE "public"."connection_status" AS ENUM('disconnected', 'connected', 'unknown');--> statement-breakpoint
CREATE TYPE "public"."document_processing_status" AS ENUM('pending', 'processing', 'completed', 'failed');--> statement-breakpoint
CREATE TYPE "public"."inbox_account_providers" AS ENUM('gmail');--> statement-breakpoint
CREATE TYPE "public"."inbox_status" AS ENUM('processing', 'pending', 'archived', 'new', 'deleted', 'done');--> statement-breakpoint
CREATE TYPE "public"."inbox_type" AS ENUM('invoice', 'expense');--> statement-breakpoint
CREATE TYPE "public"."invoice_delivery_type" AS ENUM('create', 'create_and_send', 'scheduled');--> statement-breakpoint
CREATE TYPE "public"."invoice_size" AS ENUM('a4', 'letter');--> statement-breakpoint
CREATE TYPE "public"."invoice_status" AS ENUM('draft', 'overdue', 'paid', 'unpaid', 'canceled');--> statement-breakpoint
CREATE TYPE "public"."plans" AS ENUM('trial', 'starter', 'pro');--> statement-breakpoint
CREATE TYPE "public"."reportTypes" AS ENUM('profit', 'revenue', 'burn_rate', 'expense');--> statement-breakpoint
CREATE TYPE "public"."teamRoles" AS ENUM('owner', 'member');--> statement-breakpoint
CREATE TYPE "public"."trackerStatus" AS ENUM('in_progress', 'completed');--> statement-breakpoint
CREATE TYPE "public"."transactionCategories" AS ENUM('travel', 'office_supplies', 'meals', 'software', 'rent', 'income', 'equipment', 'transfer', 'internet_and_telephone', 'facilities_expenses', 'activity', 'uncategorized', 'taxes', 'other', 'salary', 'fees');--> statement-breakpoint
CREATE TYPE "public"."transactionMethods" AS ENUM('payment', 'card_purchase', 'card_atm', 'transfer', 'other', 'unknown', 'ach', 'interest', 'deposit', 'wire', 'fee');--> statement-breakpoint
CREATE TYPE "public"."transactionStatus" AS ENUM('posted', 'pending', 'excluded', 'completed', 'archived');--> statement-breakpoint
CREATE TYPE "public"."transaction_frequency" AS ENUM('weekly', 'biweekly', 'monthly', 'semi_monthly', 'annually', 'irregular', 'unknown');--> statement-breakpoint
CREATE TABLE "document_tag_embeddings" (
	"slug" text PRIMARY KEY NOT NULL,
	"embedding" vector(1024),
	"name" text NOT NULL
);
--> statement-breakpoint
ALTER TABLE "document_tag_embeddings" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "transactions" (
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"date" date NOT NULL,
	"name" text NOT NULL,
	"method" "transactionMethods" NOT NULL,
	"amount" numeric NOT NULL,
	"currency" text NOT NULL,
	"team_id" uuid NOT NULL,
	"assigned_id" uuid,
	"note" varchar,
	"bank_account_id" uuid,
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"internal_id" text NOT NULL,
	"status" "transactionStatus" DEFAULT 'posted',
	"category" "transactionCategories",
	"balance" numeric,
	"manual" boolean DEFAULT false,
	"description" text,
	"category_slug" text,
	"base_amount" numeric,
	"base_currency" text,
	"recurring" boolean,
	"frequency" "transaction_frequency",
	"fts_vector" "tsvector" GENERATED ALWAYS AS (to_tsvector('english'::regconfig, ((COALESCE(name, ''::text) || ' '::text) || COALESCE(description, ''::text)))) STORED,
	"notified" boolean DEFAULT false,
	"internal" boolean DEFAULT false,
	CONSTRAINT "transactions_internal_id_key" UNIQUE("internal_id")
);
--> statement-breakpoint
ALTER TABLE "transactions" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "tracker_entries" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"duration" bigint,
	"project_id" uuid,
	"start" timestamp with time zone,
	"stop" timestamp with time zone,
	"assigned_id" uuid,
	"team_id" uuid,
	"description" text,
	"rate" numeric,
	"currency" text,
	"billed" boolean DEFAULT false,
	"date" date DEFAULT now()
);
--> statement-breakpoint
ALTER TABLE "tracker_entries" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "customer_tags" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"customer_id" uuid NOT NULL,
	"team_id" uuid NOT NULL,
	"tag_id" uuid NOT NULL,
	CONSTRAINT "unique_customer_tag" UNIQUE("customer_id","tag_id")
);
--> statement-breakpoint
ALTER TABLE "customer_tags" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "inbox_accounts" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"email" text NOT NULL,
	"access_token" text NOT NULL,
	"refresh_token" text NOT NULL,
	"team_id" uuid NOT NULL,
	"last_accessed" timestamp with time zone NOT NULL,
	"provider" "inbox_account_providers" NOT NULL,
	"external_id" text NOT NULL,
	"expiry_date" timestamp with time zone NOT NULL,
	"schedule_id" text,
	CONSTRAINT "inbox_accounts_email_key" UNIQUE("email"),
	CONSTRAINT "inbox_accounts_external_id_key" UNIQUE("external_id")
);
--> statement-breakpoint
ALTER TABLE "inbox_accounts" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "bank_accounts" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"team_id" uuid NOT NULL,
	"name" text,
	"currency" text,
	"bank_connection_id" uuid,
	"enabled" boolean DEFAULT true NOT NULL,
	"account_id" text NOT NULL,
	"balance" numeric DEFAULT '0',
	"manual" boolean DEFAULT false,
	"type" "account_type",
	"base_currency" text,
	"base_balance" numeric,
	"error_details" text,
	"error_retries" smallint,
	"account_reference" text
);
--> statement-breakpoint
ALTER TABLE "bank_accounts" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "invoices" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now(),
	"due_date" timestamp with time zone,
	"invoice_number" text,
	"customer_id" uuid,
	"amount" numeric,
	"currency" text,
	"line_items" jsonb,
	"payment_details" jsonb,
	"customer_details" jsonb,
	"company_datails" jsonb,
	"note" text,
	"internal_note" text,
	"team_id" uuid NOT NULL,
	"paid_at" timestamp with time zone,
	"fts" "tsvector" GENERATED ALWAYS AS (to_tsvector('english'::regconfig, ((COALESCE((amount)::text, ''::text) || ' '::text) || COALESCE(invoice_number, ''::text)))) STORED,
	"vat" numeric,
	"tax" numeric,
	"url" text,
	"file_path" text[],
	"status" "invoice_status" DEFAULT 'draft' NOT NULL,
	"viewed_at" timestamp with time zone,
	"from_details" jsonb,
	"issue_date" timestamp with time zone,
	"template" jsonb,
	"note_details" jsonb,
	"customer_name" text,
	"token" text DEFAULT '' NOT NULL,
	"sent_to" text,
	"reminder_sent_at" timestamp with time zone,
	"discount" numeric,
	"file_size" bigint,
	"user_id" uuid,
	"subtotal" numeric,
	"top_block" jsonb,
	"bottom_block" jsonb,
	"sent_at" timestamp with time zone,
	"scheduled_at" timestamp with time zone,
	"scheduled_job_id" text,
	CONSTRAINT "invoices_scheduled_job_id_key" UNIQUE("scheduled_job_id")
);
--> statement-breakpoint
ALTER TABLE "invoices" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "customers" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"name" text NOT NULL,
	"email" text NOT NULL,
	"country" text,
	"address_line_1" text,
	"address_line_2" text,
	"city" text,
	"state" text,
	"zip" text,
	"note" text,
	"team_id" uuid DEFAULT gen_random_uuid() NOT NULL,
	"website" text,
	"phone" text,
	"vat_number" text,
	"country_code" text,
	"token" text DEFAULT '' NOT NULL,
	"contact" text,
	"fts" "tsvector" GENERATED ALWAYS AS (to_tsvector('english'::regconfig, ((((((((((((((((((COALESCE(name, ''::text) || ' '::text) || COALESCE(contact, ''::text)) || ' '::text) || COALESCE(phone, ''::text)) || ' '::text) || COALESCE(email, ''::text)) || ' '::text) || COALESCE(address_line_1, ''::text)) || ' '::text) || COALESCE(address_line_2, ''::text)) || ' '::text) || COALESCE(city, ''::text)) || ' '::text) || COALESCE(state, ''::text)) || ' '::text) || COALESCE(zip, ''::text)) || ' '::text) || COALESCE(country, ''::text)))) STORED
);
--> statement-breakpoint
ALTER TABLE "customers" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "exchange_rates" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"base" text,
	"rate" numeric,
	"target" text,
	"updated_at" timestamp with time zone,
	CONSTRAINT "unique_rate" UNIQUE("base","target")
);
--> statement-breakpoint
ALTER TABLE "exchange_rates" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "tags" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"team_id" uuid NOT NULL,
	"name" text NOT NULL,
	CONSTRAINT "unique_tag_name" UNIQUE("team_id","name")
);
--> statement-breakpoint
ALTER TABLE "tags" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "tracker_reports" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"link_id" text,
	"short_link" text,
	"team_id" uuid DEFAULT gen_random_uuid(),
	"project_id" uuid DEFAULT gen_random_uuid(),
	"created_by" uuid
);
--> statement-breakpoint
ALTER TABLE "tracker_reports" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "invoice_comments" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
ALTER TABLE "invoice_comments" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "tracker_project_tags" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"tracker_project_id" uuid NOT NULL,
	"tag_id" uuid NOT NULL,
	"team_id" uuid NOT NULL,
	CONSTRAINT "unique_project_tag" UNIQUE("tracker_project_id","tag_id")
);
--> statement-breakpoint
ALTER TABLE "tracker_project_tags" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "reports" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"link_id" text,
	"team_id" uuid,
	"short_link" text,
	"from" timestamp with time zone,
	"to" timestamp with time zone,
	"type" "reportTypes",
	"expire_at" timestamp with time zone,
	"currency" text,
	"created_by" uuid
);
--> statement-breakpoint
ALTER TABLE "reports" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "bank_connections" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"institution_id" text NOT NULL,
	"expires_at" timestamp with time zone,
	"team_id" uuid NOT NULL,
	"name" text NOT NULL,
	"logo_url" text,
	"access_token" text,
	"enrollment_id" text,
	"provider" "bank_providers",
	"last_accessed" timestamp with time zone,
	"reference_id" text,
	"status" "connection_status" DEFAULT 'connected',
	"error_details" text,
	"error_retries" smallint DEFAULT '0',
	CONSTRAINT "unique_bank_connections" UNIQUE("institution_id","team_id")
);
--> statement-breakpoint
ALTER TABLE "bank_connections" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "user_invites" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"team_id" uuid,
	"email" text,
	"role" "teamRoles",
	"code" text DEFAULT nanoid(24),
	"invited_by" uuid,
	CONSTRAINT "unique_team_invite" UNIQUE("team_id","email"),
	CONSTRAINT "user_invites_code_key" UNIQUE("code")
);
--> statement-breakpoint
ALTER TABLE "user_invites" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "document_tags" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"name" text NOT NULL,
	"slug" text NOT NULL,
	"team_id" uuid NOT NULL,
	CONSTRAINT "unique_slug_per_team" UNIQUE("slug","team_id")
);
--> statement-breakpoint
ALTER TABLE "document_tags" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "transaction_tags" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"team_id" uuid NOT NULL,
	"tag_id" uuid NOT NULL,
	"transaction_id" uuid NOT NULL,
	CONSTRAINT "unique_tag" UNIQUE("tag_id","transaction_id")
);
--> statement-breakpoint
ALTER TABLE "transaction_tags" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "transaction_attachments" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"type" text,
	"transaction_id" uuid,
	"team_id" uuid,
	"size" bigint,
	"name" text,
	"path" text[]
);
--> statement-breakpoint
ALTER TABLE "transaction_attachments" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "teams" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"name" text,
	"logo_url" text,
	"inbox_id" text DEFAULT generate_inbox(10),
	"email" text,
	"inbox_email" text,
	"inbox_forwarding" boolean DEFAULT true,
	"base_currency" text,
	"document_classification" boolean DEFAULT false,
	"flags" text[],
	"canceled_at" timestamp with time zone,
	"plan" "plans" DEFAULT 'trial' NOT NULL,
	CONSTRAINT "teams_inbox_id_key" UNIQUE("inbox_id")
);
--> statement-breakpoint
ALTER TABLE "teams" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "documents" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"name" text,
	"created_at" timestamp with time zone DEFAULT now(),
	"metadata" jsonb,
	"path_tokens" text[],
	"team_id" uuid,
	"parent_id" text,
	"object_id" uuid,
	"owner_id" uuid,
	"tag" text,
	"title" text,
	"body" text,
	"fts" "tsvector" GENERATED ALWAYS AS (to_tsvector('english'::regconfig, ((title || ' '::text) || body))) STORED,
	"summary" text,
	"content" text,
	"date" date,
	"language" text,
	"processing_status" "document_processing_status" DEFAULT 'pending',
	"fts_simple" "tsvector",
	"fts_english" "tsvector",
	"fts_language" "tsvector"
);
--> statement-breakpoint
ALTER TABLE "documents" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "apps" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"team_id" uuid DEFAULT gen_random_uuid(),
	"config" jsonb,
	"created_at" timestamp with time zone DEFAULT now(),
	"app_id" text NOT NULL,
	"created_by" uuid DEFAULT gen_random_uuid(),
	"settings" jsonb,
	CONSTRAINT "unique_app_id_team_id" UNIQUE("team_id","app_id")
);
--> statement-breakpoint
ALTER TABLE "apps" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "invoice_templates" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"team_id" uuid NOT NULL,
	"customer_label" text,
	"from_label" text,
	"invoice_no_label" text,
	"issue_date_label" text,
	"due_date_label" text,
	"description_label" text,
	"price_label" text,
	"quantity_label" text,
	"total_label" text,
	"vat_label" text,
	"tax_label" text,
	"payment_label" text,
	"note_label" text,
	"logo_url" text,
	"currency" text,
	"payment_details" jsonb,
	"from_details" jsonb,
	"size" "invoice_size" DEFAULT 'a4',
	"date_format" text,
	"include_vat" boolean,
	"include_tax" boolean,
	"tax_rate" numeric,
	"delivery_type" "invoice_delivery_type" DEFAULT 'create' NOT NULL,
	"discount_label" text,
	"include_discount" boolean,
	"include_decimals" boolean,
	"include_qr" boolean,
	"total_summary_label" text,
	"title" text,
	"vat_rate" numeric,
	"include_units" boolean,
	"subtotal_label" text,
	"include_pdf" boolean,
	CONSTRAINT "invoice_templates_team_id_key" UNIQUE("team_id")
);
--> statement-breakpoint
ALTER TABLE "invoice_templates" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "transaction_enrichments" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"name" text,
	"team_id" uuid,
	"category_slug" text,
	"system" boolean DEFAULT false,
	CONSTRAINT "unique_team_name" UNIQUE("name","team_id")
);
--> statement-breakpoint
ALTER TABLE "transaction_enrichments" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "users" (
	"id" uuid PRIMARY KEY NOT NULL,
	"full_name" text,
	"avatar_url" text,
	"email" text,
	"team_id" uuid,
	"created_at" timestamp with time zone DEFAULT now(),
	"locale" text DEFAULT 'en',
	"week_starts_on_monday" boolean DEFAULT false,
	"timezone" text,
	"time_format" numeric DEFAULT '24',
	"date_format" text
);
--> statement-breakpoint
ALTER TABLE "users" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "tracker_projects" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"team_id" uuid,
	"rate" numeric,
	"currency" text,
	"status" "trackerStatus" DEFAULT 'in_progress' NOT NULL,
	"description" text,
	"name" text NOT NULL,
	"billable" boolean DEFAULT false,
	"estimate" bigint,
	"customer_id" uuid,
	"fts" "tsvector" GENERATED ALWAYS AS (to_tsvector('english'::regconfig, ((COALESCE(name, ''::text) || ' '::text) || COALESCE(description, ''::text)))) STORED
);
--> statement-breakpoint
ALTER TABLE "tracker_projects" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "inbox" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"team_id" uuid,
	"file_path" text[],
	"file_name" text,
	"transaction_id" uuid,
	"amount" numeric,
	"currency" text,
	"content_type" text,
	"size" bigint,
	"attachment_id" uuid,
	"date" date,
	"forwarded_to" text,
	"reference_id" text,
	"meta" json,
	"status" "inbox_status" DEFAULT 'new',
	"website" text,
	"display_name" text,
	"fts" "tsvector" GENERATED ALWAYS AS (generate_inbox_fts(display_name, extract_product_names((meta -> 'products'::text)))) STORED,
	"type" "inbox_type",
	"description" text,
	"base_amount" numeric,
	"base_currency" text,
	"tax_amount" numeric,
	"tax_rate" numeric,
	"tax_type" text,
	CONSTRAINT "inbox_reference_id_key" UNIQUE("reference_id")
);
--> statement-breakpoint
ALTER TABLE "inbox" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "document_tag_assignments" (
	"document_id" uuid NOT NULL,
	"tag_id" uuid NOT NULL,
	"team_id" uuid NOT NULL,
	CONSTRAINT "document_tag_assignments_pkey" PRIMARY KEY("document_id","tag_id"),
	CONSTRAINT "document_tag_assignments_unique" UNIQUE("document_id","tag_id")
);
--> statement-breakpoint
ALTER TABLE "document_tag_assignments" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "users_on_team" (
	"user_id" uuid NOT NULL,
	"team_id" uuid NOT NULL,
	"id" uuid DEFAULT gen_random_uuid() NOT NULL,
	"role" "teamRoles",
	"created_at" timestamp with time zone DEFAULT now(),
	CONSTRAINT "members_pkey" PRIMARY KEY("user_id","team_id","id")
);
--> statement-breakpoint
ALTER TABLE "users_on_team" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
CREATE TABLE "transaction_categories" (
	"id" uuid DEFAULT gen_random_uuid() NOT NULL,
	"name" text NOT NULL,
	"team_id" uuid DEFAULT gen_random_uuid() NOT NULL,
	"color" text,
	"created_at" timestamp with time zone DEFAULT now(),
	"system" boolean DEFAULT false,
	"slug" text NOT NULL,
	"vat" numeric,
	"description" text,
	"embedding" vector(384),
	CONSTRAINT "transaction_categories_pkey" PRIMARY KEY("team_id","slug"),
	CONSTRAINT "unique_team_slug" UNIQUE("team_id","slug")
);
--> statement-breakpoint
ALTER TABLE "transaction_categories" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint
ALTER TABLE "transactions" ADD CONSTRAINT "public_transactions_assigned_id_fkey" FOREIGN KEY ("assigned_id") REFERENCES "public"."users"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "transactions" ADD CONSTRAINT "public_transactions_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "transactions" ADD CONSTRAINT "transactions_bank_account_id_fkey" FOREIGN KEY ("bank_account_id") REFERENCES "public"."bank_accounts"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "transactions" ADD CONSTRAINT "transactions_category_slug_team_id_fkey" FOREIGN KEY ("team_id","category_slug") REFERENCES "public"."transaction_categories"("team_id","slug") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tracker_entries" ADD CONSTRAINT "tracker_entries_assigned_id_fkey" FOREIGN KEY ("assigned_id") REFERENCES "public"."users"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tracker_entries" ADD CONSTRAINT "tracker_entries_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."tracker_projects"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tracker_entries" ADD CONSTRAINT "tracker_entries_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "customer_tags" ADD CONSTRAINT "customer_tags_customer_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "public"."customers"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "customer_tags" ADD CONSTRAINT "customer_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."tags"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "customer_tags" ADD CONSTRAINT "customer_tags_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "inbox_accounts" ADD CONSTRAINT "inbox_accounts_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "bank_accounts" ADD CONSTRAINT "bank_accounts_bank_connection_id_fkey" FOREIGN KEY ("bank_connection_id") REFERENCES "public"."bank_connections"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "bank_accounts" ADD CONSTRAINT "bank_accounts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "bank_accounts" ADD CONSTRAINT "public_bank_accounts_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "invoices" ADD CONSTRAINT "invoices_created_by_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "invoices" ADD CONSTRAINT "invoices_customer_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "public"."customers"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "invoices" ADD CONSTRAINT "invoices_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "customers" ADD CONSTRAINT "customers_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tags" ADD CONSTRAINT "tags_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tracker_reports" ADD CONSTRAINT "public_tracker_reports_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tracker_reports" ADD CONSTRAINT "public_tracker_reports_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."tracker_projects"("id") ON DELETE cascade ON UPDATE cascade;--> statement-breakpoint
ALTER TABLE "tracker_reports" ADD CONSTRAINT "tracker_reports_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE cascade;--> statement-breakpoint
ALTER TABLE "tracker_project_tags" ADD CONSTRAINT "project_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."tags"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tracker_project_tags" ADD CONSTRAINT "project_tags_tracker_project_id_fkey" FOREIGN KEY ("tracker_project_id") REFERENCES "public"."tracker_projects"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tracker_project_tags" ADD CONSTRAINT "tracker_project_tags_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "reports" ADD CONSTRAINT "public_reports_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "reports" ADD CONSTRAINT "reports_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "bank_connections" ADD CONSTRAINT "bank_connections_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "user_invites" ADD CONSTRAINT "public_user_invites_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "user_invites" ADD CONSTRAINT "user_invites_invited_by_fkey" FOREIGN KEY ("invited_by") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "document_tags" ADD CONSTRAINT "document_tags_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "transaction_tags" ADD CONSTRAINT "transaction_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."tags"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "transaction_tags" ADD CONSTRAINT "transaction_tags_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "transaction_tags" ADD CONSTRAINT "transaction_tags_transaction_id_fkey" FOREIGN KEY ("transaction_id") REFERENCES "public"."transactions"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "transaction_attachments" ADD CONSTRAINT "public_transaction_attachments_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "transaction_attachments" ADD CONSTRAINT "public_transaction_attachments_transaction_id_fkey" FOREIGN KEY ("transaction_id") REFERENCES "public"."transactions"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "documents_created_by_fkey" FOREIGN KEY ("owner_id") REFERENCES "public"."users"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "documents" ADD CONSTRAINT "storage_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "apps" ADD CONSTRAINT "apps_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "apps" ADD CONSTRAINT "integrations_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "invoice_templates" ADD CONSTRAINT "invoice_settings_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "transaction_enrichments" ADD CONSTRAINT "transaction_enrichments_category_slug_team_id_fkey" FOREIGN KEY ("team_id","category_slug") REFERENCES "public"."transaction_categories"("team_id","slug") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "transaction_enrichments" ADD CONSTRAINT "transaction_enrichments_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "users" ADD CONSTRAINT "users_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "users" ADD CONSTRAINT "users_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tracker_projects" ADD CONSTRAINT "tracker_projects_customer_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "public"."customers"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tracker_projects" ADD CONSTRAINT "tracker_projects_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "inbox" ADD CONSTRAINT "inbox_attachment_id_fkey" FOREIGN KEY ("attachment_id") REFERENCES "public"."transaction_attachments"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "inbox" ADD CONSTRAINT "public_inbox_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "inbox" ADD CONSTRAINT "public_inbox_transaction_id_fkey" FOREIGN KEY ("transaction_id") REFERENCES "public"."transactions"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "document_tag_assignments" ADD CONSTRAINT "document_tag_assignments_document_id_fkey" FOREIGN KEY ("document_id") REFERENCES "public"."documents"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "document_tag_assignments" ADD CONSTRAINT "document_tag_assignments_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."document_tags"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "document_tag_assignments" ADD CONSTRAINT "document_tag_assignments_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "users_on_team" ADD CONSTRAINT "users_on_team_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE cascade;--> statement-breakpoint
ALTER TABLE "users_on_team" ADD CONSTRAINT "users_on_team_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "transaction_categories" ADD CONSTRAINT "transaction_categories_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
CREATE INDEX "document_tag_embeddings_idx" ON "document_tag_embeddings" USING ivfflat ("embedding" vector_l2_ops) WITH (lists=100);--> statement-breakpoint
CREATE INDEX "idx_transactions_date" ON "transactions" USING btree ("date" date_ops);--> statement-breakpoint
CREATE INDEX "idx_transactions_fts" ON "transactions" USING gin ("fts_vector" tsvector_ops);--> statement-breakpoint
CREATE INDEX "idx_transactions_fts_vector" ON "transactions" USING gin ("fts_vector" tsvector_ops);--> statement-breakpoint
CREATE INDEX "idx_transactions_id" ON "transactions" USING btree ("id" uuid_ops);--> statement-breakpoint
CREATE INDEX "idx_transactions_name" ON "transactions" USING btree ("name" text_ops);--> statement-breakpoint
CREATE INDEX "idx_transactions_name_trigram" ON "transactions" USING gin ("name" gin_trgm_ops);--> statement-breakpoint
CREATE INDEX "idx_transactions_team_id_date_name" ON "transactions" USING btree ("team_id" date_ops,"date" date_ops,"name" uuid_ops);--> statement-breakpoint
CREATE INDEX "idx_transactions_team_id_name" ON "transactions" USING btree ("team_id" uuid_ops,"name" uuid_ops);--> statement-breakpoint
CREATE INDEX "idx_trgm_name" ON "transactions" USING gist ("name" gist_trgm_ops);--> statement-breakpoint
CREATE INDEX "transactions_assigned_id_idx" ON "transactions" USING btree ("assigned_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "transactions_bank_account_id_idx" ON "transactions" USING btree ("bank_account_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "transactions_category_slug_idx" ON "transactions" USING btree ("category_slug" text_ops);--> statement-breakpoint
CREATE INDEX "transactions_team_id_date_currency_bank_account_id_category_idx" ON "transactions" USING btree ("team_id" enum_ops,"date" date_ops,"currency" text_ops,"bank_account_id" date_ops,"category" date_ops);--> statement-breakpoint
CREATE INDEX "transactions_team_id_idx" ON "transactions" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "tracker_entries_team_id_idx" ON "tracker_entries" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "bank_accounts_bank_connection_id_idx" ON "bank_accounts" USING btree ("bank_connection_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "bank_accounts_created_by_idx" ON "bank_accounts" USING btree ("created_by" uuid_ops);--> statement-breakpoint
CREATE INDEX "bank_accounts_team_id_idx" ON "bank_accounts" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "invoices_created_at_idx" ON "invoices" USING btree ("created_at" timestamptz_ops);--> statement-breakpoint
CREATE INDEX "invoices_fts" ON "invoices" USING gin ("fts" tsvector_ops);--> statement-breakpoint
CREATE INDEX "invoices_team_id_idx" ON "invoices" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "customers_fts" ON "customers" USING gin ("fts" tsvector_ops);--> statement-breakpoint
CREATE INDEX "exchange_rates_base_target_idx" ON "exchange_rates" USING btree ("base" text_ops,"target" text_ops);--> statement-breakpoint
CREATE INDEX "tags_team_id_idx" ON "tags" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "tracker_reports_team_id_idx" ON "tracker_reports" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "tracker_project_tags_team_id_idx" ON "tracker_project_tags" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "tracker_project_tags_tracker_project_id_tag_id_team_id_idx" ON "tracker_project_tags" USING btree ("tracker_project_id" uuid_ops,"tag_id" uuid_ops,"team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "reports_team_id_idx" ON "reports" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "bank_connections_team_id_idx" ON "bank_connections" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "user_invites_team_id_idx" ON "user_invites" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "transaction_tags_tag_id_idx" ON "transaction_tags" USING btree ("tag_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "transaction_tags_team_id_idx" ON "transaction_tags" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "transaction_tags_transaction_id_tag_id_team_id_idx" ON "transaction_tags" USING btree ("transaction_id" uuid_ops,"tag_id" uuid_ops,"team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "transaction_attachments_team_id_idx" ON "transaction_attachments" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "transaction_attachments_transaction_id_idx" ON "transaction_attachments" USING btree ("transaction_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "documents_name_idx" ON "documents" USING btree ("name" text_ops);--> statement-breakpoint
CREATE INDEX "documents_team_id_idx" ON "documents" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "documents_team_id_parent_id_idx" ON "documents" USING btree ("team_id" text_ops,"parent_id" text_ops);--> statement-breakpoint
CREATE INDEX "idx_documents_fts_english" ON "documents" USING gin ("fts_english" tsvector_ops);--> statement-breakpoint
CREATE INDEX "idx_documents_fts_language" ON "documents" USING gin ("fts_language" tsvector_ops);--> statement-breakpoint
CREATE INDEX "idx_documents_fts_simple" ON "documents" USING gin ("fts_simple" tsvector_ops);--> statement-breakpoint
CREATE INDEX "idx_gin_documents_title" ON "documents" USING gin ("title" gin_trgm_ops);--> statement-breakpoint
CREATE INDEX "transaction_enrichments_category_slug_team_id_idx" ON "transaction_enrichments" USING btree ("category_slug" text_ops,"team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "users_team_id_idx" ON "users" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "tracker_projects_fts" ON "tracker_projects" USING gin ("fts" tsvector_ops);--> statement-breakpoint
CREATE INDEX "tracker_projects_team_id_idx" ON "tracker_projects" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "inbox_attachment_id_idx" ON "inbox" USING btree ("attachment_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "inbox_created_at_idx" ON "inbox" USING btree ("created_at" timestamptz_ops);--> statement-breakpoint
CREATE INDEX "inbox_team_id_idx" ON "inbox" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "inbox_transaction_id_idx" ON "inbox" USING btree ("transaction_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "idx_document_tag_assignments_document_id" ON "document_tag_assignments" USING btree ("document_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "idx_document_tag_assignments_tag_id" ON "document_tag_assignments" USING btree ("tag_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "users_on_team_team_id_idx" ON "users_on_team" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "users_on_team_user_id_idx" ON "users_on_team" USING btree ("user_id" uuid_ops);--> statement-breakpoint
CREATE INDEX "transaction_categories_team_id_idx" ON "transaction_categories" USING btree ("team_id" uuid_ops);--> statement-breakpoint
CREATE MATERIALIZED VIEW "public"."team_limits_metrics" AS (SELECT t.id AS team_id, COALESCE(sum((d.metadata ->> 'size'::text)::bigint), 0::numeric) AS total_document_size, count(DISTINCT u.id) AS number_of_users, count(DISTINCT bc.id) AS number_of_bank_connections, count(DISTINCT i.id) FILTER (WHERE date_trunc('month'::text, i.created_at) = date_trunc('month'::text, CURRENT_DATE::timestamp with time zone)) AS invoices_created_this_month, count(DISTINCT inbox.id) FILTER (WHERE date_trunc('month'::text, inbox.created_at) = date_trunc('month'::text, CURRENT_DATE::timestamp with time zone)) AS inbox_created_this_month FROM teams t LEFT JOIN documents d ON d.team_id = t.id LEFT JOIN users u ON u.team_id = t.id LEFT JOIN bank_connections bc ON bc.team_id = t.id LEFT JOIN invoices i ON i.team_id = t.id LEFT JOIN inbox ON inbox.team_id = t.id GROUP BY t.id);--> statement-breakpoint
CREATE POLICY "Enable insert for authenticated users only" ON "document_tag_embeddings" AS PERMISSIVE FOR INSERT TO "authenticated" WITH CHECK (true);--> statement-breakpoint
CREATE POLICY "Transactions can be created by a member of the team" ON "transactions" AS PERMISSIVE FOR INSERT TO public WITH CHECK ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Transactions can be deleted by a member of the team" ON "transactions" AS PERMISSIVE FOR DELETE TO public;--> statement-breakpoint
CREATE POLICY "Transactions can be selected by a member of the team" ON "transactions" AS PERMISSIVE FOR SELECT TO public;--> statement-breakpoint
CREATE POLICY "Transactions can be updated by a member of the team" ON "transactions" AS PERMISSIVE FOR UPDATE TO public;--> statement-breakpoint
CREATE POLICY "Entries can be created by a member of the team" ON "tracker_entries" AS PERMISSIVE FOR INSERT TO "authenticated" WITH CHECK ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Entries can be deleted by a member of the team" ON "tracker_entries" AS PERMISSIVE FOR DELETE TO "authenticated";--> statement-breakpoint
CREATE POLICY "Entries can be selected by a member of the team" ON "tracker_entries" AS PERMISSIVE FOR SELECT TO "authenticated";--> statement-breakpoint
CREATE POLICY "Entries can be updated by a member of the team" ON "tracker_entries" AS PERMISSIVE FOR UPDATE TO "authenticated";--> statement-breakpoint
CREATE POLICY "Tags can be handled by a member of the team" ON "customer_tags" AS PERMISSIVE FOR ALL TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Inbox accounts can be deleted by a member of the team" ON "inbox_accounts" AS PERMISSIVE FOR DELETE TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Inbox accounts can be selected by a member of the team" ON "inbox_accounts" AS PERMISSIVE FOR SELECT TO public;--> statement-breakpoint
CREATE POLICY "Inbox accounts can be updated by a member of the team" ON "inbox_accounts" AS PERMISSIVE FOR UPDATE TO public;--> statement-breakpoint
CREATE POLICY "Bank Accounts can be created by a member of the team" ON "bank_accounts" AS PERMISSIVE FOR INSERT TO public WITH CHECK ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Bank Accounts can be deleted by a member of the team" ON "bank_accounts" AS PERMISSIVE FOR DELETE TO public;--> statement-breakpoint
CREATE POLICY "Bank Accounts can be selected by a member of the team" ON "bank_accounts" AS PERMISSIVE FOR SELECT TO public;--> statement-breakpoint
CREATE POLICY "Bank Accounts can be updated by a member of the team" ON "bank_accounts" AS PERMISSIVE FOR UPDATE TO public;--> statement-breakpoint
CREATE POLICY "Invoices can be handled by a member of the team" ON "invoices" AS PERMISSIVE FOR ALL TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Customers can be handled by members of the team" ON "customers" AS PERMISSIVE FOR ALL TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Enable read access for authenticated users" ON "exchange_rates" AS PERMISSIVE FOR SELECT TO public USING (true);--> statement-breakpoint
CREATE POLICY "Tags can be handled by a member of the team" ON "tags" AS PERMISSIVE FOR ALL TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Reports can be handled by a member of the team" ON "tracker_reports" AS PERMISSIVE FOR ALL TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Tags can be handled by a member of the team" ON "tracker_project_tags" AS PERMISSIVE FOR ALL TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Reports can be created by a member of the team" ON "reports" AS PERMISSIVE FOR INSERT TO public WITH CHECK ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Reports can be deleted by a member of the team" ON "reports" AS PERMISSIVE FOR DELETE TO public;--> statement-breakpoint
CREATE POLICY "Reports can be selected by a member of the team" ON "reports" AS PERMISSIVE FOR SELECT TO public;--> statement-breakpoint
CREATE POLICY "Reports can be updated by member of team" ON "reports" AS PERMISSIVE FOR UPDATE TO public;--> statement-breakpoint
CREATE POLICY "Bank Connections can be created by a member of the team" ON "bank_connections" AS PERMISSIVE FOR INSERT TO public WITH CHECK ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Bank Connections can be deleted by a member of the team" ON "bank_connections" AS PERMISSIVE FOR DELETE TO public;--> statement-breakpoint
CREATE POLICY "Bank Connections can be selected by a member of the team" ON "bank_connections" AS PERMISSIVE FOR SELECT TO public;--> statement-breakpoint
CREATE POLICY "Bank Connections can be updated by a member of the team" ON "bank_connections" AS PERMISSIVE FOR UPDATE TO public;--> statement-breakpoint
CREATE POLICY "Enable select for users based on email" ON "user_invites" AS PERMISSIVE FOR SELECT TO public USING (((auth.jwt() ->> 'email'::text) = email));--> statement-breakpoint
CREATE POLICY "User Invites can be created by a member of the team" ON "user_invites" AS PERMISSIVE FOR INSERT TO public;--> statement-breakpoint
CREATE POLICY "User Invites can be deleted by a member of the team" ON "user_invites" AS PERMISSIVE FOR DELETE TO public;--> statement-breakpoint
CREATE POLICY "User Invites can be deleted by invited email" ON "user_invites" AS PERMISSIVE FOR DELETE TO public;--> statement-breakpoint
CREATE POLICY "User Invites can be selected by a member of the team" ON "user_invites" AS PERMISSIVE FOR SELECT TO public;--> statement-breakpoint
CREATE POLICY "User Invites can be updated by a member of the team" ON "user_invites" AS PERMISSIVE FOR UPDATE TO public;--> statement-breakpoint
CREATE POLICY "Tags can be handled by a member of the team" ON "document_tags" AS PERMISSIVE FOR ALL TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Transaction Tags can be handled by a member of the team" ON "transaction_tags" AS PERMISSIVE FOR ALL TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Transaction Attachments can be created by a member of the team" ON "transaction_attachments" AS PERMISSIVE FOR INSERT TO public WITH CHECK ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Transaction Attachments can be deleted by a member of the team" ON "transaction_attachments" AS PERMISSIVE FOR DELETE TO public;--> statement-breakpoint
CREATE POLICY "Transaction Attachments can be selected by a member of the team" ON "transaction_attachments" AS PERMISSIVE FOR SELECT TO public;--> statement-breakpoint
CREATE POLICY "Transaction Attachments can be updated by a member of the team" ON "transaction_attachments" AS PERMISSIVE FOR UPDATE TO public;--> statement-breakpoint
CREATE POLICY "Enable insert for authenticated users only" ON "teams" AS PERMISSIVE FOR INSERT TO "authenticated" WITH CHECK (true);--> statement-breakpoint
CREATE POLICY "Invited users can select team if they are invited." ON "teams" AS PERMISSIVE FOR SELECT TO public;--> statement-breakpoint
CREATE POLICY "Teams can be deleted by a member of the team" ON "teams" AS PERMISSIVE FOR DELETE TO public;--> statement-breakpoint
CREATE POLICY "Teams can be selected by a member of the team" ON "teams" AS PERMISSIVE FOR SELECT TO public;--> statement-breakpoint
CREATE POLICY "Teams can be updated by a member of the team" ON "teams" AS PERMISSIVE FOR UPDATE TO public;--> statement-breakpoint
CREATE POLICY "Documents can be deleted by a member of the team" ON "documents" AS PERMISSIVE FOR ALL TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Documents can be selected by a member of the team" ON "documents" AS PERMISSIVE FOR ALL TO public;--> statement-breakpoint
CREATE POLICY "Documents can be updated by a member of the team" ON "documents" AS PERMISSIVE FOR UPDATE TO public;--> statement-breakpoint
CREATE POLICY "Enable insert for authenticated users only" ON "documents" AS PERMISSIVE FOR INSERT TO "authenticated";--> statement-breakpoint
CREATE POLICY "Apps can be deleted by a member of the team" ON "apps" AS PERMISSIVE FOR DELETE TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Apps can be inserted by a member of the team" ON "apps" AS PERMISSIVE FOR INSERT TO public;--> statement-breakpoint
CREATE POLICY "Apps can be selected by a member of the team" ON "apps" AS PERMISSIVE FOR SELECT TO public;--> statement-breakpoint
CREATE POLICY "Apps can be updated by a member of the team" ON "apps" AS PERMISSIVE FOR UPDATE TO public;--> statement-breakpoint
CREATE POLICY "Invoice templates can be handled by a member of the team" ON "invoice_templates" AS PERMISSIVE FOR ALL TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Enable insert for authenticated users only" ON "transaction_enrichments" AS PERMISSIVE FOR INSERT TO "authenticated" WITH CHECK (true);--> statement-breakpoint
CREATE POLICY "Enable update for authenticated users only" ON "transaction_enrichments" AS PERMISSIVE FOR UPDATE TO "authenticated";--> statement-breakpoint
CREATE POLICY "Users can insert their own profile." ON "users" AS PERMISSIVE FOR INSERT TO public WITH CHECK ((auth.uid() = id));--> statement-breakpoint
CREATE POLICY "Users can select their own profile." ON "users" AS PERMISSIVE FOR SELECT TO public;--> statement-breakpoint
CREATE POLICY "Users can select users if they are in the same team" ON "users" AS PERMISSIVE FOR SELECT TO "authenticated";--> statement-breakpoint
CREATE POLICY "Users can update own profile." ON "users" AS PERMISSIVE FOR UPDATE TO public;--> statement-breakpoint
CREATE POLICY "Projects can be created by a member of the team" ON "tracker_projects" AS PERMISSIVE FOR INSERT TO "authenticated" WITH CHECK ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Projects can be deleted by a member of the team" ON "tracker_projects" AS PERMISSIVE FOR DELETE TO "authenticated";--> statement-breakpoint
CREATE POLICY "Projects can be selected by a member of the team" ON "tracker_projects" AS PERMISSIVE FOR SELECT TO "authenticated";--> statement-breakpoint
CREATE POLICY "Projects can be updated by a member of the team" ON "tracker_projects" AS PERMISSIVE FOR UPDATE TO "authenticated";--> statement-breakpoint
CREATE POLICY "Inbox can be deleted by a member of the team" ON "inbox" AS PERMISSIVE FOR DELETE TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Inbox can be selected by a member of the team" ON "inbox" AS PERMISSIVE FOR SELECT TO public;--> statement-breakpoint
CREATE POLICY "Inbox can be updated by a member of the team" ON "inbox" AS PERMISSIVE FOR UPDATE TO public;--> statement-breakpoint
CREATE POLICY "Tags can be handled by a member of the team" ON "document_tag_assignments" AS PERMISSIVE FOR ALL TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));--> statement-breakpoint
CREATE POLICY "Enable insert for authenticated users only" ON "users_on_team" AS PERMISSIVE FOR INSERT TO "authenticated" WITH CHECK (true);--> statement-breakpoint
CREATE POLICY "Enable updates for users on team" ON "users_on_team" AS PERMISSIVE FOR UPDATE TO "authenticated";--> statement-breakpoint
CREATE POLICY "Select for current user teams" ON "users_on_team" AS PERMISSIVE FOR SELECT TO "authenticated";--> statement-breakpoint
CREATE POLICY "Users on team can be deleted by a member of the team" ON "users_on_team" AS PERMISSIVE FOR DELETE TO public;--> statement-breakpoint
CREATE POLICY "Users on team can manage categories" ON "transaction_categories" AS PERMISSIVE FOR ALL TO public USING ((team_id IN ( SELECT private.get_teams_for_authenticated_user() AS get_teams_for_authenticated_user)));
*/
</file>

<file path="apps/api/src/rest/middleware/auth.ts">
import { expandScopes } from "@api/utils/scopes";
import { isValidApiKeyFormat } from "@db/utils/api-keys";
import { apiKeyCache } from "@midday/cache/api-key-cache";
import { userCache } from "@midday/cache/user-cache";
import {
  getApiKeyByToken,
  getUserById,
  updateApiKeyLastUsedAt,
  validateAccessToken,
} from "@midday/db/queries";
import { hash } from "@midday/encryption";
import type { MiddlewareHandler } from "hono";
import { HTTPException } from "hono/http-exception";

export const withAuth: MiddlewareHandler = async (c, next) => {
  const authHeader = c.req.header("Authorization");

  if (!authHeader) {
    throw new HTTPException(401, { message: "Authorization header required" });
  }

  const [scheme, token] = authHeader.split(" ");

  if (scheme !== "Bearer") {
    throw new HTTPException(401, { message: "Invalid authorization scheme" });
  }

  if (!token) {
    throw new HTTPException(401, { message: "Token required" });
  }

  const db = c.get("db");

  // Handle OAuth access tokens (start with mid_access_token_)
  if (token.startsWith("mid_access_token_")) {
    const tokenData = await validateAccessToken(db, token);

    if (!tokenData || !tokenData.user) {
      throw new HTTPException(401, {
        message: "Invalid or expired access token",
      });
    }

    const session = {
      teamId: tokenData.teamId,
      user: {
        id: tokenData.user.id,
        email: tokenData.user.email,
        full_name: tokenData.user.fullName,
      },
      oauth: {
        applicationId: tokenData.applicationId,
        clientId: tokenData.application?.clientId,
        applicationName: tokenData.application?.name,
      },
    };

    c.set("session", session);
    c.set("teamId", session.teamId);
    c.set("scopes", expandScopes(tokenData.scopes ?? []));

    await next();
    return;
  }

  // Handle API keys (start with mid_ but not mid_access_token_)
  if (!token.startsWith("mid_") || !isValidApiKeyFormat(token)) {
    throw new HTTPException(401, { message: "Invalid token format" });
  }

  const keyHash = hash(token);

  // Check cache first for API key
  let apiKey = await apiKeyCache.get(keyHash);

  if (!apiKey) {
    // If not in cache, query database
    apiKey = await getApiKeyByToken(db, keyHash);
    if (apiKey) {
      // Store in cache for future requests
      await apiKeyCache.set(keyHash, apiKey);
    }
  }

  if (!apiKey) {
    throw new HTTPException(401, { message: "Invalid API key" });
  }

  // Check cache first for user
  let user = await userCache.get(apiKey.userId);

  if (!user) {
    // If not in cache, query database
    user = await getUserById(db, apiKey.userId);
    if (user) {
      // Store in cache for future requests
      await userCache.set(apiKey.userId, user);
    }
  }

  if (!user) {
    throw new HTTPException(401, { message: "User not found" });
  }

  const session = {
    teamId: apiKey.teamId,
    user: {
      id: user.id,
      email: user.email,
      full_name: user.fullName,
    },
  };

  c.set("session", session);
  c.set("teamId", session.teamId);
  c.set("scopes", expandScopes(apiKey.scopes ?? []));

  // Update last used at
  updateApiKeyLastUsedAt(db, apiKey.id);

  await next();
};
</file>

<file path="apps/api/src/rest/middleware/db.ts">
import { connectDb } from "@midday/db/client";
import type { MiddlewareHandler } from "hono";

/**
 * Database middleware that connects to the database and sets it on context
 */
export const withDatabase: MiddlewareHandler = async (c, next) => {
  // Connect to database
  const db = await connectDb();

  // Set database on context
  c.set("db", db);

  await next();
};
</file>

<file path="apps/api/src/rest/middleware/index.ts">
import type { MiddlewareHandler } from "hono";
import { rateLimiter } from "hono-rate-limiter";
import { withAuth } from "./auth";
import { withDatabase } from "./db";
import { withPrimaryReadAfterWrite } from "./primary-read-after-write";

/**
 * Public endpoint middleware - only attaches database with smart routing
 * No authentication required
 */
export const publicMiddleware: MiddlewareHandler[] = [withDatabase];

/**
 * Protected endpoint middleware - requires authentication
 * Supports both API keys and OAuth tokens in a single unified middleware
 * Note: withAuth must be first to set session in context
 */
export const protectedMiddleware: MiddlewareHandler[] = [
  withDatabase,
  withAuth,
  rateLimiter({
    windowMs: 10 * 60 * 1000, // 10 minutes
    limit: 100,
    keyGenerator: (c) => {
      return c.get("session")?.user?.id ?? "unknown";
    },
    statusCode: 429,
    message: "Rate limit exceeded",
  }),
  withPrimaryReadAfterWrite,
];

export { withRequiredScope } from "./scope";
</file>

<file path="apps/api/src/rest/middleware/primary-read-after-write.ts">
import { replicationCache } from "@midday/cache/replication-cache";
import { teamPermissionsCache } from "@midday/cache/team-permissions-cache";
import type { DatabaseWithPrimary } from "@midday/db/client";
import { getUserTeamId } from "@midday/db/queries";
import { logger } from "@midday/logger";
import type { MiddlewareHandler } from "hono";

/**
 * Database middleware that handles replication lag based on mutation operations
 * For mutations: always use primary DB
 * For queries: use primary DB if the team recently performed a mutation
 */
export const withPrimaryReadAfterWrite: MiddlewareHandler = async (c, next) => {
  // Get session and database from context
  const session = c.get("session");
  const db = c.get("db");

  // Determine operation type based on HTTP method
  const method = c.req.method;
  const operationType = ["POST", "PUT", "PATCH", "DELETE"].includes(method)
    ? "mutation"
    : "query";

  let teamId: string | null = null;

  // Try to get teamId from session/user context
  if (session?.user?.id) {
    const cacheKey = `user:${session.user.id}:team`;
    teamId = (await teamPermissionsCache.get(cacheKey)) || null;

    if (!teamId && session.user.id) {
      try {
        // Get user's current team
        const userTeamId = await getUserTeamId(db, session.user.id);

        if (userTeamId) {
          teamId = userTeamId;
          await teamPermissionsCache.set(cacheKey, userTeamId);
        }
      } catch (error) {
        logger.warn({
          msg: "Failed to fetch user team",
          userId: session.user.id,
          error: error instanceof Error ? error.message : "Unknown error",
        });
      }
    }
  }

  let finalDb = db;

  if (teamId) {
    // For mutations, always use primary DB and update the team's timestamp
    if (operationType === "mutation") {
      await replicationCache.set(teamId);

      // Use primary-only mode to maintain interface consistency
      const dbWithPrimary = db as DatabaseWithPrimary;
      if (dbWithPrimary.usePrimaryOnly) {
        finalDb = dbWithPrimary.usePrimaryOnly();
      }
      // If usePrimaryOnly doesn't exist, we're already using the primary DB
    }
    // For queries, check if the team recently performed a mutation
    else {
      const timestamp = await replicationCache.get(teamId);
      const now = Date.now();

      // If the timestamp exists and hasn't expired, use primary DB
      if (timestamp && now < timestamp) {
        // Use primary-only mode to maintain interface consistency
        const dbWithPrimary = db as DatabaseWithPrimary;
        if (dbWithPrimary.usePrimaryOnly) {
          finalDb = dbWithPrimary.usePrimaryOnly();
        }
      }
    }
  }

  // Set database and context in Hono context
  c.set("db", finalDb);
  c.set("session", session);
  c.set("teamId", teamId);

  await next();
};
</file>

<file path="apps/api/src/rest/middleware/scope.ts">
import type { Scope } from "@api/utils/scopes";
import type { MiddlewareHandler } from "hono";

export const withRequiredScope = (
  ...requiredScopes: Scope[]
): MiddlewareHandler => {
  return async (c, next) => {
    const scopes = c.get("scopes") as Scope[] | undefined;

    if (!scopes) {
      return c.json(
        {
          error: "Unauthorized",
          description:
            "No scopes found for the current user. Authentication is required.",
        },
        401,
      );
    }

    // Check if user has at least one of the required scopes
    const hasRequiredScope = requiredScopes.some((requiredScope) =>
      scopes.includes(requiredScope),
    );

    if (!hasRequiredScope) {
      return c.json(
        {
          error: "Forbidden",
          description: `Insufficient permissions. Required scopes: ${requiredScopes.join(
            ", ",
          )}. Your scopes: ${scopes.join(", ")}`,
        },
        403,
      );
    }

    await next();
  };
};
</file>

<file path="apps/api/src/rest/routers/bank-accounts.ts">
import type { Context } from "@api/rest/types";
import {
  bankAccountResponseSchema,
  bankAccountsResponseSchema,
  createBankAccountSchema,
  deleteBankAccountSchema,
  getBankAccountByIdSchema,
  getBankAccountsSchema,
  updateBankAccountSchema,
} from "@api/schemas/bank-accounts";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import {
  createBankAccount,
  deleteBankAccount,
  getBankAccountById,
  getBankAccounts,
  updateBankAccount,
} from "@midday/db/queries";
import { withRequiredScope } from "../middleware";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "List all bank accounts",
    operationId: "listBankAccounts",
    "x-speakeasy-name-override": "list",
    description: "Retrieve a list of bank accounts for the authenticated team.",
    tags: ["Bank Accounts"],
    request: {
      query: getBankAccountsSchema,
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: bankAccountsResponseSchema,
          },
        },
        description: "Retrieve a list of bank accounts",
      },
    },
    middleware: [withRequiredScope("bank-accounts.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const params = c.req.valid("query");

    const data = await getBankAccounts(db, {
      teamId,
      ...params,
    });

    return c.json(
      validateResponse(
        {
          data,
        },
        bankAccountsResponseSchema,
      ),
    );
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    summary: "Retrieve a bank account",
    operationId: "getBankAccountById",
    "x-speakeasy-name-override": "get",
    description: "Retrieve a bank account by ID for the authenticated team.",
    tags: ["Bank Accounts"],
    request: {
      params: getBankAccountByIdSchema,
    },
    responses: {
      200: {
        description: "Bank account details",
        content: {
          "application/json": {
            schema: bankAccountResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("bank-accounts.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const id = c.req.valid("param").id;
    const teamId = c.get("teamId");

    const result = await getBankAccountById(db, {
      id,
      teamId,
    });

    return c.json(validateResponse(result, bankAccountResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "post",
    path: "/",
    summary: "Create a bank account",
    operationId: "createBankAccount",
    "x-speakeasy-name-override": "create",
    description: "Create a new bank account for the authenticated team.",
    tags: ["Bank Accounts"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: createBankAccountSchema,
          },
        },
      },
    },
    responses: {
      201: {
        description: "Bank account created",
        content: {
          "application/json": {
            schema: bankAccountResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("bank-accounts.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const session = c.get("session");
    const body = c.req.valid("json");

    const result = await createBankAccount(db, {
      ...body,
      teamId,
      userId: session.user.id,
    });

    return c.json(validateResponse(result, bankAccountResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "patch",
    path: "/{id}",
    summary: "Update a bank account",
    operationId: "updateBankAccount",
    "x-speakeasy-name-override": "update",
    description: "Update a bank account by ID for the authenticated team.",
    tags: ["Bank Accounts"],
    request: {
      params: deleteBankAccountSchema,
      body: {
        content: {
          "application/json": {
            schema: updateBankAccountSchema,
          },
        },
      },
    },
    responses: {
      200: {
        description: "Bank account updated",
        content: {
          "application/json": {
            schema: bankAccountResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("bank-accounts.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const body = c.req.valid("json");
    const id = c.req.valid("param").id;

    const result = await updateBankAccount(db, {
      ...body,
      id,
      teamId,
    });

    return c.json(validateResponse(result, bankAccountResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "delete",
    path: "/{id}",
    summary: "Delete a bank account",
    operationId: "deleteBankAccount",
    "x-speakeasy-name-override": "delete",
    description: "Delete a bank account by ID for the authenticated team.",
    tags: ["Bank Accounts"],
    request: {
      params: deleteBankAccountSchema,
    },
    responses: {
      200: {
        description: "Bank account deleted",
        content: {
          "application/json": {
            schema: bankAccountResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("bank-accounts.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const id = c.req.valid("param").id;

    const result = await deleteBankAccount(db, {
      id,
      teamId,
    });

    return c.json(validateResponse(result, bankAccountResponseSchema));
  },
);

export const bankAccountsRouter = app;
</file>

<file path="apps/api/src/rest/routers/customers.ts">
import { withRequiredScope } from "@api/rest/middleware";
import type { Context } from "@api/rest/types";
import {
  customerResponseSchema,
  customersResponseSchema,
  getCustomerByIdSchema,
  getCustomersSchema,
  upsertCustomerSchema,
} from "@api/schemas/customers";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import {
  deleteCustomer,
  getCustomerById,
  getCustomers,
  upsertCustomer,
} from "@midday/db/queries";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "List all customers",
    operationId: "listCustomers",
    "x-speakeasy-name-override": "list",
    description: "Retrieve a list of customers for the authenticated team.",
    tags: ["Customers"],
    request: {
      query: getCustomersSchema,
    },
    responses: {
      200: {
        description: "Retrieve a list of customers for the authenticated team.",
        content: {
          "application/json": {
            schema: customersResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("customers.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { q, ...query } = c.req.valid("query");

    const result = await getCustomers(db, {
      ...query,
      teamId,
      q,
    });

    return c.json(validateResponse(result, customersResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "post",
    path: "/",
    summary: "Create customer",
    operationId: "createCustomer",
    "x-speakeasy-name-override": "create",
    description: "Create a new customer for the authenticated team.",
    tags: ["Customers"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: upsertCustomerSchema,
          },
        },
      },
    },
    responses: {
      201: {
        description: "Customer created",
        content: {
          "application/json": {
            schema: customerResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("customers.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const body = c.req.valid("json");

    const result = await upsertCustomer(db, {
      ...body,
      teamId,
    });

    return c.json(validateResponse(result, customerResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    summary: "Retrieve a customer",
    operationId: "getCustomerById",
    "x-speakeasy-name-override": "get",
    description: "Retrieve a customer by ID for the authenticated team.",
    tags: ["Customers"],
    request: {
      params: getCustomerByIdSchema,
    },
    responses: {
      200: {
        description: "Retrieve a customer by ID for the authenticated team.",
        content: {
          "application/json": {
            schema: customerResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("customers.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const id = c.req.valid("param").id;

    const result = await getCustomerById(db, { id, teamId });

    return c.json(validateResponse(result, customerResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "patch",
    path: "/{id}",
    summary: "Update a customer",
    operationId: "updateCustomer",
    "x-speakeasy-name-override": "update",
    description: "Update a customer by ID for the authenticated team.",
    tags: ["Customers"],
    request: {
      params: getCustomerByIdSchema,
      body: {
        content: {
          "application/json": {
            schema: upsertCustomerSchema,
          },
        },
      },
    },
    responses: {
      200: {
        description: "Customer updated",
        content: {
          "application/json": {
            schema: customerResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("customers.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const id = c.req.valid("param").id;
    const body = c.req.valid("json");

    const result = await upsertCustomer(db, {
      ...body,
      id,
      teamId,
    });

    return c.json(validateResponse(result, customerResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "delete",
    path: "/{id}",
    summary: "Delete a customer",
    operationId: "deleteCustomer",
    "x-speakeasy-name-override": "delete",
    description: "Delete a customer by ID for the authenticated team.",
    tags: ["Customers"],
    request: {
      params: getCustomerByIdSchema,
    },
    responses: {
      200: {
        description: "Customer deleted",
        content: {
          "application/json": {
            schema: customerResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("customers.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const id = c.req.valid("param").id;

    const result = await deleteCustomer(db, { id, teamId });

    return c.json(validateResponse(result, customerResponseSchema));
  },
);

export const customersRouter = app;
</file>

<file path="apps/api/src/rest/routers/documents.ts">
import type { Context } from "@api/rest/types";
import {
  deleteDocumentResponseSchema,
  deleteDocumentSchema,
  documentResponseSchema,
  documentsResponseSchema,
  getDocumentSchema,
  getDocumentsSchema,
} from "@api/schemas/documents";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import {
  deleteDocument,
  getDocumentById,
  getDocuments,
} from "@midday/db/queries";
import { withRequiredScope } from "../middleware";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "List all documents",
    operationId: "listDocuments",
    "x-speakeasy-name-override": "list",
    description: "Retrieve a list of documents for the authenticated team.",
    tags: ["Documents"],
    request: {
      query: getDocumentsSchema,
    },
    responses: {
      200: {
        description: "Retrieve a list of documents for the authenticated team.",
        content: {
          "application/json": {
            schema: documentsResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("documents.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { pageSize, cursor, sort, ...filter } = c.req.valid("query");

    const result = await getDocuments(db, {
      teamId,
      pageSize,
      cursor,
      ...filter,
    });

    return c.json(validateResponse(result, documentsResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    summary: "Retrieve a document",
    operationId: "getDocumentById",
    "x-speakeasy-name-override": "get",
    description:
      "Retrieve a document by its unique identifier for the authenticated team.",
    tags: ["Documents"],
    request: {
      params: getDocumentSchema.pick({ id: true }),
    },
    responses: {
      200: {
        description: "Retrieve a document by its unique identifier",
        content: {
          "application/json": {
            schema: documentResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("documents.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const id = c.req.valid("param").id;

    const result = await getDocumentById(db, {
      teamId,
      id,
    });

    return c.json(validateResponse(result, documentResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "delete",
    path: "/{id}",
    summary: "Delete a document",
    operationId: "deleteDocument",
    "x-speakeasy-name-override": "delete",
    description:
      "Delete a document by its unique identifier for the authenticated team.",
    tags: ["Documents"],
    request: {
      params: deleteDocumentSchema,
    },
    responses: {
      200: {
        description: "Document deleted successfully",
        content: {
          "application/json": {
            schema: deleteDocumentResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("documents.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const id = c.req.valid("param").id;

    const result = await deleteDocument(db, { teamId, id });

    return c.json(validateResponse(result, documentResponseSchema));
  },
);

export const documentsRouter = app;
</file>

<file path="apps/api/src/rest/routers/inbox.ts">
import type { Context } from "@api/rest/types";
import {
  deleteInboxResponseSchema,
  deleteInboxSchema,
  getInboxByIdSchema,
  getInboxSchema,
  inboxItemResponseSchema,
  inboxResponseSchema,
  updateInboxSchema,
} from "@api/schemas/inbox";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import {
  deleteInbox,
  getInbox,
  getInboxById,
  updateInbox,
} from "@midday/db/queries";
import { withRequiredScope } from "../middleware";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "List all inbox items",
    operationId: "listInboxItems",
    "x-speakeasy-name-override": "list",
    description: "Retrieve a list of inbox items for the authenticated team.",
    tags: ["Inbox"],
    request: {
      query: getInboxSchema,
    },
    responses: {
      200: {
        description:
          "Retrieve a list of inbox items for the authenticated team.",
        content: {
          "application/json": {
            schema: inboxResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("inbox.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { pageSize, cursor, order, ...filter } = c.req.valid("query");

    const result = await getInbox(db, {
      teamId,
      pageSize,
      cursor,
      order,
      ...filter,
    });

    return c.json(validateResponse(result, inboxResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    summary: "Retrieve a inbox item",
    operationId: "getInboxItemById",
    "x-speakeasy-name-override": "get",
    description:
      "Retrieve a inbox item by its unique identifier for the authenticated team.",
    tags: ["Inbox"],
    request: {
      params: getInboxByIdSchema.pick({ id: true }),
    },
    responses: {
      200: {
        description: "Retrieve an inbox item by its ID.",
        content: {
          "application/json": {
            schema: inboxItemResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("inbox.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { id } = c.req.valid("param");

    const result = await getInboxById(db, {
      id,
      teamId,
    });

    return c.json(validateResponse(result, inboxItemResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "delete",
    path: "/{id}",
    summary: "Delete a inbox item",
    operationId: "deleteInboxItem",
    "x-speakeasy-name-override": "delete",
    description:
      "Delete a inbox item by its unique identifier for the authenticated team.",
    tags: ["Inbox"],
    request: {
      params: deleteInboxSchema.pick({ id: true }),
    },
    responses: {
      200: {
        description: "Delete a inbox item by its ID.",
        content: {
          "application/json": {
            schema: deleteInboxResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("inbox.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { id } = c.req.valid("param");

    const result = await deleteInbox(db, {
      id,
      teamId,
    });

    return c.json(validateResponse(result, deleteInboxResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "patch",
    path: "/{id}",
    summary: "Update a inbox item",
    operationId: "updateInboxItem",
    "x-speakeasy-name-override": "update",
    description:
      "Update fields of an inbox item by its unique identifier for the authenticated team.",
    tags: ["Inbox"],
    request: {
      params: updateInboxSchema.pick({ id: true }),
      body: {
        content: {
          "application/json": {
            schema: updateInboxSchema.omit({ id: true }),
          },
        },
        required: true,
      },
    },
    responses: {
      200: {
        description:
          "Update fields of an inbox item by its unique identifier for the authenticated team.",
        content: {
          "application/json": {
            schema: inboxItemResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("inbox.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const id = c.req.valid("param").id;
    const body = c.req.valid("json");

    const result = await updateInbox(db, { ...body, id, teamId });

    return c.json(validateResponse(result, inboxItemResponseSchema));
  },
);

export const inboxRouter = app;
</file>

<file path="apps/api/src/rest/routers/index.ts">
import { OpenAPIHono } from "@hono/zod-openapi";
import { protectedMiddleware } from "../middleware";
import { bankAccountsRouter } from "./bank-accounts";
import { customersRouter } from "./customers";
import { documentsRouter } from "./documents";
import { inboxRouter } from "./inbox";
import { invoicesRouter } from "./invoices";
import { notificationsRouter } from "./notifications";
import oauthRouter from "./oauth";
import { reportsRouter } from "./reports";
import { searchRouter } from "./search";
import { tagsRouter } from "./tags";
import { teamsRouter } from "./teams";
import { trackerEntriesRouter } from "./tracker-entries";
import { trackerProjectsRouter } from "./tracker-projects";
import { transactionsRouter } from "./transactions";
import { usersRouter } from "./users";

const routers = new OpenAPIHono();

// Mount OAuth routes first (publicly accessible)
routers.route("/oauth", oauthRouter);

// Apply protected middleware to all subsequent routes
routers.use(...protectedMiddleware);

// Mount protected routes
routers.route("/notifications", notificationsRouter);
routers.route("/transactions", transactionsRouter);
routers.route("/teams", teamsRouter);
routers.route("/users", usersRouter);
routers.route("/customers", customersRouter);
routers.route("/bank-accounts", bankAccountsRouter);
routers.route("/tags", tagsRouter);
routers.route("/documents", documentsRouter);
routers.route("/inbox", inboxRouter);
routers.route("/invoices", invoicesRouter);
routers.route("/search", searchRouter);
routers.route("/reports", reportsRouter);
routers.route("/tracker-projects", trackerProjectsRouter);
routers.route("/tracker-entries", trackerEntriesRouter);

export { routers };
</file>

<file path="apps/api/src/rest/routers/invoices.ts">
import type { Context } from "@api/rest/types";
import {
  deleteInvoiceResponseSchema,
  deleteInvoiceSchema,
  getInvoiceByIdSchema,
  getInvoicesSchema,
  getPaymentStatusResponseSchema,
  invoiceResponseSchema,
  invoiceSummaryResponseSchema,
  invoiceSummarySchema,
  invoicesResponseSchema,
} from "@api/schemas/invoice";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import {
  deleteInvoice,
  getInvoiceById,
  getInvoiceSummary,
  getInvoices,
  getPaymentStatus,
} from "@midday/db/queries";
import { withRequiredScope } from "../middleware";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "List all invoices",
    operationId: "listInvoices",
    "x-speakeasy-name-override": "list",
    description: "Retrieve a list of invoices for the authenticated team.",
    tags: ["Invoices"],
    request: {
      query: getInvoicesSchema,
    },
    responses: {
      200: {
        description: "A list of invoices for the authenticated team.",
        content: {
          "application/json": {
            schema: invoicesResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("invoices.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { pageSize, cursor, sort, ...filter } = c.req.valid("query");

    const result = await getInvoices(db, {
      teamId,
      pageSize,
      cursor,
      sort,
      ...filter,
    });

    return c.json(validateResponse(result, invoicesResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/payment-status",
    summary: "Payment status",
    description: "Get payment status for the authenticated team.",
    tags: ["Invoices"],
    responses: {
      200: {
        description: "Payment status for the authenticated team.",
        content: {
          "application/json": {
            schema: getPaymentStatusResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("invoices.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");

    const result = await getPaymentStatus(db, teamId);

    return c.json(validateResponse(result, getPaymentStatusResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/summary",
    summary: "Invoice summary",
    operationId: "getInvoiceSummary",
    "x-speakeasy-name-override": "summary",
    description: "Get summary of invoices for the authenticated team.",
    tags: ["Invoices"],
    request: {
      query: invoiceSummarySchema,
    },
    responses: {
      200: {
        description: "Summary of invoices for the authenticated team.",
        content: {
          "application/json": {
            schema: invoiceSummaryResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("invoices.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { status } = c.req.valid("query");

    const result = await getInvoiceSummary(db, {
      teamId,
      status,
    });

    return c.json(validateResponse(result, invoiceSummaryResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    summary: "Retrieve a invoice",
    operationId: "getInvoiceById",
    "x-speakeasy-name-override": "get",
    description:
      "Retrieve a invoice by its unique identifier for the authenticated team.",
    tags: ["Invoices"],
    request: {
      params: getInvoiceByIdSchema.pick({ id: true }),
    },
    responses: {
      200: {
        description:
          "Retrieve a invoice by its unique identifier for the authenticated team.",
        content: {
          "application/json": {
            schema: invoiceResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("invoices.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { id } = c.req.valid("param");

    const result = await getInvoiceById(db, {
      id,
      teamId,
    });

    return c.json(validateResponse(result, invoiceResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "delete",
    path: "/{id}",
    summary: "Delete a invoice",
    operationId: "deleteInvoice",
    "x-speakeasy-name-override": "delete",
    description:
      "Delete an invoice by its unique identifier for the authenticated team. Only invoices with status 'draft' or 'canceled' can be deleted directly. If the invoice is not in one of these statuses, update its status to 'canceled' before attempting deletion.",
    tags: ["Invoices"],
    request: {
      params: deleteInvoiceSchema.pick({ id: true }),
    },
    responses: {
      200: {
        description:
          "Delete a invoice by its unique identifier for the authenticated team.",
        content: {
          "application/json": {
            schema: deleteInvoiceResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("invoices.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { id } = c.req.valid("param");

    const result = await deleteInvoice(db, {
      id,
      teamId,
    });

    return c.json(validateResponse(result, deleteInvoiceResponseSchema));
  },
);

export const invoicesRouter = app;
</file>

<file path="apps/api/src/rest/routers/notifications.ts">
import { withRequiredScope } from "@api/rest/middleware";
import type { Context } from "@api/rest/types";
import {
  getNotificationsSchema,
  notificationResponseSchema,
  notificationsResponseSchema,
  updateAllNotificationsStatusResponseSchema,
  updateAllNotificationsStatusSchema,
} from "@api/schemas/notifications";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute, z } from "@hono/zod-openapi";
import {
  getActivities,
  updateActivityStatus,
  updateAllActivitiesStatus,
} from "@midday/db/queries";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "List all notifications",
    operationId: "listNotifications",
    "x-speakeasy-name-override": "list",
    description: "Retrieve a list of notifications for the authenticated team.",
    tags: ["Notifications"],
    request: {
      query: getNotificationsSchema,
    },
    responses: {
      200: {
        description:
          "Retrieve a list of notifications for the authenticated team.",
        content: {
          "application/json": {
            schema: notificationsResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("notifications.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const query = c.req.valid("query");

    const result = await getActivities(db, {
      teamId,
      ...query,
    });

    return c.json(validateResponse(result, notificationsResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "patch",
    path: "/{notificationId}/status",
    summary: "Update notification status",
    operationId: "updateNotificationStatus",
    "x-speakeasy-name-override": "updateStatus",
    description: "Update the status of a specific notification.",
    tags: ["Notifications"],
    request: {
      params: z.object({
        notificationId: z
          .string()
          .uuid()
          .openapi({
            description: "The ID of the notification to update",
            example: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
            param: {
              in: "path",
            },
          }),
      }),
      body: {
        content: {
          "application/json": {
            schema: z.object({
              status: z.enum(["unread", "read", "archived"]).openapi({
                description: "The new status for the notification",
                example: "read",
              }),
            }),
          },
        },
      },
    },
    responses: {
      200: {
        description: "Notification status updated successfully.",
        content: {
          "application/json": {
            schema: notificationResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("notifications.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { notificationId } = c.req.valid("param");
    const { status } = c.req.valid("json");

    const result = await updateActivityStatus(
      db,
      notificationId,
      status,
      teamId,
    );

    return c.json(
      validateResponse({ data: result }, notificationResponseSchema),
    );
  },
);

app.openapi(
  createRoute({
    method: "post",
    path: "/update-all-status",
    summary: "Update status of all notifications",
    operationId: "updateAllNotificationsStatus",
    "x-speakeasy-name-override": "updateAllStatus",
    description:
      "Update the status of all notifications for the authenticated team.",
    tags: ["Notifications"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: updateAllNotificationsStatusSchema,
          },
        },
      },
    },
    responses: {
      200: {
        description: "All notifications status updated successfully.",
        content: {
          "application/json": {
            schema: updateAllNotificationsStatusResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("notifications.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const session = c.get("session");
    const body = c.req.valid("json");

    const result = await updateAllActivitiesStatus(db, teamId, body.status, {
      userId: session.user.id,
    });

    return c.json(
      validateResponse(
        { data: result },
        updateAllNotificationsStatusResponseSchema,
      ),
    );
  },
);

export { app as notificationsRouter };
</file>

<file path="apps/api/src/rest/routers/oauth.ts">
import { publicMiddleware } from "@api/rest/middleware";
import type { Context } from "@api/rest/types";
import {
  oauthApplicationInfoSchema,
  oauthAuthorizationDecisionSchema,
  oauthAuthorizationRequestSchema,
  oauthErrorResponseSchema,
  oauthRefreshTokenRequestSchema,
  oauthRevokeTokenRequestSchema,
  oauthTokenRequestSchema,
  oauthTokenResponseSchema,
} from "@api/schemas/oauth-flow";
import { resend } from "@api/services/resend";
import { verifyAccessToken } from "@api/utils/auth";
import { validateClientCredentials } from "@api/utils/oauth";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import type { Database } from "@midday/db/client";
import {
  createAuthorizationCode,
  exchangeAuthorizationCode,
  getOAuthApplicationByClientId,
  getTeamsByUserId,
  refreshAccessToken,
  revokeAccessToken,
} from "@midday/db/queries";
import { AppInstalledEmail } from "@midday/email/emails/app-installed";
import { render } from "@midday/email/render";
import { rateLimiter } from "hono-rate-limiter";
import { HTTPException } from "hono/http-exception";
import { z } from "zod";

const app = new OpenAPIHono<Context>();

app.use("*", ...publicMiddleware);

app.use(
  "*",
  rateLimiter({
    windowMs: 15 * 60 * 1000, // 15 minutes
    limit: 20, // per IP
    keyGenerator: (c) =>
      c.req.header("x-forwarded-for") || c.req.header("x-real-ip") || "unknown",
    statusCode: 429,
    message: "Rate limit exceeded",
  }),
);

app.openapi(
  createRoute({
    method: "get",
    path: "/authorize",
    summary: "OAuth Authorization Endpoint",
    operationId: "getOAuthAuthorization",
    description:
      "Initiate OAuth authorization flow and get consent screen information",
    tags: ["OAuth"],
    request: {
      query: oauthAuthorizationRequestSchema,
    },
    responses: {
      200: {
        description: "Application information for consent screen",
        content: {
          "application/json": {
            schema: oauthApplicationInfoSchema,
          },
        },
      },
      400: {
        description: "Invalid request",
        content: {
          "application/json": {
            schema: oauthErrorResponseSchema,
          },
        },
      },
    },
  }),
  async (c) => {
    const db = c.get("db") as Database;
    const query = c.req.valid("query");
    const { client_id, redirect_uri, scope, state, code_challenge } = query;

    // Validate client_id
    const application = await getOAuthApplicationByClientId(db, client_id);
    if (!application || !application.active) {
      throw new HTTPException(400, {
        message: "Invalid client_id",
      });
    }

    // Enforce PKCE for public clients
    if (application.isPublic && !code_challenge) {
      throw new HTTPException(400, {
        message: "PKCE is required for public clients",
      });
    }

    // Validate redirect_uri
    if (!application.redirectUris.includes(redirect_uri)) {
      throw new HTTPException(400, {
        message: "Invalid redirect_uri",
      });
    }

    // Validate scopes
    const requestedScopes = scope.split(" ").filter(Boolean);
    const invalidScopes = requestedScopes.filter(
      (s) => !application.scopes.includes(s),
    );

    if (invalidScopes.length > 0) {
      throw new HTTPException(400, {
        message: `Invalid scopes: ${invalidScopes.join(", ")}`,
      });
    }

    // Return application info for consent screen
    const applicationInfo = {
      id: application.id,
      name: application.name,
      description: application.description,
      logoUrl: application.logoUrl,
      website: application.website,
      clientId: application.clientId,
      scopes: requestedScopes,
      redirectUri: redirect_uri,
      state,
    };

    return c.json(
      validateResponse(applicationInfo, oauthApplicationInfoSchema),
    );
  },
);

// OAuth Authorization Decision Endpoint - POST (user consent)
app.openapi(
  createRoute({
    method: "post",
    path: "/authorize",
    summary: "OAuth Authorization Decision",
    operationId: "postOAuthAuthorization",
    description: "Process user's authorization decision (allow/deny)",
    tags: ["OAuth"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: oauthAuthorizationDecisionSchema,
          },
        },
      },
    },
    responses: {
      200: {
        description: "Authorization decision processed, returns redirect URL",
        content: {
          "application/json": {
            schema: z.object({
              redirect_url: z.string().url(),
            }),
          },
        },
      },
      400: {
        description: "Invalid request",
        content: {
          "application/json": {
            schema: z.object({
              redirect_url: z.string().url(),
            }),
          },
        },
      },
      401: {
        description: "Unauthorized",
        content: {
          "application/json": {
            schema: z.object({
              redirect_url: z.string().url(),
            }),
          },
        },
      },
    },
  }),
  async (c) => {
    const db = c.get("db");
    const authHeader = c.req.header("Authorization");
    const body = c.req.valid("json");

    const {
      client_id,
      decision,
      scopes,
      redirect_uri,
      state,
      code_challenge,
      teamId,
    } = body;

    // Verify user authentication
    const accessToken = authHeader?.split(" ")[1];
    const session = await verifyAccessToken(accessToken);

    if (!session) {
      throw new HTTPException(401, {
        message: "User must be authenticated",
      });
    }

    // Validate client_id
    const application = await getOAuthApplicationByClientId(db, client_id);
    if (!application || !application.active) {
      throw new HTTPException(400, {
        message: "Invalid client_id",
      });
    }

    // Enforce PKCE for public clients
    if (application.isPublic && !code_challenge) {
      throw new HTTPException(400, {
        message: "PKCE is required for public clients",
      });
    }

    // Validate user is a member of the selected team
    const userTeams = await getTeamsByUserId(db, session.user.id);
    const isMemberOfTeam = userTeams.some((team) => team.id === teamId);

    if (!isMemberOfTeam) {
      throw new HTTPException(403, {
        message: "User is not a member of the selected team",
      });
    }

    const redirectUrl = new URL(redirect_uri);

    // Handle denial
    if (decision === "deny") {
      redirectUrl.searchParams.set("error", "access_denied");
      redirectUrl.searchParams.set("error_description", "User denied access");
      if (state) {
        redirectUrl.searchParams.set("state", state);
      }
      return c.json({ redirect_url: redirectUrl.toString() });
    }

    // Create authorization code
    const authCode = await createAuthorizationCode(db, {
      applicationId: application.id,
      userId: session.user.id,
      teamId: teamId,
      scopes,
      redirectUri: redirect_uri,
      codeChallenge: code_challenge,
    });

    if (!authCode) {
      throw new HTTPException(500, {
        message: "Failed to create authorization code",
      });
    }

    // Send app installation email
    try {
      // Get team information
      const userTeam = userTeams.find((team) => team.id === teamId);

      if (userTeam && session.user.email) {
        const html = await render(
          AppInstalledEmail({
            email: session.user.email,
            teamName: userTeam.name!,
            appName: application.name,
          }),
        );

        await resend.emails.send({
          from: "Midday <middaybot@midday.ai>",
          to: session.user.email,
          subject: "An app has been added to your team",
          html,
        });
      }
    } catch (error) {
      // Log error but don't fail the OAuth flow
      console.error("Failed to send app installation email:", error);
    }

    // Build success redirect URL
    redirectUrl.searchParams.set("code", authCode.code);
    if (state) {
      redirectUrl.searchParams.set("state", state);
    }

    return c.json({ redirect_url: redirectUrl.toString() });
  },
);

// OAuth Token Exchange Endpoint
app.openapi(
  createRoute({
    method: "post",
    path: "/token",
    summary: "OAuth Token Exchange",
    operationId: "postOAuthToken",
    description:
      "Exchange authorization code for access token or refresh an access token",
    tags: ["OAuth"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: z.union([
              oauthTokenRequestSchema,
              oauthRefreshTokenRequestSchema,
            ]),
          },
          "application/x-www-form-urlencoded": {
            schema: z.union([
              oauthTokenRequestSchema,
              oauthRefreshTokenRequestSchema,
            ]),
          },
        },
      },
    },
    responses: {
      200: {
        description: "Token exchange successful",
        content: {
          "application/json": {
            schema: oauthTokenResponseSchema,
          },
        },
      },
      400: {
        description: "Invalid request",
        content: {
          "application/json": {
            schema: oauthErrorResponseSchema,
          },
        },
      },
    },
  }),
  async (c) => {
    const db = c.get("db");
    const contentType = c.req.header("content-type") || "";

    let body: any;
    if (contentType.includes("application/x-www-form-urlencoded")) {
      body = await c.req.parseBody();
    } else {
      body = c.req.valid("json");
    }

    const {
      grant_type,
      code,
      redirect_uri,
      client_id,
      client_secret,
      code_verifier,
      refresh_token,
      scope,
    } = body;

    // Validate client credentials
    const application = await getOAuthApplicationByClientId(db, client_id);
    if (!application || !application.active) {
      throw new HTTPException(400, {
        message: "Invalid client credentials",
      });
    }

    // For public clients, client_secret should not be provided
    if (application.isPublic) {
      if (client_secret) {
        throw new HTTPException(400, {
          message: "Public clients must not send client_secret",
        });
      }
    } else {
      // For confidential clients, validate client_secret
      if (!validateClientCredentials(application, client_secret)) {
        throw new HTTPException(400, {
          message: "Invalid client credentials",
        });
      }
    }

    if (grant_type === "authorization_code") {
      if (!code || !redirect_uri) {
        throw new HTTPException(400, {
          message: "Missing required parameters",
        });
      }

      // Exchange authorization code for access token
      const tokenResponse = await exchangeAuthorizationCode(
        db,
        code,
        redirect_uri,
        application.id,
        code_verifier,
      );

      const response = {
        access_token: tokenResponse.accessToken,
        token_type: tokenResponse.tokenType,
        expires_in: tokenResponse.expiresIn,
        refresh_token: tokenResponse.refreshToken || "",
        scope: tokenResponse.scopes.join(" "),
      };

      return c.json(validateResponse(response, oauthTokenResponseSchema));
    }

    if (grant_type === "refresh_token") {
      if (!refresh_token) {
        throw new HTTPException(400, {
          message: "Missing refresh_token",
        });
      }

      try {
        // Parse requested scopes
        const requestedScopes = scope
          ? scope.split(" ").filter(Boolean)
          : undefined;

        // Refresh access token
        const tokenResponse = await refreshAccessToken(db, {
          refreshToken: refresh_token,
          applicationId: application.id,
          scopes: requestedScopes,
        });

        const response = {
          access_token: tokenResponse.accessToken,
          token_type: tokenResponse.tokenType,
          expires_in: tokenResponse.expiresIn,
          refresh_token: tokenResponse.refreshToken || "",
          scope: tokenResponse.scopes.join(" "),
        };

        return c.json(validateResponse(response, oauthTokenResponseSchema));
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Unknown error";

        if (errorMessage.includes("Invalid refresh token")) {
          throw new HTTPException(400, {
            message: "Invalid refresh token",
          });
        }

        if (errorMessage.includes("expired")) {
          throw new HTTPException(400, {
            message: "Refresh token expired",
          });
        }

        if (errorMessage.includes("revoked")) {
          throw new HTTPException(400, {
            message: "Refresh token revoked",
          });
        }

        throw new HTTPException(400, {
          message: "Failed to refresh access token",
        });
      }
    }

    throw new HTTPException(400, {
      message: "Grant type not supported",
    });
  },
);

// OAuth Token Revocation Endpoint
app.openapi(
  createRoute({
    method: "post",
    path: "/revoke",
    summary: "OAuth Token Revocation",
    operationId: "postOAuthRevoke",
    description: "Revoke an access token or refresh token",
    tags: ["OAuth"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: oauthRevokeTokenRequestSchema,
          },
          "application/x-www-form-urlencoded": {
            schema: oauthRevokeTokenRequestSchema,
          },
        },
      },
    },
    responses: {
      200: {
        description: "Token revocation successful",
        content: {
          "application/json": {
            schema: z.object({
              success: z.boolean(),
            }),
          },
        },
      },
    },
  }),
  async (c) => {
    const db = c.get("db");
    const contentType = c.req.header("content-type") || "";

    let body: any;
    if (contentType.includes("application/x-www-form-urlencoded")) {
      body = await c.req.parseBody();
    } else {
      body = c.req.valid("json");
    }

    const { token, client_id, client_secret } = body;

    // Validate client credentials
    const application = await getOAuthApplicationByClientId(db, client_id);
    if (!application || !application.active) {
      throw new HTTPException(400, {
        message: "Invalid client credentials",
      });
    }

    // For public clients, client_secret should not be provided
    if (application.isPublic) {
      if (client_secret) {
        throw new HTTPException(400, {
          message: "Public clients must not send client_secret",
        });
      }
    } else {
      // For confidential clients, validate client_secret
      if (!validateClientCredentials(application, client_secret)) {
        throw new HTTPException(400, {
          message: "Invalid client credentials",
        });
      }
    }

    // Revoke token
    await revokeAccessToken(db, {
      token,
      applicationId: application.id,
    });

    return c.json({ success: true });
  },
);

export default app;
</file>

<file path="apps/api/src/rest/routers/reports.ts">
import type { Context } from "@api/rest/types";
import {
  getBurnRateResponseSchema,
  getBurnRateSchema,
  getExpensesResponseSchema,
  getExpensesSchema,
  getProfitResponseSchema,
  getProfitSchema,
  getRevenueResponseSchema,
  getRevenueSchema,
  getRunwayResponseSchema,
  getRunwaySchema,
  getSpendingResponseSchema,
  getSpendingSchema,
} from "@api/schemas/reports";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import {
  getBurnRate,
  getExpenses,
  getReports,
  getRunway,
  getSpending,
} from "@midday/db/queries";
import { withRequiredScope } from "../middleware";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/revenue",
    summary: "Revenue reports",
    operationId: "getRevenueReports",
    "x-speakeasy-name-override": "revenue",
    description: "Revenue reports for the authenticated team.",
    tags: ["Reports"],
    request: {
      query: getRevenueSchema,
    },
    responses: {
      200: {
        description: "Revenue reports for the authenticated team.",
        content: {
          "application/json": {
            schema: getRevenueResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("reports.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { from, to, currency } = c.req.valid("query");

    const results = await getReports(db, {
      teamId,
      from,
      to,
      currency,
      type: "revenue",
    });

    return c.json(validateResponse(results, getRevenueResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/profit",
    summary: "Profit reports",
    operationId: "getProfitReports",
    "x-speakeasy-name-override": "profit",
    description: "Profit reports for the authenticated team.",
    tags: ["Reports"],
    request: {
      query: getProfitSchema,
    },
    responses: {
      200: {
        description: "Profit reports for the authenticated team.",
        content: {
          "application/json": {
            schema: getProfitResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("reports.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { from, to, currency } = c.req.valid("query");

    const results = await getReports(db, {
      teamId,
      from,
      to,
      currency,
      type: "profit",
    });

    return c.json(validateResponse(results, getProfitResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/burn-rate",
    summary: "Burn rate reports",
    operationId: "getBurnRateReports",
    "x-speakeasy-name-override": "burn-rate",
    description: "Burn rate reports for the authenticated team.",
    tags: ["Reports"],
    request: {
      query: getBurnRateSchema,
    },
    responses: {
      200: {
        description: "Burn rate reports for the authenticated team.",
        content: {
          "application/json": {
            schema: getBurnRateResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("reports.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { from, to, currency } = c.req.valid("query");

    const results = await getBurnRate(db, {
      teamId,
      from,
      to,
      currency,
    });

    return c.json(validateResponse(results, getBurnRateResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/runway",
    summary: "Runway reports",
    operationId: "getRunwayReports",
    "x-speakeasy-name-override": "runway",
    description: "Runway reports for the authenticated team.",
    tags: ["Reports"],
    request: {
      query: getRunwaySchema,
    },
    responses: {
      200: {
        description: "Runway reports for the authenticated team.",
        content: {
          "application/json": {
            schema: getRunwayResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("reports.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { from, to, currency } = c.req.valid("query");

    const results = await getRunway(db, {
      teamId,
      from,
      to,
      currency,
    });

    return c.json(validateResponse(results, getRunwayResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/expenses",
    summary: "Expense reports",
    operationId: "getExpensesReports",
    "x-speakeasy-name-override": "expenses",
    description: "Expense reports for the authenticated team.",
    tags: ["Reports"],
    request: {
      query: getExpensesSchema,
    },
    responses: {
      200: {
        description: "Expense reports for the authenticated team.",
        content: {
          "application/json": {
            schema: getExpensesResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("reports.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { from, to, currency } = c.req.valid("query");

    const results = await getExpenses(db, {
      teamId,
      from,
      to,
      currency,
    });

    return c.json(validateResponse(results, getExpensesResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/spending",
    summary: "Spending reports",
    operationId: "getSpendingReports",
    "x-speakeasy-name-override": "spending",
    description: "Spending reports for the authenticated team.",
    tags: ["Reports"],
    request: {
      query: getSpendingSchema,
    },
    responses: {
      200: {
        description: "Spending reports for the authenticated team.",
        content: {
          "application/json": {
            schema: getSpendingResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("reports.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { from, to, currency } = c.req.valid("query");

    const results = await getSpending(db, {
      teamId,
      from,
      to,
      currency,
    });

    return c.json(validateResponse(results, getSpendingResponseSchema));
  },
);

export const reportsRouter = app;
</file>

<file path="apps/api/src/rest/routers/search.ts">
import type { Context } from "@api/rest/types";
import { globalSearchSchema, searchResponseSchema } from "@api/schemas/search";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import { globalSearchQuery } from "@midday/db/queries";
import { withRequiredScope } from "../middleware";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "Search",
    operationId: "search",
    "x-speakeasy-name-override": "search",
    description:
      "Search across all data, invoices, documents, customers, transactions, and more.",
    tags: ["Search"],
    request: {
      query: globalSearchSchema,
    },
    responses: {
      200: {
        description: "Search results.",
        content: {
          "application/json": {
            schema: searchResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("search.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { searchTerm, ...input } = c.req.valid("query");

    const results = await globalSearchQuery(db, {
      teamId: teamId!,
      ...input,
      searchTerm: searchTerm,
      /**
       * Tighten the relevance threshold whenever the user enters a multi-word query.
       *
       * Rationale:
       * 1. A longer query usually implies a more specific intent, so we only want
       *    results that score highly on relevance.
       * 2. If this stricter search returns nothing, we immediately fall back to the
       *    LLM-generated filter logic below.  By filtering aggressively here we avoid
       *    surfacing low-quality matches and give the LLM a chance to produce a more
       *    intelligent result instead.
       */
      relevanceThreshold: 0.01,
      // relevanceThreshold: shouldUseLLMFilters
      //   ? 0.9
      //   : input.relevanceThreshold,
    });

    return c.json(validateResponse(results, searchResponseSchema));
  },
);

export const searchRouter = app;
</file>

<file path="apps/api/src/rest/routers/tags.ts">
import type { Context } from "@api/rest/types";
import {
  createTagSchema,
  deleteTagSchema,
  tagResponseSchema,
  tagsResponseSchema,
  updateTagSchema,
} from "@api/schemas/tags";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import {
  createTag,
  deleteTag,
  getTagById,
  getTags,
  updateTag,
} from "@midday/db/queries";
import { withRequiredScope } from "../middleware";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "List all tags",
    operationId: "listTags",
    "x-speakeasy-name-override": "list",
    description: "Retrieve a list of tags for the authenticated team.",
    tags: ["Tags"],
    responses: {
      200: {
        description: "Retrieve a list of tags for the authenticated team.",
        content: {
          "application/json": {
            schema: tagsResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tags.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");

    const result = await getTags(db, { teamId });

    return c.json(
      validateResponse(
        {
          data: result,
        },
        tagsResponseSchema,
      ),
    );
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    summary: "Retrieve a tag",
    operationId: "getTagById",
    "x-speakeasy-name-override": "get",
    description: "Retrieve a tag by ID for the authenticated team.",
    tags: ["Tags"],
    request: {
      params: tagResponseSchema.pick({ id: true }),
    },
    responses: {
      200: {
        description: "Retrieve a tag by ID for the authenticated team.",
        content: {
          "application/json": {
            schema: tagResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tags.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { id } = c.req.valid("param");

    const result = await getTagById(db, { id, teamId });

    return c.json(validateResponse(result, tagResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "post",
    path: "/",
    summary: "Create a new tag",
    operationId: "createTag",
    "x-speakeasy-name-override": "create",
    description: "Create a new tag for the authenticated team.",
    tags: ["Tags"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: createTagSchema,
          },
        },
      },
    },
    responses: {
      201: {
        description: "Tag created",
        content: {
          "application/json": {
            schema: tagsResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tags.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const body = c.req.valid("json");

    const result = await createTag(db, { teamId, ...body });

    return c.json(validateResponse(result, tagResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "patch",
    path: "/{id}",
    summary: "Update a tag",
    operationId: "updateTag",
    "x-speakeasy-name-override": "update",
    description: "Update a tag by ID for the authenticated team.",
    tags: ["Tags"],
    request: {
      params: updateTagSchema.pick({ id: true }),
      body: {
        content: {
          "application/json": {
            schema: updateTagSchema.pick({ name: true }),
          },
        },
      },
    },
    responses: {
      200: {
        description: "Tag updated",
        content: {
          "application/json": {
            schema: tagResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tags.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { id } = c.req.valid("param");
    const { name } = c.req.valid("json");

    const result = await updateTag(db, {
      id,
      name,
      teamId,
    });

    return c.json(validateResponse(result, tagResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "delete",
    path: "/{id}",
    summary: "Delete a tag",
    operationId: "deleteTag",
    "x-speakeasy-name-override": "delete",
    description: "Delete a tag by ID for the authenticated team.",
    tags: ["Tags"],
    request: {
      params: deleteTagSchema.pick({ id: true }),
    },
    responses: {
      204: {
        description: "Tag deleted",
      },
    },
    middleware: [withRequiredScope("tags.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { id } = c.req.valid("param");

    const result = await deleteTag(db, { id, teamId });

    return c.json(validateResponse(result, tagResponseSchema));
  },
);

export const tagsRouter = app;
</file>

<file path="apps/api/src/rest/routers/teams.ts">
import type { Context } from "@api/rest/types";
import {
  getTeamByIdSchema,
  teamMembersResponseSchema,
  teamResponseSchema,
  teamsResponseSchema,
  updateTeamByIdSchema,
} from "@api/schemas/team";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import {
  getTeamById,
  getTeamMembers,
  getTeamsByUserId,
  updateTeamById,
} from "@midday/db/queries";
import { withRequiredScope } from "../middleware";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "List all teams",
    operationId: "listTeams",
    "x-speakeasy-name-override": "list",
    description: "Retrieve a list of teams for the authenticated user.",
    tags: ["Teams"],
    responses: {
      200: {
        description: "Retrieve a list of teams for the authenticated user.",
        content: {
          "application/json": {
            schema: teamsResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("teams.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const session = c.get("session");

    const result = await getTeamsByUserId(db, session.user.id);

    return c.json(validateResponse({ data: result }, teamsResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    summary: "Retrieve a team",
    operationId: "getTeamById",
    "x-speakeasy-name-override": "get",
    description: "Retrieve a team by its ID for the authenticated team.",
    tags: ["Teams"],
    request: {
      params: getTeamByIdSchema,
    },
    responses: {
      200: {
        description: "Team details",
        content: {
          "application/json": {
            schema: teamResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("teams.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.req.param("id");

    const result = await getTeamById(db, teamId);

    return c.json(validateResponse(result, teamResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "patch",
    path: "/{id}",
    summary: "Update a team",
    operationId: "updateTeamById",
    "x-speakeasy-name-override": "update",
    description:
      "Update a team for the authenticated workspace. If there’s no change, returns it as it is.",
    tags: ["Teams"],
    request: {
      params: getTeamByIdSchema,
      body: {
        content: {
          "application/json": {
            schema: updateTeamByIdSchema,
          },
        },
      },
    },
    responses: {
      200: {
        description: "Team updated",
        content: {
          "application/json": {
            schema: teamResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("teams.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.req.param("id");
    const params = c.req.valid("json");

    const result = await updateTeamById(db, {
      id: teamId,
      data: params,
    });

    return c.json(validateResponse(result, teamResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/{id}/members",
    summary: "List all team members",
    operationId: "listTeamMembers",
    "x-speakeasy-name-override": "members",
    description: "List all team members for the authenticated team.",
    tags: ["Teams"],
    request: {
      params: getTeamByIdSchema,
    },
    responses: {
      200: {
        description: "Team members",
        content: {
          "application/json": {
            schema: teamMembersResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("teams.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.req.param("id");

    const result = await getTeamMembers(db, teamId);

    return c.json(
      validateResponse({ data: result }, teamMembersResponseSchema),
    );
  },
);

export const teamsRouter = app;
</file>

<file path="apps/api/src/rest/routers/tracker-entries.ts">
import type { Context } from "@api/rest/types";
import {
  bulkCreateTrackerEntriesSchema,
  createTrackerEntriesResponseSchema,
  deleteTrackerEntrySchema,
  getCurrentTimerResponseSchema,
  getCurrentTimerSchema,
  getTimerStatusResponseSchema,
  getTrackerRecordsByRangeSchema,
  startTimerResponseSchema,
  startTimerSchema,
  stopTimerResponseSchema,
  stopTimerSchema,
  trackerEntriesResponseSchema,
  upsertTrackerEntriesSchema,
} from "@api/schemas/tracker-entries";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import {
  bulkCreateTrackerEntries,
  deleteTrackerEntry,
  getCurrentTimer,
  getTimerStatus,
  getTrackerRecordsByRange,
  startTimer,
  stopTimer,
  upsertTrackerEntries,
} from "@midday/db/queries";
import { withRequiredScope } from "../middleware";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "List all tracker entries",
    operationId: "listTrackerEntries",
    "x-speakeasy-name-override": "list",
    description: "List all tracker entries for the authenticated team.",
    tags: ["Tracker Entries"],
    request: {
      query: getTrackerRecordsByRangeSchema,
    },
    responses: {
      200: {
        description: "List all tracker entries for the authenticated team.",
        content: {
          "application/json": {
            schema: trackerEntriesResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-entries.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");

    const result = await getTrackerRecordsByRange(db, {
      teamId,
      ...c.req.valid("query"),
    });

    return c.json(validateResponse(result, trackerEntriesResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "post",
    path: "/",
    summary: "Create a tracker entry",
    operationId: "createTrackerEntry",
    "x-speakeasy-name-override": "create",
    description: "Create a tracker entry for the authenticated team.",
    tags: ["Tracker Entries"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: upsertTrackerEntriesSchema.omit({ id: true }),
          },
        },
      },
    },
    responses: {
      201: {
        description: "Tracker entry created successfully.",
        content: {
          "application/json": {
            schema: createTrackerEntriesResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-entries.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const session = c.get("session");
    const { assignedId, ...rest } = c.req.valid("json");

    const result = await upsertTrackerEntries(db, {
      teamId,
      assignedId: assignedId ?? session.user.id,
      ...rest,
    });

    // Map trackerProject to project to match the response schema
    const dataWithProject = result.map((item) => ({
      ...item,
      project: item.trackerProject,
    }));

    return c.json(
      validateResponse(
        { data: dataWithProject },
        createTrackerEntriesResponseSchema,
      ),
    );
  },
);

app.openapi(
  createRoute({
    method: "post",
    path: "/bulk",
    summary: "Create multiple tracker entries",
    operationId: "createTrackerEntriesBulk",
    "x-speakeasy-name-override": "createBulk",
    description:
      "Create multiple tracker entries in a single request for efficient data migration.",
    tags: ["Tracker Entries"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: bulkCreateTrackerEntriesSchema,
          },
        },
      },
    },
    responses: {
      201: {
        description: "Tracker entries created successfully.",
        content: {
          "application/json": {
            schema: createTrackerEntriesResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-entries.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const session = c.get("session");
    const { entries } = c.req.valid("json");

    const result = await bulkCreateTrackerEntries(db, {
      teamId,
      entries: entries.map(({ assignedId, ...rest }) => ({
        assignedId: assignedId ?? session.user.id,
        ...rest,
      })),
    });

    const dataWithProject = result.map((item) => ({
      ...item,
      project: item.trackerProject,
    }));

    return c.json(
      validateResponse(
        { data: dataWithProject },
        createTrackerEntriesResponseSchema,
      ),
    );
  },
);

app.openapi(
  createRoute({
    method: "patch",
    path: "/{id}",
    summary: "Update a tracker entry",
    operationId: "updateTrackerEntry",
    "x-speakeasy-name-override": "update",
    description: "Update a tracker entry for the authenticated team.",
    tags: ["Tracker Entries"],
    request: {
      params: deleteTrackerEntrySchema.pick({ id: true }),
      body: {
        content: {
          "application/json": {
            schema: upsertTrackerEntriesSchema.omit({ id: true }),
          },
        },
      },
    },
    responses: {
      200: {
        description: "Tracker entry updated successfully.",
        content: {
          "application/json": {
            schema: createTrackerEntriesResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-entries.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { id } = c.req.valid("param");
    const { assignedId, ...rest } = c.req.valid("json");

    const result = await upsertTrackerEntries(db, {
      id,
      teamId,
      ...rest,
      ...(assignedId !== undefined && { assignedId }),
    });

    // Map trackerProject to project to match the response schema
    const dataWithProject = result.map((item) => ({
      ...item,
      project: item.trackerProject,
    }));

    return c.json(
      validateResponse(
        { data: dataWithProject },
        createTrackerEntriesResponseSchema,
      ),
    );
  },
);

app.openapi(
  createRoute({
    method: "delete",
    path: "/{id}",
    summary: "Delete a tracker entry",
    operationId: "deleteTrackerEntry",
    "x-speakeasy-name-override": "delete",
    description: "Delete a tracker entry for the authenticated team.",
    tags: ["Tracker Entries"],
    request: {
      params: deleteTrackerEntrySchema.pick({ id: true }),
    },
    responses: {
      200: {
        description: "Tracker entry deleted successfully.",
        content: {
          "application/json": {
            schema: deleteTrackerEntrySchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-entries.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { id } = c.req.valid("param");

    const result = await deleteTrackerEntry(db, { teamId, id });

    return c.json(validateResponse(result, deleteTrackerEntrySchema));
  },
);

// Timer endpoints
app.openapi(
  createRoute({
    method: "post",
    path: "/timer/start",
    summary: "Start a timer",
    operationId: "startTimer",
    "x-speakeasy-name-override": "startTimer",
    description: "Start a new timer or continue from a paused entry.",
    tags: ["Tracker Timer"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: startTimerSchema,
          },
        },
      },
    },
    responses: {
      201: {
        description: "Timer started successfully.",
        content: {
          "application/json": {
            schema: startTimerResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-entries.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const session = c.get("session");
    const { assignedId, ...rest } = c.req.valid("json");

    const result = await startTimer(db, {
      teamId,
      assignedId: assignedId ?? session.user.id,
      ...rest,
    });

    return c.json(
      validateResponse({ data: result }, startTimerResponseSchema),
      201,
    );
  },
);

app.openapi(
  createRoute({
    method: "post",
    path: "/timer/stop",
    summary: "Stop a timer",
    operationId: "stopTimer",
    "x-speakeasy-name-override": "stopTimer",
    description: "Stop the current running timer or a specific timer entry.",
    tags: ["Tracker Timer"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: stopTimerSchema,
          },
        },
      },
    },
    responses: {
      200: {
        description: "Timer stopped successfully.",
        content: {
          "application/json": {
            schema: stopTimerResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-entries.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const session = c.get("session");
    const { assignedId, ...rest } = c.req.valid("json");

    const result = await stopTimer(db, {
      teamId,
      assignedId: assignedId ?? session.user.id,
      ...rest,
    });

    return c.json(validateResponse({ data: result }, stopTimerResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/timer/current",
    summary: "Get current timer",
    operationId: "getCurrentTimer",
    "x-speakeasy-name-override": "getCurrentTimer",
    description: "Get the currently running timer for the authenticated user.",
    tags: ["Tracker Timer"],
    request: {
      query: getCurrentTimerSchema,
    },
    responses: {
      200: {
        description: "Current timer retrieved successfully.",
        content: {
          "application/json": {
            schema: getCurrentTimerResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-entries.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const session = c.get("session");
    const { assignedId } = c.req.valid("query");

    const result = await getCurrentTimer(db, {
      teamId,
      assignedId: assignedId ?? session.user.id,
    });

    return c.json(
      validateResponse({ data: result }, getCurrentTimerResponseSchema),
    );
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/timer/status",
    summary: "Get timer status",
    operationId: "getTimerStatus",
    "x-speakeasy-name-override": "getTimerStatus",
    description:
      "Get timer status including elapsed time for the authenticated user.",
    tags: ["Tracker Timer"],
    request: {
      query: getCurrentTimerSchema,
    },
    responses: {
      200: {
        description: "Timer status retrieved successfully.",
        content: {
          "application/json": {
            schema: getTimerStatusResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-entries.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const session = c.get("session");
    const { assignedId } = c.req.valid("query");

    const result = await getTimerStatus(db, {
      teamId,
      assignedId: assignedId ?? session.user.id,
    });

    return c.json(
      validateResponse({ data: result }, getTimerStatusResponseSchema),
    );
  },
);

export const trackerEntriesRouter = app;
</file>

<file path="apps/api/src/rest/routers/tracker-projects.ts">
import type { Context } from "@api/rest/types";
import {
  deleteTrackerProjectSchema,
  getTrackerProjectByIdSchema,
  getTrackerProjectsSchema,
  trackerProjectResponseSchema,
  trackerProjectsResponseSchema,
  upsertTrackerProjectSchema,
} from "@api/schemas/tracker-projects";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import {
  deleteTrackerProject,
  getTrackerProjectById,
  getTrackerProjects,
  upsertTrackerProject,
} from "@midday/db/queries";
import { withRequiredScope } from "../middleware";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "List all tracker projects",
    operationId: "listTrackerProjects",
    "x-speakeasy-name-override": "list",
    description: "List all tracker projects for the authenticated team.",
    tags: ["Tracker Projects"],
    request: {
      query: getTrackerProjectsSchema,
    },
    responses: {
      200: {
        description: "List all tracker projects for the authenticated team.",
        content: {
          "application/json": {
            schema: trackerProjectsResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-projects.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");

    const { cursor, pageSize, sort, ...filter } = c.req.valid("query");

    const result = await getTrackerProjects(db, {
      teamId,
      cursor,
      pageSize,
      ...filter,
      sort,
    });

    return c.json(validateResponse(result, trackerProjectsResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "post",
    path: "/",
    summary: "Create a tracker project",
    operationId: "createTrackerProject",
    "x-speakeasy-name-override": "create",
    description: "Create a tracker project for the authenticated team.",
    tags: ["Tracker Projects"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: upsertTrackerProjectSchema.omit({ id: true }),
            example: {
              name: "New Project",
            },
          },
        },
        description: "Tracker project to create",
      },
    },
    responses: {
      200: {
        description: "Tracker project created successfully.",
        content: {
          "application/json": {
            schema: trackerProjectResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-projects.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const userId = c.get("session").user.id;

    const result = await upsertTrackerProject(db, {
      teamId,
      userId,
      ...c.req.valid("json"),
    });

    return c.json(validateResponse(result, trackerProjectResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "patch",
    path: "/{id}",
    summary: "Update a tracker project",
    operationId: "updateTrackerProject",
    "x-speakeasy-name-override": "update",
    description: "Update a tracker project for the authenticated team.",
    tags: ["Tracker Projects"],
    request: {
      params: getTrackerProjectByIdSchema.pick({ id: true }),
      body: {
        content: {
          "application/json": {
            schema: upsertTrackerProjectSchema.omit({ id: true }),
          },
        },
      },
    },
    responses: {
      200: {
        description: "Tracker project updated successfully.",
        content: {
          "application/json": {
            schema: trackerProjectResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-projects.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const userId = c.get("session").user.id;
    const { id } = c.req.valid("param");

    const result = await upsertTrackerProject(db, {
      teamId,
      id,
      userId,
      ...c.req.valid("json"),
    });

    return c.json(validateResponse(result, trackerProjectResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    summary: "Retrieve a tracker project",
    operationId: "getTrackerProjectById",
    "x-speakeasy-name-override": "get",
    description: "Retrieve a tracker project for the authenticated team.",
    tags: ["Tracker Projects"],
    request: {
      params: getTrackerProjectByIdSchema.pick({ id: true }),
    },
    responses: {
      200: {
        description: "Tracker project by ID for the authenticated team.",
        content: {
          "application/json": {
            schema: trackerProjectResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-projects.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");

    const { id } = c.req.valid("param");

    const result = await getTrackerProjectById(db, {
      teamId,
      id,
    });

    return c.json(validateResponse(result, trackerProjectResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "delete",
    path: "/{id}",
    summary: "Delete a tracker project",
    operationId: "deleteTrackerProject",
    "x-speakeasy-name-override": "delete",
    description: "Delete a tracker project for the authenticated team.",
    tags: ["Tracker Projects"],
    request: {
      params: getTrackerProjectByIdSchema.pick({ id: true }),
    },
    responses: {
      200: {
        description: "Tracker project deleted successfully.",
        content: {
          "application/json": {
            schema: deleteTrackerProjectSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("tracker-projects.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");

    const { id } = c.req.valid("param");

    const result = await deleteTrackerProject(db, {
      teamId,
      id,
    });

    return c.json(validateResponse(result, deleteTrackerProjectSchema));
  },
);

export const trackerProjectsRouter = app;
</file>

<file path="apps/api/src/rest/routers/transactions.ts">
import type { Context } from "@api/rest/types";
import {
  createTransactionSchema,
  createTransactionsResponseSchema,
  createTransactionsSchema,
  deleteTransactionResponseSchema,
  deleteTransactionSchema,
  deleteTransactionsResponseSchema,
  deleteTransactionsSchema,
  getTransactionByIdSchema,
  getTransactionsSchema,
  transactionResponseSchema,
  transactionsResponseSchema,
  updateTransactionSchema,
  updateTransactionsSchema,
} from "@api/schemas/transactions";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import {
  createTransaction,
  createTransactions,
  deleteTransactions,
  getTransactionById,
  getTransactions,
  updateTransaction,
  updateTransactions,
} from "@midday/db/queries";
import { withRequiredScope } from "../middleware";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "List all transactions",
    operationId: "listTransactions",
    "x-speakeasy-name-override": "list",
    description: "Retrieve a list of transactions for the authenticated team.",
    tags: ["Transactions"],
    request: {
      query: getTransactionsSchema,
    },
    responses: {
      200: {
        description:
          "Retrieve a list of transactions for the authenticated team.",
        content: {
          "application/json": {
            schema: transactionsResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("transactions.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const query = c.req.valid("query");

    const data = await getTransactions(db, {
      teamId,
      ...query,
    });

    return c.json(validateResponse(data, transactionsResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    summary: "Retrieve a transaction",
    operationId: "getTransactionById",
    "x-speakeasy-name-override": "get",
    description: "Retrieve a transaction by its ID for the authenticated team.",
    tags: ["Transactions"],
    request: {
      params: getTransactionByIdSchema.pick({ id: true }),
    },
    responses: {
      200: {
        description: "Transaction details",
        content: {
          "application/json": {
            schema: transactionResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("transactions.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { id } = c.req.valid("param");

    const result = await getTransactionById(db, { id, teamId });

    return c.json(validateResponse(result, transactionResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "post",
    path: "/",
    summary: "Create a transaction",
    operationId: "createTransaction",
    "x-speakeasy-name-override": "create",
    description: "Create a transaction",
    tags: ["Transactions"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: createTransactionSchema,
          },
        },
      },
    },
    responses: {
      200: {
        description: "Transaction created",
        content: { "application/json": { schema: transactionResponseSchema } },
      },
    },
    middleware: [withRequiredScope("transactions.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const params = c.req.valid("json");

    const result = await createTransaction(db, { teamId, ...params });

    return c.json(validateResponse(result, transactionResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "patch",
    path: "/{id}",
    summary: "Update a transaction",
    operationId: "updateTransaction",
    "x-speakeasy-name-override": "update",
    description:
      "Update a transaction for the authenticated team. If there's no change, returns it as it is.",
    tags: ["Transactions"],
    request: {
      params: getTransactionByIdSchema.pick({ id: true }),
      body: {
        content: {
          "application/json": {
            schema: updateTransactionSchema.omit({ id: true }),
          },
        },
      },
    },
    responses: {
      200: {
        description: "Transaction updated",
        content: {
          "application/json": {
            schema: transactionResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("transactions.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const userId = c.get("session").user.id;
    const { id } = c.req.valid("param");
    const params = c.req.valid("json");

    const result = await updateTransaction(db, {
      teamId,
      id,
      userId,
      ...params,
    });

    return c.json(validateResponse(result, transactionResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "patch",
    path: "/bulk",
    summary: "Bulk update transactions",
    operationId: "updateTransactions",
    "x-speakeasy-name-override": "updateMany",
    description:
      "Bulk update transactions for the authenticated team. If there's no change, returns it as it is.",
    tags: ["Transactions"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: updateTransactionsSchema,
          },
        },
      },
    },
    responses: {
      200: {
        description: "Transactions updated",
        content: {
          "application/json": {
            schema: transactionsResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("transactions.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const userId = c.get("session").user.id;
    const params = c.req.valid("json");

    const result = await updateTransactions(db, {
      teamId,
      userId,
      ...params,
    });

    return c.json(validateResponse(result, transactionsResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "post",
    path: "/bulk",
    summary: "Bulk create transactions",
    operationId: "createTransactions",
    "x-speakeasy-name-override": "createMany",
    description: "Bulk create transactions for the authenticated team.",
    tags: ["Transactions"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: createTransactionsSchema,
          },
        },
      },
    },
    responses: {
      200: {
        description: "Transactions created",
        content: {
          "application/json": {
            schema: createTransactionsResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("transactions.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const params = c.req.valid("json");

    const data = params.map((item) => ({ ...item, teamId }));
    const result = await createTransactions(db, data);

    return c.json(validateResponse(result, createTransactionsResponseSchema));
  },
);

// app.post(
//   "/:id/attachments",
//   describeRoute({
//     description: "Upload an attachment to a transaction",
//     tags: ["Transactions"],
//   }),
// );

// NOTE: This endpoint needs to be registred before :id delete
app.openapi(
  createRoute({
    method: "delete",
    path: "/bulk",
    summary: "Bulk delete transactions",
    operationId: "deleteTransactions",
    "x-speakeasy-name-override": "deleteMany",
    description:
      "Bulk delete transactions for the authenticated team. Only manually created transactions can be deleted via this endpoint or the form. Transactions inserted by bank connections cannot be deleted, but can be excluded by updating the status.",
    tags: ["Transactions"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: deleteTransactionsSchema,
          },
        },
      },
    },
    responses: {
      200: {
        description: "Transactions deleted",
        content: {
          "application/json": {
            schema: deleteTransactionsResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("transactions.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const params = c.req.valid("json");

    const result = await deleteTransactions(db, {
      teamId,
      ids: params,
    });

    return c.json(validateResponse(result, deleteTransactionsResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "delete",
    path: "/{id}",
    summary: "Delete a transaction",
    operationId: "deleteTransaction",
    "x-speakeasy-name-override": "delete",
    description:
      "Delete a transaction for the authenticated team. Only manually created transactions can be deleted via this endpoint or the form. Transactions inserted by bank connections cannot be deleted, but can be excluded by updating the status.",
    tags: ["Transactions"],
    request: {
      params: deleteTransactionSchema,
    },
    responses: {
      200: {
        description: "Transaction deleted",
        content: {
          "application/json": {
            schema: deleteTransactionResponseSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("transactions.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const { id } = c.req.valid("param");

    const [result] = await deleteTransactions(db, { teamId, ids: [id] });

    return c.json(validateResponse(result, deleteTransactionResponseSchema));
  },
);

export const transactionsRouter = app;
</file>

<file path="apps/api/src/rest/routers/users.ts">
import type { Context } from "@api/rest/types";
import { updateUserSchema, userSchema } from "@api/schemas/users";
import { validateResponse } from "@api/utils/validate-response";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import { getUserById, updateUser } from "@midday/db/queries";
import { withRequiredScope } from "../middleware";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/me",
    summary: "Retrieve the current user",
    operationId: "getCurrentUser",
    "x-speakeasy-name-override": "get",
    description: "Retrieve the current user for the authenticated team.",
    tags: ["Users"],
    responses: {
      200: {
        description: "Retrieve the current user for the authenticated team.",
        content: {
          "application/json": {
            schema: userSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("users.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const session = c.get("session");

    const result = await getUserById(db, session.user.id);

    return c.json(validateResponse(result, userSchema));
  },
);

app.openapi(
  createRoute({
    method: "patch",
    path: "/me",
    summary: "Update the current user",
    operationId: "updateCurrentUser",
    "x-speakeasy-name-override": "update",
    description: "Update the current user for the authenticated team.",
    tags: ["Users"],
    request: {
      body: {
        content: {
          "application/json": {
            schema: updateUserSchema,
          },
        },
      },
    },
    responses: {
      200: {
        description: "The updated user",
        content: {
          "application/json": {
            schema: userSchema,
          },
        },
      },
    },
    middleware: [withRequiredScope("users.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const session = c.get("session");
    const body = c.req.valid("json");

    const result = await updateUser(db, {
      id: session.user.id,
      ...body,
    });

    return c.json(validateResponse(result, userSchema));
  },
);

export const usersRouter = app;
</file>

<file path="apps/api/src/rest/types.ts">
import type { Session } from "@api/utils/auth";
import type { Database } from "@midday/db/client";

export type Context = {
  Variables: {
    db: Database;
    session: Session;
    teamId: string;
  };
};
</file>

<file path="apps/api/src/schemas/api-keys.ts">
import type { Scope } from "@api/utils/scopes";
import { SCOPES } from "@api/utils/scopes";
import { z } from "@hono/zod-openapi";

export const upsertApiKeySchema = z.object({
  id: z.string().optional(),
  name: z.string().openapi({
    description: "The name of the API key",
    example: "API Key 1",
  }),
  scopes: z.array(z.enum(SCOPES)).openapi({
    description: "The scopes of the API key",
    example: ["bank-accounts.read", "bank-accounts.write"],
  }),
});

export const deleteApiKeySchema = z.object({
  id: z.string().openapi({
    description: "The ID of the API key",
    example: "123",
  }),
});
</file>

<file path="apps/api/src/schemas/apps.ts">
import { z } from "@hono/zod-openapi";

export const disconnectAppSchema = z.object({
  appId: z.string(),
});

export const updateAppSettingsSchema = z.object({
  appId: z.string(),
  option: z.object({
    id: z.string(),
    value: z.union([z.string(), z.number(), z.boolean()]),
  }),
});
</file>

<file path="apps/api/src/schemas/bank-accounts.ts">
import { z } from "@hono/zod-openapi";

export const getBankAccountsSchema = z
  .object({
    enabled: z
      .boolean()
      .optional()
      .openapi({
        description: "Whether the bank account is enabled.",
        param: {
          in: "query",
        },
      }),
    manual: z
      .boolean()
      .optional()
      .openapi({
        description: "Whether the bank account is a manual account.",
        param: {
          in: "query",
        },
      }),
  })
  .openapi({
    description: "Query parameters for filtering bank accounts.",
    param: {
      in: "query",
    },
  });

export const bankAccountResponseSchema = z
  .object({
    id: z.string().uuid().openapi({
      description: "Unique identifier for the bank account.",
      example: "b7e6c2a0-1f2d-4c3b-9a8e-123456789abc",
    }),
    name: z.string().nullable().openapi({
      description: "Name of the bank account.",
      example: "Checking Account",
    }),
    currency: z.string().nullable().openapi({
      description: "Currency code of the bank account (e.g., USD, EUR).",
      example: "USD",
    }),
    type: z.string().nullable().openapi({
      description: "Type of the bank account (e.g., depository, credit).",
      example: "depository",
    }),
    enabled: z.boolean().openapi({
      description: "Whether the bank account is enabled.",
      example: true,
    }),
    balance: z.number().nullable().openapi({
      description: "Current balance of the bank account.",
      example: 1500.75,
    }),
    manual: z.boolean().nullable().openapi({
      description: "Whether the bank account is a manual account.",
      example: false,
    }),
  })
  .openapi({
    description: "A single bank account object response.",
    example: {
      id: "b7e6c2a0-1f2d-4c3b-9a8e-123456789abc",
      name: "Checking Account",
      currency: "USD",
      type: "depository",
      enabled: true,
      balance: 1500.75,
      manual: false,
    },
  });

export const bankAccountsResponseSchema = z
  .object({
    data: z.array(bankAccountResponseSchema).openapi({
      description: "Array of bank account objects.",
    }),
  })
  .openapi({
    description: "Response containing a list of bank accounts.",
  });

export const deleteBankAccountSchema = z.object({
  id: z
    .string()
    .uuid()
    .openapi({
      description: "The unique identifier of the bank account.",
      example: "b7e6c2a0-1f2d-4c3b-9a8e-123456789abc",
      param: {
        in: "path",
        name: "id",
      },
    }),
});

export const getBankAccountByIdSchema = z.object({
  id: z
    .string()
    .uuid()
    .openapi({
      description: "The unique identifier of the bank account.",
      example: "b7e6c2a0-1f2d-4c3b-9a8e-123456789abc",
      param: {
        in: "path",
        name: "id",
      },
    }),
});

export const updateBankAccountSchema = z
  .object({
    id: z.string().uuid().optional().openapi({
      description: "The unique identifier of the bank account.",
      example: "b7e6c2a0-1f2d-4c3b-9a8e-123456789abc",
    }),
    name: z.string().optional().openapi({
      description: "The name of the bank account.",
      example: "Checking Account",
    }),
    enabled: z.boolean().optional().openapi({
      description: "Whether the bank account is enabled.",
      example: true,
    }),
    balance: z.number().optional().openapi({
      description: "Current balance of the bank account.",
      example: 1500.75,
    }),
    currency: z.string().optional().openapi({
      description: "The currency code for the bank account (ISO 4217).",
      example: "USD",
    }),
    type: z
      .enum(["depository", "credit", "other_asset", "loan", "other_liability"])
      .optional()
      .openapi({
        description: "Type of the bank account.",
        example: "depository",
      }),
  })
  .openapi({
    description: "Schema for updating a bank account.",
    example: {
      id: "b7e6c2a0-1f2d-4c3b-9a8e-123456789abc",
      name: "Checking Account",
      enabled: true,
      balance: 1500.75,
      type: "depository",
    },
  });

export const createBankAccountSchema = z
  .object({
    name: z.string().openapi({
      description: "The name of the bank account.",
      example: "Checking Account",
    }),
    currency: z.string().optional().openapi({
      description: "The currency code for the bank account (ISO 4217).",
      example: "USD",
    }),
    manual: z.boolean().optional().openapi({
      description: "Whether the bank account is a manual account.",
      example: false,
    }),
  })
  .openapi({
    description: "Schema for creating a new bank account.",
    example: {
      name: "Checking Account",
      currency: "USD",
      manual: false,
    },
  });
</file>

<file path="apps/api/src/schemas/bank-connections.ts">
import { z } from "@hono/zod-openapi";

export const getBankConnectionsSchema = z
  .object({ enabled: z.boolean().optional() })
  .optional();

export const createBankConnectionSchema = z.object({
  accessToken: z.string().nullable().optional(), // Teller
  enrollmentId: z.string().nullable().optional(), // Teller
  referenceId: z.string().nullable().optional(), // GoCardLess
  provider: z.enum(["gocardless", "teller", "plaid", "enablebanking"]),
  accounts: z.array(
    z.object({
      accountId: z.string(),
      institutionId: z.string(),
      logoUrl: z.string().nullable().optional(),
      name: z.string(),
      bankName: z.string(),
      currency: z.string(),
      enabled: z.boolean(),
      balance: z.number().optional(),
      type: z.enum([
        "credit",
        "depository",
        "other_asset",
        "loan",
        "other_liability",
      ]),
      accountReference: z.string().nullable().optional(), // EnableBanking & GoCardLess
      expiresAt: z.string().nullable().optional(), // EnableBanking & GoCardLess
    }),
  ),
});

export const deleteBankConnectionSchema = z.object({ id: z.string() });
</file>

<file path="apps/api/src/schemas/billing.ts">
import { z } from "zod";

export const getBillingOrdersSchema = z.object({
  cursor: z.string().optional(),
  pageSize: z.number().min(1).max(100).default(25),
});

export type GetBillingOrdersSchema = z.infer<typeof getBillingOrdersSchema>;
</file>

<file path="apps/api/src/schemas/customers.ts">
import { z } from "@hono/zod-openapi";

export const getCustomersSchema = z
  .object({
    q: z
      .string()
      .nullable()
      .optional()
      .openapi({
        description:
          "Search query string to filter customers by name, email, or other text fields",
        example: "acme",
        param: {
          in: "query",
        },
      }),
    sort: z
      .array(z.string(), z.string())
      .nullable()
      .optional()
      .openapi({
        description:
          "Sorting order as a tuple: [field, direction]. Example: ['name', 'asc'] or ['createdAt', 'desc']",
        example: ["name", "asc"],
        param: {
          in: "query",
        },
      }),
    cursor: z
      .string()
      .optional()
      .openapi({
        description:
          "Cursor for pagination, representing the last item from the previous page",
        example: "eyJpZCI6IjEyMyJ9",
        param: {
          in: "query",
        },
      }),
    pageSize: z.coerce
      .number()
      .min(1)
      .max(100)
      .optional()
      .openapi({
        description: "Number of customers to return per page (1-100)",
        example: 20,
        param: {
          in: "query",
        },
      }),
  })
  .openapi({
    description: "Query parameters for filtering and paginating customers",
    param: {
      in: "query",
    },
  });

export const customerResponseSchema = z.object({
  id: z.string().uuid().openapi({
    description: "Unique identifier of the customer",
    example: "b3b7c1e2-4c2a-4e7a-9c1a-2b7c1e24c2a4",
  }),
  name: z.string().openapi({
    description: "Name of the customer or organization",
    example: "Acme Corporation",
  }),
  email: z.string().email().openapi({
    description: "Primary email address of the customer",
    example: "contact@acme.com",
  }),
  billingEmail: z.string().email().nullable().openapi({
    description: "Billing email address of the customer",
    example: "finance@acme.com",
  }),
  phone: z.string().nullable().openapi({
    description: "Primary phone number of the customer",
    example: "+1-555-123-4567",
  }),
  website: z.string().nullable().openapi({
    description: "Website URL of the customer",
    example: "https://acme.com",
  }),
  createdAt: z.string().openapi({
    description:
      "Date and time when the customer was created in ISO 8601 format",
    example: "2024-05-01T12:34:56.789Z",
  }),
  country: z.string().nullable().openapi({
    description: "Country name where the customer is located",
    example: "United States",
  }),
  addressLine1: z.string().nullable().openapi({
    description: "First line of the customer's address",
    example: "123 Main Street",
  }),
  addressLine2: z.string().nullable().openapi({
    description:
      "Second line of the customer's address (suite, apartment, etc.)",
    example: "Suite 400",
  }),
  city: z.string().nullable().openapi({
    description: "City where the customer is located",
    example: "San Francisco",
  }),
  state: z.string().nullable().openapi({
    description: "State or province where the customer is located",
    example: "California",
  }),
  zip: z.string().nullable().openapi({
    description: "ZIP or postal code of the customer's address",
    example: "94105",
  }),
  note: z.string().nullable().openapi({
    description: "Internal notes about the customer for team reference",
    example: "Preferred contact method is email. Large enterprise client.",
  }),
  vatNumber: z.string().nullable().openapi({
    description: "VAT (Value Added Tax) number of the customer",
    example: "US123456789",
  }),
  countryCode: z.string().nullable().openapi({
    description: "Country code in ISO 3166-1 alpha-2 format",
    example: "US",
  }),
  token: z.string().openapi({
    description:
      "Unique token for the customer (used for internal identification)",
    example: "cus_abc123xyz789",
  }),
  contact: z.string().nullable().openapi({
    description: "Primary contact person's name at the customer organization",
    example: "John Smith",
  }),
  invoiceCount: z.number().openapi({
    description: "Total number of invoices created for this customer",
    example: 12,
  }),
  projectCount: z.number().openapi({
    description: "Total number of projects associated with this customer",
    example: 3,
  }),
  tags: z
    .array(
      z.object({
        id: z.string().uuid().openapi({
          description: "Unique identifier of the tag",
          example: "e7a9c1a2-4c2a-4e7a-9c1a-2b7c1e24c2a4",
        }),
        name: z.string().openapi({
          description: "Display name of the tag",
          example: "VIP",
        }),
      }),
    )
    .openapi({
      description:
        "Array of tags associated with the customer for categorization",
      example: [
        { id: "e7a9c1a2-4c2a-4e7a-9c1a-2b7c1e24c2a4", name: "VIP" },
        { id: "f1b2c3d4-5678-4e7a-9c1a-2b7c1e24c2a4", name: "Enterprise" },
      ],
    }),
});

export const customersResponseSchema = z.object({
  meta: z
    .object({
      cursor: z.string().nullable().openapi({
        description:
          "Cursor for the next page of results, null if no more pages",
        example: "eyJpZCI6IjQ1NiJ9",
      }),
      hasPreviousPage: z.boolean().openapi({
        description:
          "Whether there are more customers available on the previous page",
        example: false,
      }),
      hasNextPage: z.boolean().openapi({
        description:
          "Whether there are more customers available on the next page",
        example: true,
      }),
    })
    .openapi({
      description: "Pagination metadata for the customers response",
    }),
  data: z.array(customerResponseSchema).openapi({
    description: "Array of customers matching the query criteria",
  }),
});

export const getCustomerByIdSchema = z.object({
  id: z.string().openapi({
    description: "Unique identifier of the customer to retrieve",
    example: "b3b7c1e2-4c2a-4e7a-9c1a-2b7c1e24c2a4",
    param: {
      in: "path",
      name: "id",
    },
  }),
});

export const deleteCustomerSchema = z.object({
  id: z.string().openapi({
    description: "Unique identifier of the customer to delete",
    example: "b3b7c1e2-4c2a-4e7a-9c1a-2b7c1e24c2a4",
    param: {
      in: "path",
      name: "id",
    },
  }),
});

export const upsertCustomerSchema = z.object({
  id: z.string().uuid().optional().openapi({
    description:
      "Unique identifier of the customer. Required for updates, omit for new customers",
    example: "b3b7c1e2-4c2a-4e7a-9c1a-2b7c1e24c2a4",
  }),
  name: z.string().openapi({
    description: "Name of the customer or organization",
    example: "Acme Corporation",
  }),
  email: z.string().email().openapi({
    description: "Primary email address of the customer",
    example: "contact@acme.com",
  }),
  billingEmail: z.string().email().nullable().optional().openapi({
    description: "Billing email address of the customer",
    example: "finance@acme.com",
  }),
  country: z.string().nullable().optional().openapi({
    description: "Country name where the customer is located",
    example: "United States",
  }),
  addressLine1: z.string().nullable().optional().openapi({
    description: "First line of the customer's address",
    example: "123 Main Street",
  }),
  addressLine2: z.string().nullable().optional().openapi({
    description:
      "Second line of the customer's address (suite, apartment, etc.)",
    example: "Suite 400",
  }),
  city: z.string().nullable().optional().openapi({
    description: "City where the customer is located",
    example: "San Francisco",
  }),
  state: z.string().nullable().optional().openapi({
    description: "State or province where the customer is located",
    example: "California",
  }),
  zip: z.string().nullable().optional().openapi({
    description: "ZIP or postal code of the customer's address",
    example: "94105",
  }),
  phone: z.string().nullable().optional().openapi({
    description: "Primary phone number of the customer",
    example: "+1-555-123-4567",
  }),
  website: z.string().nullable().optional().openapi({
    description: "Website URL of the customer",
    example: "https://acme.com",
  }),
  note: z.string().nullable().optional().openapi({
    description: "Internal notes about the customer for team reference",
    example: "Preferred contact method is email. Large enterprise client.",
  }),
  vatNumber: z.string().nullable().optional().openapi({
    description: "VAT (Value Added Tax) number of the customer",
    example: "US123456789",
  }),
  countryCode: z.string().nullable().optional().openapi({
    description: "Country code in ISO 3166-1 alpha-2 format",
    example: "US",
  }),
  contact: z.string().nullable().optional().openapi({
    description: "Primary contact person's name at the customer organization",
    example: "John Smith",
  }),
  tags: z
    .array(
      z.object({
        id: z.string().uuid().openapi({
          description: "Unique identifier of the tag",
          example: "e7a9c1a2-4c2a-4e7a-9c1a-2b7c1e24c2a4",
        }),
        name: z.string().openapi({
          description: "Display name of the tag",
          example: "VIP",
        }),
      }),
    )
    .optional()
    .openapi({
      description:
        "Array of tags to associate with the customer for categorization",
      example: [
        { id: "e7a9c1a2-4c2a-4e7a-9c1a-2b7c1e24c2a4", name: "VIP" },
        { id: "f1b2c3d4-5678-4e7a-9c1a-2b7c1e24c2a4", name: "Enterprise" },
      ],
    }),
});
</file>

<file path="apps/api/src/schemas/document-tag-assignments.ts">
import { z } from "@hono/zod-openapi";

export const createDocumentTagAssignmentSchema = z.object({
  documentId: z.string(),
  tagId: z.string(),
});

export const deleteDocumentTagAssignmentSchema = z.object({
  documentId: z.string(),
  tagId: z.string(),
});
</file>

<file path="apps/api/src/schemas/document-tags.ts">
import { z } from "@hono/zod-openapi";

export const createDocumentTagSchema = z.object({
  name: z.string(),
});

export const deleteDocumentTagSchema = z.object({
  id: z.string(),
});
</file>

<file path="apps/api/src/schemas/documents.ts">
import { z } from "@hono/zod-openapi";

export const getDocumentsSchema = z
  .object({
    cursor: z.string().nullable().optional().openapi({
      description:
        "A cursor for pagination. Pass the value returned from the previous response to get the next page.",
      example: "20",
    }),
    sort: z
      .array(z.string(), z.string())
      .nullable()
      .optional()
      .openapi({
        description:
          "Sorting order as a tuple: [field, direction]. Example: ['name', 'asc'].",
        param: {
          in: "query",
        },
      }),
    pageSize: z.coerce.number().min(1).max(100).optional().openapi({
      description: "Number of documents to return per page.",
      example: 20,
    }),
    q: z.string().nullable().optional().openapi({
      description: "Search query string to filter documents by text.",
      example: "invoice",
    }),
    tags: z
      .array(z.string())
      .nullable()
      .optional()
      .openapi({
        description: "Array of tag IDs to filter documents by tags.",
        example: ["tag1", "tag2"],
      }),
  })
  .openapi({
    description: "Query parameters for listing documents.",
  });

export const getDocumentSchema = z.object({
  id: z
    .string()
    .nullable()
    .optional()
    .openapi({
      param: {
        in: "path",
        name: "id",
        required: true,
      },
    }),
  filePath: z.string().nullable().optional(),
});

export const getRelatedDocumentsSchema = z.object({
  id: z.string().openapi({
    param: {
      in: "path",
      name: "id",
    },
  }),
  pageSize: z.coerce.number().min(1).max(100),
});

export const deleteDocumentSchema = z.object({
  id: z.string().openapi({
    param: {
      in: "path",
      name: "id",
    },
  }),
});

export const deleteDocumentResponseSchema = z.object({
  id: z.string(),
});

export const processDocumentSchema = z.array(
  z.object({
    mimetype: z.string(),
    size: z.number(),
    filePath: z.array(z.string()),
  }),
);

export const signedUrlSchema = z.object({
  filePath: z.string(),
  expireIn: z.number(),
});

export const signedUrlsSchema = z.array(z.string());

export const documentResponseSchema = z
  .object({
    id: z.string().openapi({
      description: "Unique identifier for the document.",
      example: "doc_1234567890abcdef",
    }),
    title: z.string().nullable().openapi({
      description: "Title of the document.",
      example: "Invoice April 2024",
    }),
    pathTokens: z.array(z.string()).openapi({
      description: "Array of path tokens representing the document's location.",
      example: ["invoices", "2024", "april", "invoice-123.pdf"],
    }),
    metadata: z
      .object({
        size: z.number().nullable().openapi({
          description: "Size of the document in bytes.",
          example: 204800,
        }),
        mimetype: z.string().nullable().openapi({
          description: "MIME type of the document.",
          example: "application/pdf",
        }),
      })
      .nullable()
      .openapi({
        description: "Metadata about the document.",
      }),
    processingStatus: z.string().openapi({
      description: "Processing status of the document.",
      example: "processed",
    }),
    summary: z.string().nullable().openapi({
      description: "Summary or extracted content from the document.",
      example: "Invoice for April 2024, total $1,200.00",
    }),
    date: z.string().nullable().openapi({
      description: "Date associated with the document (ISO 8601).",
      example: "2024-04-30",
    }),
  })
  .openapi({
    description: "A single document object response.",
    example: {
      id: "doc_1234567890abcdef",
      title: "Invoice April 2024",
      pathTokens: ["invoices", "2024", "april", "invoice-123.pdf"],
      metadata: {
        size: 204800,
        mimetype: "application/pdf",
      },
      processingStatus: "processed",
      summary: "Invoice for April 2024, total $1,200.00",
      date: "2024-04-30",
    },
  });

export const documentsResponseSchema = z
  .object({
    meta: z
      .object({
        cursor: z.string().nullable().optional().openapi({
          description: "Cursor for pagination.",
          example: "20",
        }),
        hasPreviousPage: z.boolean().openapi({
          description: "Whether there is a previous page.",
          example: false,
        }),
        hasNextPage: z.boolean().openapi({
          description: "Whether there is a next page.",
          example: true,
        }),
      })
      .openapi({
        description: "Pagination metadata for the documents list.",
      }),
    data: z.array(documentResponseSchema).openapi({
      description: "Array of document objects.",
    }),
  })
  .openapi({
    description:
      "Response containing a list of documents and pagination metadata.",
    example: {
      meta: {
        cursor: "20",
        hasPreviousPage: false,
        hasNextPage: true,
      },
      data: [
        {
          id: "doc_1234567890abcdef",
          title: "Invoice April 2024",
          pathTokens: ["invoices", "2024", "april", "invoice-123.pdf"],
          metadata: {
            size: 204800,
            mimetype: "application/pdf",
          },
          processingStatus: "processed",
          summary: "Invoice for April 2024, total $1,200.00",
          date: "2024-04-30",
        },
      ],
    },
  });
</file>

<file path="apps/api/src/schemas/inbox-accounts.ts">
import { z } from "@hono/zod-openapi";

export const connectInboxAccountSchema = z.object({
  provider: z.enum(["gmail"]),
});

export const exchangeCodeForAccountSchema = z.object({
  code: z.string(),
  provider: z.enum(["gmail"]),
});

export const deleteInboxAccountSchema = z.object({ id: z.string() });

export const syncInboxAccountSchema = z.object({
  id: z.string(),
  manualSync: z.boolean().optional(),
});
</file>

<file path="apps/api/src/schemas/inbox.ts">
import { z } from "@hono/zod-openapi";

export const getInboxSchema = z.object({
  cursor: z.string().nullable().optional(),
  order: z.string().nullable().optional(),
  pageSize: z.coerce.number().min(1).max(100).optional(),
  q: z.string().nullable().optional(),
  status: z.enum(["done", "pending", "suggested_match"]).nullable().optional(),
});

export const inboxItemResponseSchema = z
  .object({
    id: z.string().openapi({
      description: "Inbox item ID (UUID)",
      example: "b3b7c1e2-4c2a-4e7a-9c1a-2b7c1e24c2a4",
    }),
    fileName: z.string().openapi({
      description: "Original file name of the uploaded document",
      example: "invoice-123.pdf",
    }),
    filePath: z.array(z.string()).openapi({
      description: "Path segments to the file in storage",
      example: ["inbox", "2024", "05", "invoice-123.pdf"],
    }),
    displayName: z.string().openapi({
      description: "Display name for the inbox item",
      example: "Invoice May 2024",
    }),
    amount: z.number().nullable().openapi({
      description: "Amount detected or entered for the inbox item",
      example: 123.45,
    }),
    currency: z.string().nullable().openapi({
      description: "Currency code (ISO 4217) for the amount",
      example: "USD",
    }),
    contentType: z.string().nullable().openapi({
      description: "MIME type of the uploaded file",
      example: "application/pdf",
    }),
    date: z.string().nullable().openapi({
      description: "Date associated with the inbox item (ISO 8601)",
      example: "2024-05-01",
    }),
    status: z.string().openapi({
      description: "Status of the inbox item",
      example: "pending",
    }),
    createdAt: z.string().openapi({
      description: "Date and time when the inbox item was created (ISO 8601)",
      example: "2024-05-01T12:34:56.789Z",
    }),
    website: z.string().nullable().openapi({
      description: "Website associated with the inbox item, if any",
      example: "https://vendor.com",
    }),
    description: z.string().nullable().openapi({
      description: "Description or notes for the inbox item",
      example: "Invoice for May 2024 services",
    }),
    transaction: z
      .object({
        id: z.string().openapi({
          description: "Transaction ID (UUID)",
          example: "a1b2c3d4-5678-4e7a-9c1a-2b7c1e24c2a4",
        }),
        amount: z.number().openapi({
          description: "Transaction amount",
          example: 123.45,
        }),
        currency: z.string().openapi({
          description: "Transaction currency (ISO 4217)",
          example: "USD",
        }),
        name: z.string().openapi({
          description: "Transaction name or payee",
          example: "Acme Corp",
        }),
        date: z.string().openapi({
          description: "Transaction date (ISO 8601)",
          example: "2024-05-01",
        }),
      })
      .nullable()
      .openapi({
        description: "Matched transaction for this inbox item, if any",
      }),
  })
  .openapi({
    description: "Inbox item object",
  });

export const inboxResponseSchema = z.object({
  meta: z
    .object({
      cursor: z.string().nullable().optional().openapi({
        description:
          "A cursor for pagination, representing the last item from the previous page.",
        example: "b3b7c1e2-4c2a-4e7a-9c1a-2b7c1e24c2a4",
      }),
      hasPreviousPage: z.boolean().openapi({
        description: "Whether there is a previous page of results.",
        example: false,
      }),
      hasNextPage: z.boolean().openapi({
        description: "Whether there is a next page of results.",
        example: true,
      }),
    })
    .openapi({
      description: "Pagination metadata for the inbox list response.",
    }),
  data: z.array(inboxItemResponseSchema).openapi({
    description: "List of inbox items",
  }),
});

export const getInboxByIdSchema = z
  .object({
    id: z.string().openapi({
      description: "The unique identifier of the inbox item.",
      example: "b3b7c1e2-4c2a-4e7a-9c1a-2b7c1e24c2a4",
      param: {
        in: "path",
        name: "id",
      },
    }),
  })
  .openapi({
    description: "Schema for retrieving an inbox item by its ID.",
  });

export const deleteInboxSchema = z
  .object({
    id: z.string().openapi({
      description: "The unique identifier of the inbox item to delete.",
      example: "b3b7c1e2-4c2a-4e7a-9c1a-2b7c1e24c2a4",
      param: {
        in: "path",
        name: "id",
      },
    }),
  })
  .openapi({
    description: "Schema for deleting an inbox item by its ID.",
  });

export const createInboxItemSchema = z.object({
  filename: z.string(),
  mimetype: z.string(),
  size: z.number(),
  filePath: z.array(z.string()),
});

export const processAttachmentsSchema = z.array(
  z.object({
    mimetype: z.string(),
    size: z.number(),
    filePath: z.array(z.string()),
  }),
);

export const searchInboxSchema = z.object({
  q: z.string().optional(), // Search query (text or amount)
  transactionId: z.string().optional(), // For AI suggestions
  limit: z.number().optional().default(10),
});

export const updateInboxSchema = z.object({
  id: z.string().openapi({
    param: {
      in: "path",
      name: "id",
    },
  }),
  status: z
    .enum([
      "new",
      "archived",
      "processing",
      "done",
      "pending",
      "deleted",
      "analyzing",
      "suggested_match",
    ])
    .optional(),
  displayName: z.string().optional(),
  currency: z.string().optional(),
  amount: z.number().optional(),
});

export const matchTransactionSchema = z.object({
  id: z.string(),
  transactionId: z.string().uuid(),
});

export const unmatchTransactionSchema = z.object({
  id: z.string().uuid(),
});

export const retryMatchingSchema = z.object({
  id: z.string().uuid().openapi({
    description: "Inbox item ID to retry matching for",
    example: "b3b7c1e2-4c2a-4e7a-9c1a-2b7c1e24c2a4",
  }),
});

export const getInboxByStatusSchema = z.object({
  status: z
    .enum([
      "processing",
      "pending",
      "archived",
      "new",
      "analyzing",
      "suggested_match",
      "no_match",
      "done",
      "deleted",
    ])
    .optional(),
});

export const confirmMatchSchema = z.object({
  suggestionId: z.string().uuid(),
  inboxId: z.string().uuid(),
  transactionId: z.string().uuid(),
});

export const declineMatchSchema = z.object({
  suggestionId: z.string().uuid(),
  inboxId: z.string().uuid(),
});

export const deleteInboxResponseSchema = z
  .object({
    id: z.string().openapi({
      description: "The unique identifier of the deleted inbox item.",
      example: "b3b7c1e2-4c2a-4e7a-9c1a-2b7c1e24c2a4",
    }),
  })
  .openapi({
    description: "Response schema for a successfully deleted inbox item.",
  });
</file>

<file path="apps/api/src/schemas/institutions.ts">
import { z } from "@hono/zod-openapi";

export const getInstitutionsSchema = z.object({
  q: z.string().optional(),
  countryCode: z.string(),
});

export const getAccountsSchema = z.object({
  id: z.string().optional(), // EnableBanking & GoCardLess
  accessToken: z.string().optional(),
  institutionId: z.string().optional(), // Plaid
  provider: z.enum(["gocardless", "teller", "plaid", "enablebanking"]),
});

export const updateUsageSchema = z.object({ id: z.string() });
</file>

<file path="apps/api/src/schemas/invoice.ts">
import { z } from "@hono/zod-openapi";

export const upsertInvoiceTemplateSchema = z.object({
  customerLabel: z.string().optional(),
  title: z.string().optional(),
  fromLabel: z.string().optional(),
  invoiceNoLabel: z.string().optional(),
  issueDateLabel: z.string().optional(),
  dueDateLabel: z.string().optional(),
  descriptionLabel: z.string().optional(),
  priceLabel: z.string().optional(),
  quantityLabel: z.string().optional(),
  totalLabel: z.string().optional(),
  totalSummaryLabel: z.string().optional(),
  vatLabel: z.string().optional(),
  subtotalLabel: z.string().optional(),
  taxLabel: z.string().optional(),
  discountLabel: z.string().optional(),
  timezone: z.string().optional(),
  paymentLabel: z.string().optional(),
  noteLabel: z.string().optional(),
  logoUrl: z.string().optional().nullable(),
  currency: z.string().optional(),
  paymentDetails: z.string().optional().nullable(),
  fromDetails: z.string().optional().nullable(),
  dateFormat: z.string().optional(),
  includeVat: z.boolean().optional().optional(),
  includeTax: z.boolean().optional().optional(),
  includeDiscount: z.boolean().optional(),
  includeDecimals: z.boolean().optional(),
  includePdf: z.boolean().optional(),
  sendCopy: z.boolean().optional(),
  includeUnits: z.boolean().optional(),
  includeQr: z.boolean().optional(),
  taxRate: z.number().min(0).max(100).optional(),
  vatRate: z.number().min(0).max(100).optional(),
  size: z.enum(["a4", "letter"]).optional(),
  deliveryType: z.enum(["create", "create_and_send", "scheduled"]).optional(),
  locale: z.string().optional(),
});

export const draftLineItemSchema = z.object({
  name: z.string().optional(),
  quantity: z.number().min(0, "Quantity must be at least 0").optional(),
  unit: z.string().optional().nullable(),
  price: z.number().safe().optional(),
  vat: z.number().min(0, "VAT must be at least 0").optional(),
  tax: z.number().min(0, "Tax must be at least 0").optional(),
});

export const draftInvoiceSchema = z
  .object({
    id: z.string().uuid().openapi({
      description: "Unique identifier for the draft invoice",
      example: "b3b7e6e2-8c2a-4e2a-9b1a-2e4b5c6d7f8a",
    }),
    template: upsertInvoiceTemplateSchema.openapi({
      description: "Invoice template details for the draft invoice",
    }),
    fromDetails: z.string().nullable().optional().openapi({
      description: "Sender details in stringified format",
      example: "Acme Inc, 123 Main St, City, Country",
    }),
    customerDetails: z.string().nullable().optional().openapi({
      description: "Customer details in stringified format",
      example: "John Doe, johndoe@email.com",
    }),
    customerId: z.string().uuid().nullable().optional().openapi({
      description: "Unique identifier for the customer",
      example: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    }),
    customerName: z.string().nullable().optional().openapi({
      description: "Name of the customer",
      example: "Acme Corporation",
    }),
    paymentDetails: z.string().nullable().optional().openapi({
      description: "Payment details in stringified format",
      example: "Bank: 123456, IBAN: DE1234567890",
    }),
    noteDetails: z.string().nullable().optional().openapi({
      description: "Additional notes for the invoice",
      example: "Thank you for your business.",
    }),
    dueDate: z.string().openapi({
      description: "Due date of the invoice in ISO 8601 format",
      example: "2024-06-30T23:59:59.000Z",
    }),
    issueDate: z.string().openapi({
      description: "Issue date of the invoice in ISO 8601 format",
      example: "2024-06-01T00:00:00.000Z",
    }),
    invoiceNumber: z.string().openapi({
      description: "Invoice number as shown to the customer",
      example: "INV-2024-001",
    }),
    logoUrl: z.string().optional().nullable().openapi({
      description: "URL of the logo to display on the invoice",
      example: "https://example.com/logo.png",
    }),
    vat: z.number().nullable().optional().openapi({
      description: "VAT amount for the invoice",
      example: 150.0,
    }),
    tax: z.number().nullable().optional().openapi({
      description: "Tax amount for the invoice",
      example: 50.0,
    }),
    discount: z.number().nullable().optional().openapi({
      description: "Discount applied to the invoice",
      example: 100.0,
    }),
    subtotal: z.number().nullable().optional().openapi({
      description: "Subtotal amount before taxes and discounts",
      example: 1400.0,
    }),
    topBlock: z.any().nullable().optional().openapi({
      description: "Custom content block to display at the top of the invoice",
    }),
    bottomBlock: z.any().nullable().optional().openapi({
      description:
        "Custom content block to display at the bottom of the invoice",
    }),
    amount: z.number().nullable().optional().openapi({
      description: "Total amount of the invoice",
      example: 1500.75,
    }),
    lineItems: z.array(draftLineItemSchema).optional().openapi({
      description: "List of line items for the invoice",
    }),
    token: z.string().optional().openapi({
      description:
        "Unique token for the draft invoice (for sharing or public access)",
      example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    }),
    scheduledAt: z.string().nullable().optional().openapi({
      description: "Scheduled date of the invoice in ISO 8601 format",
      example: "2024-06-30T23:59:59.000Z",
    }),
    scheduledJobId: z.string().nullable().optional().openapi({
      description: "Scheduled job ID of the invoice",
      example: "1234567890",
    }),
  })
  .openapi({
    description: "Schema for creating or updating a draft invoice",
    example: {
      id: "b3b7e6e2-8c2a-4e2a-9b1a-2e4b5c6d7f8a",
      template: {
        title: "Invoice",
        customerLabel: "To",
        fromLabel: "From",
        invoiceNoLabel: "Invoice No",
        issueDateLabel: "Issue Date",
        dueDateLabel: "Due Date",
        descriptionLabel: "Description",
        priceLabel: "Price",
        quantityLabel: "Quantity",
        totalLabel: "Total",
        totalSummaryLabel: "Total",
        vatLabel: "VAT",
        taxLabel: "Tax",
        paymentLabel: "Payment Details",
        noteLabel: "Note",
        logoUrl: "https://example.com/logo.png",
        currency: "USD",
        paymentDetails: "Bank: 123456, IBAN: DE1234567890",
        fromDetails: "Acme Inc, 123 Main St, City, Country",
        size: "a4",
        includeVat: true,
        includeTax: true,
        discountLabel: "Discount",
        includeDiscount: false,
        includeUnits: false,
        includeDecimals: false,
        includePdf: false,
        sendCopy: false,
        includeQr: true,
        dateFormat: "dd/MM/yyyy",
        taxRate: 0,
        vatRate: 0,
        deliveryType: "create",
        timezone: "UTC",
        locale: "en-US",
      },
      fromDetails: "Acme Inc, 123 Main St, City, Country",
      customerDetails: "John Doe, johndoe@email.com",
      customerId: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
      customerName: "Acme Corporation",
      paymentDetails: "Bank: 123456, IBAN: DE1234567890",
      noteDetails: "Thank you for your business.",
      dueDate: "2024-06-30T23:59:59.000Z",
      issueDate: "2024-06-01T00:00:00.000Z",
      invoiceNumber: "INV-2024-001",
      logoUrl: "https://example.com/logo.png",
      vat: 150.0,
      tax: 50.0,
      discount: 100.0,
      subtotal: 1400.0,
      topBlock: null,
      bottomBlock: null,
      amount: 1500.75,
      lineItems: [
        {
          name: "Consulting Services",
          quantity: 10,
          unit: "hours",
          price: 100.0,
          vat: 15.0,
          tax: 5.0,
        },
      ],
      token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    },
  });

export const lineItemSchema = z.object({
  name: z.string().min(1, "Name is required"),
  quantity: z.number().min(0, "Quantity must be at least 0"),
  unit: z.string().optional(),
  price: z.number(),
  vat: z.number().min(0, "VAT must be at least 0").optional(),
  tax: z.number().min(0, "Tax must be at least 0").optional(),
});

export const invoiceTemplateSchema = z.object({
  title: z.string().optional(),
  customerLabel: z.string(),
  fromLabel: z.string(),
  invoiceNoLabel: z.string(),
  issueDateLabel: z.string(),
  dueDateLabel: z.string(),
  descriptionLabel: z.string(),
  priceLabel: z.string(),
  quantityLabel: z.string(),
  totalLabel: z.string(),
  totalSummaryLabel: z.string().optional(),
  vatLabel: z.string().optional(),
  subtotalLabel: z.string().optional(),
  taxLabel: z.string().optional(),
  discountLabel: z.string().optional(),
  paymentLabel: z.string(),
  noteLabel: z.string(),
  logoUrl: z.string().optional().nullable(),
  currency: z.string(),
  paymentDetails: z.any().nullable().optional(),
  fromDetails: z.any().nullable().optional(),
  size: z.enum(["a4", "letter"]),
  includeVat: z.boolean().optional(),
  includeTax: z.boolean().optional(),
  includeDiscount: z.boolean().optional(),
  includeDecimals: z.boolean().optional(),
  includePdf: z.boolean().optional(),
  includeUnits: z.boolean().optional(),
  includeQr: z.boolean().optional(),
  taxRate: z.number().min(0).max(100).optional(),
  vatRate: z.number().min(0).max(100).optional(),
  dateFormat: z.enum(["dd/MM/yyyy", "MM/dd/yyyy", "yyyy-MM-dd", "dd.MM.yyyy"]),
  deliveryType: z.enum(["create", "create_and_send", "scheduled"]),
  locale: z.string().optional(),
  timezone: z.string().optional(),
});

export const getInvoicesSchema = z.object({
  cursor: z
    .string()
    .nullable()
    .optional()
    .openapi({
      description:
        "A cursor for pagination, representing the last item from the previous page.",
      param: { in: "query" },
      example: "25",
    }),
  sort: z
    .array(z.string(), z.string())
    .nullable()
    .optional()
    .openapi({
      description:
        "Sorting order as a tuple: [field, direction]. Example: ['createdAt', 'desc'].",
      param: { in: "query" },
      example: ["createdAt", "desc"],
    }),
  pageSize: z.coerce
    .number()
    .min(1)
    .max(100)
    .optional()
    .openapi({
      description: "Number of invoices to return per page (1-100).",
      param: { in: "query" },
      example: 25,
    }),
  q: z
    .string()
    .nullable()
    .optional()
    .openapi({
      description: "Search query string to filter invoices by text.",
      param: { in: "query" },
      example: "Acme",
    }),
  start: z
    .string()
    .nullable()
    .optional()
    .openapi({
      description:
        "Start date (inclusive) for filtering invoices, in ISO 8601 format.",
      param: { in: "query" },
      example: "2024-01-01",
    }),
  end: z
    .string()
    .nullable()
    .optional()
    .openapi({
      description:
        "End date (inclusive) for filtering invoices, in ISO 8601 format.",
      param: { in: "query" },
      example: "2024-01-31",
    }),
  statuses: z
    .array(z.string())
    .nullable()
    .optional()
    .openapi({
      description:
        "List of invoice statuses to filter by (e.g., 'paid', 'unpaid', 'overdue').",
      param: { in: "query" },
      example: ["paid", "unpaid"],
    }),
  customers: z
    .array(z.string())
    .nullable()
    .optional()
    .openapi({
      description: "List of customer IDs to filter invoices.",
      param: { in: "query" },
      example: ["customer-uuid-1", "customer-uuid-2"],
    }),
});

export const getInvoiceByIdSchema = z.object({
  id: z.string().openapi({
    param: {
      in: "path",
      name: "id",
    },
  }),
});

export const searchInvoiceNumberSchema = z.object({
  query: z.string(),
});

export const invoiceSummarySchema = z
  .object({
    status: z
      .enum(["draft", "overdue", "paid", "unpaid", "canceled"])
      .optional()
      .openapi({
        description: "Filter summary by invoice status",
        example: "paid",
        param: { in: "query" },
      }),
  })
  .openapi({
    description: "Query parameters for retrieving invoice summary",
  });

export const updateInvoiceSchema = z.object({
  id: z.string().openapi({
    param: {
      in: "path",
      name: "id",
    },
  }),
  status: z
    .enum(["paid", "canceled", "unpaid", "scheduled", "draft"])
    .optional(),
  paidAt: z.string().nullable().optional(),
  internalNote: z.string().nullable().optional(),
});

export const deleteInvoiceSchema = z.object({
  id: z.string().openapi({
    param: {
      in: "path",
      name: "id",
    },
  }),
});

export const createInvoiceSchema = z.object({
  id: z.string().uuid(),
  deliveryType: z.enum(["create", "create_and_send", "scheduled"]),
  scheduledAt: z.string().datetime().optional(),
});

export const remindInvoiceSchema = z.object({
  id: z
    .string()
    .uuid()
    .openapi({
      param: {
        in: "path",
        name: "id",
      },
    }),
  date: z.string(),
});

export const updateScheduledInvoiceSchema = z.object({
  id: z.string().uuid(),
  scheduledAt: z.string().datetime(),
});

export const cancelScheduledInvoiceSchema = z.object({
  id: z.string().uuid(),
});

export const duplicateInvoiceSchema = z.object({
  id: z
    .string()
    .uuid()
    .openapi({
      param: {
        in: "path",
        name: "id",
      },
    }),
});

export const getInvoiceByTokenSchema = z.object({
  token: z.string(),
});

export const invoiceResponseSchema = z
  .object({
    id: z.string().uuid().openapi({
      description: "Unique identifier for the invoice",
      example: "b3b7e6e2-8c2a-4e2a-9b1a-2e4b5c6d7f8a",
    }),
    status: z
      .enum(["draft", "overdue", "paid", "unpaid", "canceled", "scheduled"])
      .openapi({
        description: "Current status of the invoice",
        example: "paid",
      }),
    dueDate: z.string().openapi({
      description: "Due date of the invoice in ISO 8601 format",
      example: "2024-06-30T23:59:59.000Z",
    }),
    issueDate: z.string().openapi({
      description: "Issue date of the invoice in ISO 8601 format",
      example: "2024-06-01T00:00:00.000Z",
    }),
    invoiceNumber: z.string().openapi({
      description: "Invoice number as shown to the customer",
      example: "INV-2024-001",
    }),
    amount: z.number().openapi({
      description: "Total amount of the invoice",
      example: 1500.75,
    }),
    currency: z.string().openapi({
      description: "Currency code (ISO 4217) for the invoice amount",
      example: "USD",
    }),
    customer: z
      .object({
        id: z.string().uuid().openapi({
          description: "Unique identifier for the customer",
          example: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        }),
        name: z.string().openapi({
          description: "Name of the customer",
          example: "Acme Corporation",
        }),
        website: z.string().nullable().openapi({
          description: "Website URL of the customer",
          example: "https://acme.com",
        }),
        email: z.string().email().nullable().openapi({
          description: "Email address of the customer",
          example: "info@acme.com",
        }),
      })
      .openapi({
        description: "Customer details",
      }),
    paidAt: z.string().nullable().openapi({
      description:
        "Timestamp when the invoice was paid (ISO 8601), or null if unpaid",
      example: "2024-06-15T12:00:00.000Z",
    }),
    reminderSentAt: z.string().nullable().openapi({
      description:
        "Timestamp when a payment reminder was sent (ISO 8601), or null if never sent",
      example: "2024-06-10T09:00:00.000Z",
    }),
    note: z.string().nullable().openapi({
      description: "Optional note attached to the invoice",
      example: "Thank you for your business.",
    }),
    vat: z.number().nullable().openapi({
      description: "Value-added tax amount, or null if not applicable",
      example: 120.0,
    }),
    tax: z.number().nullable().openapi({
      description: "Tax amount, or null if not applicable",
      example: 80.0,
    }),
    discount: z.number().nullable().openapi({
      description: "Discount amount applied to the invoice, or null if none",
      example: 50.0,
    }),
    subtotal: z.number().nullable().openapi({
      description:
        "Subtotal before taxes and discounts, or null if not calculated",
      example: 1400.0,
    }),
    viewedAt: z.string().nullable().openapi({
      description:
        "Timestamp when the invoice was viewed by the customer (ISO 8601), or null if never viewed",
      example: "2024-06-05T14:30:00.000Z",
    }),
    customerName: z.string().nullable().openapi({
      description:
        "Name of the customer as shown on the invoice, or null if not set",
      example: "Acme Corporation",
    }),
    sentTo: z.string().email().nullable().openapi({
      description:
        "Email address to which the invoice was sent, or null if not sent",
      example: "billing@acme.com",
    }),
    sentAt: z.string().nullable().openapi({
      description:
        "Timestamp when the invoice was sent (ISO 8601), or null if not sent",
      example: "2024-06-02T08:00:00.000Z",
    }),
    createdAt: z.string().openapi({
      description: "Timestamp when the invoice was created (ISO 8601)",
      example: "2024-06-01T07:00:00.000Z",
    }),
    updatedAt: z.string().openapi({
      description: "Timestamp when the invoice was last updated (ISO 8601)",
      example: "2024-06-15T10:00:00.000Z",
    }),
  })
  .openapi({
    description: "Invoice object",
  });

export const invoicesResponseSchema = z
  .object({
    meta: z
      .object({
        cursor: z.string().nullable().openapi({
          description: "Cursor for pagination; null if there is no next page",
          example: "25",
        }),
        hasPreviousPage: z.boolean().openapi({
          description: "Indicates if there is a previous page of results",
          example: false,
        }),
        hasNextPage: z.boolean().openapi({
          description: "Indicates if there is a next page of results",
          example: true,
        }),
      })
      .openapi({
        description: "Pagination metadata",
      }),
    data: z.array(invoiceResponseSchema).openapi({
      description: "Array of invoice objects",
    }),
  })
  .openapi({
    description:
      "Response containing a list of invoices and pagination metadata",
  });

export const deleteInvoiceResponseSchema = z.object({
  id: z.string().uuid().openapi({
    description: "Unique identifier for the deleted invoice",
    example: "b3b7e6e2-8c2a-4e2a-9b1a-2e4b5c6d7f8a",
  }),
});

export const getPaymentStatusResponseSchema = z.object({
  score: z.number().openapi({
    description: "Score associated with the invoice payment status",
    example: 85,
  }),
  paymentStatus: z.string().openapi({
    description: "The payment status of the invoice",
    example: "good",
  }),
});

export const invoiceSummaryResponseSchema = z
  .array(
    z.object({
      currency: z.string().openapi({
        description: "Currency of the invoice",
        example: "SEK",
      }),
      totalAmount: z.number().openapi({
        description: "Total amount of the invoice",
        example: 224171.25,
      }),
      invoiceCount: z.number().openapi({
        description: "Number of invoices for this currency",
        example: 15,
      }),
    }),
  )
  .openapi({
    description:
      "Array of invoice summary objects, each containing currency, total amount, and invoice count.",
    example: [
      {
        currency: "SEK",
        totalAmount: 224171.25,
        invoiceCount: 15,
      },
    ],
  });
</file>

<file path="apps/api/src/schemas/notification-settings.ts">
import { z } from "zod";

export const notificationChannelSchema = z.enum(["in_app", "email", "push"]);

export const getNotificationSettingsSchema = z.object({
  notificationType: z.string().optional(),
  channel: notificationChannelSchema.optional(),
});

export const updateNotificationSettingSchema = z.object({
  notificationType: z.string(),
  channel: notificationChannelSchema,
  enabled: z.boolean(),
});

export const bulkUpdateNotificationSettingsSchema = z.object({
  updates: z.array(
    z.object({
      notificationType: z.string(),
      channel: notificationChannelSchema,
      enabled: z.boolean(),
    }),
  ),
});
</file>

<file path="apps/api/src/schemas/notifications.ts">
import { z } from "@hono/zod-openapi";

export const getNotificationsSchema = z
  .object({
    cursor: z
      .string()
      .nullable()
      .optional()
      .openapi({
        description:
          "Cursor for pagination, representing the last item from the previous page",
        example: "20",
        param: {
          in: "query",
        },
      }),
    pageSize: z.coerce
      .number()
      .min(1)
      .max(100)
      .optional()
      .openapi({
        description: "Number of notifications to return per page (1-100)",
        example: 20,
        param: {
          in: "query",
        },
      }),
    status: z
      .union([
        z.enum(["unread", "read", "archived"]),
        z.array(z.enum(["unread", "read", "archived"])),
      ])
      .optional()
      .openapi({
        description:
          "Filter by notification status. Can be a single status or array of statuses. unread = new notifications, read = viewed but not dismissed, archived = dismissed from view",
        example: ["unread", "read"],
        param: {
          in: "query",
        },
      }),
    userId: z
      .string()
      .uuid()
      .nullable()
      .optional()
      .openapi({
        description: "Filter notifications by specific user ID",
        example: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        param: {
          in: "query",
        },
      }),
    priority: z.coerce
      .number()
      .int()
      .min(1)
      .max(10)
      .nullable()
      .optional()
      .openapi({
        description: "Filter notifications by priority level (1-10)",
        example: 5,
        param: {
          in: "query",
        },
      }),
    maxPriority: z.coerce
      .number()
      .int()
      .min(1)
      .max(10)
      .nullable()
      .optional()
      .openapi({
        description:
          "Filter notifications by maximum priority level (priority <= maxPriority). Use 3 for user-facing notifications only.",
        example: 3,
        param: {
          in: "query",
        },
      }),
  })
  .openapi("GetNotificationsSchema");

export const updateNotificationStatusSchema = z
  .object({
    activityId: z.string().uuid().openapi({
      description: "The ID of the notification to update",
      example: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
    }),
    status: z.enum(["unread", "read", "archived"]).openapi({
      description: "The new status for the notification",
      example: "read",
    }),
  })
  .openapi("UpdateNotificationStatusSchema");

export const updateAllNotificationsStatusSchema = z
  .object({
    status: z.enum(["unread", "read", "archived"]).openapi({
      description:
        "The new status to apply to all notifications for the authenticated user",
      example: "read",
    }),
  })
  .openapi("UpdateAllNotificationsStatusSchema");

// Response schemas for REST API
export const notificationSchema = z
  .object({
    id: z.string().uuid().openapi({
      description: "Unique identifier of the notification",
      example: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
    }),
    createdAt: z.string().openapi({
      description: "ISO timestamp when the notification was created",
      example: "2024-04-15T09:00:00.000Z",
    }),
    teamId: z.string().uuid().openapi({
      description: "Unique identifier of the team",
      example: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    }),
    userId: z.string().uuid().nullable().openapi({
      description: "Unique identifier of the user (if applicable)",
      example: "c2d3e4f5-a6b7-8901-bcde-f23456789012",
    }),
    type: z.string().openapi({
      description: "Type of notification",
      example: "transactions_created",
    }),
    priority: z.number().int().min(1).max(10).openapi({
      description:
        "Priority level of the notification (1-3 = user notifications, 4-10 = insights)",
      example: 3,
    }),
    source: z.enum(["system", "user"]).openapi({
      description: "Source of the notification",
      example: "system",
    }),
    status: z.enum(["unread", "read", "archived"]).openapi({
      description: "Current status of the notification",
      example: "unread",
    }),
    metadata: z.record(z.any()).openapi({
      description: "Additional metadata for the notification",
      example: {
        transactionCount: 5,
        dateRange: { from: "2024-04-01", to: "2024-04-15" },
      },
    }),
    lastUsedAt: z.string().nullable().openapi({
      description:
        "ISO timestamp when the notification was last used by the system",
      example: "2024-04-15T11:00:00.000Z",
    }),
  })
  .openapi("NotificationSchema");

export const notificationsResponseSchema = z
  .object({
    data: z.array(notificationSchema).openapi({
      description: "Array of notifications",
    }),
    meta: z
      .object({
        cursor: z.string().nullable().openapi({
          description: "Cursor for pagination (null if no more pages)",
          example: "40",
        }),
        hasPreviousPage: z.boolean().openapi({
          description: "Whether there are previous pages available",
          example: true,
        }),
        hasNextPage: z.boolean().openapi({
          description: "Whether there are more pages available",
          example: false,
        }),
      })
      .openapi({
        description: "Pagination metadata",
      }),
  })
  .openapi("NotificationsResponseSchema");

export const notificationResponseSchema = z
  .object({
    data: notificationSchema.openapi({
      description: "The updated notification",
    }),
  })
  .openapi("NotificationResponseSchema");

export const updateAllNotificationsStatusResponseSchema = z
  .object({
    data: z.array(notificationSchema).openapi({
      description: "Array of updated notifications",
    }),
  })
  .openapi("UpdateAllNotificationsStatusResponseSchema");
</file>

<file path="apps/api/src/schemas/oauth-applications.ts">
import { z } from "@hono/zod-openapi";

// Create OAuth Application Schema
export const createOAuthApplicationSchema = z.object({
  name: z.string().min(1).max(255).openapi({
    description: "The name of the OAuth application",
    example: "My Raycast Extension",
  }),
  description: z.string().optional().openapi({
    description: "The description of the OAuth application",
    example: "A Raycast extension for managing transactions",
  }),
  overview: z.string().optional().openapi({
    description: "Detailed overview of the OAuth application",
    example:
      "This application provides advanced transaction management features including:\n- Real-time sync\n- Advanced filtering",
  }),
  developerName: z.string().optional().openapi({
    description: "The person or company developing this application",
    example: "Acme Corp",
  }),
  logoUrl: z.string().url().optional().openapi({
    description: "URL to the application's logo",
    example: "https://example.com/logo.png",
  }),
  website: z.string().url().optional().openapi({
    description: "The website URL of the OAuth application",
    example: "https://myapp.com",
  }),
  installUrl: z.string().url().optional().openapi({
    description: "An optional URL for installing the application",
    example: "https://myapp.com/install",
  }),
  screenshots: z
    .array(z.string().url())
    .max(4)
    .optional()
    .openapi({
      description:
        "Up to 4 screenshots that will be displayed on the apps page",
      example: [
        "https://example.com/screenshot1.png",
        "https://example.com/screenshot2.png",
      ],
    }),
  redirectUris: z
    .array(z.string().url())
    .min(1)
    .openapi({
      description: "Array of redirect URIs for OAuth callbacks",
      example: ["https://myapp.com/callback"],
    }),
  scopes: z
    .array(z.string())
    .default([])
    .openapi({
      description: "Array of scopes requested by the application",
      example: ["transactions.read", "invoices.read"],
    }),
  isPublic: z.boolean().default(false).openapi({
    description: "Whether this is a public OAuth application",
    example: false,
  }),
});

// Update OAuth Application Schema
export const updateOAuthApplicationSchema = z.object({
  id: z.string().uuid().openapi({
    description: "The unique identifier of the OAuth application",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
  name: z.string().min(1).max(255).optional().openapi({
    description: "The name of the OAuth application",
    example: "My Updated Raycast Extension",
  }),
  description: z.string().optional().openapi({
    description: "The description of the OAuth application",
    example: "An updated Raycast extension for managing transactions",
  }),
  overview: z.string().optional().openapi({
    description: "Detailed overview of the OAuth application",
    example:
      "This updated application now includes:\n- Enhanced security\n- Better performance",
  }),
  developerName: z.string().optional().openapi({
    description: "The person or company developing this application",
    example: "Acme Corp",
  }),
  logoUrl: z.string().url().optional().openapi({
    description: "URL to the application's logo",
    example: "https://example.com/updated-logo.png",
  }),
  website: z.string().url().optional().openapi({
    description: "The website URL of the OAuth application",
    example: "https://myapp.com",
  }),
  installUrl: z.string().url().optional().openapi({
    description: "An optional URL for installing the application",
    example: "https://myapp.com/install",
  }),
  screenshots: z
    .array(z.string().url())
    .max(4)
    .optional()
    .openapi({
      description:
        "Up to 4 screenshots that will be displayed on the apps page",
      example: [
        "https://example.com/screenshot1.png",
        "https://example.com/screenshot2.png",
      ],
    }),
  redirectUris: z
    .array(z.string().url())
    .min(1)
    .optional()
    .openapi({
      description: "Array of redirect URIs for OAuth callbacks",
      example: ["https://myapp.com/callback"],
    }),
  scopes: z
    .array(z.string())
    .optional()
    .openapi({
      description: "Array of scopes requested by the application",
      example: ["transactions.read", "invoices.read"],
    }),
  isPublic: z.boolean().optional().openapi({
    description: "Whether this is a public OAuth application",
    example: false,
  }),
  active: z.boolean().optional().openapi({
    description: "Whether the OAuth application is active",
    example: true,
  }),
});

// Get OAuth Application Schema
export const getOAuthApplicationSchema = z.object({
  id: z
    .string()
    .uuid()
    .openapi({
      description: "The unique identifier of the OAuth application",
      example: "123e4567-e89b-12d3-a456-426614174000",
      param: {
        in: "path",
        name: "id",
        required: true,
      },
    }),
});

// Delete OAuth Application Schema
export const deleteOAuthApplicationSchema = z.object({
  id: z.string().uuid().openapi({
    description: "The unique identifier of the OAuth application to delete",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
});

// Regenerate Client Secret Schema
export const regenerateClientSecretSchema = z.object({
  id: z.string().uuid().openapi({
    description: "The unique identifier of the OAuth application",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
});

// OAuth Application Response Schema
export const oauthApplicationResponseSchema = z.object({
  id: z.string().uuid().openapi({
    description: "Unique identifier of the OAuth application",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
  name: z.string().openapi({
    description: "Name of the OAuth application",
    example: "My Raycast Extension",
  }),
  description: z.string().nullable().openapi({
    description: "Description of the OAuth application",
    example: "A Raycast extension for managing transactions",
  }),
  overview: z.string().nullable().openapi({
    description: "Detailed overview of the OAuth application",
    example:
      "This application provides advanced transaction management features including:\n- Real-time sync\n- Advanced filtering",
  }),
  developerName: z.string().nullable().openapi({
    description: "The person or company developing this application",
    example: "Acme Corp",
  }),
  logoUrl: z.string().nullable().openapi({
    description: "URL to the application's logo",
    example: "https://example.com/logo.png",
  }),
  website: z.string().nullable().openapi({
    description: "Website URL of the OAuth application",
    example: "https://myapp.com",
  }),
  installUrl: z.string().nullable().openapi({
    description: "An optional URL for installing the application",
    example: "https://myapp.com/install",
  }),
  screenshots: z.array(z.string().url()).openapi({
    description: "Up to 4 screenshots that will be displayed on the apps page",
    example: [
      "https://example.com/screenshot1.png",
      "https://example.com/screenshot2.png",
    ],
  }),
  redirectUris: z.array(z.string()).openapi({
    description: "Array of redirect URIs for OAuth callbacks",
    example: ["https://myapp.com/callback"],
  }),
  clientId: z.string().openapi({
    description: "Client ID of the OAuth application",
    example: "mid_client_abcdef123456789",
  }),
  scopes: z.array(z.string()).openapi({
    description: "Array of scopes for the application",
    example: ["transactions.read", "invoices.read"],
  }),
  isPublic: z.boolean().openapi({
    description: "Whether this is a public OAuth application",
    example: false,
  }),
  active: z.boolean().openapi({
    description: "Whether the OAuth application is active",
    example: true,
  }),
  createdAt: z.string().openapi({
    description: "ISO 8601 timestamp when the application was created",
    example: "2024-01-01T00:00:00Z",
  }),
  updatedAt: z.string().openapi({
    description: "ISO 8601 timestamp when the application was last updated",
    example: "2024-01-01T00:00:00Z",
  }),
});

// OAuth Applications List Response Schema
export const oauthApplicationsListResponseSchema = z.object({
  data: z.array(oauthApplicationResponseSchema).openapi({
    description: "Array of OAuth applications",
  }),
});

// Client Secret Response Schema
export const clientSecretResponseSchema = z.object({
  clientSecret: z.string().openapi({
    description: "The new client secret",
    example: "mid_secret_abcdef123456789",
  }),
});

export const authorizeOAuthApplicationSchema = z.object({
  clientId: z.string(),
  decision: z.enum(["allow", "deny"]),
  scopes: z.array(z.string()),
  redirectUri: z.string().url(),
  state: z.string().optional(),
  codeChallenge: z.string().optional(),
  teamId: z.string().uuid(),
});

export const getApplicationInfoSchema = z.object({
  clientId: z.string(),
  redirectUri: z.string().url(),
  scope: z.string(),
  state: z.string().optional(),
});

export const updateApprovalStatusSchema = z
  .object({
    id: z.string().uuid().openapi({
      description: "The unique identifier of the OAuth application",
      example: "123e4567-e89b-12d3-a456-426614174000",
    }),
    status: z.enum(["draft", "pending"]).openapi({
      description: "The approval status of the OAuth application",
      example: "pending",
    }),
  })
  .openapi({
    description: "Update the approval status of an OAuth application",
    example: {
      id: "123e4567-e89b-12d3-a456-426614174000",
      status: "pending",
    },
  });
</file>

<file path="apps/api/src/schemas/oauth-flow.ts">
import { SCOPES } from "@api/utils/scopes";
import { z } from "@hono/zod-openapi";

// OAuth Authorization Request Schema
export const oauthAuthorizationRequestSchema = z.object({
  response_type: z.literal("code").openapi({
    description: "OAuth response type, must be 'code'",
    example: "code",
  }),
  client_id: z.string().openapi({
    description: "Client ID of the OAuth application",
    example: "mid_client_abcdef123456789",
  }),
  redirect_uri: z.string().url().openapi({
    description: "Redirect URI for OAuth callback",
    example: "https://myapp.com/callback",
  }),
  scope: z.string().openapi({
    description: "Space-separated list of requested scopes",
    example: "transactions.read invoices.read",
  }),
  // SECURITY: Enhanced state parameter validation for CSRF protection
  state: z
    .string()
    .min(32, "State parameter must be at least 32 characters for security")
    .max(512, "State parameter must not exceed 512 characters")
    .regex(
      /^[A-Za-z0-9_.-]+$/,
      "State parameter must contain only alphanumeric characters, underscores, dots, and hyphens",
    )
    .openapi({
      description:
        "State parameter for CSRF protection (min 32 chars, alphanumeric + _.-)",
      example: "abc123xyz789_secure-random-state-value-with-sufficient-entropy",
    }),
  code_challenge: z.string().optional().openapi({
    description: "Code challenge for PKCE",
    example: "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM",
  }),
});

// OAuth Authorization Response Schema
export const oauthAuthorizationResponseSchema = z.object({
  authorize_url: z.string().url().openapi({
    description: "URL to redirect user for authorization",
    example:
      "https://app.midday.ai/oauth/authorize?client_id=mid_abcdef123456789&...",
  }),
});

// OAuth Token Exchange Request Schema
export const oauthTokenRequestSchema = z
  .object({
    grant_type: z.literal("authorization_code").openapi({
      description: "OAuth grant type, must be 'authorization_code'",
      example: "authorization_code",
    }),
    code: z.string().openapi({
      description: "Authorization code received from authorization endpoint",
      example: "mid_authorization_code_abcdef123456789",
    }),
    redirect_uri: z.string().url().openapi({
      description: "Redirect URI used in authorization request",
      example: "https://myapp.com/callback",
    }),
    client_id: z.string().openapi({
      description: "Client ID of the OAuth application",
      example: "mid_client_abcdef123456789",
    }),
    client_secret: z.string().optional().openapi({
      description:
        "Client secret of the OAuth application (required for confidential clients)",
      example: "mid_secret_abcdef123456789",
    }),
    code_verifier: z.string().optional().openapi({
      description:
        "Code verifier for PKCE (required for public clients using PKCE)",
      example: "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk",
    }),
  })
  .refine((data) => data.client_secret || data.code_verifier, {
    message: "Either client_secret or code_verifier must be provided",
  });

// OAuth Refresh Token Request Schema
export const oauthRefreshTokenRequestSchema = z.object({
  grant_type: z.literal("refresh_token").openapi({
    description: "OAuth grant type, must be 'refresh_token'",
    example: "refresh_token",
  }),
  refresh_token: z.string().openapi({
    description: "Refresh token received from token endpoint",
    example: "mid_rt_abcdef123456789",
  }),
  client_id: z.string().openapi({
    description: "Client ID of the OAuth application",
    example: "mid_client_abcdef123456789",
  }),
  client_secret: z.string().optional().openapi({
    description:
      "Client secret of the OAuth application (required for confidential clients)",
    example: "mid_secret_abcdef123456789",
  }),
  scope: z.string().optional().openapi({
    description: "Space-separated list of requested scopes (optional)",
    example: "transactions.read invoices.read",
  }),
});

// OAuth Token Response Schema
export const oauthTokenResponseSchema = z.object({
  access_token: z.string().openapi({
    description: "Access token for API requests",
    example: "mid_access_token_abcdef123456789",
  }),
  token_type: z.literal("Bearer").openapi({
    description: "Token type, always 'Bearer'",
    example: "Bearer",
  }),
  expires_in: z.number().openapi({
    description: "Token expiration time in seconds",
    example: 3600,
  }),
  refresh_token: z.string().openapi({
    description: "Refresh token for obtaining new access tokens",
    example: "mid_refresh_token_abcdef123456789",
  }),
  scope: z.string().openapi({
    description: "Space-separated list of granted scopes",
    example: "transactions.read invoices.read",
  }),
});

// OAuth Token Revocation Request Schema
export const oauthRevokeTokenRequestSchema = z.object({
  token: z.string().openapi({
    description: "Token to revoke (access token or refresh token)",
    example: "mid_access_token_abcdef123456789",
  }),
  token_type_hint: z
    .enum(["access_token", "refresh_token"])
    .optional()
    .openapi({
      description: "Hint about the token type",
      example: "access_token",
    }),
  client_id: z.string().openapi({
    description: "Client ID of the OAuth application",
    example: "mid_client_abcdef123456789",
  }),
  client_secret: z.string().optional().openapi({
    description:
      "Client secret of the OAuth application (required for confidential clients)",
    example: "mid_secret_abcdef123456789",
  }),
});

// OAuth Error Response Schema
export const oauthErrorResponseSchema = z.object({
  error: z.string().openapi({
    description: "Error code",
    example: "invalid_request",
  }),
  error_description: z.string().optional().openapi({
    description: "Human-readable error description",
    example: "The request is missing a required parameter",
  }),
  error_uri: z.string().url().optional().openapi({
    description: "URI to a human-readable error page",
    example: "https://docs.midday.ai/errors/invalid_request",
  }),
  // SECURITY: Enhanced state parameter validation (optional for error responses)
  state: z
    .string()
    .min(32, "State parameter must be at least 32 characters for security")
    .max(512, "State parameter must not exceed 512 characters")
    .regex(
      /^[A-Za-z0-9_.-]+$/,
      "State parameter must contain only alphanumeric characters, underscores, dots, and hyphens",
    )
    .optional()
    .openapi({
      description:
        "State parameter from the original request (min 32 chars, alphanumeric + _.-)",
      example: "abc123xyz789_secure-random-state-value-with-sufficient-entropy",
    }),
});

// OAuth Authorization Decision Schema (for consent flow)
export const oauthAuthorizationDecisionSchema = z.object({
  client_id: z.string().openapi({
    description: "Client ID of the OAuth application",
    example: "mid_client_abcdef123456789",
  }),
  decision: z.enum(["allow", "deny"]).openapi({
    description: "User's authorization decision",
    example: "allow",
  }),
  scopes: z.array(z.enum(SCOPES)).openapi({
    description: "Scopes the user has approved",
    example: ["transactions.read", "invoices.read"],
  }),
  redirect_uri: z.string().url().openapi({
    description: "Redirect URI for OAuth callback",
    example: "https://myapp.com/callback",
  }),
  // SECURITY: Enhanced state parameter validation for CSRF protection
  state: z
    .string()
    .min(32, "State parameter must be at least 32 characters for security")
    .max(512, "State parameter must not exceed 512 characters")
    .regex(
      /^[A-Za-z0-9_.-]+$/,
      "State parameter must contain only alphanumeric characters, underscores, dots, and hyphens",
    )
    .openapi({
      description:
        "State parameter for CSRF protection (min 32 chars, alphanumeric + _.-)",
      example: "abc123xyz789_secure-random-state-value-with-sufficient-entropy",
    }),
  code_challenge: z.string().optional().openapi({
    description: "Code challenge for PKCE (S256 method assumed)",
    example: "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM",
  }),
  teamId: z.string().uuid().openapi({
    description: "Team ID to authorize the application for",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
});

// OAuth Application Info Schema (for consent screen)
export const oauthApplicationInfoSchema = z.object({
  id: z.string().uuid().openapi({
    description: "Application ID",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
  name: z.string().openapi({
    description: "Application name",
    example: "My Raycast Extension",
  }),
  description: z.string().nullable().openapi({
    description: "Application description",
    example: "A Raycast extension for managing transactions",
  }),
  overview: z.string().nullable().openapi({
    description: "Application overview",
    example:
      "This application provides advanced transaction management features including:\n- Real-time sync\n- Advanced filtering",
  }),
  developerName: z.string().nullable().openapi({
    description: "The person or company developing this application",
    example: "Acme Corp",
  }),
  logoUrl: z.string().nullable().openapi({
    description: "Application logo URL",
    example: "https://example.com/logo.png",
  }),
  website: z.string().nullable().openapi({
    description: "Application website",
    example: "https://myapp.com",
  }),
  installUrl: z.string().nullable().openapi({
    description: "An optional URL for installing the application",
    example: "https://myapp.com/install",
  }),
  screenshots: z.array(z.string().url()).openapi({
    description: "Up to 4 screenshots that will be displayed on the apps page",
    example: [
      "https://example.com/screenshot1.png",
      "https://example.com/screenshot2.png",
    ],
  }),
  clientId: z.string().openapi({
    description: "Client ID",
    example: "mid_client_abcdef123456789",
  }),
  scopes: z.array(z.string()).openapi({
    description: "Requested scopes",
    example: ["transactions.read", "invoices.read"],
  }),
  redirectUri: z.string().url().openapi({
    description: "Redirect URI",
    example: "https://myapp.com/callback",
  }),
  // SECURITY: Enhanced state parameter validation (optional for consent screen)
  state: z
    .string()
    .min(32, "State parameter must be at least 32 characters for security")
    .max(512, "State parameter must not exceed 512 characters")
    .regex(
      /^[A-Za-z0-9_.-]+$/,
      "State parameter must contain only alphanumeric characters, underscores, dots, and hyphens",
    )
    .optional()
    .openapi({
      description: "State parameter (min 32 chars, alphanumeric + _.-)",
      example: "abc123xyz789_secure-random-state-value-with-sufficient-entropy",
    }),
  status: z.enum(["draft", "pending", "approved", "rejected"]).openapi({
    description: "Application verification status",
    example: "approved",
  }),
});

// User's Authorized Applications Schema
export const userAuthorizedApplicationsSchema = z.object({
  data: z.array(
    z.object({
      id: z.string().uuid(),
      name: z.string(),
      description: z.string().nullable(),
      overview: z.string().nullable(),
      developerName: z.string().nullable(),
      logoUrl: z.string().nullable(),
      website: z.string().nullable(),
      installUrl: z.string().nullable(),
      screenshots: z.array(z.string().url()),
      scopes: z.array(z.string()),
      lastUsedAt: z.string().nullable(),
      createdAt: z.string(),
    }),
  ),
});

// Revoke User Application Access Schema
export const revokeUserApplicationAccessSchema = z.object({
  applicationId: z.string().uuid().openapi({
    description: "ID of the application to revoke access for",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
});
</file>

<file path="apps/api/src/schemas/polar.ts">
import { z } from "zod";

export const getPolarOrdersSchema = z.object({
  cursor: z.string().optional(),
  pageSize: z.number().min(1).max(100).default(25),
});

export type GetPolarOrdersSchema = z.infer<typeof getPolarOrdersSchema>;
</file>

<file path="apps/api/src/schemas/reports.ts">
import { z } from "@hono/zod-openapi";

export const getRevenueSchema = z
  .object({
    from: z.string().openapi({
      description: "Start date (ISO 8601 format)",
      example: "2023-01-01",
    }),
    to: z.string().openapi({
      description: "End date (ISO 8601 format)",
      example: "2023-12-31",
    }),
    currency: z.string().optional().openapi({
      description: "Currency code (ISO 4217)",
      example: "USD",
    }),
  })
  .openapi("GetRevenueSchema");

export const getProfitSchema = z
  .object({
    from: z.string().openapi({
      description: "Start date (ISO 8601 format)",
      example: "2023-01-01",
    }),
    to: z.string().openapi({
      description: "End date (ISO 8601 format)",
      example: "2023-12-31",
    }),
    currency: z.string().optional().openapi({
      description: "Currency code (ISO 4217)",
      example: "USD",
    }),
  })
  .openapi("GetProfitSchema");

export const getBurnRateSchema = z
  .object({
    from: z.string().openapi({
      description: "Start date (ISO 8601 format)",
      example: "2023-01-01",
    }),
    to: z.string().openapi({
      description: "End date (ISO 8601 format)",
      example: "2023-12-31",
    }),
    currency: z.string().optional().openapi({
      description: "Currency code (ISO 4217)",
      example: "USD",
    }),
  })
  .openapi("GetBurnRateSchema");

export const getRunwaySchema = z
  .object({
    from: z.string().openapi({
      description: "Start date (ISO 8601 format)",
      example: "2023-01-01",
    }),
    to: z.string().openapi({
      description: "End date (ISO 8601 format)",
      example: "2023-12-31",
    }),
    currency: z.string().optional().openapi({
      description: "Currency code (ISO 4217)",
      example: "USD",
    }),
  })
  .openapi("GetRunwaySchema");

export const getExpensesSchema = z
  .object({
    from: z.string().openapi({
      description: "Start date (ISO 8601 format)",
      example: "2023-01-01",
    }),
    to: z.string().openapi({
      description: "End date (ISO 8601 format)",
      example: "2023-12-31",
    }),
    currency: z.string().optional().openapi({
      description: "Currency code (ISO 4217)",
      example: "USD",
    }),
  })
  .openapi("GetExpensesSchema");

export const getSpendingSchema = z
  .object({
    from: z.string().openapi({
      description: "Start date (ISO 8601 format)",
      example: "2023-01-01",
    }),
    to: z.string().openapi({
      description: "End date (ISO 8601 format)",
      example: "2023-12-31",
    }),
    currency: z.string().optional().openapi({
      description: "Currency code (ISO 4217)",
      example: "USD",
    }),
  })
  .openapi("GetSpendingSchema");

export const getRevenueResponseSchema = z
  .object({
    summary: z
      .object({
        currentTotal: z.number().openapi({
          description: "Total revenue for the current period",
          example: 10000,
        }),
        prevTotal: z.number().openapi({
          description: "Total revenue for the previous period",
          example: 8000,
        }),
        currency: z.string().openapi({
          description: "Currency code (ISO 4217)",
          example: "USD",
        }),
      })
      .openapi("RevenueSummary"),
    meta: z
      .object({
        type: z
          .literal("revenue")
          .openapi({ description: "Type of metric", example: "revenue" }),
        currency: z.string().openapi({
          description: "Currency code (ISO 4217)",
          example: "USD",
        }),
      })
      .openapi("RevenueMeta"),
    result: z
      .array(
        z
          .object({
            date: z.string().openapi({
              description: "Date for the metric (ISO 8601)",
              example: "2023-01-31",
            }),
            percentage: z
              .object({
                value: z.number().openapi({
                  description: "Percentage change compared to previous period",
                  example: 25,
                }),
                status: z.enum(["negative", "positive"]).openapi({
                  description: "Status of the change",
                  example: "positive",
                }),
              })
              .openapi("RevenuePercentage"),
            current: z
              .object({
                date: z.string().openapi({
                  description: "Date for the current value",
                  example: "2023-01-31",
                }),
                value: z.number().openapi({
                  description: "Current value",
                  example: 1000,
                }),
                currency: z.string().openapi({
                  description: "Currency code (ISO 4217)",
                  example: "USD",
                }),
              })
              .openapi("RevenueCurrent"),
            previous: z
              .object({
                date: z.string().openapi({
                  description: "Date for the previous value",
                  example: "2022-01-31",
                }),
                value: z.number().openapi({
                  description: "Previous value",
                  example: 800,
                }),
                currency: z.string().openapi({
                  description: "Currency code (ISO 4217)",
                  example: "USD",
                }),
              })
              .openapi("RevenuePrevious"),
          })
          .openapi("RevenueResultItem"),
      )
      .openapi("RevenueResultArray"),
  })
  .openapi("GetRevenueResponseSchema");

export const getProfitResponseSchema = z
  .object({
    summary: z
      .object({
        currentTotal: z.number().openapi({
          description: "Total profit for the current period",
          example: 10000,
        }),
        prevTotal: z.number().openapi({
          description: "Total profit for the previous period",
          example: 8000,
        }),
        currency: z.string().openapi({
          description: "Currency code (ISO 4217)",
          example: "USD",
        }),
      })
      .openapi("ProfitSummary"),
    meta: z
      .object({
        type: z
          .literal("profit")
          .openapi({ description: "Type of metric", example: "profit" }),
        currency: z.string().openapi({
          description: "Currency code (ISO 4217)",
          example: "USD",
        }),
      })
      .openapi("ProfitMeta"),
    result: z
      .array(
        z
          .object({
            date: z.string().openapi({
              description: "Date for the metric (ISO 8601)",
              example: "2023-01-31",
            }),
            percentage: z
              .object({
                value: z.number().openapi({
                  description: "Percentage change compared to previous period",
                  example: 25,
                }),
                status: z.enum(["negative", "positive"]).openapi({
                  description: "Status of the change",
                  example: "positive",
                }),
              })
              .openapi("ProfitPercentage"),
            current: z
              .object({
                date: z.string().openapi({
                  description: "Date for the current value",
                  example: "2023-01-31",
                }),
                value: z.number().openapi({
                  description: "Current value",
                  example: 1000,
                }),
                currency: z.string().openapi({
                  description: "Currency code (ISO 4217)",
                  example: "USD",
                }),
              })
              .openapi("ProfitCurrent"),
            previous: z
              .object({
                date: z.string().openapi({
                  description: "Date for the previous value",
                  example: "2022-01-31",
                }),
                value: z.number().openapi({
                  description: "Previous value",
                  example: 800,
                }),
                currency: z.string().openapi({
                  description: "Currency code (ISO 4217)",
                  example: "USD",
                }),
              })
              .openapi("ProfitPrevious"),
          })
          .openapi("ProfitResultItem"),
      )
      .openapi("ProfitResultArray"),
  })
  .openapi("GetProfitResponseSchema");

export const getBurnRateResponseSchema = z
  .array(
    z
      .object({
        date: z.string().openapi({
          description: "Date for the burn rate value",
          example: "2024-01-01",
        }),
        value: z.number().openapi({
          description: "Burn rate value for the given date",
          example: 647366.44,
        }),
        currency: z.string().openapi({
          description: "Currency code (ISO 4217)",
          example: "SEK",
        }),
      })
      .openapi("GetBurnRateResponseSchema"),
  )
  .openapi("GetBurnRateResponseSchema");

export const getRunwayResponseSchema = z.number().openapi({
  title: "GetRunwayResponseSchema",
  description:
    "Number of months of runway remaining, based on current burn rate and available cash.",
  example: 12,
});

export const getExpensesResponseSchema = z
  .object({
    summary: z.object({
      averageExpense: z.number().openapi({
        description: "Average expense over the period",
        example: 121054.86,
      }),
      currency: z.string().openapi({
        description: "Currency code (ISO 4217)",
        example: "SEK",
      }),
    }),
    meta: z.object({
      type: z.string().openapi({
        description: "Type of metric",
        example: "expense",
      }),
      currency: z.string().openapi({
        description: "Currency code (ISO 4217)",
        example: "SEK",
      }),
    }),
    result: z
      .array(
        z.object({
          date: z.string().openapi({
            description: "Date for the expense value",
            example: "2024-01-01 00:00:00",
          }),
          value: z.number().openapi({
            description: "Expense value for the given date",
            example: 637898.68,
          }),
          currency: z.string().openapi({
            description: "Currency code (ISO 4217)",
            example: "SEK",
          }),
          recurring: z.number().openapi({
            description: "Recurring expense value for the given date",
            example: 9467.76,
          }),
          total: z.number().openapi({
            description: "Total expense for the given date",
            example: 647366.44,
          }),
        }),
      )
      .openapi("ExpensesResultArray"),
  })
  .openapi("GetExpensesResponseSchema");

export const getSpendingResponseSchema = z
  .array(
    z.object({
      name: z.string().openapi({
        description: "Spending category name",
        example: "Taxes",
      }),
      slug: z.string().openapi({
        description: "Spending category slug",
        example: "taxes",
      }),
      amount: z.number().openapi({
        description: "Amount spent in this category",
        example: -1256445,
      }),
      currency: z.string().openapi({
        description: "Currency code (ISO 4217)",
        example: "SEK",
      }),
      color: z.string().openapi({
        description: "Color code for the category",
        example: "#8492A6",
      }),
      percentage: z.number().openapi({
        description: "Percentage of total spending for this category",
        example: 44,
      }),
    }),
  )
  .openapi("SpendingResultArray");

export const getTaxSummarySchema = z
  .object({
    from: z.string().openapi({
      description: "Start date (ISO 8601 format)",
      example: "2023-01-01",
    }),
    to: z.string().openapi({
      description: "End date (ISO 8601 format)",
      example: "2023-12-31",
    }),
    currency: z.string().optional().openapi({
      description: "Currency code (ISO 4217)",
      example: "USD",
    }),
    type: z.enum(["paid", "collected"]).openapi({
      description: "Type of tax",
      example: "paid",
    }),
    categorySlug: z.string().optional().openapi({
      description: "Category slug",
      example: "taxes",
    }),
    taxType: z.string().optional().openapi({
      description: "Tax type",
      example: "vat",
    }),
  })
  .openapi("GetTaxSummarySchema");
</file>

<file path="apps/api/src/schemas/search.ts">
import { z } from "@hono/zod-openapi";

export const globalSearchSchema = z
  .object({
    searchTerm: z.string().optional().openapi({
      description: "The term to search for across all data sources.",
      example: "Acme",
    }),
    language: z.string().optional().openapi({
      description: "Language code to use for search relevance and results.",
      example: "en",
    }),
    limit: z.number().default(30).openapi({
      description: "Maximum number of results to return.",
      example: 30,
    }),
    itemsPerTableLimit: z.number().default(5).openapi({
      description: "Maximum number of results to return per table/entity.",
      example: 5,
    }),
    relevanceThreshold: z.number().default(0.01).openapi({
      description: "Minimum relevance score threshold for including a result.",
      example: 0.01,
    }),
  })
  .openapi({
    description:
      "Parameters for performing a global search across all data sources.",
  });

export const searchResponseSchema = z
  .array(
    z.object({
      id: z.string().openapi({
        description: "Unique identifier for the search result item.",
        example: "b3b7e6e2-8c2a-4e2a-9b1a-2e4b5c6d7f8a",
      }),
      type: z.string().openapi({
        description:
          "Type of the entity returned (e.g., invoice, customer, transaction).",
        example: "invoice",
      }),
      relevance: z.number().openapi({
        description: "Relevance score for the search result.",
        example: 0.92,
      }),
      created_at: z.string().openapi({
        description: "ISO 8601 timestamp when the entity was created.",
        example: "2024-06-01T00:00:00.000Z",
      }),
      data: z.any().openapi({
        description:
          "Additional data for the search result, structure depends on the type.",
        example: {
          invoiceNumber: "INV-2024-001",
          customerName: "Acme Corporation",
          amount: 1500.75,
        },
      }),
    }),
  )
  .openapi({
    description: "Search results.",
    example: [
      {
        id: "b3b7e6e2-8c2a-4e2a-9b1a-2e4b5c6d7f8a",
        type: "invoice",
        relevance: 0.92,
        created_at: "2024-06-01T00:00:00.000Z",
        data: {
          invoiceNumber: "INV-2024-001",
          customerName: "Acme Corporation",
          amount: 1500.75,
        },
      },
    ],
  });
</file>

<file path="apps/api/src/schemas/short-links.ts">
import { z } from "@hono/zod-openapi";

export const createShortLinkSchema = z.object({
  url: z.string().url().openapi({
    description: "The URL to create a short link for",
    example: "https://example.com/document.pdf",
  }),
});

export const createShortLinkForDocumentSchema = z
  .object({
    documentId: z.string().optional().openapi({
      description: "The ID of the document",
      example: "doc_1234567890",
    }),
    filePath: z.string().optional().openapi({
      description: "The path to the file in storage",
      example: "team_123/documents/document.pdf",
    }),
    expireIn: z.number().default(3600).openapi({
      description: "Expiration time in seconds for the signed URL",
      example: 3600,
    }),
  })
  .refine((data) => data.documentId || data.filePath, {
    message: "At least one of documentId or filePath must be provided",
    path: ["documentId", "filePath"],
  });

export const getShortLinkSchema = z.object({
  shortId: z.string().openapi({
    description: "The short ID of the link",
    example: "abc12345",
  }),
});
</file>

<file path="apps/api/src/schemas/tags.ts">
import { z } from "@hono/zod-openapi";

export const createTagSchema = z
  .object({
    name: z.string().openapi({
      description: "The name of the tag.",
      example: "Important",
    }),
  })
  .openapi("CreateTag");

export const deleteTagSchema = z
  .object({
    id: z
      .string()
      .uuid()
      .openapi({
        description: "The UUID of the tag to delete.",
        example: "b3b7c8e2-1f2a-4c3d-9e4f-5a6b7c8d9e0f",
        param: {
          in: "path",
          name: "id",
        },
      }),
  })
  .openapi("DeleteTag");

export const updateTagSchema = z
  .object({
    id: z
      .string()
      .uuid()
      .openapi({
        description: "The ID of the tag to update.",
        example: "b3b7c8e2-1f2a-4c3d-9e4f-5a6b7c8d9e0f",
        param: {
          in: "path",
          name: "id",
        },
      }),
    name: z.string().openapi({
      description: "The new name of the tag.",
      example: "Urgent",
    }),
  })
  .openapi("UpdateTag");

export const tagResponseSchema = z
  .object({
    id: z
      .string()
      .uuid()
      .openapi({
        description: "The UUID of the tag.",
        example: "b3b7c8e2-1f2a-4c3d-9e4f-5a6b7c8d9e0f",
        param: {
          in: "path",
        },
      }),
    name: z.string().openapi({
      description: "The name of the tag.",
      example: "Important",
    }),
  })
  .openapi("TagResponse");

export const tagsResponseSchema = z
  .object({
    data: z.array(tagResponseSchema).openapi({
      description: "List of tags.",
    }),
  })
  .openapi("TagsResponse");
</file>

<file path="apps/api/src/schemas/team.ts">
import { z } from "@hono/zod-openapi";

export const teamResponseSchema = z.object({
  id: z.string().uuid().openapi({
    description: "Unique identifier of the team",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
  name: z.string().openapi({
    description: "Name of the team or organization",
    example: "Acme Corporation",
  }),
  logoUrl: z.string().url().nullable().openapi({
    description: "URL to the team's logo image",
    example: "https://cdn.midday.ai/logos/acme-corp.png",
  }),
  plan: z.enum(["trial", "starter", "pro"]).openapi({
    description: "Current subscription plan of the team",
    example: "pro",
  }),
  // subscriptionStatus: z
  //   .enum([
  //     "active",
  //     "canceled",
  //     "past_due",
  //     "unpaid",
  //     "trialing",
  //     "incomplete",
  //     "incomplete_expired",
  //   ])
  //   .nullable()
  //   .openapi({
  //     description: "Current subscription status of the team",
  //     example: "active",
  //   }),
});

export const teamsResponseSchema = z.object({
  data: z.array(teamResponseSchema).openapi({
    description: "Array of teams that the user has access to",
  }),
});

export const getTeamByIdSchema = z.object({
  id: z
    .string()
    .uuid()
    .openapi({
      description: "Unique identifier of the team",
      example: "123e4567-e89b-12d3-a456-426614174000",
      param: {
        in: "path",
        name: "id",
        required: true,
      },
    })
    .openapi({
      description: "Unique identifier of the team",
      example: "123e4567-e89b-12d3-a456-426614174000",
    }),
});

export const updateTeamByIdSchema = z.object({
  name: z.string().min(2).max(32).optional().openapi({
    description:
      "Name of the team or organization. Must be between 2 and 32 characters",
    example: "Acme Corporation",
  }),
  email: z.string().email().optional().openapi({
    description: "Primary contact email address for the team",
    example: "team@acme.com",
  }),
  logoUrl: z
    .string()
    .url()
    .refine((url) => url.includes("midday.ai"), {
      message: "logoUrl must be a midday.ai domain URL",
    })
    .optional()
    .openapi({
      description:
        "URL to the team's logo image. Must be hosted on midday.ai domain",
      example: "https://cdn.midday.ai/logos/acme-corp.png",
    }),
  baseCurrency: z.string().optional().openapi({
    description:
      "Base currency for the team in ISO 4217 format (3-letter currency code)",
    example: "USD",
  }),
  countryCode: z.string().optional().openapi({
    description: "Country code for the team",
    example: "US",
  }),
});

export const createTeamSchema = z.object({
  name: z.string().openapi({
    description: "Name of the team or organization",
    example: "Acme Corporation",
  }),
  baseCurrency: z.string().openapi({
    description:
      "Base currency for the team in ISO 4217 format (3-letter currency code)",
    example: "USD",
  }),
  countryCode: z.string().optional().openapi({
    description: "Country code for the team",
    example: "US",
  }),
  logoUrl: z.string().url().optional().openapi({
    description: "URL to the team's logo image",
    example: "https://cdn.midday.ai/logos/acme-corp.png",
  }),
  switchTeam: z.boolean().optional().default(false).openapi({
    description:
      "Whether to automatically switch the user to the newly created team",
    example: true,
  }),
});

export const leaveTeamSchema = z.object({
  teamId: z.string().openapi({
    description: "Unique identifier of the team to leave",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
});

export const acceptTeamInviteSchema = z.object({
  id: z.string().openapi({
    description: "Unique identifier of the team invitation to accept",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
});

export const declineTeamInviteSchema = z.object({
  id: z.string().openapi({
    description: "Unique identifier of the team invitation to decline",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
});

export const deleteTeamSchema = z.object({
  teamId: z.string().openapi({
    description: "Unique identifier of the team to delete",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
});

export const deleteTeamMemberSchema = z.object({
  teamId: z.string().openapi({
    description: "Unique identifier of the team",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
  userId: z.string().openapi({
    description: "Unique identifier of the user to remove from the team",
    example: "456e7890-f12a-34b5-c678-901234567890",
  }),
});

export const updateTeamMemberSchema = z.object({
  teamId: z.string().openapi({
    description: "Unique identifier of the team",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
  userId: z.string().openapi({
    description: "Unique identifier of the user whose role to update",
    example: "456e7890-f12a-34b5-c678-901234567890",
  }),
  role: z.enum(["owner", "member"]).openapi({
    description:
      "New role for the team member. 'owner' has full permissions, 'member' has limited permissions",
    example: "member",
  }),
});

export const inviteTeamMembersSchema = z
  .array(
    z.object({
      email: z.string().openapi({
        description: "Email address of the person to invite",
        example: "john.doe@acme.com",
      }),
      role: z.enum(["owner", "member"]).openapi({
        description:
          "Role to assign to the invited member. 'owner' has full permissions, 'member' has limited permissions",
        example: "member",
      }),
    }),
  )
  .openapi({
    description: "Array of team member invitations to send",
    example: [
      { email: "john.doe@acme.com", role: "member" },
      { email: "jane.smith@acme.com", role: "owner" },
    ],
  });

export const deleteTeamInviteSchema = z.object({
  id: z.string().openapi({
    description: "Unique identifier of the team invitation to delete",
    example: "invite-123abc456def",
  }),
});

export const updateBaseCurrencySchema = z.object({
  baseCurrency: z.string().openapi({
    description:
      "New base currency for the team in ISO 4217 format (3-letter currency code)",
    example: "EUR",
  }),
});

export const teamMemberResponseSchema = z.object({
  id: z.string().uuid().openapi({
    description: "Unique identifier of the user",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
  role: z.enum(["owner", "member"]).openapi({
    description:
      "Role of the team member. 'owner' has full permissions, 'member' has limited permissions",
    example: "owner",
  }),
  fullName: z.string().openapi({
    description: "Full name of the team member",
    example: "John Doe",
  }),
  avatarUrl: z.string().url().nullable().openapi({
    description: "URL to the team member's avatar image",
    example: "https://cdn.midday.ai/avatars/john-doe.png",
  }),
});

export const teamMembersResponseSchema = z.object({
  data: z.array(teamMemberResponseSchema).openapi({
    description: "Array of team members with their roles and information",
  }),
});
</file>

<file path="apps/api/src/schemas/tracker-entries.ts">
import { z } from "@hono/zod-openapi";

export const getTrackerRecordsByDateSchema = z.object({
  date: z.string().openapi({
    description: "Date for which to fetch tracker records in YYYY-MM-DD format",
    example: "2024-04-15",
    param: {
      in: "query",
    },
  }),
});

export const getTrackerRecordsByRangeSchema = z.object({
  from: z.string().openapi({
    description: "Start date of the range (inclusive) in YYYY-MM-DD format",
    example: "2024-04-01",
    param: {
      in: "query",
    },
  }),
  to: z.string().openapi({
    description: "End date of the range (inclusive) in YYYY-MM-DD format",
    example: "2024-04-30",
    param: {
      in: "query",
    },
  }),
  projectId: z
    .string()
    .uuid()
    .optional()
    .openapi({
      description:
        "Optional project ID to filter tracker entries by specific project",
      example: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
      param: {
        in: "query",
      },
    }),
});

export const upsertTrackerEntriesSchema = z.object({
  id: z.string().uuid().optional().openapi({
    description:
      "Unique identifier for the tracker entry. Required for updates, omit for new entries",
    example: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
  }),
  start: z.string().datetime().openapi({
    description: "Start time of the tracker entry in ISO 8601 format",
    example: "2024-04-15T09:00:00.000Z",
  }),
  stop: z.string().datetime().openapi({
    description: "Stop time of the tracker entry in ISO 8601 format",
    example: "2024-04-15T17:00:00.000Z",
  }),
  dates: z
    .array(
      z.string().openapi({
        description: "Date in YYYY-MM-DD format",
        example: "2024-04-15",
      }),
    )
    .openapi({
      description: "Array of dates for which to create tracker entries",
      example: ["2024-04-15", "2024-04-16"],
    }),
  assignedId: z.string().uuid().nullable().openapi({
    description: "Unique identifier of the user assigned to this tracker entry",
    example: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  }),
  projectId: z.string().openapi({
    description:
      "Unique identifier of the project associated with this tracker entry",
    example: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
  }),
  description: z.string().optional().nullable().openapi({
    description: "Optional description or notes for the tracker entry",
    example: "Worked on implementing user authentication feature",
  }),
  duration: z.number().openapi({
    description: "Duration of the tracker entry in seconds",
    example: 28800,
  }),
});

export const bulkCreateTrackerEntriesSchema = z.object({
  entries: z
    .array(upsertTrackerEntriesSchema.omit({ id: true }))
    .max(100)
    .min(1)
    .openapi({
      description:
        "Array of tracker entries to create (maximum 100 entries per request)",
      example: [
        {
          start: "2024-04-15T09:00:00.000Z",
          stop: "2024-04-15T17:00:00.000Z",
          dates: ["2024-04-15"],
          assignedId: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
          projectId: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
          description: "Working on authentication feature",
          duration: 28800,
        },
        {
          start: "2024-04-16T09:00:00.000Z",
          stop: "2024-04-16T17:00:00.000Z",
          dates: ["2024-04-16"],
          assignedId: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
          projectId: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
          description: "Working on dashboard feature",
          duration: 28800,
        },
      ],
    }),
});

export const deleteTrackerEntrySchema = z.object({
  id: z.string().uuid().openapi({
    description: "Unique identifier of the tracker entry to delete",
    example: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
  }),
});

export const trackerEntryResponseSchema = z.object({
  id: z.string().uuid().openapi({
    description: "Unique identifier of the tracker entry",
    example: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
  }),
  createdAt: z.string().openapi({
    description:
      "Date and time when the tracker entry was created in ISO 8601 format",
    example: "2024-04-15T09:00:00.000Z",
  }),
  duration: z.number().openapi({
    description: "Duration of the tracker entry in seconds",
    example: 28800,
  }),
  start: z.string().openapi({
    description: "Start time of the tracker entry in ISO 8601 format",
    example: "2024-04-15T09:00:00.000Z",
  }),
  stop: z.string().openapi({
    description: "Stop time of the tracker entry in ISO 8601 format",
    example: "2024-04-15T17:00:00.000Z",
  }),
  teamId: z.string().openapi({
    description: "Unique identifier of the team that owns this tracker entry",
    example: "team-1234",
  }),
  description: z.string().nullable().openapi({
    description: "Description or notes for the tracker entry",
    example: "Worked on implementing user authentication feature",
  }),
  rate: z.number().nullable().openapi({
    description: "Hourly rate applied to this tracker entry",
    example: 75.0,
  }),
  currency: z.string().nullable().openapi({
    description: "Currency code for the rate in ISO 4217 format",
    example: "USD",
  }),
  billed: z.boolean().openapi({
    description: "Whether this tracker entry has been billed to the customer",
    example: false,
  }),
  date: z.string().openapi({
    description: "Date of the tracker entry in YYYY-MM-DD format",
    example: "2024-04-15",
  }),
  user: z
    .object({
      id: z.string().uuid().openapi({
        description: "Unique identifier of the user",
        example: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
      }),
      fullName: z.string().openapi({
        description: "Full name of the user",
        example: "Jane Doe",
      }),
      avatarUrl: z.string().openapi({
        description: "URL to the user's avatar image",
        example: "https://cdn.midday.ai/avatar.jpg",
      }),
    })
    .openapi({
      description:
        "User information for the person who created this tracker entry",
    }),
  project: z
    .object({
      id: z.string().uuid().openapi({
        description: "Unique identifier of the project",
        example: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
      }),
      createdAt: z.string().openapi({
        description:
          "Date and time when the project was created in ISO 8601 format",
        example: "2024-03-01T10:00:00.000Z",
      }),
      rate: z.number().nullable().openapi({
        description: "Default hourly rate for the project",
        example: 75.0,
      }),
      currency: z.string().nullable().openapi({
        description: "Currency code for the project rate in ISO 4217 format",
        example: "USD",
      }),
      status: z.string().openapi({
        description: "Current status of the project",
        example: "in_progress",
      }),
      description: z.string().nullable().openapi({
        description: "Description of the project",
        example: "Complete website redesign with modern UI/UX",
      }),
      name: z.string().openapi({
        description: "Name of the project",
        example: "Website Redesign Project",
      }),
      billable: z.boolean().nullable().openapi({
        description: "Whether the project is billable to the customer",
        example: true,
      }),
      estimate: z.number().nullable().openapi({
        description: "Estimated total hours for the project",
        example: 120,
      }),
      customer: z
        .object({
          id: z.string().openapi({
            description: "Unique identifier of the customer",
            example: "customer-1234",
          }),
          name: z.string().openapi({
            description: "Name of the customer or organization",
            example: "Acme Corporation",
          }),
        })
        .nullable()
        .openapi({
          description: "Customer information associated with the project",
        }),
    })
    .openapi({
      description: "Project information associated with this tracker entry",
    }),
});

export const trackerEntriesResponseSchema = z.object({
  meta: z
    .object({
      totalDuration: z.number().openapi({
        description:
          "Total duration of all tracker entries in the response in seconds",
        example: 86400,
      }),
      totalAmount: z.number().openapi({
        description:
          "Total monetary amount for all tracker entries in the response",
        example: 1800.0,
      }),
      from: z.string().openapi({
        description: "Start date of the queried range in YYYY-MM-DD format",
        example: "2024-04-01",
      }),
      to: z.string().openapi({
        description: "End date of the queried range in YYYY-MM-DD format",
        example: "2024-04-30",
      }),
    })
    .openapi({
      description:
        "Metadata about the tracker entries response including totals and date range",
    }),
  result: z.record(z.string(), z.array(trackerEntryResponseSchema)).openapi({
    description:
      "Tracker entries grouped by date, where each key is a date in YYYY-MM-DD format and the value is an array of tracker entries for that date",
  }),
});

export const createTrackerEntriesResponseSchema = z
  .object({
    data: z.array(trackerEntryResponseSchema).openapi({
      description: "Array of created tracker entries",
    }),
  })
  .openapi({
    description: "Response schema for created tracker entries",
  });

export const startTimerSchema = z.object({
  projectId: z.string().uuid().openapi({
    description: "Unique identifier of the project to track time for",
    example: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
  }),
  assignedId: z.string().uuid().optional().nullable().openapi({
    description:
      "Unique identifier of the user to assign the timer to. If not provided, will use the authenticated user",
    example: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  }),
  description: z.string().optional().nullable().openapi({
    description: "Optional description for the timer session",
    example: "Working on implementing timer feature",
  }),
  start: z.string().datetime().optional().openapi({
    description:
      "Start time in ISO 8601 format. If not provided, will use current time",
    example: "2024-04-15T09:00:00.000Z",
  }),
  continueFromEntry: z.string().uuid().optional().openapi({
    description: "Continue from a specific paused entry ID",
    example: "c4d5e6f7-2a3b-4c5d-8e9f-3a4b5c6d7e8f",
  }),
});

export const stopTimerSchema = z.object({
  entryId: z.string().uuid().optional().openapi({
    description:
      "Unique identifier of the specific timer entry to stop. If not provided, will stop the current running timer for the user",
    example: "b3b6e2c2-1f2a-4e3b-9c1d-2a4b6e2c21f2",
  }),
  assignedId: z.string().uuid().optional().nullable().openapi({
    description:
      "Unique identifier of the user whose timer should be stopped. If not provided, will use the authenticated user",
    example: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  }),
  stop: z.string().datetime().optional().openapi({
    description:
      "Stop time in ISO 8601 format. If not provided, will use current time",
    example: "2024-04-15T17:00:00.000Z",
  }),
});

export const getCurrentTimerSchema = z.object({
  assignedId: z.string().uuid().optional().nullable().openapi({
    description:
      "Unique identifier of the user whose current timer should be retrieved. If not provided, will use the authenticated user",
    example: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  }),
});

// Reuse existing trackerEntryResponseSchema but make duration nullable for running entries
export const timerResponseSchema = trackerEntryResponseSchema.extend({
  duration: z.number().nullable().openapi({
    description:
      "Duration of the timer entry in seconds. -1 indicates running, null for paused, positive number for completed",
    example: -1,
  }),
});

export const timerStatusSchema = z.object({
  isRunning: z.boolean().openapi({
    description: "Whether there is currently a running timer",
    example: true,
  }),
  currentEntry: z
    .object({
      id: z.string().uuid(),
      start: z.string().nullable(),
      description: z.string().nullable(),
      projectId: z.string().uuid(),
      trackerProject: z.object({
        id: z.string().uuid(),
        name: z.string(),
      }),
    })
    .nullable()
    .openapi({
      description: "Current running timer details, null if not running",
    }),
  elapsedTime: z.number().openapi({
    description: "Elapsed time in seconds for the current running timer",
    example: 1800,
  }),
});

// Timer response schemas
export const startTimerResponseSchema = z.object({
  data: timerResponseSchema,
});

export const stopTimerResponseSchema = z.object({
  data: timerResponseSchema,
});

export const getCurrentTimerResponseSchema = z.object({
  data: timerResponseSchema.nullable(),
});

export const getTimerStatusResponseSchema = z.object({
  data: timerStatusSchema,
});
</file>

<file path="apps/api/src/schemas/tracker-projects.ts">
import { z } from "@hono/zod-openapi";

export const getTrackerProjectsSchema = z.object({
  cursor: z
    .string()
    .nullable()
    .optional()
    .openapi({
      description:
        "Cursor for pagination, representing the last item from the previous page",
      example: "eyJpZCI6IjEyMyJ9",
      param: {
        in: "query",
      },
    }),
  pageSize: z.coerce
    .number()
    .min(1)
    .max(100)
    .optional()
    .openapi({
      description: "Number of projects to return per page (1-100)",
      example: 20,
      param: {
        in: "query",
      },
    }),
  q: z
    .string()
    .nullable()
    .optional()
    .openapi({
      description:
        "Search query string to filter projects by name or description",
      example: "website",
      param: {
        in: "query",
      },
    }),
  start: z
    .string()
    .nullable()
    .optional()
    .openapi({
      description:
        "Start date for filtering projects by creation date in YYYY-MM-DD format",
      example: "2024-04-01",
      param: {
        in: "query",
      },
    }),
  end: z
    .string()
    .nullable()
    .optional()
    .openapi({
      description:
        "End date for filtering projects by creation date in YYYY-MM-DD format",
      example: "2024-04-30",
      param: {
        in: "query",
      },
    }),
  status: z
    .enum(["in_progress", "completed"])
    .nullable()
    .optional()
    .openapi({
      description: "Filter projects by status",
      example: "in_progress",
      param: {
        in: "query",
      },
    }),
  customers: z
    .array(z.string())
    .nullable()
    .optional()
    .openapi({
      description:
        "Array of customer IDs to filter projects by specific customers",
      example: ["customer-1", "customer-2"],
      param: {
        in: "query",
      },
    }),
  tags: z
    .array(z.string())
    .nullable()
    .optional()
    .openapi({
      description: "Array of tag IDs to filter projects by specific tags",
      example: ["tag-1", "tag-2"],
      param: {
        in: "query",
      },
    }),
  sort: z
    .array(z.string())
    .nullable()
    .optional()
    .openapi({
      description:
        "Sorting order as an array of field names. Prefix with '-' for descending order",
      example: ["-createdAt", "name"],
      param: {
        in: "query",
      },
    }),
});

export const upsertTrackerProjectSchema = z
  .object({
    id: z.string().uuid().optional().openapi({
      description:
        "Unique identifier for the project. Required for updates, omit for new projects",
      example: "b7e6c8e2-1f2a-4c3b-9e2d-1a2b3c4d5e6f",
    }),
    name: z.string().min(1).openapi({
      description: "Name of the project",
      example: "Website Redesign",
    }),
    description: z.string().nullable().optional().openapi({
      description: "Detailed description of the project",
      example:
        "Complete redesign of the company website with modern UI/UX and improved performance",
    }),
    estimate: z.number().nullable().optional().openapi({
      description: "Estimated total hours required to complete the project",
      example: 120,
    }),
    billable: z.boolean().nullable().optional().default(false).openapi({
      description: "Whether the project is billable to the customer",
      example: true,
    }),
    rate: z.number().min(1).nullable().optional().openapi({
      description: "Hourly rate for the project in the specified currency",
      example: 75.0,
    }),
    currency: z.string().nullable().optional().openapi({
      description: "Currency code for the project rate in ISO 4217 format",
      example: "USD",
    }),
    status: z.enum(["in_progress", "completed"]).optional().openapi({
      description: "Current status of the project",
      example: "in_progress",
    }),
    customerId: z.string().uuid().nullable().optional().openapi({
      description:
        "Unique identifier of the customer associated with this project",
      example: "a1b2c3d4-e5f6-7890-abcd-1234567890ef",
    }),
    tags: z
      .array(
        z.object({
          id: z.string().uuid().openapi({
            description: "Unique identifier of the tag",
            example: "f1e2d3c4-b5a6-7890-1234-567890abcdef",
          }),
          value: z.string().openapi({
            description: "Display value of the tag",
            example: "Design",
          }),
        }),
      )
      .optional()
      .nullable()
      .openapi({
        description: "Array of tags to associate with the project",
        example: [
          { id: "f1e2d3c4-b5a6-7890-1234-567890abcdef", value: "Design" },
          { id: "e2d3c4b5-a6f1-7890-1234-567890abcdef", value: "Frontend" },
        ],
      }),
  })
  .openapi("UpsertTrackerProject");

export const deleteTrackerProjectSchema = z.object({
  id: z.string().uuid().openapi({
    description: "Unique identifier of the project to delete",
    example: "b7e6c8e2-1f2a-4c3b-9e2d-1a2b3c4d5e6f",
  }),
});

export const getTrackerProjectByIdSchema = z.object({
  id: z.string().uuid().openapi({
    description: "Unique identifier of the project to retrieve",
    example: "b7e6c8e2-1f2a-4c3b-9e2d-1a2b3c4d5e6f",
  }),
});

export const trackerProjectResponseSchema = z
  .object({
    id: z.string().uuid().openapi({
      description: "Unique identifier of the project",
      example: "b7e6c8e2-1f2a-4c3b-9e2d-1a2b3c4d5e6f",
    }),
    name: z.string().openapi({
      description: "Name of the project",
      example: "Website Redesign",
    }),
    description: z.string().nullable().openapi({
      description: "Detailed description of the project",
      example:
        "Complete redesign of the company website with modern UI/UX and improved performance",
    }),
    status: z.enum(["in_progress", "completed"]).openapi({
      description: "Current status of the project",
      example: "in_progress",
    }),
    estimate: z.number().nullable().openapi({
      description: "Estimated total hours required to complete the project",
      example: 120,
    }),
    currency: z.string().nullable().openapi({
      description: "Currency code for the project rate in ISO 4217 format",
      example: "USD",
    }),
    createdAt: z.string().openapi({
      description:
        "Date and time when the project was created in ISO 8601 format",
      example: "2024-05-01T12:00:00.000Z",
    }),
    totalDuration: z.number().nullable().openapi({
      description: "Total tracked time for the project in seconds",
      example: 43200,
    }),
    totalAmount: z.number().openapi({
      description: "Total monetary amount earned from the project",
      example: 3600.0,
    }),
    customer: z
      .object({
        id: z.string().uuid().openapi({
          description: "Unique identifier of the customer",
          example: "a1b2c3d4-e5f6-7890-abcd-1234567890ef",
        }),
        name: z.string().openapi({
          description: "Name of the customer or organization",
          example: "Acme Corporation",
        }),
        website: z.string().openapi({
          description: "Website URL of the customer",
          example: "https://acme.com",
        }),
      })
      .nullable()
      .openapi({
        description: "Customer information associated with the project",
      }),
    tags: z
      .array(
        z.object({
          id: z.string().uuid().openapi({
            description: "Unique identifier of the tag",
            example: "d1e2f3a4-b5c6-7890-abcd-1234567890ef",
          }),
          name: z.string().openapi({
            description: "Display name of the tag",
            example: "Design",
          }),
        }),
      )
      .openapi({
        description: "Array of tags associated with the project",
      }),
    users: z
      .array(
        z.object({
          id: z.string().uuid().openapi({
            description: "Unique identifier of the user",
            example: "f1e2d3c4-b5a6-7890-abcd-1234567890ef",
          }),
          fullName: z.string().openapi({
            description: "Full name of the user",
            example: "Jane Doe",
          }),
          avatarUrl: z.string().url().openapi({
            description: "URL to the user's avatar image",
            example: "https://cdn.midday.ai/avatar.jpg",
          }),
        }),
      )
      .nullable()
      .openapi({
        description: "Array of users assigned to work on the project",
      }),
  })
  .openapi("TrackerProjectResponse");

export const trackerProjectsResponseSchema = z
  .object({
    meta: z
      .object({
        hasNextPage: z.boolean().openapi({
          description:
            "Whether there are more projects available on the next page",
          example: true,
        }),
        hasPreviousPage: z.boolean().openapi({
          description:
            "Whether there are more projects available on the previous page",
          example: false,
        }),
      })
      .openapi({
        description: "Pagination metadata for the projects response",
      }),
    data: z.array(trackerProjectResponseSchema).openapi({
      description: "Array of tracker projects matching the query criteria",
    }),
  })
  .openapi("TrackerProjectsResponse");
</file>

<file path="apps/api/src/schemas/transaction-attachments.ts">
import { z } from "@hono/zod-openapi";

export const createAttachmentsSchema = z.array(
  z.object({
    path: z.array(z.string()),
    name: z.string(),
    size: z.number(),
    transactionId: z.string(),
    type: z.string(),
  }),
);

export const deleteAttachmentSchema = z.object({ id: z.string() });

export const processTransactionAttachmentSchema = z.array(
  z.object({
    transactionId: z.string(),
    mimetype: z.string(),
    filePath: z.array(z.string()),
  }),
);
</file>

<file path="apps/api/src/schemas/transaction-categories.ts">
import { z } from "@hono/zod-openapi";

export const createTransactionCategorySchema = z.object({
  name: z.string(),
  color: z.string().optional(),
  description: z.string().optional(),
  taxRate: z.number().optional(),
  taxType: z.string().optional(),
  taxReportingCode: z.string().optional(),
  excluded: z.boolean().optional(),
  parentId: z.string().optional(),
});

export const createManyTransactionCategorySchema = z.array(
  z.object({
    name: z.string(),
    color: z.string().optional(),
    description: z.string().optional(),
    taxRate: z.number().optional(),
    taxType: z.string().optional(),
    taxReportingCode: z.string().optional(),
    excluded: z.boolean().optional(),
  }),
);

export const updateTransactionCategorySchema = z.object({
  id: z.string(),
  name: z.string(),
  color: z.string().nullable(),
  description: z.string().nullable(),
  taxRate: z.number().nullable(),
  taxType: z.string().nullable(),
  taxReportingCode: z.string().nullable(),
  excluded: z.boolean().nullable(),
});

export const deleteTransactionCategorySchema = z.object({ id: z.string() });

export const getCategoriesSchema = z
  .object({
    limit: z.number().optional(),
  })
  .optional();
</file>

<file path="apps/api/src/schemas/transaction-tags.ts">
import { z } from "@hono/zod-openapi";

export const createTransactionTagSchema = z.object({
  transactionId: z.string(),
  tagId: z.string(),
});

export const deleteTransactionTagSchema = z.object({
  transactionId: z.string(),
  tagId: z.string(),
});
</file>

<file path="apps/api/src/schemas/transactions.ts">
import { z } from "@hono/zod-openapi";

export const getTransactionsSchema = z.object({
  cursor: z
    .string()
    .nullable()
    .optional()
    .openapi({
      description:
        "Cursor for pagination, representing the last item from the previous page",
      example: "eyJpZCI6IjEyMyJ9",
      param: {
        in: "query",
      },
    }),
  sort: z
    .array(z.string(), z.string())
    .nullable()
    .optional()
    .openapi({
      description:
        "Sorting order as a tuple: [field, direction]. Example: ['date', 'desc'] or ['amount', 'asc']",
      example: ["date", "desc"],
      param: {
        in: "query",
      },
    }),
  pageSize: z.coerce
    .number()
    .min(1)
    .max(10000)
    .optional()
    .openapi({
      description: "Number of transactions to return per page (1-10000)",
      example: 50,
      param: {
        in: "query",
      },
    }),

  q: z
    .string()
    .nullable()
    .optional()
    .openapi({
      description:
        "Search query string to filter transactions by name, description, or other text fields",
      example: "office supplies",
      param: {
        in: "query",
      },
    }),
  categories: z
    .array(z.string())
    .nullable()
    .optional()
    .openapi({
      description:
        "Array of category slugs to filter transactions by specific categories",
      example: ["office-supplies", "travel"],
      param: {
        in: "query",
      },
    }),
  tags: z
    .array(z.string())
    .nullable()
    .optional()
    .openapi({
      description: "Array of tag IDs to filter transactions by specific tags",
      example: ["tag-1", "tag-2"],
      param: {
        in: "query",
      },
    }),
  start: z
    .string()
    .nullable()
    .optional()
    .openapi({
      description:
        "Start date (inclusive) for filtering transactions in ISO 8601 format",
      example: "2024-04-01T00:00:00.000Z",
      param: {
        in: "query",
      },
    }),
  end: z
    .string()
    .nullable()
    .optional()
    .openapi({
      description:
        "End date (inclusive) for filtering transactions in ISO 8601 format",
      example: "2024-04-30T23:59:59.999Z",
      param: {
        in: "query",
      },
    }),
  accounts: z
    .array(z.string())
    .nullable()
    .optional()
    .openapi({
      description:
        "Array of bank account IDs to filter transactions by specific accounts",
      example: ["account-1", "account-2"],
      param: {
        in: "query",
      },
    }),
  assignees: z
    .array(z.string())
    .nullable()
    .optional()
    .openapi({
      description: "Array of user IDs to filter transactions by assigned users",
      example: ["user-1", "user-2"],
      param: {
        in: "query",
      },
    }),
  statuses: z
    .array(z.string())
    .nullable()
    .optional()
    .openapi({
      description:
        "Array of transaction statuses to filter by. Available statuses: 'pending', 'completed', 'archived', 'posted', 'excluded'",
      example: ["pending", "completed"],
      param: {
        in: "query",
      },
    }),
  recurring: z
    .array(z.string())
    .nullable()
    .optional()
    .openapi({
      description:
        "Array of recurring frequency values to filter by. Available frequencies: 'weekly', 'monthly', 'annually', 'irregular'",
      example: ["monthly", "annually"],
      param: {
        in: "query",
      },
    }),
  attachments: z
    .enum(["include", "exclude"])
    .nullable()
    .optional()
    .openapi({
      description:
        "Filter transactions based on attachment presence. 'include' returns only transactions with attachments, 'exclude' returns only transactions without attachments",
      example: "include",
      param: {
        in: "query",
      },
    }),
  amountRange: z
    .array(z.coerce.number())
    .nullable()
    .optional()
    .openapi({
      description:
        "Amount range as [min, max] to filter transactions by monetary value",
      example: [100, 1000],
      param: {
        in: "query",
      },
    }),
  amount: z
    .array(z.string())
    .nullable()
    .optional()
    .openapi({
      description:
        "Array of specific amounts (as strings) to filter transactions by exact values",
      example: ["150.75", "299.99"],
      param: {
        in: "query",
      },
    }),
  type: z
    .enum(["income", "expense"])
    .nullable()
    .optional()
    .openapi({
      description:
        "Transaction type to filter by. 'income' for money received, 'expense' for money spent",
      example: "expense",
      param: {
        in: "query",
      },
    }),
});

export const transactionResponseSchema = z
  .object({
    id: z.string().uuid().openapi({
      description: "Unique identifier of the transaction",
      example: "b3b7c8e2-1f2a-4c3d-9e4f-5a6b7c8d9e0f",
    }),
    name: z.string().openapi({
      description: "Name or description of the transaction",
      example: "Office Supplies Purchase",
    }),
    amount: z.number().openapi({
      description: "Monetary amount of the transaction",
      example: 150.75,
    }),
    taxAmount: z.number().nullable().openapi({
      description: "Tax amount of the transaction",
      example: 15.07,
    }),
    taxRate: z.number().nullable().openapi({
      description: "Tax rate of the transaction",
      example: 10,
    }),
    taxType: z.string().nullable().openapi({
      description: "Tax type of the transaction",
      example: "VAT",
    }),
    currency: z.string().openapi({
      description: "Currency code of the transaction in ISO 4217 format",
      example: "USD",
    }),
    counterpartyName: z.string().nullable().openapi({
      description: "Name of the counterparty",
      example: "Spotify AB",
    }),
    date: z.string().openapi({
      description: "Date and time of the transaction in ISO 8601 format",
      example: "2024-05-01T12:00:00.000Z",
    }),
    category: z
      .object({
        id: z.string().openapi({
          description: "Unique identifier of the category",
          example: "office-supplies",
        }),
        name: z.string().openapi({
          description: "Display name of the category",
          example: "Office Supplies",
        }),
        color: z.string().openapi({
          description:
            "Hex color code associated with the category for UI display",
          example: "#FF5733",
        }),
        taxRate: z.number().nullable().openapi({
          description: "Tax rate of the category",
          example: 10,
        }),
        taxType: z.string().nullable().openapi({
          description: "Tax type of the category",
          example: "VAT",
        }),
        slug: z.string().openapi({
          description: "URL-friendly slug of the category",
          example: "office-supplies",
        }),
      })
      .nullable()
      .openapi({
        description:
          "Category information assigned to the transaction for organization",
        example: {
          id: "office-supplies",
          name: "Office Supplies",
          color: "#FF5733",
          slug: "office-supplies",
          taxRate: 10,
          taxType: "VAT",
        },
      }),
    status: z.string().openapi({
      description: "Current status of the transaction",
      example: "completed",
    }),
    internal: z.boolean().nullable().openapi({
      description: "Whether the transaction is internal (between own accounts)",
      example: false,
    }),
    recurring: z.boolean().nullable().openapi({
      description: "Whether the transaction is part of a recurring series",
      example: false,
    }),
    manual: z.boolean().nullable().openapi({
      description:
        "Whether the transaction was created manually (via API/form) rather than imported from bank connections",
      example: false,
    }),
    frequency: z.string().nullable().openapi({
      description:
        "Frequency of the recurring transaction if applicable (weekly, monthly, annually, irregular)",
      example: "monthly",
    }),
    isFulfilled: z.boolean().openapi({
      description: "Whether the transaction has been fulfilled or processed",
      example: true,
    }),
    note: z.string().nullable().openapi({
      description: "Optional note or memo attached to the transaction",
      example: "Paid with company credit card for office renovation",
    }),
    account: z
      .object({
        id: z.string().openapi({
          description: "Unique identifier of the bank account",
          example: "a43dc3a5-6925-4d91-ac9c-4c1a34bdb388",
        }),
        name: z.string().openapi({
          description: "Display name of the bank account",
          example: "Company Credit Card",
        }),
        currency: z.string().openapi({
          description: "Currency of the bank account in ISO 4217 format",
          example: "USD",
        }),
        connection: z
          .object({
            id: z.string().openapi({
              description: "Unique identifier of the bank connection",
              example: "a43dc3a5-6925-4d91-ac9c-4c1a34bdb388",
            }),
            name: z.string().openapi({
              description: "Name of the bank institution",
              example: "Chase Bank",
            }),
            logoUrl: z.string().nullable().openapi({
              description: "URL to the bank institution's logo image",
              example: "https://cdn.midday.ai/logos/chase-bank.png",
            }),
          })
          .openapi({
            description:
              "Bank connection information associated with the account",
            example: {
              id: "a43dc3a5-6925-4d91-ac9c-4c1a34bdb388",
              name: "Chase Bank",
              logoUrl: "https://cdn.midday.ai/logos/chase-bank.png",
            },
          }),
      })
      .openapi({
        description: "Bank account information associated with the transaction",
        example: {
          id: "a43dc3a5-6925-4d91-ac9c-4c1a34bdb388",
          name: "Company Credit Card",
          currency: "USD",
          connection: {
            id: "a43dc3a5-6925-4d91-ac9c-4c1a34bdb388",
            name: "Chase Bank",
            logoUrl: "https://cdn.midday.ai/logos/chase-bank.png",
          },
        },
      }),
    tags: z
      .array(
        z.object({
          id: z.string().openapi({
            description: "Unique identifier of the tag",
            example: "b7e2f8c1-3d4a-4e2b-9f1a-2c3d4e5f6a7b",
          }),
          name: z.string().nullable().openapi({
            description: "Display name of the tag",
            example: "invoice",
          }),
        }),
      )
      .nullable()
      .openapi({
        description:
          "Array of tags associated with the transaction for categorization and filtering",
        example: [
          { id: "b7e2f8c1-3d4a-4e2b-9f1a-2c3d4e5f6a7b", name: "invoice" },
          { id: "c8e2f8c1-3d4a-4e2b-9f1a-2c3d4e5f6a7c", name: "travel" },
        ],
      }),
    attachments: z
      .array(
        z.object({
          id: z.string().openapi({
            description: "Unique identifier of the attachment",
            example: "a43dc3a5-6925-4d91-ac9c-4c1a34bdb388",
          }),
          path: z.array(z.string()).openapi({
            description:
              "Array of path segments for the attachment file storage location",
            example: [
              "dd6a039e-d071-423a-9a4d-9ba71325d890",
              "transactions",
              "1d2c3753-79d7-45b0-9c40-60f482bac8e8",
              "receipt.pdf",
            ],
          }),
          size: z.number().openapi({
            description: "Size of the attachment file in bytes",
            example: 1928716,
          }),
          type: z.string().openapi({
            description: "MIME type of the attachment file",
            example: "application/pdf",
          }),
          filename: z.string().nullable().openapi({
            description: "Original filename of the attachment when uploaded",
            example: "receipt.pdf",
          }),
        }),
      )
      .nullable()
      .openapi({
        description:
          "Array of file attachments associated with the transaction (receipts, invoices, etc.)",
        example: [
          {
            id: "b7e2f8c1-3d4a-4e2b-9f1a-2c3d4e5f6a7b",
            path: [
              "e1f2d3c4-b5a6-7d8e-9f0a-1b2c3d4e5f6a",
              "transactions",
              "9a8b7c6d-5e4f-3a2b-1c0d-9e8f7a6b5c4d",
              "receipt.pdf",
            ],
            size: 1928716,
            type: "application/pdf",
            filename: "receipt.pdf",
          },
        ],
      }),
  })
  .openapi("TransactionResponse");

export const transactionsResponseSchema = z.object({
  meta: z
    .object({
      cursor: z.string().optional().openapi({
        description:
          "Cursor for the next page of results, undefined if no more pages",
        example: "eyJpZCI6IjQ1NiJ9",
      }),
      hasPreviousPage: z.boolean().openapi({
        description:
          "Whether there are more transactions available on the previous page",
        example: false,
      }),
      hasNextPage: z.boolean().openapi({
        description:
          "Whether there are more transactions available on the next page",
        example: true,
      }),
    })
    .openapi({
      description: "Pagination metadata for the transactions response",
    }),
  data: z.array(transactionResponseSchema).openapi({
    description: "Array of transactions matching the query criteria",
  }),
});

export const deleteTransactionsSchema = z
  .array(z.string().uuid())
  .max(100)
  .min(1)
  .openapi({
    description: "List of transaction IDs to delete.",
  });

export const deleteTransactionResponseSchema = z.object({
  id: z.string().uuid().openapi({
    description: "Transaction ID (UUID).",
  }),
});

export const deleteTransactionsResponseSchema = z.array(
  deleteTransactionResponseSchema,
);

export const deleteTransactionSchema = z.object({
  id: z
    .string()
    .uuid()
    .openapi({
      description: "Transaction ID (UUID).",
      param: {
        in: "path",
        name: "id",
      },
    }),
});

export const getTransactionByIdSchema = z.object({
  id: z
    .string()
    .uuid()
    .openapi({
      description: "Transaction ID (UUID).",
      param: {
        in: "path",
        name: "id",
      },
    }),
});

export const updateTransactionSchema = z.object({
  id: z
    .string()
    .uuid()
    .openapi({
      description: "Transaction ID (UUID).",
      param: {
        in: "path",
        name: "id",
      },
    }),
  categorySlug: z.string().nullable().optional().openapi({
    description: "Category slug for the transaction.",
  }),
  status: z
    .enum(["pending", "archived", "completed", "posted", "excluded"])
    .nullable()
    .optional()
    .openapi({
      description: "Status of the transaction.",
    }),
  internal: z.boolean().optional().openapi({
    description: "Whether the transaction is internal.",
  }),
  recurring: z.boolean().optional().openapi({
    description: "Whether the transaction is recurring.",
  }),
  frequency: z
    .enum(["weekly", "monthly", "annually", "irregular"])
    .nullable()
    .optional()
    .openapi({
      description: "Recurring frequency of the transaction.",
    }),
  note: z.string().nullable().optional().openapi({
    description: "Note for the transaction.",
  }),
  assignedId: z.string().nullable().optional().openapi({
    description: "Assigned user ID for the transaction.",
  }),
});

export const updateTransactionsSchema = z.object({
  ids: z.array(z.string()).openapi({
    description: "Array of transaction IDs to update.",
  }),
  categorySlug: z.string().nullable().optional().openapi({
    description: "Category slug for the transactions.",
  }),
  status: z
    .enum(["pending", "archived", "completed", "posted", "excluded"])
    .nullable()
    .optional()
    .openapi({
      description: "Status to set for the transactions.",
    }),
  frequency: z
    .enum(["weekly", "monthly", "annually", "irregular"])
    .nullable()
    .optional()
    .openapi({
      description: "Recurring frequency to set for the transactions.",
    }),
  internal: z.boolean().optional().openapi({
    description: "Whether the transactions are internal.",
  }),
  note: z.string().nullable().optional().openapi({
    description: "Note to set for the transactions.",
  }),
  assignedId: z.string().nullable().optional().openapi({
    description: "Assigned user ID for the transactions.",
  }),
  recurring: z.boolean().optional().openapi({
    description: "Whether the transactions are recurring.",
  }),
  tagId: z.string().nullable().optional().openapi({
    description: "Tag ID to set for the transactions.",
  }),
});

export const getSimilarTransactionsSchema = z.object({
  name: z.string().openapi({
    description: "Name of the transaction.",
    param: {
      in: "query",
    },
  }),
  categorySlug: z
    .string()
    .optional()
    .openapi({
      description: "Category slug to filter similar transactions.",
      param: {
        in: "query",
      },
    }),
  frequency: z
    .enum(["weekly", "monthly", "annually", "irregular"])
    .optional()
    .openapi({
      description: "Recurring frequency to filter similar transactions.",
      param: {
        in: "query",
      },
    }),
  transactionId: z.string().uuid().optional().openapi({
    description: "Transaction ID to exclude from results.",
  }),
  minSimilarityScore: z
    .number()
    .min(0.1)
    .max(1.0)
    .optional()
    .default(0.8)
    .openapi({
      description:
        "Minimum similarity score (0.1-1.0) for transactions to be considered similar.",
      param: {
        in: "query",
      },
    }),
});

export const searchTransactionMatchSchema = z.object({
  query: z
    .string()
    .optional()
    .openapi({
      description: "Search query for matching transactions.",
      param: {
        in: "query",
      },
    }),
  inboxId: z
    .string()
    .uuid()
    .optional()
    .openapi({
      description: "Inbox ID to search within.",
      param: {
        in: "query",
      },
    }),
  maxResults: z
    .number()
    .optional()
    .openapi({
      description: "Maximum number of results to return.",
      param: {
        in: "query",
      },
    }),
  minConfidenceScore: z
    .number()
    .optional()
    .openapi({
      description: "Minimum confidence score for matches.",
      param: {
        in: "query",
      },
    }),
  includeAlreadyMatched: z
    .boolean()
    .optional()
    .openapi({
      description: "Whether to include already matched transactions.",
      param: {
        in: "query",
      },
    }),
});

export const createTransactionSchema = z.object({
  name: z.string().openapi({
    description: "Name of the transaction.",
  }),
  amount: z.number().openapi({
    description: "Amount of the transaction.",
  }),
  currency: z.string().openapi({
    description: "Currency of the transaction.",
  }),
  date: z.string().openapi({
    description: "Date of the transaction (ISO 8601).",
  }),
  bankAccountId: z.string().openapi({
    description: "Bank account ID associated with the transaction.",
  }),
  assignedId: z.string().optional().openapi({
    description: "Assigned user ID for the transaction.",
  }),
  categorySlug: z.string().optional().openapi({
    description: "Category slug for the transaction.",
  }),
  note: z.string().optional().openapi({
    description: "Note for the transaction.",
  }),
  internal: z.boolean().optional().openapi({
    description: "Whether the transaction is internal.",
  }),
  attachments: z
    .array(
      z.object({
        path: z.array(z.string()).openapi({
          description: "Path(s) of the attachment file(s).",
        }),
        name: z.string().openapi({
          description: "Name of the attachment file.",
        }),
        size: z.number().openapi({
          description: "Size of the attachment file in bytes.",
        }),
        type: z.string().openapi({
          description: "MIME type of the attachment file.",
        }),
      }),
    )
    .optional()
    .openapi({
      description: "Array of attachments for the transaction.",
    }),
});

export const createTransactionsSchema = z
  .array(createTransactionSchema)
  .max(100)
  .min(1)
  .openapi({
    description: "List of transactions to create.",
  });

export const createTransactionsResponseSchema = z.array(
  transactionResponseSchema,
);
</file>

<file path="apps/api/src/schemas/users.ts">
import { z } from "@hono/zod-openapi";

export const updateUserSchema = z.object({
  fullName: z.string().min(2).max(32).optional().openapi({
    description: "Full name of the user. Must be between 2 and 32 characters",
    example: "Jane Doe",
  }),
  teamId: z.string().optional().openapi({
    description: "Unique identifier of the team the user belongs to",
    example: "team-abc123",
  }),
  email: z.string().email().optional().openapi({
    description: "Email address of the user",
    example: "jane.doe@acme.com",
  }),
  avatarUrl: z
    .string()
    .url()
    .refine((url) => url.includes("midday.ai"), {
      message: "avatarUrl must be a midday.ai domain URL",
    })
    .optional()
    .openapi({
      description:
        "URL to the user's avatar image. Must be hosted on midday.ai domain",
      example: "https://cdn.midday.ai/avatars/jane-doe.jpg",
    }),
  locale: z.string().optional().openapi({
    description:
      "User's preferred locale for internationalization (language and region)",
    example: "en-US",
  }),
  weekStartsOnMonday: z.boolean().optional().openapi({
    description:
      "Whether the user's calendar week starts on Monday (true) or Sunday (false)",
    example: true,
  }),
  timezone: z.string().optional().openapi({
    description: "User's timezone identifier in IANA Time Zone Database format",
    example: "America/New_York",
  }),
  timezoneAutoSync: z.boolean().optional().openapi({
    description: "Whether to automatically sync timezone with browser timezone",
    example: true,
  }),
  timeFormat: z.number().optional().openapi({
    description:
      "User's preferred time format: 12 for 12-hour format, 24 for 24-hour format",
    example: 24,
  }),
  dateFormat: z
    .enum(["dd/MM/yyyy", "MM/dd/yyyy", "yyyy-MM-dd", "dd.MM.yyyy"])
    .optional()
    .openapi({
      description:
        "User's preferred date format. Available options: 'dd/MM/yyyy', 'MM/dd/yyyy', 'yyyy-MM-dd', 'dd.MM.yyyy'",
      example: "yyyy-MM-dd",
      "x-speakeasy-enums": [
        "ddSlashMMSlashyyyy",
        "MMSlashddSlashyyyy",
        "yyyyDashMMDashdd",
        "ddDotMMDotyyyy",
      ],
    }),
});

export const userSchema = z.object({
  id: z.string().uuid().openapi({
    description: "Unique identifier of the user",
    example: "123e4567-e89b-12d3-a456-426614174000",
  }),
  fullName: z.string().openapi({
    description: "Full name of the user",
    example: "Jane Doe",
  }),
  email: z.string().email().openapi({
    description: "Email address of the user",
    example: "jane.doe@acme.com",
  }),
  avatarUrl: z.string().url().nullable().openapi({
    description: "URL to the user's avatar image",
    example: "https://cdn.midday.ai/avatars/jane-doe.jpg",
  }),
  locale: z.string().nullable().openapi({
    description:
      "User's preferred locale for internationalization (language and region)",
    example: "en-US",
  }),
  weekStartsOnMonday: z.boolean().nullable().openapi({
    description:
      "Whether the user's calendar week starts on Monday (true) or Sunday (false)",
    example: true,
  }),
  timezone: z.string().nullable().openapi({
    description: "User's timezone identifier in IANA Time Zone Database format",
    example: "America/New_York",
  }),
  timezoneAutoSync: z.boolean().nullable().openapi({
    description: "Whether to automatically sync timezone with browser timezone",
    example: true,
  }),
  timeFormat: z.number().nullable().openapi({
    description:
      "User's preferred time format: 12 for 12-hour format, 24 for 24-hour format",
    example: 24,
  }),
  dateFormat: z
    .enum(["dd/MM/yyyy", "MM/dd/yyyy", "yyyy-MM-dd", "dd.MM.yyyy"])
    .nullable()
    .openapi({
      description:
        "User's preferred date format. Available options: 'dd/MM/yyyy', 'MM/dd/yyyy', 'yyyy-MM-dd', 'dd.MM.yyyy'",
      example: "yyyy-MM-dd",
      "x-speakeasy-enums": [
        "ddSlashMMSlashyyyy",
        "MMSlashddSlashyyyy",
        "yyyyDashMMDashdd",
        "ddDotMMDotyyyy",
      ],
    }),
  team: z
    .object({
      id: z.string().uuid().openapi({
        description: "Unique identifier of the team",
        example: "123e4567-e89b-12d3-a456-426614174000",
      }),
      name: z.string().openapi({
        description: "Name of the team or organization",
        example: "Acme Corporation",
      }),
      logoUrl: z.string().url().openapi({
        description: "URL to the team's logo image",
        example: "https://cdn.midday.ai/logos/acme-corp.png",
      }),
      plan: z.string().openapi({
        description: "Current subscription plan of the team",
        example: "pro",
      }),
    })
    .nullable()
    .openapi({
      description: "Team information that the user belongs to",
    }),
});
</file>

<file path="apps/api/src/services/resend.ts">
import { Resend } from "resend";

export const resend = new Resend(process.env.RESEND_API_KEY!);
</file>

<file path="apps/api/src/services/supabase.ts">
import type { Database } from "@midday/supabase/types";
import { createClient as createSupabaseClient } from "@supabase/supabase-js";

export async function createClient(accessToken?: string) {
  return createSupabaseClient<Database>(
    process.env.SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_KEY!,
    {
      accessToken() {
        return Promise.resolve(accessToken || "");
      },
    },
  );
}
</file>

<file path="apps/api/src/trpc/middleware/primary-read-after-write.ts">
import type { Session } from "@api/utils/auth";
import { replicationCache } from "@midday/cache/replication-cache";
import type { Database, DatabaseWithPrimary } from "@midday/db/client";

// Database middleware that handles replication lag based on mutation operations
// For mutations: always use primary DB
// For queries: use primary DB if the team recently performed a mutation
export const withPrimaryReadAfterWrite = async <TReturn>(opts: {
  ctx: {
    session?: Session | null;
    teamId?: string | null;
    db: Database;
  };
  type: "query" | "mutation" | "subscription";
  next: (opts: {
    ctx: {
      session?: Session | null;
      teamId?: string | null;
      db: Database;
    };
  }) => Promise<TReturn>;
}) => {
  const { ctx, type, next } = opts;
  const teamId = ctx.teamId;

  if (teamId) {
    // For mutations, always use primary DB and update the team's timestamp
    if (type === "mutation") {
      await replicationCache.set(teamId);

      // Use primary-only mode to maintain interface consistency
      const dbWithPrimary = ctx.db as DatabaseWithPrimary;
      if (dbWithPrimary.usePrimaryOnly) {
        ctx.db = dbWithPrimary.usePrimaryOnly();
      }
      // If usePrimaryOnly doesn't exist, we're already using the primary DB
    }
    // For queries, check if the team recently performed a mutation
    else {
      const timestamp = await replicationCache.get(teamId);
      const now = Date.now();

      // If the timestamp exists and hasn't expired, use primary DB
      if (timestamp && now < timestamp) {
        // Use primary-only mode to maintain interface consistency
        const dbWithPrimary = ctx.db as DatabaseWithPrimary;
        if (dbWithPrimary.usePrimaryOnly) {
          ctx.db = dbWithPrimary.usePrimaryOnly();
        }
        // If usePrimaryOnly doesn't exist, we're already using the primary DB
      }
    }
  } else {
    // When no team ID is present, always use primary DB
    const dbWithPrimary = ctx.db as DatabaseWithPrimary;
    if (dbWithPrimary.usePrimaryOnly) {
      ctx.db = dbWithPrimary.usePrimaryOnly();
    }
    // If usePrimaryOnly doesn't exist, we're already using the primary DB
  }

  const result = await next({ ctx });

  return result;
};
</file>

<file path="apps/api/src/trpc/middleware/team-permission.ts">
import type { Session } from "@api/utils/auth";
import { teamCache } from "@midday/cache/team-cache";
import type { Database } from "@midday/db/client";
import { TRPCError } from "@trpc/server";

export const withTeamPermission = async <TReturn>(opts: {
  ctx: {
    session?: Session | null;
    db: Database;
  };
  next: (opts: {
    ctx: {
      session?: Session | null;
      db: Database;
      teamId: string | null;
    };
  }) => Promise<TReturn>;
}) => {
  const { ctx, next } = opts;

  const userId = ctx.session?.user?.id;

  if (!userId) {
    throw new TRPCError({
      code: "UNAUTHORIZED",
      message: "No permission to access this team",
    });
  }

  const result = await ctx.db.query.users.findFirst({
    with: {
      usersOnTeams: {
        columns: {
          id: true,
          teamId: true,
        },
      },
    },
    where: (users, { eq }) => eq(users.id, userId),
  });

  if (!result) {
    throw new TRPCError({
      code: "NOT_FOUND",
      message: "User not found",
    });
  }

  const teamId = result.teamId;

  // If teamId is null, user has no team assigned but this is now allowed
  if (teamId !== null) {
    const cacheKey = `user:${userId}:team:${teamId}`;
    let hasAccess = await teamCache.get(cacheKey);

    if (hasAccess === undefined) {
      hasAccess = result.usersOnTeams.some(
        (membership) => membership.teamId === teamId,
      );

      await teamCache.set(cacheKey, hasAccess);
    }

    if (!hasAccess) {
      throw new TRPCError({
        code: "FORBIDDEN",
        message: "No permission to access this team",
      });
    }
  }

  return next({
    ctx: {
      session: ctx.session,
      teamId,
      db: ctx.db,
    },
  });
};
</file>

<file path="apps/api/src/trpc/routers/_app.ts">
import type { inferRouterInputs, inferRouterOutputs } from "@trpc/server";
import { createTRPCRouter } from "../init";
import { apiKeysRouter } from "./api-keys";
import { appsRouter } from "./apps";
import { bankAccountsRouter } from "./bank-accounts";
import { bankConnectionsRouter } from "./bank-connections";
import { billingRouter } from "./billing";
import { customersRouter } from "./customers";
import { documentTagAssignmentsRouter } from "./document-tag-assignments";
import { documentTagsRouter } from "./document-tags";
import { documentsRouter } from "./documents";
import { inboxRouter } from "./inbox";
import { inboxAccountsRouter } from "./inbox-accounts";
import { institutionsRouter } from "./institutions";
import { invoiceRouter } from "./invoice";
import { invoiceTemplateRouter } from "./invoice-template";
import { notificationSettingsRouter } from "./notification-settings";
import { notificationsRouter } from "./notifications";
import { oauthApplicationsRouter } from "./oauth-applications";
import { reportsRouter } from "./reports";
import { searchRouter } from "./search";
import { shortLinksRouter } from "./short-links";
import { tagsRouter } from "./tags";
import { teamRouter } from "./team";
import { trackerEntriesRouter } from "./tracker-entries";
import { trackerProjectsRouter } from "./tracker-projects";
import { transactionAttachmentsRouter } from "./transaction-attachments";
import { transactionCategoriesRouter } from "./transaction-categories";
import { transactionTagsRouter } from "./transaction-tags";
import { transactionsRouter } from "./transactions";
import { userRouter } from "./user";

export const appRouter = createTRPCRouter({
  notifications: notificationsRouter,
  notificationSettings: notificationSettingsRouter,
  apps: appsRouter,
  bankAccounts: bankAccountsRouter,
  bankConnections: bankConnectionsRouter,
  customers: customersRouter,
  documents: documentsRouter,
  documentTagAssignments: documentTagAssignmentsRouter,
  documentTags: documentTagsRouter,
  inbox: inboxRouter,
  inboxAccounts: inboxAccountsRouter,
  institutions: institutionsRouter,
  invoice: invoiceRouter,
  invoiceTemplate: invoiceTemplateRouter,
  reports: reportsRouter,
  oauthApplications: oauthApplicationsRouter,
  billing: billingRouter,
  tags: tagsRouter,
  team: teamRouter,
  trackerEntries: trackerEntriesRouter,
  trackerProjects: trackerProjectsRouter,
  transactionAttachments: transactionAttachmentsRouter,
  transactionCategories: transactionCategoriesRouter,
  transactions: transactionsRouter,
  transactionTags: transactionTagsRouter,
  user: userRouter,
  search: searchRouter,
  shortLinks: shortLinksRouter,
  apiKeys: apiKeysRouter,
});

// export type definition of API
export type AppRouter = typeof appRouter;
export type RouterOutputs = inferRouterOutputs<AppRouter>;
export type RouterInputs = inferRouterInputs<AppRouter>;
</file>

<file path="apps/api/src/trpc/routers/api-keys.ts">
import { deleteApiKeySchema, upsertApiKeySchema } from "@api/schemas/api-keys";
import { resend } from "@api/services/resend";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import { apiKeyCache } from "@midday/cache/api-key-cache";
import {
  deleteApiKey,
  getApiKeysByTeam,
  upsertApiKey,
} from "@midday/db/queries";
import { ApiKeyCreatedEmail } from "@midday/email/emails/api-key-created";
import { logger } from "@midday/logger";

export const apiKeysRouter = createTRPCRouter({
  get: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    return getApiKeysByTeam(db, teamId!);
  }),

  upsert: protectedProcedure
    .input(upsertApiKeySchema)
    .mutation(async ({ ctx: { db, teamId, session, geo }, input }) => {
      const { data, key, keyHash } = await upsertApiKey(db, {
        teamId: teamId!,
        userId: session.user.id,
        ...input,
      });

      // Invalidate cache if this was an update (has keyHash)
      if (keyHash) {
        await apiKeyCache.delete(keyHash);
      }

      if (data) {
        try {
          // We don't need to await this, it will be sent in the background
          resend.emails.send({
            from: "Middaybot <middaybot@midday.ai>",
            to: session.user.email!,
            subject: "New API Key Created",
            react: ApiKeyCreatedEmail({
              fullName: session.user.full_name!,
              keyName: input.name,
              createdAt: data.createdAt,
              email: session.user.email!,
              ip: geo.ip!,
            }),
          });
        } catch (error) {
          logger.error(error);
        }
      }

      return {
        key,
        data,
      };
    }),

  delete: protectedProcedure
    .input(deleteApiKeySchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      const keyHash = await deleteApiKey(db, {
        teamId: teamId!,
        ...input,
      });

      // Invalidate cache if key was deleted
      if (keyHash) {
        await apiKeyCache.delete(keyHash);
      }

      return keyHash;
    }),
});
</file>

<file path="apps/api/src/trpc/routers/apps.ts">
import {
  disconnectAppSchema,
  updateAppSettingsSchema,
} from "@api/schemas/apps";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import { disconnectApp, getApps, updateAppSettings } from "@midday/db/queries";

export const appsRouter = createTRPCRouter({
  get: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    return getApps(db, teamId!);
  }),

  disconnect: protectedProcedure
    .input(disconnectAppSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      const { appId } = input;

      return disconnectApp(db, { appId, teamId: teamId! });
    }),

  update: protectedProcedure
    .input(updateAppSettingsSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      const { appId, option } = input;

      return updateAppSettings(db, {
        appId,
        teamId: teamId!,
        option,
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/bank-accounts.ts">
import {
  createBankAccountSchema,
  deleteBankAccountSchema,
  getBankAccountsSchema,
  updateBankAccountSchema,
} from "@api/schemas/bank-accounts";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  createBankAccount,
  deleteBankAccount,
  getBankAccounts,
  getBankAccountsBalances,
  getBankAccountsCurrencies,
  updateBankAccount,
} from "@midday/db/queries";

export const bankAccountsRouter = createTRPCRouter({
  get: protectedProcedure
    .input(getBankAccountsSchema.optional())
    .query(async ({ input, ctx: { db, teamId } }) => {
      return getBankAccounts(db, {
        teamId: teamId!,
        enabled: input?.enabled,
        manual: input?.manual,
      });
    }),

  currencies: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    return getBankAccountsCurrencies(db, teamId!);
  }),

  balances: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    return getBankAccountsBalances(db, teamId!);
  }),

  delete: protectedProcedure
    .input(deleteBankAccountSchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      return deleteBankAccount(db, {
        id: input.id,
        teamId: teamId!,
      });
    }),

  update: protectedProcedure
    .input(updateBankAccountSchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      return updateBankAccount(db, {
        ...input,
        id: input.id!,
        teamId: teamId!,
      });
    }),

  create: protectedProcedure
    .input(createBankAccountSchema)
    .mutation(async ({ input, ctx: { db, teamId, session } }) => {
      return createBankAccount(db, {
        ...input,
        teamId: teamId!,
        userId: session.user.id,
        manual: input.manual,
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/bank-connections.ts">
import {
  createBankConnectionSchema,
  deleteBankConnectionSchema,
  getBankConnectionsSchema,
} from "@api/schemas/bank-connections";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  createBankConnection,
  deleteBankConnection,
  getBankConnections,
} from "@midday/db/queries";
import type {
  DeleteConnectionPayload,
  InitialBankSetupPayload,
} from "@midday/jobs/schema";
import { tasks } from "@trigger.dev/sdk";
import { TRPCError } from "@trpc/server";

export const bankConnectionsRouter = createTRPCRouter({
  get: protectedProcedure
    .input(getBankConnectionsSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getBankConnections(db, {
        teamId: teamId!,
        enabled: input?.enabled,
      });
    }),

  create: protectedProcedure
    .input(createBankConnectionSchema)
    .mutation(async ({ input, ctx: { db, teamId, session } }) => {
      const data = await createBankConnection(db, {
        ...input,
        teamId: teamId!,
        userId: session.user.id,
      });

      if (!data) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Bank connection not found",
        });
      }

      const event = await tasks.trigger("initial-bank-setup", {
        connectionId: data.id,
        teamId: teamId!,
      } satisfies InitialBankSetupPayload);

      return event;
    }),

  delete: protectedProcedure
    .input(deleteBankConnectionSchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      const data = await deleteBankConnection(db, {
        id: input.id,
        teamId: teamId!,
      });

      if (!data) {
        throw new Error("Bank connection not found");
      }

      await tasks.trigger("delete-connection", {
        referenceId: data.referenceId,
        provider: data.provider!,
        accessToken: data.accessToken,
      } satisfies DeleteConnectionPayload);

      return data;
    }),
});
</file>

<file path="apps/api/src/trpc/routers/billing.ts">
import { getBillingOrdersSchema } from "@api/schemas/billing";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import { api } from "@api/utils/polar";
import { z } from "zod";

export const billingRouter = createTRPCRouter({
  orders: protectedProcedure
    .input(getBillingOrdersSchema)
    .query(async ({ input, ctx: { teamId } }) => {
      try {
        const customer = await api.customers.getExternal({
          externalId: teamId!,
        });

        const ordersResult = await api.orders.list({
          customerId: customer.id,
          page: input.cursor ? Number(input.cursor) : 1,
          limit: input.pageSize,
        });

        const orders = ordersResult.result.items;
        const pagination = ordersResult.result.pagination;

        // Filter orders to only include those where metadata.teamId matches teamId
        const filteredOrders = orders.filter((order) => {
          const organizationId = order.metadata?.teamId;
          return organizationId === teamId;
        });

        return {
          data: filteredOrders.map((order) => ({
            id: order.id,
            createdAt: order.createdAt,
            amount: {
              amount: order.totalAmount,
              currency: order.currency,
            },
            status: order.status,
            product: {
              name: order.product.name,
            },
            invoiceId: order.isInvoiceGenerated ? order.id : null,
          })),
          meta: {
            hasNextPage:
              (input.cursor ? Number(input.cursor) : 1) < pagination.maxPage,
            cursor:
              (input.cursor ? Number(input.cursor) : 1) < pagination.maxPage
                ? ((input.cursor ? Number(input.cursor) : 1) + 1).toString()
                : undefined,
          },
        };
      } catch {
        return {
          data: [],
          meta: {
            hasNextPage: false,
            cursor: undefined,
          },
        };
      }
    }),

  getInvoice: protectedProcedure
    .input(z.string())
    .mutation(async ({ input: orderId, ctx: { teamId } }) => {
      try {
        const order = await api.orders.get({
          id: orderId,
        });

        // Verify the order belongs to the team's customer
        if (order.customer.externalId !== teamId) {
          throw new Error("Order not found or not authorized");
        }

        // If invoice doesn't exist, generate it
        if (!order.isInvoiceGenerated) {
          await api.orders.generateInvoice({
            id: orderId,
          });

          // Return status indicating generation is in progress
          return {
            status: "generating",
          };
        }

        // Try to get the invoice
        try {
          const invoice = await api.orders.invoice({
            id: orderId,
          });

          return {
            status: "ready",
            downloadUrl: invoice.url,
          };
        } catch (invoiceError) {
          // Invoice might still be generating
          return {
            status: "generating",
          };
        }
      } catch (error) {
        console.error("Failed to get invoice download URL:", error);
        throw new Error(
          error instanceof Error ? error.message : "Failed to download invoice",
        );
      }
    }),

  checkInvoiceStatus: protectedProcedure
    .input(z.string())
    .query(async ({ input: orderId, ctx: { teamId } }) => {
      try {
        const order = await api.orders.get({
          id: orderId,
        });

        // Verify the order belongs to the team's customer
        if (order.customer.externalId !== teamId) {
          throw new Error("Order not found or not authorized");
        }

        if (!order.isInvoiceGenerated) {
          return {
            status: "not_generated",
          };
        }

        try {
          const invoice = await api.orders.invoice({
            id: orderId,
          });

          return {
            status: "ready",
            downloadUrl: invoice.url,
          };
        } catch (invoiceError) {
          return {
            status: "generating",
          };
        }
      } catch (error) {
        console.error("Failed to check invoice status:", error);
        throw new Error(
          error instanceof Error
            ? error.message
            : "Failed to check invoice status",
        );
      }
    }),
});
</file>

<file path="apps/api/src/trpc/routers/customers.ts">
import {
  deleteCustomerSchema,
  getCustomerByIdSchema,
  getCustomersSchema,
  upsertCustomerSchema,
} from "@api/schemas/customers";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  deleteCustomer,
  getCustomerById,
  getCustomers,
  upsertCustomer,
} from "@midday/db/queries";

export const customersRouter = createTRPCRouter({
  get: protectedProcedure
    .input(getCustomersSchema.optional())
    .query(async ({ ctx: { teamId, db }, input }) => {
      return getCustomers(db, {
        teamId: teamId!,
        ...input,
      });
    }),

  getById: protectedProcedure
    .input(getCustomerByIdSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getCustomerById(db, {
        id: input.id,
        teamId: teamId!,
      });
    }),

  delete: protectedProcedure
    .input(deleteCustomerSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return deleteCustomer(db, {
        id: input.id,
        teamId: teamId!,
      });
    }),

  upsert: protectedProcedure
    .input(upsertCustomerSchema)
    .mutation(async ({ ctx: { db, teamId, session }, input }) => {
      return upsertCustomer(db, {
        ...input,
        teamId: teamId!,
        userId: session.user.id,
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/document-tag-assignments.ts">
import {
  createDocumentTagAssignmentSchema,
  deleteDocumentTagAssignmentSchema,
} from "@api/schemas/document-tag-assignments";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  createDocumentTagAssignment,
  deleteDocumentTagAssignment,
} from "@midday/db/queries";

export const documentTagAssignmentsRouter = createTRPCRouter({
  create: protectedProcedure
    .input(createDocumentTagAssignmentSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return createDocumentTagAssignment(db, {
        documentId: input.documentId,
        tagId: input.tagId,
        teamId: teamId!,
      });
    }),

  delete: protectedProcedure
    .input(deleteDocumentTagAssignmentSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return deleteDocumentTagAssignment(db, {
        documentId: input.documentId,
        tagId: input.tagId,
        teamId: teamId!,
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/document-tags.ts">
import {
  createDocumentTag,
  createDocumentTagEmbedding,
  deleteDocumentTag,
  getDocumentTags,
} from "@midday/db/queries";

import {
  createDocumentTagSchema,
  deleteDocumentTagSchema,
} from "@api/schemas/document-tags";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import { Embed } from "@midday/documents/embed";
import slugify from "@sindresorhus/slugify";

export const documentTagsRouter = createTRPCRouter({
  get: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    return getDocumentTags(db, teamId!);
  }),

  create: protectedProcedure
    .input(createDocumentTagSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      const data = await createDocumentTag(db, {
        teamId: teamId!,
        name: input.name,
        slug: slugify(input.name),
      });

      // If a tag is created, we need to embed it
      if (data) {
        const embedService = new Embed();
        const { embedding, model } = await embedService.embed(input.name);

        await createDocumentTagEmbedding(db, {
          slug: data.slug,
          name: input.name,
          embedding: JSON.stringify(embedding),
          model,
        });
      }

      return data;
    }),

  delete: protectedProcedure
    .input(deleteDocumentTagSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return deleteDocumentTag(db, {
        id: input.id,
        teamId: teamId!,
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/documents.ts">
import {
  deleteDocumentSchema,
  getDocumentSchema,
  getDocumentsSchema,
  getRelatedDocumentsSchema,
  processDocumentSchema,
  signedUrlSchema,
  signedUrlsSchema,
} from "@api/schemas/documents";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  deleteDocument,
  getDocumentById,
  getDocuments,
  getRelatedDocuments,
  updateDocuments,
} from "@midday/db/queries";
import { isMimeTypeSupportedForProcessing } from "@midday/documents/utils";
import type { ProcessDocumentPayload } from "@midday/jobs/schema";
import { remove, signedUrl } from "@midday/supabase/storage";
import { tasks } from "@trigger.dev/sdk";
import { TRPCError } from "@trpc/server";

export const documentsRouter = createTRPCRouter({
  get: protectedProcedure
    .input(getDocumentsSchema)
    .query(async ({ input, ctx: { db, teamId } }) => {
      return getDocuments(db, {
        teamId: teamId!,
        ...input,
      });
    }),

  getById: protectedProcedure
    .input(getDocumentSchema)
    .query(async ({ input, ctx: { db, teamId } }) => {
      return getDocumentById(db, {
        id: input.id,
        filePath: input.filePath,
        teamId: teamId!,
      });
    }),

  getRelatedDocuments: protectedProcedure
    .input(getRelatedDocumentsSchema)
    .query(async ({ input, ctx: { db, teamId } }) => {
      return getRelatedDocuments(db, {
        id: input.id,
        pageSize: input.pageSize,
        teamId: teamId!,
      });
    }),

  delete: protectedProcedure
    .input(deleteDocumentSchema)
    .mutation(async ({ input, ctx: { db, supabase, teamId } }) => {
      const document = await deleteDocument(db, {
        id: input.id,
        teamId: teamId!,
      });

      if (!document || !document.pathTokens) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Document not found",
        });
      }

      // Delete from storage
      await remove(supabase, {
        bucket: "vault",
        path: document.pathTokens,
      });

      return document;
    }),

  processDocument: protectedProcedure
    .input(processDocumentSchema)
    .mutation(async ({ ctx: { teamId, db }, input }) => {
      const supportedDocuments = input.filter((item) =>
        isMimeTypeSupportedForProcessing(item.mimetype),
      );

      const unsupportedDocuments = input.filter(
        (item) => !isMimeTypeSupportedForProcessing(item.mimetype),
      );

      if (unsupportedDocuments.length > 0) {
        const unsupportedNames = unsupportedDocuments.map((doc) =>
          doc.filePath.join("/"),
        );

        await updateDocuments(db, {
          ids: unsupportedNames,
          teamId: teamId!,
          processingStatus: "completed",
        });
      }

      if (supportedDocuments.length === 0) {
        return;
      }

      // Trigger processing task only for supported documents
      return tasks.batchTrigger(
        "process-document",
        supportedDocuments.map(
          (item) =>
            ({
              payload: {
                filePath: item.filePath,
                mimetype: item.mimetype,
                teamId: teamId!,
              },
            }) as { payload: ProcessDocumentPayload },
        ),
      );
    }),

  signedUrl: protectedProcedure
    .input(signedUrlSchema)
    .mutation(async ({ input, ctx: { supabase } }) => {
      const { data } = await signedUrl(supabase, {
        bucket: "vault",
        path: input.filePath,
        expireIn: input.expireIn,
      });

      return data;
    }),

  signedUrls: protectedProcedure
    .input(signedUrlsSchema)
    .mutation(async ({ input, ctx: { supabase } }) => {
      const signedUrls = [];

      for (const filePath of input) {
        const { data } = await signedUrl(supabase, {
          bucket: "vault",
          path: filePath,
          expireIn: 60, // 1 Minute
        });

        if (data?.signedUrl) {
          signedUrls.push(data.signedUrl);
        }
      }

      return signedUrls ?? [];
    }),
});
</file>

<file path="apps/api/src/trpc/routers/inbox-accounts.ts">
import {
  connectInboxAccountSchema,
  deleteInboxAccountSchema,
  exchangeCodeForAccountSchema,
  syncInboxAccountSchema,
} from "@api/schemas/inbox-accounts";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import { deleteInboxAccount, getInboxAccounts } from "@midday/db/queries";
import { InboxConnector } from "@midday/inbox/connector";
import { schedules, tasks } from "@trigger.dev/sdk";
import { TRPCError } from "@trpc/server";

export const inboxAccountsRouter = createTRPCRouter({
  get: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    return getInboxAccounts(db, teamId!);
  }),

  connect: protectedProcedure
    .input(connectInboxAccountSchema)
    .mutation(async ({ ctx: { db }, input }) => {
      try {
        const connector = new InboxConnector(input.provider, db);

        return connector.connect();
      } catch (error) {
        console.error(error);
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to connect to inbox account",
        });
      }
    }),

  exchangeCodeForAccount: protectedProcedure
    .input(exchangeCodeForAccountSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      try {
        const connector = new InboxConnector(input.provider, db);

        const account = await connector.exchangeCodeForAccount({
          code: input.code,
          teamId: teamId!,
        });

        return account;
      } catch (error) {
        console.error(error);
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to exchange code for account",
        });
      }
    }),

  delete: protectedProcedure
    .input(deleteInboxAccountSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      const data = await deleteInboxAccount(db, {
        id: input.id,
        teamId: teamId!,
      });

      if (data?.scheduleId) {
        await schedules.del(data.scheduleId);
      }

      return data;
    }),

  sync: protectedProcedure
    .input(syncInboxAccountSchema)
    .mutation(async ({ input }) => {
      const event = await tasks.trigger("sync-inbox-account", {
        id: input.id,
        manualSync: input.manualSync || false,
      });

      return event;
    }),
});
</file>

<file path="apps/api/src/trpc/routers/inbox.ts">
import {
  confirmMatchSchema,
  createInboxItemSchema,
  declineMatchSchema,
  deleteInboxSchema,
  getInboxByIdSchema,
  getInboxByStatusSchema,
  getInboxSchema,
  matchTransactionSchema,
  processAttachmentsSchema,
  retryMatchingSchema,
  searchInboxSchema,
  unmatchTransactionSchema,
  updateInboxSchema,
} from "@api/schemas/inbox";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  confirmSuggestedMatch,
  createInbox,
  declineSuggestedMatch,
  deleteInbox,
  deleteInboxEmbedding,
  getInbox,
  getInboxById,
  getInboxByStatus,
  getInboxSearch,
  matchTransaction,
  unmatchTransaction,
  updateInbox,
} from "@midday/db/queries";
import type { ProcessAttachmentPayload } from "@midday/jobs/schema";
import { tasks } from "@trigger.dev/sdk";

export const inboxRouter = createTRPCRouter({
  get: protectedProcedure
    .input(getInboxSchema.optional())
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getInbox(db, {
        teamId: teamId!,
        ...input,
      });
    }),

  getById: protectedProcedure
    .input(getInboxByIdSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getInboxById(db, {
        id: input.id,
        teamId: teamId!,
      });
    }),

  delete: protectedProcedure
    .input(deleteInboxSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      await Promise.all([
        deleteInboxEmbedding(db, {
          inboxId: input.id,
          teamId: teamId!,
        }),
        deleteInbox(db, {
          id: input.id,
          teamId: teamId!,
        }),
      ]);
    }),

  create: protectedProcedure
    .input(createInboxItemSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return createInbox(db, {
        displayName: input.filename,
        teamId: teamId!,
        filePath: input.filePath,
        fileName: input.filename,
        contentType: input.mimetype,
        size: input.size,
        status: "processing",
      });
    }),

  processAttachments: protectedProcedure
    .input(processAttachmentsSchema)
    .mutation(async ({ ctx: { teamId }, input }) => {
      const batchResult = await tasks.batchTrigger(
        "process-attachment",
        input.map((item) => ({
          payload: {
            filePath: item.filePath,
            mimetype: item.mimetype,
            size: item.size,
            teamId: teamId!,
          },
        })) as { payload: ProcessAttachmentPayload }[],
      );

      // Send notification for user uploads
      await tasks.trigger("notification", {
        type: "inbox_new",
        teamId: teamId!,
        totalCount: input.length,
        inboxType: "upload",
      });

      return batchResult;
    }),

  search: protectedProcedure
    .input(searchInboxSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      const { q, transactionId, limit = 10 } = input;

      return getInboxSearch(db, {
        teamId: teamId!,
        q,
        transactionId,
        limit,
      });
    }),

  update: protectedProcedure
    .input(updateInboxSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return updateInbox(db, { ...input, teamId: teamId! });
    }),

  matchTransaction: protectedProcedure
    .input(matchTransactionSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return matchTransaction(db, { ...input, teamId: teamId! });
    }),

  unmatchTransaction: protectedProcedure
    .input(unmatchTransactionSchema)
    .mutation(async ({ ctx: { db, teamId, session }, input }) => {
      return unmatchTransaction(db, {
        id: input.id,
        teamId: teamId!,
        userId: session.user.id,
      });
    }),

  // Get inbox items by status
  getByStatus: protectedProcedure
    .input(getInboxByStatusSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getInboxByStatus(db, {
        teamId: teamId!,
        status: input.status,
      });
    }),

  // Confirm a match suggestion
  confirmMatch: protectedProcedure
    .input(confirmMatchSchema)
    .mutation(async ({ ctx: { db, teamId, session }, input }) => {
      return confirmSuggestedMatch(db, {
        teamId: teamId!,
        suggestionId: input.suggestionId,
        inboxId: input.inboxId,
        transactionId: input.transactionId,
        userId: session.user.id,
      });
    }),

  // Decline a match suggestion
  declineMatch: protectedProcedure
    .input(declineMatchSchema)
    .mutation(async ({ ctx: { db, session, teamId }, input }) => {
      return declineSuggestedMatch(db, {
        suggestionId: input.suggestionId,
        inboxId: input.inboxId,
        userId: session.user.id,
        teamId: teamId!,
      });
    }),

  // Retry matching for an inbox item
  retryMatching: protectedProcedure
    .input(retryMatchingSchema)
    .mutation(async ({ ctx: { teamId }, input }) => {
      const result = await tasks.trigger("batch-process-matching", {
        teamId: teamId!,
        inboxIds: [input.id],
      });

      return { jobId: result.id };
    }),
});
</file>

<file path="apps/api/src/trpc/routers/institutions.ts">
import {
  getAccountsSchema,
  getInstitutionsSchema,
  updateUsageSchema,
} from "@api/schemas/institutions";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import { client } from "@midday/engine-client";

export const institutionsRouter = createTRPCRouter({
  get: protectedProcedure
    .input(getInstitutionsSchema)
    .query(async ({ input }) => {
      const institutionsResponse = await client.institutions.$get({
        query: input,
      });

      if (!institutionsResponse.ok) {
        throw new Error("Failed to get institutions");
      }

      const { data } = await institutionsResponse.json();

      return data.map((institution) => ({
        ...institution,
        availableHistory: institution.available_history,
        maximumConsentValidity: institution.maximum_consent_validity,
        type: institution.type,
        provider: institution.provider!,
      }));
    }),

  accounts: protectedProcedure
    .input(getAccountsSchema)
    .query(async ({ input }) => {
      const accountsResponse = await client.accounts.$get({
        query: input,
      });

      if (!accountsResponse.ok) {
        throw new Error("Failed to get accounts");
      }

      const { data } = await accountsResponse.json();

      return data.sort((a, b) => b.balance.amount - a.balance.amount);
    }),

  updateUsage: protectedProcedure
    .input(updateUsageSchema)
    .mutation(async ({ input }) => {
      const usageResponse = await client.institutions[":id"].usage.$put({
        param: input,
      });

      if (!usageResponse.ok) {
        throw new Error("Failed to update institution usage");
      }

      return usageResponse.json();
    }),
});
</file>

<file path="apps/api/src/trpc/routers/invoice-template.ts">
import { upsertInvoiceTemplateSchema } from "@api/schemas/invoice";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import { parseInputValue } from "@api/utils/parse";
import { updateInvoiceTemplate } from "@midday/db/queries";

export const invoiceTemplateRouter = createTRPCRouter({
  upsert: protectedProcedure
    .input(upsertInvoiceTemplateSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return updateInvoiceTemplate(db, {
        ...input,
        teamId: teamId!,
        fromDetails: parseInputValue(input.fromDetails),
        paymentDetails: parseInputValue(input.paymentDetails),
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/invoice.ts">
import {
  cancelScheduledInvoiceSchema,
  createInvoiceSchema,
  deleteInvoiceSchema,
  draftInvoiceSchema,
  duplicateInvoiceSchema,
  getInvoiceByIdSchema,
  getInvoiceByTokenSchema,
  getInvoicesSchema,
  invoiceSummarySchema,
  remindInvoiceSchema,
  searchInvoiceNumberSchema,
  updateInvoiceSchema,
  updateScheduledInvoiceSchema,
} from "@api/schemas/invoice";
import {
  createTRPCRouter,
  protectedProcedure,
  publicProcedure,
} from "@api/trpc/init";
import { parseInputValue } from "@api/utils/parse";
import { UTCDate } from "@date-fns/utc";
import {
  deleteInvoice,
  draftInvoice,
  duplicateInvoice,
  getAverageDaysToPayment,
  getAverageInvoiceSize,
  getCustomerById,
  getInactiveClientsCount,
  getInvoiceById,
  getInvoiceSummary,
  getInvoiceTemplate,
  getInvoices,
  getMostActiveClient,
  getNewCustomersCount,
  getNextInvoiceNumber,
  getPaymentStatus,
  getTeamById,
  getTopRevenueClient,
  getTrackerProjectById,
  getTrackerRecordsByRange,
  getUserById,
  searchInvoiceNumber,
  updateInvoice,
} from "@midday/db/queries";
import { verify } from "@midday/invoice/token";
import { transformCustomerToContent } from "@midday/invoice/utils";
import type {
  GenerateInvoicePayload,
  SendInvoiceReminderPayload,
} from "@midday/jobs/schema";
import { runs, tasks } from "@trigger.dev/sdk";
import { TRPCError } from "@trpc/server";
import { addMonths, format, parseISO } from "date-fns";
import { v4 as uuidv4 } from "uuid";
import { z } from "zod";

const defaultTemplate = {
  title: "Invoice",
  customerLabel: "To",
  fromLabel: "From",
  invoiceNoLabel: "Invoice No",
  issueDateLabel: "Issue Date",
  dueDateLabel: "Due Date",
  descriptionLabel: "Description",
  priceLabel: "Price",
  quantityLabel: "Quantity",
  totalLabel: "Total",
  totalSummaryLabel: "Total",
  subtotalLabel: "Subtotal",
  vatLabel: "VAT",
  taxLabel: "Tax",
  paymentLabel: "Payment Details",
  paymentDetails: undefined,
  noteLabel: "Note",
  logoUrl: undefined,
  currency: "USD",
  fromDetails: undefined,
  size: "a4",
  includeVat: true,
  includeTax: true,
  discountLabel: "Discount",
  includeDiscount: false,
  includeUnits: false,
  includeDecimals: false,
  includePdf: false,
  sendCopy: false,
  includeQr: true,
  dateFormat: "dd/MM/yyyy",
  taxRate: 0,
  vatRate: 0,
  deliveryType: "create",
  timezone: undefined,
  locale: undefined,
};

export const invoiceRouter = createTRPCRouter({
  get: protectedProcedure
    .input(getInvoicesSchema.optional())
    .query(async ({ input, ctx: { db, teamId } }) => {
      return getInvoices(db, {
        teamId: teamId!,
        ...input,
      });
    }),

  getById: protectedProcedure
    .input(getInvoiceByIdSchema)
    .query(async ({ input, ctx: { db, teamId } }) => {
      return getInvoiceById(db, {
        id: input.id,
        teamId: teamId!,
      });
    }),

  getInvoiceByToken: publicProcedure
    .input(getInvoiceByTokenSchema)
    .query(async ({ input, ctx: { db } }) => {
      const { id } = (await verify(decodeURIComponent(input.token))) as {
        id: string;
      };

      if (!id) {
        throw new TRPCError({ code: "NOT_FOUND" });
      }

      return getInvoiceById(db, {
        id,
      });
    }),

  paymentStatus: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    return getPaymentStatus(db, teamId!);
  }),

  searchInvoiceNumber: protectedProcedure
    .input(searchInvoiceNumberSchema)
    .query(async ({ input, ctx: { db, teamId } }) => {
      return searchInvoiceNumber(db, {
        teamId: teamId!,
        query: input.query,
      });
    }),

  invoiceSummary: protectedProcedure
    .input(invoiceSummarySchema.optional())
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getInvoiceSummary(db, {
        teamId: teamId!,
        status: input?.status,
      });
    }),

  createFromTracker: protectedProcedure
    .input(
      z.object({
        projectId: z.string().uuid(),
        dateFrom: z.string(),
        dateTo: z.string(),
      }),
    )
    .mutation(async ({ ctx: { db, teamId, session }, input }) => {
      const { projectId, dateFrom, dateTo } = input;

      // Get project data and tracker entries
      const [projectData, trackerData] = await Promise.all([
        getTrackerProjectById(db, { id: projectId, teamId: teamId! }),
        getTrackerRecordsByRange(db, {
          teamId: teamId!,
          projectId,
          from: dateFrom,
          to: dateTo,
        }),
      ]);

      if (!projectData) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "PROJECT_NOT_FOUND",
        });
      }

      // Check if project is billable
      if (!projectData.billable) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "PROJECT_NOT_BILLABLE",
        });
      }

      // Check if project has a rate
      if (!projectData.rate || projectData.rate <= 0) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "PROJECT_NO_RATE",
        });
      }

      // Calculate total hours from tracker entries
      const allEntries = Object.values(trackerData.result || {}).flat();
      const totalDuration = allEntries.reduce(
        (sum, entry) => sum + (entry.duration || 0),
        0,
      );
      const totalHours = Math.round((totalDuration / 3600) * 100) / 100;

      if (totalHours === 0) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "NO_TRACKED_HOURS",
        });
      }

      // Get default invoice settings and customer details
      const [nextInvoiceNumber, template, team, fullCustomer, user] =
        await Promise.all([
          getNextInvoiceNumber(db, teamId!),
          getInvoiceTemplate(db, teamId!),
          getTeamById(db, teamId!),
          projectData.customerId
            ? getCustomerById(db, {
                id: projectData.customerId,
                teamId: teamId!,
              })
            : null,
          getUserById(db, session?.user.id!),
        ]);

      const invoiceId = uuidv4();
      const currency = projectData.currency || team?.baseCurrency || "USD";
      const amount = totalHours * Number(projectData.rate);

      // Get user's preferred date format
      const userDateFormat =
        template?.dateFormat ?? user?.dateFormat ?? defaultTemplate.dateFormat;

      // Format the date range for the line item description
      // Use parseISO to avoid timezone shifts when parsing date strings
      const formattedDateFrom = format(parseISO(dateFrom), userDateFormat);
      const formattedDateTo = format(parseISO(dateTo), userDateFormat);
      const dateRangeDescription = `${projectData.name} (${formattedDateFrom} - ${formattedDateTo})`;

      // Create draft invoice with tracker data
      const templateData = {
        ...defaultTemplate,
        currency: currency.toUpperCase(),
        ...(template
          ? Object.fromEntries(
              Object.entries(template).map(([key, value]) => [
                key,
                value === null ? undefined : value,
              ]),
            )
          : {}),
        size: (template?.size === "a4" || template?.size === "letter"
          ? template.size
          : defaultTemplate.size) as "a4" | "letter",
        deliveryType: (template?.deliveryType === "create" ||
        template?.deliveryType === "create_and_send"
          ? template.deliveryType
          : defaultTemplate.deliveryType) as
          | "create"
          | "create_and_send"
          | undefined,
      };

      const invoiceData = {
        id: invoiceId,
        teamId: teamId!,
        userId: session?.user.id!,
        customerId: projectData.customerId,
        customerName: fullCustomer?.name,
        invoiceNumber: nextInvoiceNumber,
        currency: currency.toUpperCase(),
        amount,
        lineItems: [
          {
            name: dateRangeDescription,
            quantity: totalHours,
            price: Number(projectData.rate),
            vat: 0,
          },
        ],
        issueDate: new Date().toISOString(),
        dueDate: addMonths(new Date(), 1).toISOString(),
        template: templateData,
        fromDetails: (template?.fromDetails || null) as string | null,
        paymentDetails: (template?.paymentDetails || null) as string | null,
        customerDetails: fullCustomer
          ? JSON.stringify(transformCustomerToContent(fullCustomer))
          : null,
        noteDetails: null,
        topBlock: null,
        bottomBlock: null,
        vat: null,
        tax: null,
        discount: null,
        subtotal: null,
      };

      return draftInvoice(db, invoiceData);
    }),

  defaultSettings: protectedProcedure.query(
    async ({ ctx: { db, teamId, session, geo } }) => {
      // Fetch invoice number, template, and team details concurrently
      const [nextInvoiceNumber, template, team, user] = await Promise.all([
        getNextInvoiceNumber(db, teamId!),
        getInvoiceTemplate(db, teamId!),
        getTeamById(db, teamId!),
        getUserById(db, session?.user.id!),
      ]);

      const locale = user?.locale ?? geo?.locale ?? "en";
      const timezone = user?.timezone ?? geo?.timezone ?? "America/New_York";
      const currency =
        template?.currency ?? team?.baseCurrency ?? defaultTemplate.currency;
      const dateFormat =
        template?.dateFormat ?? user?.dateFormat ?? defaultTemplate.dateFormat;
      const logoUrl = template?.logoUrl ?? defaultTemplate.logoUrl;
      const countryCode = geo?.country ?? "US";

      // Default to letter size for US/CA, A4 for rest of world
      const size = ["US", "CA"].includes(countryCode) ? "letter" : "a4";

      // Default to include sales tax for countries where it's common
      const includeTax = ["US", "CA", "AU", "NZ", "SG", "MY", "IN"].includes(
        countryCode,
      );

      const savedTemplate = {
        title: template?.title ?? defaultTemplate.title,
        logoUrl,
        currency,
        size: template?.size ?? defaultTemplate.size,
        includeTax: template?.includeTax ?? includeTax,
        includeVat: template?.includeVat ?? !includeTax,
        includeDiscount:
          template?.includeDiscount ?? defaultTemplate.includeDiscount,
        includeDecimals:
          template?.includeDecimals ?? defaultTemplate.includeDecimals,
        includeUnits: template?.includeUnits ?? defaultTemplate.includeUnits,
        includeQr: template?.includeQr ?? defaultTemplate.includeQr,
        includePdf: template?.includePdf ?? defaultTemplate.includePdf,
        sendCopy: template?.sendCopy ?? defaultTemplate.sendCopy,
        customerLabel: template?.customerLabel ?? defaultTemplate.customerLabel,
        fromLabel: template?.fromLabel ?? defaultTemplate.fromLabel,
        invoiceNoLabel:
          template?.invoiceNoLabel ?? defaultTemplate.invoiceNoLabel,
        subtotalLabel: template?.subtotalLabel ?? defaultTemplate.subtotalLabel,
        issueDateLabel:
          template?.issueDateLabel ?? defaultTemplate.issueDateLabel,
        totalSummaryLabel:
          template?.totalSummaryLabel ?? defaultTemplate.totalSummaryLabel,
        dueDateLabel: template?.dueDateLabel ?? defaultTemplate.dueDateLabel,
        discountLabel: template?.discountLabel ?? defaultTemplate.discountLabel,
        descriptionLabel:
          template?.descriptionLabel ?? defaultTemplate.descriptionLabel,
        priceLabel: template?.priceLabel ?? defaultTemplate.priceLabel,
        quantityLabel: template?.quantityLabel ?? defaultTemplate.quantityLabel,
        totalLabel: template?.totalLabel ?? defaultTemplate.totalLabel,
        vatLabel: template?.vatLabel ?? defaultTemplate.vatLabel,
        taxLabel: template?.taxLabel ?? defaultTemplate.taxLabel,
        paymentLabel: template?.paymentLabel ?? defaultTemplate.paymentLabel,
        noteLabel: template?.noteLabel ?? defaultTemplate.noteLabel,
        dateFormat,
        deliveryType: template?.deliveryType ?? defaultTemplate.deliveryType,
        taxRate: template?.taxRate ?? defaultTemplate.taxRate,
        vatRate: template?.vatRate ?? defaultTemplate.vatRate,
        fromDetails: template?.fromDetails ?? defaultTemplate.fromDetails,
        paymentDetails:
          template?.paymentDetails ?? defaultTemplate.paymentDetails,
        timezone,
        locale,
      };

      return {
        // Default values first
        id: uuidv4(),
        currency,
        status: "draft",
        size,
        includeTax: savedTemplate?.includeTax ?? includeTax,
        includeVat: savedTemplate?.includeVat ?? !includeTax,
        includeDiscount: false,
        includeDecimals: false,
        includePdf: false,
        sendCopy: false,
        includeUnits: false,
        includeQr: true,
        invoiceNumber: nextInvoiceNumber,
        timezone,
        locale,
        fromDetails: savedTemplate.fromDetails,
        paymentDetails: savedTemplate.paymentDetails,
        customerDetails: undefined,
        noteDetails: undefined,
        customerId: undefined,
        issueDate: new UTCDate().toISOString(),
        dueDate: addMonths(new UTCDate(), 1).toISOString(),
        lineItems: [{ name: "", quantity: 0, price: 0, vat: 0 }],
        tax: undefined,
        token: undefined,
        discount: undefined,
        subtotal: undefined,
        topBlock: undefined,
        bottomBlock: undefined,
        amount: undefined,
        customerName: undefined,
        logoUrl: undefined,
        vat: undefined,
        template: savedTemplate,
      };
    },
  ),

  update: protectedProcedure
    .input(updateInvoiceSchema)
    .mutation(async ({ input, ctx: { db, teamId, session } }) => {
      return updateInvoice(db, {
        ...input,
        teamId: teamId!,
        userId: session.user.id,
      });
    }),

  delete: protectedProcedure
    .input(deleteInvoiceSchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      return deleteInvoice(db, {
        id: input.id,
        teamId: teamId!,
      });
    }),

  draft: protectedProcedure
    .input(draftInvoiceSchema)
    .mutation(async ({ input, ctx: { db, teamId, session } }) => {
      return draftInvoice(db, {
        ...input,
        teamId: teamId!,
        userId: session?.user.id!,
        paymentDetails: parseInputValue(input.paymentDetails),
        fromDetails: parseInputValue(input.fromDetails),
        customerDetails: parseInputValue(input.customerDetails),
        noteDetails: parseInputValue(input.noteDetails),
      });
    }),

  create: protectedProcedure
    .input(createInvoiceSchema)
    .mutation(async ({ input, ctx: { db, teamId, session } }) => {
      // Handle different delivery types
      if (input.deliveryType === "scheduled") {
        if (!input.scheduledAt) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "scheduledAt is required for scheduled delivery",
          });
        }

        // Convert to Date object and validate it's in the future
        const scheduledDate = new Date(input.scheduledAt);
        const now = new Date();

        if (scheduledDate <= now) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "scheduledAt must be in the future",
          });
        }

        // Check if this is an existing scheduled invoice
        const existingInvoice = await getInvoiceById(db, {
          id: input.id,
          teamId: teamId!,
        });

        let scheduledJobId: string;

        if (existingInvoice?.scheduledJobId) {
          // Reschedule the existing job instead of creating a new one
          await runs.reschedule(existingInvoice.scheduledJobId, {
            delay: scheduledDate,
          });
          scheduledJobId = existingInvoice.scheduledJobId;
        } else {
          // Create a new scheduled job
          const scheduledRun = await tasks.trigger(
            "schedule-invoice",
            {
              invoiceId: input.id,
              scheduledAt: input.scheduledAt,
            },
            {
              delay: scheduledDate,
            },
          );

          scheduledJobId = scheduledRun.id;
        }

        // Update the invoice with scheduling information
        const data = await updateInvoice(db, {
          id: input.id,
          status: "scheduled",
          scheduledAt: input.scheduledAt,
          scheduledJobId,
          teamId: teamId!,
        });

        if (!data) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Invoice not found",
          });
        }

        tasks.trigger("notification", {
          type: "invoice_scheduled",
          teamId: teamId!,
          invoiceId: input.id,
          invoiceNumber: data.invoiceNumber,
          scheduledAt: input.scheduledAt,
          customerName: data.customerName,
        });

        return data;
      }

      const data = await updateInvoice(db, {
        id: input.id,
        status: "unpaid",
        teamId: teamId!,
        userId: session.user.id,
      });

      if (!data) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Invoice not found",
        });
      }

      await tasks.trigger("generate-invoice", {
        invoiceId: data.id,
        deliveryType: input.deliveryType,
      } satisfies GenerateInvoicePayload);

      return data;
    }),

  remind: protectedProcedure
    .input(remindInvoiceSchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      await tasks.trigger("send-invoice-reminder", {
        invoiceId: input.id,
      } satisfies SendInvoiceReminderPayload);

      return updateInvoice(db, {
        id: input.id,
        teamId: teamId!,
        reminderSentAt: input.date,
      });
    }),

  duplicate: protectedProcedure
    .input(duplicateInvoiceSchema)
    .mutation(async ({ input, ctx: { db, session, teamId } }) => {
      const nextInvoiceNumber = await getNextInvoiceNumber(db, teamId!);

      return duplicateInvoice(db, {
        id: input.id,
        userId: session?.user.id!,
        invoiceNumber: nextInvoiceNumber!,
        teamId: teamId!,
      });
    }),

  updateSchedule: protectedProcedure
    .input(updateScheduledInvoiceSchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      // Get the current invoice to find the old scheduled job ID
      const invoice = await getInvoiceById(db, {
        id: input.id,
        teamId: teamId!,
      });

      if (!invoice || !invoice.scheduledJobId) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Scheduled invoice not found",
        });
      }

      // Convert to Date object and validate it's in the future
      const scheduledDate = new Date(input.scheduledAt);
      const now = new Date();

      if (scheduledDate <= now) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "scheduledAt must be in the future",
        });
      }

      // Reschedule the existing job with the new date
      await runs.reschedule(invoice.scheduledJobId, {
        delay: scheduledDate,
      });

      // Update the scheduled date in the database
      const updatedInvoice = await updateInvoice(db, {
        id: input.id,
        scheduledAt: input.scheduledAt,
        teamId: teamId!,
      });

      return updatedInvoice;
    }),

  cancelSchedule: protectedProcedure
    .input(cancelScheduledInvoiceSchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      // Get the current invoice to find the scheduled job ID
      const invoice = await getInvoiceById(db, {
        id: input.id,
        teamId: teamId!,
      });

      if (!invoice || !invoice.scheduledJobId) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Scheduled invoice not found",
        });
      }

      // Cancel the scheduled job
      await runs.cancel(invoice.scheduledJobId);

      // Update the invoice status back to draft and clear scheduling fields
      const updatedInvoice = await updateInvoice(db, {
        id: input.id,
        status: "draft",
        scheduledAt: null,
        scheduledJobId: null,
        teamId: teamId!,
      });

      return updatedInvoice;
    }),

  mostActiveClient: protectedProcedure.query(
    async ({ ctx: { db, teamId } }) => {
      return getMostActiveClient(db, { teamId: teamId! });
    },
  ),

  inactiveClientsCount: protectedProcedure.query(
    async ({ ctx: { db, teamId } }) => {
      return getInactiveClientsCount(db, { teamId: teamId! });
    },
  ),

  averageDaysToPayment: protectedProcedure.query(
    async ({ ctx: { db, teamId } }) => {
      return getAverageDaysToPayment(db, { teamId: teamId! });
    },
  ),

  averageInvoiceSize: protectedProcedure.query(
    async ({ ctx: { db, teamId } }) => {
      return getAverageInvoiceSize(db, { teamId: teamId! });
    },
  ),

  topRevenueClient: protectedProcedure.query(
    async ({ ctx: { db, teamId } }) => {
      return getTopRevenueClient(db, { teamId: teamId! });
    },
  ),

  newCustomersCount: protectedProcedure.query(
    async ({ ctx: { db, teamId } }) => {
      return getNewCustomersCount(db, { teamId: teamId! });
    },
  ),
});
</file>

<file path="apps/api/src/trpc/routers/notification-settings.ts">
import {
  bulkUpdateNotificationSettingsSchema,
  getNotificationSettingsSchema,
  updateNotificationSettingSchema,
} from "@api/schemas/notification-settings";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  bulkUpdateNotificationSettings,
  getNotificationSettings,
  getUserNotificationPreferences,
  upsertNotificationSetting,
} from "@midday/db/queries";

export const notificationSettingsRouter = createTRPCRouter({
  get: protectedProcedure
    .input(getNotificationSettingsSchema.optional())
    .query(async ({ ctx: { db, session, teamId }, input = {} }) => {
      return getNotificationSettings(db, {
        userId: session.user.id,
        teamId: teamId!,
        ...input,
      });
    }),

  // Get all notification types with their current settings for the user
  getAll: protectedProcedure.query(async ({ ctx: { db, session, teamId } }) => {
    return getUserNotificationPreferences(db, session.user.id, teamId!);
  }),

  // Update a single notification setting
  update: protectedProcedure
    .input(updateNotificationSettingSchema)
    .mutation(async ({ ctx: { db, session, teamId }, input }) => {
      return upsertNotificationSetting(db, {
        userId: session.user.id,
        teamId: teamId!,
        ...input,
      });
    }),

  // Bulk update multiple notification settings
  bulkUpdate: protectedProcedure
    .input(bulkUpdateNotificationSettingsSchema)
    .mutation(async ({ ctx: { db, session, teamId }, input }) => {
      return bulkUpdateNotificationSettings(
        db,
        session.user.id,
        teamId!,
        input.updates,
      );
    }),
});
</file>

<file path="apps/api/src/trpc/routers/notifications.ts">
import {
  getNotificationsSchema,
  updateAllNotificationsStatusSchema,
  updateNotificationStatusSchema,
} from "@api/schemas/notifications";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  getActivities,
  updateActivityStatus,
  updateAllActivitiesStatus,
} from "@midday/db/queries";

export const notificationsRouter = createTRPCRouter({
  list: protectedProcedure
    .input(getNotificationsSchema.optional())
    .query(async ({ ctx: { teamId, db, session }, input }) => {
      return getActivities(db, {
        teamId: teamId!,
        userId: session.user.id,
        ...input,
      });
    }),

  updateStatus: protectedProcedure
    .input(updateNotificationStatusSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return updateActivityStatus(db, input.activityId, input.status, teamId!);
    }),

  updateAllStatus: protectedProcedure
    .input(updateAllNotificationsStatusSchema)
    .mutation(async ({ ctx: { db, teamId, session }, input }) => {
      return updateAllActivitiesStatus(db, teamId!, input.status, {
        userId: session.user.id,
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/oauth-applications.ts">
import {
  authorizeOAuthApplicationSchema,
  createOAuthApplicationSchema,
  deleteOAuthApplicationSchema,
  getApplicationInfoSchema,
  getOAuthApplicationSchema,
  regenerateClientSecretSchema,
  updateApprovalStatusSchema,
  updateOAuthApplicationSchema,
} from "@api/schemas/oauth-applications";
import { revokeUserApplicationAccessSchema } from "@api/schemas/oauth-flow";
import { resend } from "@api/services/resend";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  createAuthorizationCode,
  createOAuthApplication,
  deleteOAuthApplication,
  getOAuthApplicationByClientId,
  getOAuthApplicationById,
  getOAuthApplicationsByTeam,
  getTeamsByUserId,
  getUserAuthorizedApplications,
  regenerateClientSecret,
  revokeUserApplicationTokens,
  updateOAuthApplication,
  updateOAuthApplicationstatus,
} from "@midday/db/queries";
import { AppInstalledEmail } from "@midday/email/emails/app-installed";
import { AppReviewRequestEmail } from "@midday/email/emails/app-review-request";
import { render } from "@midday/email/render";

export const oauthApplicationsRouter = createTRPCRouter({
  list: protectedProcedure.query(async ({ ctx }) => {
    const { db, teamId } = ctx;

    const applications = await getOAuthApplicationsByTeam(db, teamId!);

    return {
      data: applications,
    };
  }),

  getApplicationInfo: protectedProcedure
    .input(getApplicationInfoSchema)
    .query(async ({ ctx, input }) => {
      const { db } = ctx;
      const { clientId, redirectUri, scope, state } = input;

      // Validate client_id
      const application = await getOAuthApplicationByClientId(db, clientId);
      if (!application || !application.active) {
        throw new Error("Invalid client_id");
      }

      // Validate redirect_uri
      if (!application.redirectUris.includes(redirectUri)) {
        throw new Error("Invalid redirect_uri");
      }

      // Validate scopes
      const requestedScopes = scope.split(" ").filter(Boolean);
      const invalidScopes = requestedScopes.filter(
        (s) => !application.scopes.includes(s),
      );

      if (invalidScopes.length > 0) {
        throw new Error(`Invalid scopes: ${invalidScopes.join(", ")}`);
      }

      // Return application info for consent screen
      return {
        id: application.id,
        name: application.name,
        description: application.description,
        overview: application.overview,
        developerName: application.developerName,
        logoUrl: application.logoUrl,
        website: application.website,
        installUrl: application.installUrl,
        screenshots: application.screenshots,
        clientId: application.clientId,
        scopes: requestedScopes,
        redirectUri: redirectUri,
        state,
        status: application.status,
      };
    }),

  authorize: protectedProcedure
    .input(authorizeOAuthApplicationSchema)
    .mutation(async ({ ctx, input }) => {
      const { db, session } = ctx;
      const {
        clientId,
        decision,
        scopes,
        redirectUri,
        state,
        codeChallenge,
        teamId,
      } = input;

      // Validate client_id first (needed for both allow and deny)
      const application = await getOAuthApplicationByClientId(db, clientId);
      if (!application || !application.active) {
        throw new Error("Invalid client_id");
      }

      // Validate scopes against application's registered scopes (prevent privilege escalation)
      const invalidScopes = scopes.filter(
        (scope) => !application.scopes.includes(scope),
      );

      if (invalidScopes.length > 0) {
        throw new Error(`Invalid scopes: ${invalidScopes.join(", ")}`);
      }

      const redirectUrl = new URL(redirectUri);

      // Handle denial early - no need to check team membership for denial
      if (decision === "deny") {
        redirectUrl.searchParams.set("error", "access_denied");
        redirectUrl.searchParams.set("error_description", "User denied access");
        if (state) {
          redirectUrl.searchParams.set("state", state);
        }
        return { redirect_url: redirectUrl.toString() };
      }

      // Only validate team membership for "allow" decisions
      const userTeams = await getTeamsByUserId(db, session.user.id);

      if (!userTeams) {
        throw new Error("User not found");
      }

      const hasTeamAccess = userTeams.some((team) => team.id === teamId);

      if (!hasTeamAccess) {
        throw new Error("User is not a member of the specified team");
      }

      // Enforce PKCE for public clients
      if (application.isPublic && !codeChallenge) {
        throw new Error("PKCE is required for public clients");
      }

      // Create authorization code
      const authCode = await createAuthorizationCode(db, {
        applicationId: application.id,
        userId: session.user.id,
        teamId,
        scopes,
        redirectUri,
        codeChallenge,
      });

      if (!authCode) {
        throw new Error("Failed to create authorization code");
      }

      // Send app installation email
      try {
        // Get team information
        const userTeam = userTeams.find((team) => team.id === teamId);

        if (userTeam && session.user.email) {
          const html = await render(
            AppInstalledEmail({
              email: session.user.email,
              teamName: userTeam.name!,
              appName: application.name,
            }),
          );

          await resend.emails.send({
            from: "Midday <middaybot@midday.ai>",
            to: session.user.email,
            subject: "An app has been added to your team",
            html,
          });
        }
      } catch (error) {
        // Log error but don't fail the OAuth flow
        console.error("Failed to send app installation email:", error);
      }

      // Build success redirect URL
      redirectUrl.searchParams.set("code", authCode.code);
      if (state) {
        redirectUrl.searchParams.set("state", state);
      }

      return { redirect_url: redirectUrl.toString() };
    }),

  create: protectedProcedure
    .input(createOAuthApplicationSchema)
    .mutation(async ({ ctx, input }) => {
      const { db, teamId, session } = ctx;

      const application = await createOAuthApplication(db, {
        ...input,
        teamId: teamId!,
        createdBy: session.user.id,
      });

      return application;
    }),

  get: protectedProcedure
    .input(getOAuthApplicationSchema)
    .query(async ({ ctx, input }) => {
      const { db, teamId } = ctx;

      const application = await getOAuthApplicationById(db, input.id, teamId!);

      if (!application) {
        throw new Error("OAuth application not found");
      }

      return application;
    }),

  update: protectedProcedure
    .input(updateOAuthApplicationSchema)
    .mutation(async ({ ctx, input }) => {
      const { db, teamId } = ctx;
      const { id, ...updateData } = input;

      const application = await updateOAuthApplication(db, {
        ...updateData,
        id,
        teamId: teamId!,
      });

      if (!application) {
        throw new Error("OAuth application not found");
      }

      return application;
    }),

  delete: protectedProcedure
    .input(deleteOAuthApplicationSchema)
    .mutation(async ({ ctx, input }) => {
      const { db, teamId } = ctx;

      const result = await deleteOAuthApplication(db, {
        id: input.id,
        teamId: teamId!,
      });

      if (!result) {
        throw new Error("OAuth application not found");
      }

      return { success: true };
    }),

  regenerateSecret: protectedProcedure
    .input(regenerateClientSecretSchema)
    .mutation(async ({ ctx, input }) => {
      const { db, teamId } = ctx;

      const result = await regenerateClientSecret(db, input.id, teamId!);

      if (!result) {
        throw new Error("OAuth application not found");
      }

      return result;
    }),

  authorized: protectedProcedure.query(async ({ ctx }) => {
    const { db, teamId, session } = ctx;

    const applications = await getUserAuthorizedApplications(
      db,
      session.user.id,
      teamId!,
    );

    return {
      data: applications,
    };
  }),

  revokeAccess: protectedProcedure
    .input(revokeUserApplicationAccessSchema)
    .mutation(async ({ ctx, input }) => {
      const { db, session } = ctx;

      await revokeUserApplicationTokens(
        db,
        session.user.id,
        input.applicationId,
      );

      return { success: true };
    }),

  updateApprovalStatus: protectedProcedure
    .input(updateApprovalStatusSchema)
    .mutation(async ({ ctx, input }) => {
      const { db, teamId, session } = ctx;

      // Get full application details before updating
      const application = await getOAuthApplicationById(db, input.id, teamId!);

      if (!application) {
        throw new Error("OAuth application not found");
      }

      const result = await updateOAuthApplicationstatus(db, {
        id: input.id,
        teamId: teamId!,
        status: input.status,
      });

      if (!result) {
        throw new Error("OAuth application not found");
      }

      // Send email notification when status changes to "pending"
      if (input.status === "pending") {
        try {
          // Get team information
          const userTeams = await getTeamsByUserId(db, session.user.id);
          const currentTeam = userTeams?.find((team) => team.id === teamId);

          if (currentTeam && session.user.email) {
            const html = await render(
              AppReviewRequestEmail({
                applicationName: application.name,
                developerName: application.developerName || undefined,
                teamName: currentTeam.name!,
                userEmail: session.user.email,
              }),
            );

            await resend.emails.send({
              from: "Midday <middaybot@midday.ai>",
              to: "pontus@midday.ai",
              subject: `Application Review Request - ${application.name}`,
              html,
            });
          }
        } catch (error) {
          // Log error but don't fail the mutation
          console.error("Failed to send application review request:", error);
        }
      }

      return result;
    }),
});
</file>

<file path="apps/api/src/trpc/routers/reports.ts">
import {
  getBurnRateSchema,
  getExpensesSchema,
  getProfitSchema,
  getRevenueSchema,
  getRunwaySchema,
  getSpendingSchema,
  getTaxSummarySchema,
} from "@api/schemas/reports";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  getBurnRate,
  getExpenses,
  getReports,
  getRunway,
  getSpending,
  getTaxSummary,
} from "@midday/db/queries";

export const reportsRouter = createTRPCRouter({
  revenue: protectedProcedure
    .input(getRevenueSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getReports(db, {
        teamId: teamId!,
        from: input.from,
        to: input.to,
        currency: input.currency,
        type: "revenue",
      });
    }),

  profit: protectedProcedure
    .input(getProfitSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getReports(db, {
        teamId: teamId!,
        from: input.from,
        to: input.to,
        currency: input.currency,
        type: "profit",
      });
    }),

  burnRate: protectedProcedure
    .input(getBurnRateSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getBurnRate(db, {
        teamId: teamId!,
        from: input.from,
        to: input.to,
        currency: input.currency,
      });
    }),

  runway: protectedProcedure
    .input(getRunwaySchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getRunway(db, {
        teamId: teamId!,
        from: input.from,
        to: input.to,
        currency: input.currency,
      });
    }),

  expense: protectedProcedure
    .input(getExpensesSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getExpenses(db, {
        teamId: teamId!,
        from: input.from,
        to: input.to,
        currency: input.currency,
      });
    }),

  spending: protectedProcedure
    .input(getSpendingSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getSpending(db, {
        teamId: teamId!,
        from: input.from,
        to: input.to,
        currency: input.currency,
      });
    }),

  taxSummary: protectedProcedure
    .input(getTaxSummarySchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getTaxSummary(db, {
        teamId: teamId!,
        from: input.from,
        to: input.to,
        currency: input.currency,
        type: input.type,
        categorySlug: input.categorySlug,
        taxType: input.taxType,
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/search.ts">
import { globalSearchSchema } from "@api/schemas/search";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import { generateLLMFilters } from "@api/utils/search-filters";
import {
  globalSearchQuery,
  globalSemanticSearchQuery,
} from "@midday/db/queries";

export const searchRouter = createTRPCRouter({
  global: protectedProcedure
    .input(globalSearchSchema)
    .query(async ({ input, ctx: { db, teamId } }) => {
      const { searchTerm } = input;

      // Determine if we should fall back to LLM-generated filters:
      // we only do this when the user provides a multi-word query.
      const shouldUseLLMFilters =
        !!searchTerm && searchTerm.trim().split(/\s+/).length > 1;

      const results = await globalSearchQuery(db, {
        teamId: teamId!,
        ...input,
        searchTerm: searchTerm,
        /**
         * Tighten the relevance threshold whenever the user enters a multi-word query.
         *
         * Rationale:
         * 1. A longer query usually implies a more specific intent, so we only want
         *    results that score highly on relevance.
         * 2. If this stricter search returns nothing, we immediately fall back to the
         *    LLM-generated filter logic below.  By filtering aggressively here we avoid
         *    surfacing low-quality matches and give the LLM a chance to produce a more
         *    intelligent result instead.
         */
        relevanceThreshold: shouldUseLLMFilters
          ? 0.01
          : input.relevanceThreshold,
      });

      if (shouldUseLLMFilters && !results.length) {
        const filters = await generateLLMFilters(searchTerm);

        const semanticResults = await globalSemanticSearchQuery(db, {
          teamId: teamId!,
          itemsPerTableLimit: input.itemsPerTableLimit,
          ...filters,
        });

        return semanticResults;
      }

      return results;
    }),
});
</file>

<file path="apps/api/src/trpc/routers/short-links.ts">
import {
  createShortLinkForDocumentSchema,
  createShortLinkSchema,
  getShortLinkSchema,
} from "@api/schemas/short-links";
import {
  createTRPCRouter,
  protectedProcedure,
  publicProcedure,
} from "@api/trpc/init";
import {
  createShortLink,
  getDocumentById,
  getShortLinkByShortId,
} from "@midday/db/queries";
import { signedUrl } from "@midday/supabase/storage";

export const shortLinksRouter = createTRPCRouter({
  createForUrl: protectedProcedure
    .input(createShortLinkSchema)
    .mutation(async ({ ctx: { db, teamId, session }, input }) => {
      const result = await createShortLink(db, {
        url: input.url,
        teamId: teamId!,
        userId: session.user.id,
        type: "redirect",
      });

      if (!result) {
        throw new Error("Failed to create short link");
      }

      return {
        ...result,
        shortUrl: `${process.env.MIDDAY_DASHBOARD_URL}/s/${result.shortId}`,
      };
    }),

  createForDocument: protectedProcedure
    .input(createShortLinkForDocumentSchema)
    .mutation(async ({ ctx: { db, teamId, session, supabase }, input }) => {
      const document = await getDocumentById(db, {
        id: input.documentId,
        filePath: input.filePath,
        teamId: teamId!,
      });

      if (!document) {
        throw new Error("Document not found");
      }

      // First create the signed URL for the file
      const response = await signedUrl(supabase, {
        bucket: "vault",
        path: document.pathTokens?.join("/") ?? "",
        expireIn: input.expireIn,
        options: {
          download: true,
        },
      });

      if (!response.data?.signedUrl) {
        throw new Error("Failed to create signed URL for file");
      }

      // Then create a short link for the signed URL
      const result = await createShortLink(db, {
        url: response.data.signedUrl,
        teamId: teamId!,
        userId: session.user.id,
        type: "download",
        fileName: document.name ?? undefined,
        // @ts-expect-error
        mimeType: document.metadata?.contentType ?? undefined,
        // @ts-expect-error
        size: document.metadata?.size ?? undefined,
        expiresAt: input.expireIn
          ? new Date(Date.now() + input.expireIn * 1000).toISOString()
          : undefined,
      });

      if (!result) {
        throw new Error("Failed to create short link");
      }

      return {
        ...result,
        shortUrl: `${process.env.MIDDAY_DASHBOARD_URL}/s/${result.shortId}`,
        originalUrl: response.data.signedUrl,
      };
    }),

  get: publicProcedure
    .input(getShortLinkSchema)
    .query(async ({ ctx: { db }, input }) => {
      return getShortLinkByShortId(db, input.shortId);
    }),
});
</file>

<file path="apps/api/src/trpc/routers/tags.ts">
import {
  createTagSchema,
  deleteTagSchema,
  updateTagSchema,
} from "@api/schemas/tags";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import { createTag, deleteTag, getTags, updateTag } from "@midday/db/queries";

export const tagsRouter = createTRPCRouter({
  get: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    return getTags(db, {
      teamId: teamId!,
    });
  }),

  create: protectedProcedure
    .input(createTagSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return createTag(db, {
        teamId: teamId!,
        name: input.name,
      });
    }),

  delete: protectedProcedure
    .input(deleteTagSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return deleteTag(db, {
        id: input.id,
        teamId: teamId!,
      });
    }),

  update: protectedProcedure
    .input(updateTagSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return updateTag(db, {
        id: input.id,
        name: input.name,
        teamId: teamId!,
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/team.ts">
import {
  acceptTeamInviteSchema,
  createTeamSchema,
  declineTeamInviteSchema,
  deleteTeamInviteSchema,
  deleteTeamMemberSchema,
  deleteTeamSchema,
  inviteTeamMembersSchema,
  leaveTeamSchema,
  updateBaseCurrencySchema,
  updateTeamByIdSchema,
  updateTeamMemberSchema,
} from "@api/schemas/team";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  acceptTeamInvite,
  createTeam,
  createTeamInvites,
  declineTeamInvite,
  deleteTeam,
  deleteTeamInvite,
  deleteTeamMember,
  getAvailablePlans,
  getBankConnections,
  getInvitesByEmail,
  getTeamById,
  getTeamInvites,
  getTeamMembers,
  getTeamMembersByTeamId,
  getTeamsByUserId,
  leaveTeam,
  updateTeamById,
  updateTeamMember,
} from "@midday/db/queries";
import type {
  DeleteTeamPayload,
  InviteTeamMembersPayload,
  UpdateBaseCurrencyPayload,
} from "@midday/jobs/schema";
import { tasks } from "@trigger.dev/sdk";
import { TRPCError } from "@trpc/server";

export const teamRouter = createTRPCRouter({
  current: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    if (!teamId) {
      return null;
    }

    return getTeamById(db, teamId!);
  }),

  update: protectedProcedure
    .input(updateTeamByIdSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return updateTeamById(db, {
        id: teamId!,
        data: input,
      });
    }),

  members: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    return getTeamMembersByTeamId(db, teamId!);
  }),

  list: protectedProcedure.query(async ({ ctx: { db, session } }) => {
    return getTeamsByUserId(db, session.user.id);
  }),

  create: protectedProcedure
    .input(createTeamSchema)
    .mutation(async ({ ctx: { db, session }, input }) => {
      return createTeam(db, {
        ...input,
        userId: session.user.id,
        email: session.user.email!,
      });
    }),

  leave: protectedProcedure
    .input(leaveTeamSchema)
    .mutation(async ({ ctx: { db, session }, input }) => {
      const teamMembersData = await getTeamMembersByTeamId(db, input.teamId);

      const currentUser = teamMembersData?.find(
        (member) => member.user?.id === session.user.id,
      );

      const totalOwners = teamMembersData?.filter(
        (member) => member.role === "owner",
      ).length;

      if (currentUser?.role === "owner" && totalOwners === 1) {
        throw Error("Action not allowed");
      }

      return leaveTeam(db, {
        userId: session.user.id,
        teamId: input.teamId,
      });
    }),

  acceptInvite: protectedProcedure
    .input(acceptTeamInviteSchema)
    .mutation(async ({ ctx: { db, session }, input }) => {
      return acceptTeamInvite(db, {
        id: input.id,
        userId: session.user.id,
      });
    }),

  declineInvite: protectedProcedure
    .input(declineTeamInviteSchema)
    .mutation(async ({ ctx: { db, session }, input }) => {
      return declineTeamInvite(db, {
        id: input.id,
        email: session.user.email!,
      });
    }),

  delete: protectedProcedure
    .input(deleteTeamSchema)
    .mutation(async ({ ctx: { db }, input }) => {
      const data = await deleteTeam(db, input.teamId);

      if (!data) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Team not found",
        });
      }

      const bankConnections = await getBankConnections(db, {
        teamId: data.id,
      });

      if (bankConnections.length > 0) {
        await tasks.trigger("delete-team", {
          teamId: input.teamId!,
          connections: bankConnections.map((connection) => ({
            accessToken: connection.accessToken,
            provider: connection.provider,
            referenceId: connection.referenceId,
          })),
        } satisfies DeleteTeamPayload);
      }
    }),

  deleteMember: protectedProcedure
    .input(deleteTeamMemberSchema)
    .mutation(async ({ ctx: { db }, input }) => {
      return deleteTeamMember(db, {
        teamId: input.teamId,
        userId: input.userId,
      });
    }),

  updateMember: protectedProcedure
    .input(updateTeamMemberSchema)
    .mutation(async ({ ctx: { db }, input }) => {
      return updateTeamMember(db, input);
    }),

  teamInvites: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    return getTeamInvites(db, teamId!);
  }),

  invitesByEmail: protectedProcedure.query(async ({ ctx: { db, session } }) => {
    return getInvitesByEmail(db, session.user.email!);
  }),

  invite: protectedProcedure
    .input(inviteTeamMembersSchema)
    .mutation(async ({ ctx: { db, session, teamId, geo }, input }) => {
      const ip = geo.ip ?? "127.0.0.1";

      const data = await createTeamInvites(db, {
        teamId: teamId!,
        invites: input.map((invite) => ({
          ...invite,
          invitedBy: session.user.id,
        })),
      });

      const results = data?.results ?? [];
      const skippedInvites = data?.skippedInvites ?? [];

      const invites = results.map((invite) => ({
        email: invite?.email!,
        invitedBy: session.user.id!,
        invitedByName: session.user.full_name!,
        invitedByEmail: session.user.email!,
        teamName: invite?.team?.name!,
        inviteCode: invite?.code!,
      }));

      // Only trigger email sending if there are valid invites
      if (invites.length > 0) {
        await tasks.trigger("invite-team-members", {
          teamId: teamId!,
          invites,
          ip,
          locale: "en",
        } satisfies InviteTeamMembersPayload);
      }

      // Return information about the invitation process
      return {
        sent: invites.length,
        skipped: skippedInvites.length,
        skippedInvites,
      };
    }),

  deleteInvite: protectedProcedure
    .input(deleteTeamInviteSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return deleteTeamInvite(db, {
        teamId: teamId!,
        id: input.id,
      });
    }),

  availablePlans: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    return getAvailablePlans(db, teamId!);
  }),

  updateBaseCurrency: protectedProcedure
    .input(updateBaseCurrencySchema)
    .mutation(async ({ ctx: { teamId }, input }) => {
      const event = await tasks.trigger("update-base-currency", {
        teamId: teamId!,
        baseCurrency: input.baseCurrency,
      } satisfies UpdateBaseCurrencyPayload);

      return event;
    }),
});
</file>

<file path="apps/api/src/trpc/routers/tracker-entries.ts">
import {
  deleteTrackerEntrySchema,
  getCurrentTimerSchema,
  getTrackerRecordsByDateSchema,
  getTrackerRecordsByRangeSchema,
  startTimerSchema,
  stopTimerSchema,
  upsertTrackerEntriesSchema,
} from "@api/schemas/tracker-entries";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  deleteTrackerEntry,
  getCurrentTimer,
  getTimerStatus,
  getTrackerRecordsByDate,
  getTrackerRecordsByRange,
  startTimer,
  stopTimer,
  upsertTrackerEntries,
} from "@midday/db/queries";

export const trackerEntriesRouter = createTRPCRouter({
  byDate: protectedProcedure
    .input(getTrackerRecordsByDateSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getTrackerRecordsByDate(db, {
        date: input.date,
        teamId: teamId!,
      });
    }),

  byRange: protectedProcedure
    .input(getTrackerRecordsByRangeSchema)
    .query(async ({ input, ctx: { db, session, teamId } }) => {
      return getTrackerRecordsByRange(db, {
        teamId: teamId!,
        userId: session.user.id,
        ...input,
      });
    }),

  upsert: protectedProcedure
    .input(upsertTrackerEntriesSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return upsertTrackerEntries(db, {
        ...input,
        teamId: teamId!,
      });
    }),

  delete: protectedProcedure
    .input(deleteTrackerEntrySchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return deleteTrackerEntry(db, {
        teamId: teamId!,
        id: input.id,
      });
    }),

  // Timer procedures
  startTimer: protectedProcedure
    .input(startTimerSchema)
    .mutation(async ({ ctx: { db, teamId, session }, input }) => {
      return startTimer(db, {
        teamId: teamId!,
        assignedId: input.assignedId ?? session.user.id,
        ...input,
      });
    }),

  stopTimer: protectedProcedure
    .input(stopTimerSchema)
    .mutation(async ({ ctx: { db, teamId, session }, input }) => {
      return stopTimer(db, {
        teamId: teamId!,
        assignedId: input.assignedId ?? session.user.id,
        ...input,
      });
    }),

  getCurrentTimer: protectedProcedure
    .input(getCurrentTimerSchema.optional())
    .query(async ({ ctx: { db, teamId, session }, input }) => {
      return getCurrentTimer(db, {
        teamId: teamId!,
        assignedId: input?.assignedId ?? session.user.id,
      });
    }),

  getTimerStatus: protectedProcedure
    .input(getCurrentTimerSchema.optional())
    .query(async ({ ctx: { db, teamId, session }, input }) => {
      return getTimerStatus(db, {
        teamId: teamId!,
        assignedId: input?.assignedId ?? session.user.id,
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/tracker-projects.ts">
import {
  deleteTrackerProjectSchema,
  getTrackerProjectByIdSchema,
  getTrackerProjectsSchema,
  upsertTrackerProjectSchema,
} from "@api/schemas/tracker-projects";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  deleteTrackerProject,
  getTrackerProjectById,
  getTrackerProjects,
  upsertTrackerProject,
} from "@midday/db/queries";

export const trackerProjectsRouter = createTRPCRouter({
  get: protectedProcedure
    .input(getTrackerProjectsSchema.optional())
    .query(async ({ input, ctx: { db, teamId } }) => {
      return getTrackerProjects(db, {
        ...input,
        teamId: teamId!,
      });
    }),

  upsert: protectedProcedure
    .input(upsertTrackerProjectSchema)
    .mutation(async ({ input, ctx: { db, teamId, session } }) => {
      return upsertTrackerProject(db, {
        ...input,
        teamId: teamId!,
        userId: session.user.id,
      });
    }),

  delete: protectedProcedure
    .input(deleteTrackerProjectSchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      return deleteTrackerProject(db, {
        ...input,
        teamId: teamId!,
      });
    }),

  getById: protectedProcedure
    .input(getTrackerProjectByIdSchema)
    .query(async ({ input, ctx: { db, teamId } }) => {
      return getTrackerProjectById(db, {
        ...input,
        teamId: teamId!,
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/transaction-attachments.ts">
import {
  createAttachmentsSchema,
  deleteAttachmentSchema,
  processTransactionAttachmentSchema,
} from "@api/schemas/transaction-attachments";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import type { ProcessTransactionAttachmentPayload } from "@jobs/schema";
import { createAttachments, deleteAttachment } from "@midday/db/queries";
import { allowedMimeTypes } from "@midday/documents/utils";
import { tasks } from "@trigger.dev/sdk";

export const transactionAttachmentsRouter = createTRPCRouter({
  createMany: protectedProcedure
    .input(createAttachmentsSchema)
    .mutation(async ({ input, ctx: { db, teamId, session } }) => {
      return createAttachments(db, {
        teamId: teamId!,
        userId: session.user.id,
        attachments: input,
      });
    }),

  delete: protectedProcedure
    .input(deleteAttachmentSchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      return deleteAttachment(db, {
        id: input.id,
        teamId: teamId!,
      });
    }),

  processAttachment: protectedProcedure
    .input(processTransactionAttachmentSchema)
    .mutation(async ({ input, ctx: { teamId } }) => {
      const allowedAttachments = input.filter((item) =>
        allowedMimeTypes.includes(item.mimetype),
      );

      if (allowedAttachments.length === 0) {
        return;
      }

      return tasks.batchTrigger(
        "process-transaction-attachment",
        allowedAttachments.map(
          (item) =>
            ({
              payload: {
                filePath: item.filePath,
                mimetype: item.mimetype,
                teamId: teamId!,
                transactionId: item.transactionId,
              },
            }) as { payload: ProcessTransactionAttachmentPayload },
        ),
      );
    }),
});
</file>

<file path="apps/api/src/trpc/routers/transaction-categories.ts">
import {
  createManyTransactionCategorySchema,
  createTransactionCategorySchema,
  deleteTransactionCategorySchema,
  getCategoriesSchema,
  updateTransactionCategorySchema,
} from "@api/schemas/transaction-categories";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  createTransactionCategories,
  createTransactionCategory,
  deleteTransactionCategory,
  getCategories,
  updateTransactionCategory,
} from "@midday/db/queries";

export const transactionCategoriesRouter = createTRPCRouter({
  get: protectedProcedure
    .input(getCategoriesSchema)
    .query(async ({ ctx: { db, teamId }, input }) => {
      const data = await getCategories(db, {
        teamId: teamId!,
        limit: input?.limit,
      });

      return data;
    }),

  create: protectedProcedure
    .input(createTransactionCategorySchema)
    .mutation(async ({ input, ctx: { db, teamId, session } }) => {
      return createTransactionCategory(db, {
        teamId: teamId!,
        userId: session.user.id,
        ...input,
      });
    }),

  createMany: protectedProcedure
    .input(createManyTransactionCategorySchema)
    .mutation(async ({ input, ctx: { db, teamId, session } }) => {
      return createTransactionCategories(db, {
        teamId: teamId!,
        userId: session.user.id,
        categories: input,
      });
    }),

  update: protectedProcedure
    .input(updateTransactionCategorySchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      return updateTransactionCategory(db, {
        ...input,
        teamId: teamId!,
      });
    }),

  delete: protectedProcedure
    .input(deleteTransactionCategorySchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      return deleteTransactionCategory(db, {
        id: input.id,
        teamId: teamId!,
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/transaction-tags.ts">
import {
  createTransactionTagSchema,
  deleteTransactionTagSchema,
} from "@api/schemas/transaction-tags";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import { createTransactionTag, deleteTransactionTag } from "@midday/db/queries";

export const transactionTagsRouter = createTRPCRouter({
  create: protectedProcedure
    .input(createTransactionTagSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return createTransactionTag(db, {
        teamId: teamId!,
        transactionId: input.transactionId,
        tagId: input.tagId,
      });
    }),

  delete: protectedProcedure
    .input(deleteTransactionTagSchema)
    .mutation(async ({ ctx: { db, teamId }, input }) => {
      return deleteTransactionTag(db, {
        transactionId: input.transactionId,
        tagId: input.tagId,
        teamId: teamId!,
      });
    }),
});
</file>

<file path="apps/api/src/trpc/routers/transactions.ts">
import {
  createTransactionSchema,
  deleteTransactionsSchema,
  getSimilarTransactionsSchema,
  getTransactionByIdSchema,
  getTransactionsSchema,
  searchTransactionMatchSchema,
  updateTransactionSchema,
  updateTransactionsSchema,
} from "@api/schemas/transactions";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  createTransaction,
  deleteTransactions,
  getSimilarTransactions,
  getTransactionById,
  getTransactions,
  getTransactionsAmountFullRangeData,
  searchTransactionMatch,
  updateTransaction,
  updateTransactions,
} from "@midday/db/queries";
import type { EmbedTransactionPayload } from "@midday/jobs/schema";
import { tasks } from "@trigger.dev/sdk";

export const transactionsRouter = createTRPCRouter({
  get: protectedProcedure
    .input(getTransactionsSchema)
    .query(async ({ input, ctx: { db, teamId } }) => {
      return getTransactions(db, {
        ...input,
        teamId: teamId!,
      });
    }),

  getById: protectedProcedure
    .input(getTransactionByIdSchema)
    .query(async ({ input, ctx: { db, teamId } }) => {
      return getTransactionById(db, {
        id: input.id,
        teamId: teamId!,
      });
    }),

  deleteMany: protectedProcedure
    .input(deleteTransactionsSchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      return deleteTransactions(db, { ids: input, teamId: teamId! });
    }),

  getAmountRange: protectedProcedure.query(async ({ ctx: { db, teamId } }) => {
    return getTransactionsAmountFullRangeData(db, teamId!);
  }),

  update: protectedProcedure
    .input(updateTransactionSchema)
    .mutation(async ({ input, ctx: { db, teamId, session } }) => {
      return updateTransaction(db, {
        ...input,
        userId: session.user.id,
        teamId: teamId!,
      });
    }),

  updateMany: protectedProcedure
    .input(updateTransactionsSchema)
    .mutation(async ({ input, ctx: { db, teamId, session } }) => {
      return updateTransactions(db, {
        ...input,
        userId: session.user.id,
        teamId: teamId!,
      });
    }),

  getSimilarTransactions: protectedProcedure
    .input(getSimilarTransactionsSchema)
    .query(async ({ input, ctx: { db, teamId } }) => {
      return getSimilarTransactions(db, {
        name: input.name,
        categorySlug: input.categorySlug,
        frequency: input.frequency,
        teamId: teamId!,
        transactionId: input.transactionId,
      });
    }),

  searchTransactionMatch: protectedProcedure
    .input(searchTransactionMatchSchema)
    .query(async ({ input, ctx: { db, teamId } }) => {
      return searchTransactionMatch(db, {
        query: input.query,
        teamId: teamId!,
        inboxId: input.inboxId,
        maxResults: input.maxResults,
        minConfidenceScore: input.minConfidenceScore,
        includeAlreadyMatched: input.includeAlreadyMatched,
      });
    }),

  create: protectedProcedure
    .input(createTransactionSchema)
    .mutation(async ({ input, ctx: { db, teamId } }) => {
      const transaction = await createTransaction(db, {
        ...input,
        teamId: teamId!,
      });

      // Trigger embedding for the newly created manual transaction
      if (transaction?.id) {
        tasks.trigger("embed-transaction", {
          transactionIds: [transaction.id],
          teamId: teamId!,
        } satisfies EmbedTransactionPayload);
      }

      return transaction;
    }),
});
</file>

<file path="apps/api/src/trpc/routers/user.ts">
import { updateUserSchema } from "@api/schemas/users";
import { resend } from "@api/services/resend";
import { createTRPCRouter, protectedProcedure } from "@api/trpc/init";
import {
  deleteUser,
  getUserById,
  getUserInvites,
  updateUser,
} from "@midday/db/queries";

export const userRouter = createTRPCRouter({
  me: protectedProcedure.query(async ({ ctx: { db, session } }) => {
    return getUserById(db, session.user.id);
  }),

  update: protectedProcedure
    .input(updateUserSchema)
    .mutation(async ({ ctx: { db, session }, input }) => {
      return updateUser(db, {
        id: session.user.id,
        ...input,
      });
    }),

  delete: protectedProcedure.mutation(
    async ({ ctx: { supabase, db, session } }) => {
      const [data] = await Promise.all([
        deleteUser(db, session.user.id),
        supabase.auth.admin.deleteUser(session.user.id),
        resend.contacts.remove({
          email: session.user.email!,
          audienceId: process.env.RESEND_AUDIENCE_ID!,
        }),
      ]);

      return data;
    },
  ),

  invites: protectedProcedure.query(async ({ ctx: { db, session } }) => {
    if (!session.user.email) {
      return [];
    }

    return getUserInvites(db, session.user.email);
  }),
});
</file>

<file path="apps/api/src/trpc/init.ts">
import { createClient } from "@api/services/supabase";
import { verifyAccessToken } from "@api/utils/auth";
import type { Session } from "@api/utils/auth";
import { getGeoContext } from "@api/utils/geo";
import type { Database } from "@midday/db/client";
import { connectDb } from "@midday/db/client";
import type { SupabaseClient } from "@supabase/supabase-js";
import { TRPCError, initTRPC } from "@trpc/server";
import type { Context } from "hono";
import superjson from "superjson";
import { withPrimaryReadAfterWrite } from "./middleware/primary-read-after-write";
import { withTeamPermission } from "./middleware/team-permission";

type TRPCContext = {
  session: Session | null;
  supabase: SupabaseClient;
  db: Database;
  geo: ReturnType<typeof getGeoContext>;
  teamId?: string;
};

export const createTRPCContext = async (
  _: unknown,
  c: Context,
): Promise<TRPCContext> => {
  const accessToken = c.req.header("Authorization")?.split(" ")[1];
  const session = await verifyAccessToken(accessToken);
  const supabase = await createClient(accessToken);
  const db = await connectDb();
  const geo = getGeoContext(c.req);

  return {
    session,
    supabase,
    db,
    geo,
  };
};

const t = initTRPC.context<TRPCContext>().create({
  transformer: superjson,
});

export const createTRPCRouter = t.router;
export const createCallerFactory = t.createCallerFactory;

const withPrimaryDbMiddleware = t.middleware(async (opts) => {
  return withPrimaryReadAfterWrite({
    ctx: opts.ctx,
    type: opts.type,
    next: opts.next,
  });
});

const withTeamPermissionMiddleware = t.middleware(async (opts) => {
  return withTeamPermission({
    ctx: opts.ctx,
    next: opts.next,
  });
});

export const publicProcedure = t.procedure.use(withPrimaryDbMiddleware);

export const protectedProcedure = t.procedure
  .use(withTeamPermissionMiddleware) // NOTE: This is needed to ensure that the teamId is set in the context
  .use(withPrimaryDbMiddleware)
  .use(async (opts) => {
    const { teamId, session } = opts.ctx;

    if (!session) {
      throw new TRPCError({ code: "UNAUTHORIZED" });
    }

    return opts.next({
      ctx: {
        teamId,
        session,
      },
    });
  });
</file>

<file path="apps/api/src/utils/auth.ts">
import { type JWTPayload, jwtVerify } from "jose";

export type Session = {
  user: {
    id: string;
    email?: string;
    full_name?: string;
  };
  teamId?: string;
};

type SupabaseJWTPayload = JWTPayload & {
  user_metadata?: {
    email?: string;
    full_name?: string;
    [key: string]: string | undefined;
  };
};

export async function verifyAccessToken(
  accessToken?: string,
): Promise<Session | null> {
  if (!accessToken) return null;

  try {
    const { payload } = await jwtVerify(
      accessToken,
      new TextEncoder().encode(process.env.SUPABASE_JWT_SECRET),
    );

    const supabasePayload = payload as SupabaseJWTPayload;

    return {
      user: {
        id: supabasePayload.sub!,
        email: supabasePayload.user_metadata?.email,
        full_name: supabasePayload.user_metadata?.full_name,
      },
    };
  } catch (error) {
    return null;
  }
}
</file>

<file path="apps/api/src/utils/geo.ts">
import type { HonoRequest } from "hono";

export function getGeoContext(req: HonoRequest) {
  const headers = req.header();

  const country = headers["x-user-country"]?.toUpperCase() ?? null;
  const locale = headers["x-user-locale"] ?? null;
  const timezone = headers["x-user-timezone"] ?? null;
  const ip = headers["x-forwarded-for"] ?? null;

  return {
    country,
    locale,
    timezone,
    ip,
  };
}
</file>

<file path="apps/api/src/utils/health.ts">
import { checkHealth as checkDbHealth } from "@midday/db/utils/health";

export async function checkHealth(): Promise<void> {
  await checkDbHealth();
}
</file>

<file path="apps/api/src/utils/oauth.ts">
import { timingSafeEqual } from "node:crypto";
import { hash } from "@midday/encryption";

export type OAuthApplication = {
  id: string;
  active: boolean | null;
  clientSecret: string;
};

export function validateClientCredentials(
  application: OAuthApplication | null | undefined,
  clientSecret: string,
): boolean {
  if (!application || !application.active) {
    return false;
  }

  const hashedSecret = hash(clientSecret);
  const storedSecret = application.clientSecret;

  // Use timing-safe comparison to prevent timing attacks
  return timingSafeEqual(Buffer.from(storedSecret), Buffer.from(hashedSecret));
}
</file>

<file path="apps/api/src/utils/parse.ts">
export function parseInputValue(value?: string | null) {
  if (value === null) return null;
  return value ? JSON.parse(value) : undefined;
}
</file>

<file path="apps/api/src/utils/polar.ts">
import { Polar } from "@polar-sh/sdk";

export const api = new Polar({
  accessToken: process.env.POLAR_ACCESS_TOKEN!,
  server: process.env.POLAR_ENVIRONMENT as "production" | "sandbox",
});
</file>

<file path="apps/api/src/utils/scopes.ts">
export const SCOPES = [
  "bank-accounts.read",
  "bank-accounts.write",
  "customers.read",
  "customers.write",
  "documents.read",
  "documents.write",
  "inbox.read",
  "inbox.write",
  "invoices.read",
  "invoices.write",
  "reports.read",
  "search.read",
  "tags.read",
  "tags.write",
  "teams.read",
  "teams.write",
  "tracker-entries.read",
  "tracker-entries.write",
  "tracker-projects.read",
  "tracker-projects.write",
  "transactions.read",
  "transactions.write",
  "users.read",
  "users.write",
  "notifications.read",
  "notifications.write",
  "apis.all", // All API scopes
  "apis.read", // All read scopes
] as const;

export type Scope = (typeof SCOPES)[number];
export type ScopePreset = "all_access" | "read_only" | "restricted";

export const scopePresets = [
  {
    value: "all_access",
    label: "All",
    description: "full access to all resources",
  },
  {
    value: "read_only",
    label: "Read Only",
    description: "read-only access to all resources",
  },
  {
    value: "restricted",
    label: "Restricted",
    description: "restricted access to some resources",
  },
];

export const scopesToName = (scopes: string[]) => {
  if (scopes.includes("apis.all")) {
    return {
      name: "All access",
      description: "full access to all resources",
      preset: "all_access",
    };
  }

  if (scopes.includes("apis.read")) {
    return {
      name: "Read-only",
      description: "read-only access to all resources",
      preset: "read_only",
    };
  }

  return {
    name: "Restricted",
    description: "restricted access to some resources",
    preset: "restricted",
  };
};

export const expandScopes = (scopes: string[]): string[] => {
  if (scopes.includes("apis.all")) {
    // Return all scopes except any that start with "apis."
    return SCOPES.filter((scope) => !scope.startsWith("apis."));
  }

  if (scopes.includes("apis.read")) {
    // Return all read scopes except any that start with "apis."
    return SCOPES.filter(
      (scope) => scope.endsWith(".read") && !scope.startsWith("apis."),
    );
  }

  // For custom scopes, filter out any "apis." scopes
  return scopes.filter((scope) => !scope.startsWith("apis."));
};
</file>

<file path="apps/api/src/utils/search-filters.ts">
import { openai } from "@ai-sdk/openai";
import { generateObject } from "ai";
import { z } from "zod";

const schema = z.object({
  searchTerm: z.string().describe("The query to search for"),
  startDate: z
    .string()
    .optional()
    .describe("The start date when to retrieve from. Return ISO-8601 format."),
  endDate: z
    .string()
    .optional()
    .describe(
      "The end date when to retrieve data from. If not provided, defaults to the current date. Return ISO-8601 format.",
    ),
  types: z
    .array(
      z.enum([
        "transactions",
        "invoices",
        "tracker_projects",
        "customers",
        "documents",
      ]),
    )
    .describe("The type of the items to search for"),
  amount: z
    .number()
    .optional()
    .describe(
      "The exact amount to search for if the type is transactions or invoices.",
    ),
  amountMin: z
    .number()
    .optional()
    .describe("Minimum amount filter for transactions or invoices."),
  amountMax: z
    .number()
    .optional()
    .describe("Maximum amount filter for transactions or invoices."),
  status: z
    .enum(["paid", "unpaid", "overdue", "draft"])
    .optional()
    .describe(
      "The status filter (e.g. 'paid', 'unpaid', 'overdue', 'draft') for invoices or projects.",
    ),
  currency: z
    .string()
    .optional()
    .describe("The currency code to filter by (e.g., 'USD', 'EUR')."),
  language: z
    .string()
    .describe(
      "The language to search in based on the query. Return in PostgreSQL text search configuration name (e.g., 'english', 'swedish', 'german', 'french').",
    ),
  dueDateStart: z
    .string()
    .optional()
    .describe("Start date for invoice due dates (ISO-8601)."),
  dueDateEnd: z
    .string()
    .optional()
    .describe("End date for invoice due dates (ISO-8601)."),
});

export async function generateLLMFilters(
  query: string,
): Promise<z.infer<typeof schema>> {
  const { object } = await generateObject({
    model: openai("gpt-4o-mini"),
    system: `You are an AI assistant that converts natural language search queries into structured search filters.

Current date: ${new Date().toISOString().split("T")[0]}

GUIDELINES:
- Extract search terms, date ranges, amounts, and other filters from the query
- When dates are mentioned but incomplete (like "March" or "last year"), infer reasonable date ranges
- For currency values, default to the user's local currency if not specified
- Choose appropriate types based on the query context:
  * "transactions" for money movements, payments, expenses
  * "invoices" are for user created invoices, "Unpaid invoices for customer X"
  * "tracker_projects" for work items, tasks, projects
  * "customers" for client or customer information
  * "documents" for files, attachments, contracts, receipts, bills, invoices etc, but also in the query like "invoices from vendor X"

EXAMPLES:
- "show me invoices from last month" → {types: ["documents"], startDate: "2023-05-01", endDate: "2023-05-31", language: "english"}
- "show me invoices from vendor X" → {types: ["documents"], searchTerm: "vendor X", language: "english"}
- "unpaid invoices for customer X" → {types: ["invoices"], searchTerm: "customer X", status: "unpaid", language: "english"}
- "paid invoices last week" → {types: ["invoices"], status: "paid", startDate: "2023-05-01", endDate: "2023-05-31", language: "english"}
- "transactions with Apple between January and March" → {types: ["transactions"], searchTerm: "Apple", startDate: "2024-01-01", endDate: "2024-03-31", language: "english"}

For language, detect the appropriate language of the query for PostgreSQL text search.
`,
    schema,
    prompt: query,
  });

  return object;
}
</file>

<file path="apps/api/src/utils/search.ts">
export const buildSearchQuery = (input: string) => {
  return input
    .trim()
    .split(/\s+/)
    .map((term) => `${term.toLowerCase()}:*`)
    .join(" & ");
};
</file>

<file path="apps/api/src/utils/validate-response.ts">
import { logger } from "@midday/logger";
import type { ZodSchema } from "zod";

export const validateResponse = (data: any, schema: ZodSchema) => {
  const result = schema.safeParse(data);

  if (!result.success) {
    const cause = result.error.flatten();

    logger.error(cause);

    return {
      success: false,
      error: "Response validation failed",
      details: cause,
      data: null,
    };
  }

  return result.data;
};
</file>

<file path="apps/api/src/index.ts">
import { trpcServer } from "@hono/trpc-server";
import { OpenAPIHono } from "@hono/zod-openapi";
import { Scalar } from "@scalar/hono-api-reference";
import { cors } from "hono/cors";
import { secureHeaders } from "hono/secure-headers";
import { routers } from "./rest/routers";
import type { Context } from "./rest/types";
import { createTRPCContext } from "./trpc/init";
import { appRouter } from "./trpc/routers/_app";
import { checkHealth } from "./utils/health";

const app = new OpenAPIHono<Context>();

app.use(secureHeaders());

app.use(
  "*",
  cors({
    origin: process.env.ALLOWED_API_ORIGINS?.split(",") ?? [],
    allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
    allowHeaders: [
      "Authorization",
      "Content-Type",
      "accept-language",
      "x-trpc-source",
      "x-user-locale",
      "x-user-timezone",
      "x-user-country",
    ],
    exposeHeaders: ["Content-Length"],
    maxAge: 86400,
  }),
);

app.use(
  "/trpc/*",
  trpcServer({
    router: appRouter,
    createContext: createTRPCContext,
  }),
);

app.get("/health", async (c) => {
  try {
    await checkHealth();

    return c.json({ status: "ok" }, 200);
  } catch (error) {
    return c.json(
      {
        status: "error",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      500,
    );
  }
});

app.doc("/openapi", {
  openapi: "3.1.0",
  info: {
    version: "0.0.1",
    title: "Midday API",
    description:
      "Midday is a platform for Invoicing, Time tracking, File reconciliation, Storage, Financial Overview & your own Assistant.",
    contact: {
      name: "Midday Support",
      email: "engineer@midday.ai",
      url: "https://midday.ai",
    },
    license: {
      name: "AGPL-3.0 license",
      url: "https://github.com/midday-ai/midday/blob/main/LICENSE",
    },
  },
  servers: [
    {
      url: "https://api.midday.ai",
      description: "Production API",
    },
  ],
  security: [
    {
      oauth2: [],
    },
    { token: [] },
  ],
});

// Register security scheme
app.openAPIRegistry.registerComponent("securitySchemes", "token", {
  type: "http",
  scheme: "bearer",
  description: "Default authentication mechanism",
  "x-speakeasy-example": "MIDDAY_API_KEY",
});

app.get(
  "/",
  Scalar({ url: "/openapi", pageTitle: "Midday API", theme: "saturn" }),
);

app.route("/", routers);

export default {
  port: process.env.PORT ? Number.parseInt(process.env.PORT) : 3000,
  fetch: app.fetch,
  host: "::", // Listen on all interfaces
};
</file>

<file path="apps/api/.dockerignore">
# Node modules
node_modules

# Build outputs
.next
dist
build

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Other app directories not needed for API
apps/dashboard
apps/docs
apps/website

# Environment files
.env.local
.env.development.local
.env.test.local
.env.production.local

# System files
.DS_Store
*.pem

# Cache
.turbo
</file>

<file path="apps/api/.env-template">
# Resend
RESEND_API_KEY=

# Supabase
SUPABASE_JWT_SECRET=
SUPABASE_SERVICE_KEY=
SUPABASE_URL=

# Supabase - Database
DATABASE_PRIMARY_URL="" # (Frankfurt)
DATABASE_FRA_URL="" # (Frankfurt)
DATABASE_SJC_URL="" # (San Jose)
DATABASE_IAD_URL="" # (North Virginia)
DATABASE_PRIMARY_POOLER_URL=

# Used in drizzle-kit
DATABASE_SESSION_POOLER=

# Engine
ENGINE_API_URL=
ENGINE_API_KEY=

# LLMS
OPENAI_API_KEY=

# Config
ALLOWED_API_ORIGINS="http://localhost:3001"
LOG_LEVEL=debug
INVOICE_JWT_SECRET=
MIDDAY_ENCRYPTION_KEY=
MIDDAY_DASHBOARD_URL="http://localhost:3001"

# Trigger
TRIGGER_PROJECT_ID=
TRIGGER_SECRET_KEY=

# Polar
POLAR_ACCESS_TOKEN=
POLAR_ENVIRONMENT=sandbox

# Environment
NODE_ENV=development

# Redis
REDIS_URL=redis://localhost:6379

# Google
GOOGLE_GENERATIVE_AI_API_KEY=
</file>

<file path="apps/api/Dockerfile">
# Base image with Bun
FROM oven/bun:1.2.21 AS base

# Install turbo CLI globally using Bun
FROM base AS turbo-cli
RUN bun add -g turbo

# Builder stage
FROM turbo-cli AS builder
WORKDIR /app
# Copy all files
COPY . .
# Use turbo CLI from Bun global install to prune workspaces
RUN turbo prune @midday/api --docker

# Installer stage
FROM base AS installer
WORKDIR /app

# First install the dependencies (as they change less often)
COPY --from=builder /app/out/json/ .
# Don't copy the lockfile, allow Bun to generate a fresh one
RUN bun install

# Copy the full source code
COPY --from=builder /app/out/full/ .

# Copy the prebuilt engine dist from the build context (assumes CI built it)
COPY apps/engine/dist /app/apps/engine/dist

# Runner stage (same as installer to avoid another copy)
FROM installer AS runner

# Set the API directory as working directory
WORKDIR /app/apps/api

# Set environment variables
ENV NODE_ENV=production

# Expose the port the API runs on
EXPOSE 3000

# Run the API directly with Bun
CMD ["bun", "run", "src/index.ts"]
</file>

<file path="apps/api/fly-preview.yml">
app = "midday-api-staging"
primary_region = 'fra'

[build]

[env]
  PORT = '8080'

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = 'off'
  auto_start_machines = true
  min_machines_running = 3
  processes = ['app']

  [[http_service.checks]]
    grace_period = "10s"
    interval = "45s"
    method = "GET"
    timeout = "10s"
    path = "/health"

[[vm]]
  memory = '2gb'
  cpu_kind = 'shared'
  cpus = 1
</file>

<file path="apps/api/fly.toml">
app = 'midday-api'
primary_region = 'fra'

[build]

[env]
  PORT = '8080'

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = 'off'
  auto_start_machines = true
  min_machines_running = 6
  processes = ['app']

  [[http_service.checks]]
    grace_period = "10s"
    interval = "45s"
    method = "GET"
    timeout = "10s"
    path = "/health"

[[vm]]
  memory = '4gb'
  cpu_kind = 'shared'
  cpus = 2
</file>

<file path="apps/api/package.json">
{
  "name": "@midday/api",
  "scripts": {
    "dev": "TZ=UTC PORT=3003 bun run --hot src/index.ts",
    "lint": "biome check .",
    "lint:fix": "biome check --write .",
    "format": "biome format --write .",
    "typecheck": "tsc --noEmit",
    "test": "bun test",
    "test:watch": "bun test --watch"
  },
  "exports": {
    "./trpc/routers/_app": "./src/trpc/routers/_app.ts"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.3.22",
    "@hono/trpc-server": "^0.4.0",
    "@hono/zod-openapi": "^0.19.8",
    "@hono/zod-validator": "^0.7.0",
    "@midday/cache": "workspace:*",
    "@midday/categories": "workspace:*",
    "@midday/db": "workspace:*",
    "@midday/documents": "workspace:*",
    "@midday/encryption": "workspace:*",
    "@midday/engine": "workspace:*",
    "@midday/engine-client": "workspace:*",
    "@midday/inbox": "workspace:*",
    "@midday/invoice": "workspace:*",
    "@midday/jobs": "workspace:*",
    "@midday/location": "workspace:*",
    "@midday/logger": "workspace:*",
    "@midday/notifications": "workspace:*",
    "@midday/supabase": "workspace:*",
    "@polar-sh/sdk": "^0.34.9",
    "@scalar/hono-api-reference": "^0.9.4",
    "@sindresorhus/slugify": "^2.2.1",
    "@trigger.dev/sdk": "4.0.1",
    "@trpc/server": "^11.5.0",
    "ai": "^4.3.19",
    "camelcase-keys": "^9.1.3",
    "date-fns": "^4.1.0",
    "hono": "^4.8.12",
    "hono-rate-limiter": "^0.4.2",
    "jose": "^6.0.11",
    "nanoid": "^5.1.5",
    "pino": "^9.7.0",
    "postgres": "^3.4.7",
    "resend": "^4.6.0",
    "snakecase-keys": "^8.0.1",
    "superjson": "^2.2.2",
    "uuid": "^11.1.0",
    "zod": "3.25.64",
    "zod-openapi": "^4.2.4"
  },
  "devDependencies": {
    "@types/bun": "^1.2.16"
  }
}
</file>

<file path="apps/api/README.md">
## API

### Environment Variables

The API requires the following environment variables:

#### Redis Configuration
```bash
# Local development (Docker):
REDIS_URL=redis://localhost:6379

# Production (Upstash Redis via Fly.io):
# REDIS_URL=rediss://:password@fly-midday-redis.upstash.io:6379
```

#### Local Development Setup

1. **Start Redis with Docker:**
   ```bash
   docker run -d --name redis -p 6379:6379 redis:alpine
   ```

2. **Set environment variable:**
   ```bash
   export REDIS_URL=redis://localhost:6379
   ```

3. **Test Redis connection:**
   ```bash
   bun run packages/cache/src/test-redis.ts
   ```

#### Database Configuration
```bash
DATABASE_URL=postgresql://...
DATABASE_READ_URL=postgresql://... # Optional: read replica URL
```

### Development

```bash
bun dev
```

### Production

```bash
bun start
```

### Cache Implementation

The API uses Redis for distributed caching across multiple server instances:

- **apiKeyCache**: Caches API key lookups (30 min TTL)
- **userCache**: Caches user data (30 min TTL)
- **teamCache**: Caches team access permissions (30 min TTL)
- **teamPermissionsCache**: Caches team permission lookups (30 min TTL)
- **replicationCache**: Tracks recent mutations for read-after-write consistency (10 sec TTL)

#### Environment-Specific Configuration

The Redis client automatically configures itself based on the environment:

**Production (Fly.io):**
- Handles IPv6 connections
- Longer connection timeouts (10s)
- Higher retry attempts (10)
- TLS support for Upstash Redis

**Development (Local):**
- IPv4 connections
- Shorter timeouts (5s)
- Fewer retries (3)
- No idle timeout

This ensures cache consistency across multiple stateful servers and eliminates the "No procedure found" TRPC errors caused by cache misses.
</file>

<file path="apps/api/tsconfig.json">
{
  "compilerOptions": {
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "allowJs": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false,
    "jsx": "react-jsx",
    "jsxImportSource": "react",
    "baseUrl": ".",
    "paths": {
      "@api/*": ["src/*"],
      "@engine/*": ["../engine/src/*"],
      "@jobs/*": ["../../packages/jobs/src/*"],
      "@db/*": ["../../packages/db/src/*"]
    },
    "types": ["bun-types"]
  },
  "exclude": ["node_modules"],
  "include": ["src/**/*.ts"]
}
</file>

</files>
