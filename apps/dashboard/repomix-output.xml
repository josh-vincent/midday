This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: apps/dashboard
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
apps/
  dashboard/
    public/
      assets/
        setup-animation-dark.json
        setup-animation.json
    src/
      actions/
        ai/
          editor/
            generate-editor-content.ts
          filters/
            generate-invoice-filters.ts
            generate-tracker-filters.ts
            generate-transactions-filters.ts
            generate-vault-filters.ts
          generate-csv-mapping.ts
          get-tax-rate.ts
        institutions/
          create-enablebanking-link.ts
          create-gocardless-link.ts
          create-plaid-link.ts
          exchange-public-token.ts
          reconnect-enablebanking-link.ts
          reconnect-gocardless-link.ts
        transactions/
          import-transactions.ts
          manual-sync-transactions-action.ts
          reconnect-connection-action.ts
        export-transactions-action.ts
        hide-connect-flow-action.ts
        mfa-verify-action.ts
        revalidate-action.ts
        safe-action.ts
        send-feedback-action.ts
        send-support-action.tsx
        set-weekly-calendar-action.ts
        tracking-consent-action.ts
        unenroll-mfa-action.ts
        update-column-visibility-action.ts
        verify-otp-action.ts
      app/
        [locale]/
          (app)/
            (sidebar)/
              account/
                date-and-locale/
                  page.tsx
                security/
                  page.tsx
                support/
                  page.tsx
                teams/
                  page.tsx
                layout.tsx
                page.tsx
              apps/
                page.tsx
              customers/
                page.tsx
              inbox/
                settings/
                  page.tsx
                page.tsx
              invoices/
                page.tsx
              settings/
                accounts/
                  page.tsx
                billing/
                  page.tsx
                developer/
                  page.tsx
                members/
                  page.tsx
                notifications/
                  page.tsx
                layout.tsx
                page.tsx
              tracker/
                page.tsx
              transactions/
                categories/
                  page.tsx
                page.tsx
              vault/
                page.tsx
              layout.tsx
              page.tsx
            desktop/
              checkout/
                success/
                  page.tsx
              search/
                page.tsx
            mfa/
              setup/
                page.tsx
              verify/
                page.tsx
            oauth/
              authorize/
                page.tsx
              layout.tsx
            setup/
              page.tsx
            teams/
              create/
                page.tsx
              page.tsx
          (public)/
            all-done/
              event-emitter.tsx
              page.tsx
              schema.ts
            i/
              [token]/
                opengraph-image.tsx
                page.tsx
            login/
              page.tsx
            s/
              [shortId]/
                page.tsx
            verify/
              page.tsx
          error.tsx
          layout.tsx
          not-found.tsx
          providers.tsx
        api/
          apps/
            slack/
              install-url/
                route.ts
              interactive/
                route.ts
              oauth_callback/
                route.ts
          auth/
            callback/
              route.ts
          chat/
            route.ts
          checkout/
            success/
              route.ts
            route.ts
          connector/
            callback/
              route.ts
          download/
            file/
              route.ts
            invoice/
              route.ts
          enablebanking/
            session/
              route.ts
          gocardless/
            reconnect/
              route.ts
          portal/
            route.ts
          preview/
            route.ts
          proxy/
            route.ts
          webhook/
            inbox/
              route.ts
            plaid/
              route.ts
            polar/
              route.ts
            registered/
              route.ts
            teller/
              route.ts
        global-error.tsx
      components/
        assistant/
          assistant-modal.tsx
          header.tsx
          index.tsx
          toolbar.tsx
        base-currency/
          base-currency.tsx
          select-currency.tsx
        charts/
          area-chart.tsx
          bar-chart.tsx
          burn-rate-chart.tsx
          chart-filters.tsx
          chart-period.tsx
          chart-selectors.tsx
          chart-type.tsx
          charts.tsx
          data.ts
          empty-state.tsx
          expense-chart.tsx
          profit-chart.tsx
          revenue-chart.tsx
          stacked-bar-chart.tsx
          status.tsx
        chat/
          tools/
            burn-rate/
              burn-rate.tsx
            documents/
              documents.tsx
            inbox/
              inbox.tsx
            profit/
              profit.tsx
            revenue/
              revenue.tsx
            transactions/
              show-more-buttont.tsx
              skeleton.tsx
              transactions.tsx
          chat-avatar.tsx
          chat-empty.tsx
          chat-examples.tsx
          chat-footer.tsx
          chat-input.tsx
          examples.ts
          index.tsx
          markdown.tsx
          message.tsx
          messages.tsx
          spinner.tsx
        forms/
          api-key-form.tsx
          create-team-form.tsx
          customer-form.tsx
          invite-form.tsx
          oauth-application-form.tsx
          tracker-entries-form.tsx
          tracker-project-form.tsx
          transaction-create-form.tsx
        inbox/
          connect-gmail.tsx
          delete-inbox-account.tsx
          inbox-actions.tsx
          inbox-connected-accounts-skeleton.tsx
          inbox-connected-accounts.tsx
          inbox-details-skeleton.tsx
          inbox-details.tsx
          inbox-email-settings.tsx
          inbox-empty.tsx
          inbox-get-started.tsx
          inbox-header.tsx
          inbox-item.tsx
          inbox-list-skeleton.tsx
          inbox-ordering.tsx
          inbox-search.tsx
          inbox-skeleton.tsx
          inbox-status.tsx
          inbox-upload-zone.tsx
          inbox-view.tsx
          index.tsx
          match-transaction.tsx
          suggested-match.tsx
          sync-inbox-account.tsx
          transaction-match-item.tsx
          transaction-unmatch-item.tsx
        invoice/
          activity.tsx
          amount-input.tsx
          customer-details.tsx
          description.tsx
          due-date.tsx
          edit-block.tsx
          editor.tsx
          form-context.tsx
          form.tsx
          from-details.tsx
          input.tsx
          invoice-no.tsx
          invoice-title.tsx
          issue-date.tsx
          label-input.tsx
          line-items.tsx
          logo.tsx
          meta.tsx
          note-details.tsx
          payment-details.tsx
          quantity-input.tsx
          settings-menu.tsx
          submit-button.tsx
          summary.tsx
          tax-input.tsx
          utils.ts
          vat-input.tsx
        modals/
          import-modal/
            context.tsx
            field-mapping.tsx
            index.tsx
            select-file.tsx
            utils.ts
          add-new-device.tsx
          choose-plan-modal.tsx
          connect-transactions-modal.tsx
          create-api-key-modal.tsx
          create-categories-modal.tsx
          create-sub-category-modal.tsx
          delete-api-key-modal.tsx
          delete-oauth-application-modal.tsx
          edit-api-key-modal.tsx
          edit-bank-account-modal.tsx
          edit-category-modal.tsx
          edit-inbox-modal.tsx
          invite-team-members-modal.tsx
          oauth-secret-modal.tsx
          overview-modal.tsx
          select-bank-accounts.tsx
          transactions-modal.tsx
          trial-ended-modal.tsx
        notification-center/
          empty-state.tsx
          index.ts
          notification-center.tsx
          notification-descriptions.ts
          notification-item.tsx
          notification-link.tsx
        oauth/
          oauth-consent-screen.tsx
          oauth-error-message.tsx
        search/
          open-search-button.tsx
          search-footer.tsx
          search-modal.tsx
          search.tsx
        sheets/
          customer-create-sheet.tsx
          customer-edit-sheet.tsx
          document-sheet.tsx
          global-sheets.tsx
          inbox-details-sheet.tsx
          invoice-details-sheet.tsx
          invoice-sheet.tsx
          oauth-application-create-sheet.tsx
          oauth-application-edit-sheet.tsx
          tracker-create-sheet.tsx
          tracker-schedule-sheet.tsx
          tracker-update-sheet.tsx
          transaction-create-sheet.tsx
          transaction-sheet.tsx
        tables/
          api-keys/
            columns.tsx
            empty-state.tsx
            index.tsx
          categories/
            columns.tsx
            header.tsx
            skeleton.tsx
            table.tsx
          customers/
            columns.tsx
            data-table.tsx
            empty-states.tsx
            row.tsx
            skeleton.tsx
            table-header.tsx
          invoices/
            actions-menu.tsx
            columns.tsx
            data-table.tsx
            empty-states.tsx
            row.tsx
            skeleton.tsx
            table-header.tsx
          members/
            columns.tsx
            index.tsx
          oauth-applications/
            columns.tsx
            empty-state.tsx
            index.tsx
          orders/
            actions-menu.tsx
            data-table.tsx
            index.tsx
            skeleton.tsx
            table-header.tsx
          pending-invites/
            columns.tsx
            index.tsx
            skeleton.tsx
            table-header.tsx
          select-team/
            table-row.tsx
            table.tsx
          teams/
            columns.tsx
            index.tsx
            invites.tsx
            skeleton.tsx
            table-header.tsx
            table.tsx
          tracker/
            data-table-header.tsx
            data-table-row.tsx
            empty-states.tsx
            index.tsx
            loading.tsx
          transactions/
            bottom-bar.tsx
            columns.tsx
            data-table-header.tsx
            data-table.tsx
            empty-states.tsx
            export-bar.tsx
            loading.tsx
          vault/
            bottom-bar.tsx
            columns.tsx
            data-table-header.tsx
            data-table-skeleton.tsx
            data-table.tsx
        tracker/
          calendar-day.tsx
          calendar-header.tsx
          calendar-month-view.tsx
          calendar-week-view.tsx
          events.tsx
          utils.ts
        vault/
          empty-states.tsx
          vault-actions.tsx
          vault-get-started.tsx
          vault-grid-skeleton.tsx
          vault-grid.tsx
          vault-header.tsx
          vault-item-actions.tsx
          vault-item-skeleton.tsx
          vault-item-tags.tsx
          vault-item.tsx
          vault-related-files-skeleton.tsx
          vault-related-files.tsx
          vault-search-filter.tsx
          vault-select-tags.tsx
          vault-skeleton.tsx
          vault-upload-button.tsx
          vault-upload-zone.tsx
          vault-view-switch.tsx
          vault-view.tsx
        widgets/
          account-balance/
            account-balance-widget.tsx
            account-balance.tsx
            index.tsx
          assistant/
            assistant-input.tsx
            assistant-list.tsx
            assistant-widget.tsx
            index.tsx
          inbox/
            data.ts
            inbox-header.tsx
            inbox-list.tsx
            inbox-widget.tsx
            index.tsx
          invoice/
            empty-state.tsx
            index.tsx
            invoice-header.tsx
            invoice-row.tsx
            invoice-widget.tsx
            invoice.tsx
            skeleton.tsx
          spending/
            data.ts
            index.tsx
            skeleton.tsx
            spending-category-item.tsx
            spending-category-list.tsx
            spending-list.tsx
            spending-period.tsx
          tracker/
            index.tsx
            tracker-header.tsx
            tracker-indicator.tsx
            tracker-widget.tsx
          transactions/
            data.ts
            skeleton.tsx
            transaction-list-header.tsx
            transaction-list-item.tsx
            transactions-item-list.tsx
            transactions-list.tsx
            transactions-period.tsx
            transactions.tsx
          vault/
            index.tsx
            vault-header.tsx
            vault-widget.tsx
            vault.tsx
          index.tsx
          navigation.tsx
        account-settings.tsx
        add-account-button.tsx
        add-transactions.tsx
        amount-range.tsx
        animated-number.tsx
        app-settings.tsx
        app.tsx
        apple-sign-in.tsx
        apps-header.tsx
        apps-tabs.tsx
        apps.skeleton.tsx
        apps.tsx
        assign-user.tsx
        assigned-user.tsx
        attachment-item.tsx
        avatar-upload.tsx
        average-days-to-payment.tsx
        average-invoice-size.tsx
        bank-account-list-skeleton.tsx
        bank-account-list.tsx
        bank-account.tsx
        bank-connect-button.tsx
        bank-connections.tsx
        bank-logo.tsx
        bulk-actions.tsx
        category.tsx
        change-email.tsx
        change-theme.tsx
        change-timezone.tsx
        checkout-success-desktop.tsx
        choose-plan-button.tsx
        color-picker.tsx
        company-country.tsx
        company-email.tsx
        company-logo.tsx
        company-name.tsx
        connect-bank-provider.tsx
        connected-accounts.tsx
        connection-status.tsx
        consent-banner.tsx
        copy-input.tsx
        country-selector.tsx
        customer-header.tsx
        customers-header.tsx
        date-format-settings.tsx
        delete-account.tsx
        delete-connection.tsx
        delete-team.tsx
        desktop-header.tsx
        desktop-provider.tsx
        desktop-sign-in-verify-code.tsx
        desktop-traffic-light.tsx
        display-name.tsx
        document-actions.tsx
        document-details-skeleton.tsx
        document-details.tsx
        document-tags.tsx
        enablebanking-connect.tsx
        enroll-mfa.tsx
        error-fallback.tsx
        export-status.tsx
        feedback-form.tsx
        file-preview-icon.tsx
        file-preview.tsx
        file-viewer.tsx
        filter-list.tsx
        format-amount.tsx
        github-sign-in.tsx
        global-timer-indicator.tsx
        global-timer-provider.tsx
        gocardless-connect.tsx
        google-sign-in.tsx
        header.tsx
        horizontal-pagination.tsx
        image-viewer.tsx
        inactive-clients.tsx
        inbox-sheet-details.tsx
        input-color.tsx
        institution-info.tsx
        invoice-actions.tsx
        invoice-column-visibility.tsx
        invoice-content.tsx
        invoice-details-skeleton.tsx
        invoice-details.tsx
        invoice-header.tsx
        invoice-note.tsx
        invoice-payment-score.tsx
        invoice-search-filter.tsx
        invoice-sheet-header.tsx
        invoice-status.tsx
        invoice-success.tsx
        invoice-summary.tsx
        invoice-toolbar.tsx
        invoices-open.tsx
        invoices-overdue.tsx
        invoices-paid.tsx
        load-more.tsx
        loading-transactions-event.tsx
        locale-settings.tsx
        logo-upload.tsx
        main-menu.tsx
        manage-subscription.tsx
        manual-accounts.tsx
        markdown.tsx
        mfa-list.tsx
        mfa-settings-list.tsx
        mobile-menu.tsx
        most-active-client.tsx
        new-customers-this-month.tsx
        note.tsx
        notification-setting.tsx
        notification-settings.tsx
        notifications-settings-list.tsx
        oauth-application-status-badge.tsx
        open-customer-sheet.tsx
        open-invoice-sheet.tsx
        open-tracker-sheet.tsx
        open-url.tsx
        order-status.tsx
        orders.tsx
        otp-sign-in.tsx
        payment-score-visualizer.tsx
        pdf-viewer.tsx
        plans.tsx
        project-members.tsx
        reconnect-provider.tsx
        remove-mfa-button.tsx
        scope-selector.tsx
        search-address-input.tsx
        search-customers.tsx
        search-field.tsx
        secondary-menu.tsx
        select-account.tsx
        select-attachment.tsx
        select-category.tsx
        select-currency.tsx
        select-customer.tsx
        select-tags.tsx
        select-tax-type.tsx
        select-user.tsx
        setup-form.tsx
        setup-mfa.tsx
        sidebar.tsx
        sign-out-button.tsx
        sign-out.tsx
        suggested-match.tsx
        support-form.tsx
        sync-transactions.tsx
        system-banner.tsx
        tax-rate-assistant.tsx
        tax-rate-input.tsx
        team-dropdown.tsx
        team-invite.tsx
        team-invites.tsx
        team-members.tsx
        teller-connect.tsx
        theme-provider.tsx
        theme-switch.tsx
        time-format-settings.tsx
        timezone-detector.tsx
        top-revenue-client.tsx
        total-earnings.tsx
        tracker-calendar-type.tsx
        tracker-calendar.tsx
        tracker-create-invoice.tsx
        tracker-day-select.tsx
        tracker-export-csv.tsx
        tracker-pagination.tsx
        tracker-period-select.tsx
        tracker-schedule.tsx
        tracker-search-filter.tsx
        tracker-select-project.tsx
        tracker-settings.tsx
        tracker-status.tsx
        tracker-timer.tsx
        transaction-attachments.tsx
        transaction-bank-account.tsx
        transaction-details.tsx
        transaction-method.tsx
        transaction-shortcuts.tsx
        transaction-status.tsx
        transactions-actions.tsx
        transactions-column-visibility.tsx
        transactions-search-filter.tsx
        trial.tsx
        unenroll-mfa.tsx
        unified-app.tsx
        usage.tsx
        user-avatar.tsx
        user-menu.tsx
        vat-number-input.tsx
        verify-mfa.tsx
        week-settings.tsx
      hooks/
        use-calendar-dates.ts
        use-connect-params.ts
        use-customer-filter-params.ts
        use-customer-params.ts
        use-document-filter-params.ts
        use-document-params.ts
        use-download-zip.ts
        use-export-status.ts
        use-global-timer-status.ts
        use-inbox-filter-params.ts
        use-inbox-params.ts
        use-initial-connection-status.ts
        use-invoice-filter-params.ts
        use-invoice-params.ts
        use-latest-project-id.ts
        use-local-storage.ts
        use-notifications.ts
        use-oauth-application-params.ts
        use-oauth-params.ts
        use-realtime.ts
        use-reports-params.ts
        use-scroll-to-bottom.ts
        use-slider-with-input.ts
        use-sort-params.ts
        use-sticky-columns.ts
        use-sync-status.ts
        use-table-scroll.ts
        use-team.ts
        use-tracker-filter-params.ts
        use-tracker-params.ts
        use-transaction-filter-params-with-persistence.ts
        use-transaction-filter-params.ts
        use-transaction-params.ts
        use-upload.ts
        use-user.ts
        use-zod-form.ts
      lib/
        tools/
          get-burn-rate.ts
          get-documents.tsx
          get-forecast.ts
          get-inbox.tsx
          get-profit.ts
          get-revenue.ts
          get-runway.ts
          get-spending.ts
          get-tax-summary.ts
          get-transactions.ts
        download.ts
      locales/
        client.ts
        en.ts
        server.ts
        sv.ts
      store/
        assistant.ts
        export.ts
        invoice.ts
        oauth-secret-modal.ts
        search.ts
        token-modal.ts
        transactions.ts
        vault.ts
      styles/
        globals.css
      trpc/
        client.tsx
        query-client.ts
        server.tsx
      types/
        react-table.d.ts
      utils/
        canvas-factory.ts
        categories.ts
        check-team-eligibility.ts
        columns.ts
        connection-status.ts
        constants.ts
        desktop.ts
        environment.ts
        format.ts
        logger.ts
        logos.ts
        notification-definitions.ts
        oauth-utils.ts
        pdf-to-img.ts
        plans.ts
        polar.ts
        process.ts
        resend.ts
        scopes.ts
        teller.ts
        tracker.ts
        transaction-filters.ts
        upload.ts
      instrumentation-client.ts
      instrumentation.ts
      middleware.ts
    .env-example
    image-loader.ts
    next.config.mjs
    package.json
    postcss.config.cjs
    README.md
    sentry.edge.config.ts
    sentry.server.config.ts
    tailwind.config.ts
    tsconfig.json
    vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/dashboard/public/assets/setup-animation-dark.json">
{
  "v": "5.12.1",
  "fr": 60,
  "ip": 0,
  "op": 60,
  "w": 500,
  "h": 500,
  "nm": "system-regular-40-add-card",
  "ddd": 0,
  "assets": [
    {
      "id": "comp_1",
      "nm": "hover-add-card",
      "fr": 60,
      "layers": [
        {
          "ddd": 0,
          "ind": 1,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": { "a": 0, "k": -90, "ix": 10 },
            "p": { "a": 0, "k": [354.165, 145.831, 0], "ix": 2, "l": 2 },
            "a": { "a": 0, "k": [0, 0, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": 0.833, "y": 0.833 },
                        "o": { "x": 0.6, "y": 0 },
                        "t": 1,
                        "s": [
                          {
                            "i": [
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505],
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0]
                            ],
                            "o": [
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0],
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505]
                            ],
                            "v": [
                              [46.875, -67.709],
                              [-46.875, -67.709],
                              [-67.709, -46.875],
                              [-67.709, 46.875],
                              [-46.875, 67.709],
                              [46.875, 67.709],
                              [67.709, 46.875],
                              [67.709, -46.875]
                            ],
                            "c": true
                          }
                        ]
                      },
                      {
                        "i": { "x": 0.833, "y": 0.833 },
                        "o": { "x": 0.167, "y": 0.167 },
                        "t": 16,
                        "s": [
                          {
                            "i": [
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505],
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0]
                            ],
                            "o": [
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0],
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505]
                            ],
                            "v": [
                              [46.581, 26.291],
                              [-47.169, 26.291],
                              [-68.003, 47.125],
                              [-67.709, 46.875],
                              [-46.875, 67.709],
                              [46.875, 67.709],
                              [67.709, 46.875],
                              [67.415, 47.125]
                            ],
                            "c": true
                          }
                        ]
                      },
                      {
                        "t": 18,
                        "s": [
                          {
                            "i": [
                              [11.506, 0],
                              [0, 0],
                              [0, 0.034],
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, -0.034],
                              [0, 0]
                            ],
                            "o": [
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, -0.034],
                              [0, 0],
                              [11.506, 0],
                              [0, 0],
                              [0, 0.034]
                            ],
                            "v": [
                              [46.581, 67.83],
                              [-47.169, 67.83],
                              [-68.003, 67.769],
                              [-67.709, 67.77],
                              [-46.875, 67.709],
                              [46.875, 67.709],
                              [67.709, 67.77],
                              [67.415, 67.769]
                            ],
                            "c": true
                          }
                        ]
                      }
                    ],
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "st",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 3,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 4 },
                  "w": { "a": 0, "k": 31.3, "ix": 5 },
                  "lc": 2,
                  "lj": 2,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Stroke",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [0, 0], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 2,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 1,
          "op": 18,
          "st": 0,
          "ct": 1,
          "bm": 0
        },
        {
          "ddd": 0,
          "ind": 2,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": {
              "a": 1,
              "k": [
                {
                  "i": { "x": [0.2], "y": [1] },
                  "o": { "x": [0.333], "y": [0] },
                  "t": 1,
                  "s": [0]
                },
                { "t": 35, "s": [90] }
              ],
              "ix": 10
            },
            "p": { "a": 0, "k": [354.171, 354.168, 0], "ix": 2, "l": 2 },
            "a": { "a": 0, "k": [354.171, 354.168, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": 0.667, "y": 1 },
                        "o": { "x": 0.333, "y": 0 },
                        "t": 1,
                        "s": [
                          {
                            "i": [[0, 0], [0, 0]],
                            "o": [[0, 0], [0, 0]],
                            "v": [[67.709, 0], [-67.709, 0]],
                            "c": false
                          }
                        ]
                      },
                      {
                        "i": { "x": 0.4, "y": 1 },
                        "o": { "x": 0.333, "y": 0 },
                        "t": 8,
                        "s": [
                          {
                            "i": [[0, 0], [0, 0]],
                            "o": [[0, 0], [0, 0]],
                            "v": [[43.168, 0], [-43.168, 0]],
                            "c": false
                          }
                        ]
                      },
                      {
                        "t": 20,
                        "s": [
                          {
                            "i": [[0, 0], [0, 0]],
                            "o": [[0, 0], [0, 0]],
                            "v": [[67.709, 0], [-67.709, 0]],
                            "c": false
                          }
                        ]
                      }
                    ],
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": 0.667, "y": 1 },
                        "o": { "x": 0.333, "y": 0 },
                        "t": 1,
                        "s": [
                          {
                            "i": [[0, 0], [0, 0]],
                            "o": [[0, 0], [0, 0]],
                            "v": [[0, -67.709], [0, 67.709]],
                            "c": false
                          }
                        ]
                      },
                      {
                        "i": { "x": 0.4, "y": 1 },
                        "o": { "x": 0.333, "y": 0 },
                        "t": 8,
                        "s": [
                          {
                            "i": [[0, 0], [0, 0]],
                            "o": [[0, 0], [0, 0]],
                            "v": [[0, -43.168], [0, 43.168]],
                            "c": false
                          }
                        ]
                      },
                      {
                        "t": 20,
                        "s": [
                          {
                            "i": [[0, 0], [0, 0]],
                            "o": [[0, 0], [0, 0]],
                            "v": [[0, -67.709], [0, 67.709]],
                            "c": false
                          }
                        ]
                      }
                    ],
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "st",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 3,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 4 },
                  "w": { "a": 0, "k": 31.3, "ix": 5 },
                  "lc": 2,
                  "lj": 2,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Stroke",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [354.171, 354.168], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 1,
          "op": 60,
          "st": 0,
          "ct": 1,
          "bm": 0
        },
        {
          "ddd": 0,
          "ind": 3,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": { "a": 0, "k": 0, "ix": 10 },
            "p": {
              "a": 1,
              "k": [
                {
                  "i": { "x": 0, "y": 1 },
                  "o": { "x": 0.333, "y": 0 },
                  "t": 8,
                  "s": [145.831, 145.831, 0],
                  "to": [34.722, 0, 0],
                  "ti": [-34.722, 0, 0]
                },
                { "t": 42, "s": [354.165, 145.831, 0] }
              ],
              "ix": 2,
              "l": 2
            },
            "a": { "a": 0, "k": [0, 0, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [11.506, 0],
                        [0, 0],
                        [0, -11.506],
                        [0, 0],
                        [-11.506, 0],
                        [0, 0],
                        [0, 11.505],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-11.506, 0],
                        [0, 0],
                        [0, 11.505],
                        [0, 0],
                        [11.506, 0],
                        [0, 0],
                        [0, -11.506]
                      ],
                      "v": [
                        [46.875, -67.709],
                        [-46.875, -67.709],
                        [-67.709, -46.875],
                        [-67.709, 46.875],
                        [-46.875, 67.709],
                        [46.875, 67.709],
                        [67.709, 46.875],
                        [67.709, -46.875]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "st",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 3,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 4 },
                  "w": { "a": 0, "k": 31.3, "ix": 5 },
                  "lc": 2,
                  "lj": 2,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Stroke",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [0, 0], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 2,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 1,
          "op": 60,
          "st": 0,
          "ct": 1,
          "bm": 0
        },
        {
          "ddd": 0,
          "ind": 4,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": { "a": 0, "k": 0, "ix": 10 },
            "p": {
              "a": 1,
              "k": [
                {
                  "i": { "x": 0, "y": 1 },
                  "o": { "x": 0.333, "y": 0 },
                  "t": 15,
                  "s": [145.831, 354.17, 0],
                  "to": [0, -34.723, 0],
                  "ti": [0, 34.723, 0]
                },
                { "t": 49, "s": [145.831, 145.831, 0] }
              ],
              "ix": 2,
              "l": 2
            },
            "a": { "a": 0, "k": [0, 0, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [11.506, 0],
                        [0, 0],
                        [0, -11.505],
                        [0, 0],
                        [-11.506, 0],
                        [0, 0],
                        [0, 11.506],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-11.506, 0],
                        [0, 0],
                        [0, 11.506],
                        [0, 0],
                        [11.506, 0],
                        [0, 0],
                        [0, -11.505]
                      ],
                      "v": [
                        [46.875, -67.709],
                        [-46.875, -67.709],
                        [-67.709, -46.875],
                        [-67.709, 46.875],
                        [-46.875, 67.709],
                        [46.875, 67.709],
                        [67.709, 46.875],
                        [67.709, -46.875]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "st",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 3,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 4 },
                  "w": { "a": 0, "k": 31.3, "ix": 5 },
                  "lc": 2,
                  "lj": 2,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Stroke",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [0, 0], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 2,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 1,
          "op": 60,
          "st": 0,
          "ct": 1,
          "bm": 0
        },
        {
          "ddd": 0,
          "ind": 5,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": { "a": 0, "k": 0, "ix": 10 },
            "p": { "a": 0, "k": [145.831, 354.17, 0], "ix": 2, "l": 2 },
            "a": { "a": 0, "k": [0, 0, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": 0.833, "y": 0.833 },
                        "o": { "x": 0.167, "y": 0.167 },
                        "t": 23,
                        "s": [
                          {
                            "i": [
                              [11.506, 0],
                              [0, 0],
                              [0, 0.034],
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, -0.034],
                              [0, 0]
                            ],
                            "o": [
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, -0.034],
                              [0, 0],
                              [11.506, 0],
                              [0, 0],
                              [0, 0.034]
                            ],
                            "v": [
                              [46.581, 67.83],
                              [-47.169, 67.83],
                              [-68.003, 67.769],
                              [-67.709, 67.77],
                              [-46.875, 67.709],
                              [46.875, 67.709],
                              [67.709, 67.77],
                              [67.415, 67.769]
                            ],
                            "c": true
                          }
                        ]
                      },
                      {
                        "i": { "x": 0, "y": 1 },
                        "o": { "x": 0.167, "y": 0.167 },
                        "t": 25,
                        "s": [
                          {
                            "i": [
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505],
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0]
                            ],
                            "o": [
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0],
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505]
                            ],
                            "v": [
                              [46.581, 26.291],
                              [-47.169, 26.291],
                              [-68.003, 47.125],
                              [-67.709, 46.875],
                              [-46.875, 67.709],
                              [46.875, 67.709],
                              [67.709, 46.875],
                              [67.415, 47.125]
                            ],
                            "c": true
                          }
                        ]
                      },
                      {
                        "t": 57,
                        "s": [
                          {
                            "i": [
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505],
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0]
                            ],
                            "o": [
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0],
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505]
                            ],
                            "v": [
                              [46.875, -67.709],
                              [-46.875, -67.709],
                              [-67.709, -46.875],
                              [-67.709, 46.875],
                              [-46.875, 67.709],
                              [46.875, 67.709],
                              [67.709, 46.875],
                              [67.709, -46.875]
                            ],
                            "c": true
                          }
                        ]
                      }
                    ],
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "st",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 3,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 4 },
                  "w": { "a": 0, "k": 31.3, "ix": 5 },
                  "lc": 2,
                  "lj": 2,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Stroke",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [0, 0], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 2,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 23,
          "op": 60,
          "st": 0,
          "ct": 1,
          "bm": 0
        },
        {
          "ddd": 0,
          "ind": 6,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": { "a": 0, "k": 0, "ix": 10 },
            "p": { "a": 0, "k": [250.002, 250.002, 0], "ix": 2, "l": 2 },
            "a": { "a": 0, "k": [250, 250, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [2083, 2083, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.41, 0],
                        [0, 0],
                        [0, 0],
                        [0.41, 0],
                        [0, -0.41],
                        [0, 0],
                        [0, 0],
                        [0, -0.41],
                        [-0.41, 0],
                        [0, 0],
                        [0, 0],
                        [-0.41, 0],
                        [0, 0.41],
                        [0, 0],
                        [0, 0],
                        [0, 0.41]
                      ],
                      "o": [
                        [0, 0],
                        [0, 0],
                        [0, -0.41],
                        [-0.41, 0],
                        [0, 0],
                        [0, 0],
                        [-0.41, 0],
                        [0, 0.41],
                        [0, 0],
                        [0, 0],
                        [0, 0.41],
                        [0.41, 0],
                        [0, 0],
                        [0, 0],
                        [0.41, 0],
                        [0, -0.41]
                      ],
                      "v": [
                        [3.25, -0.75],
                        [0.75, -0.75],
                        [0.75, -3.25],
                        [0, -4],
                        [-0.75, -3.25],
                        [-0.75, -0.75],
                        [-3.25, -0.75],
                        [-4, 0],
                        [-3.25, 0.75],
                        [-0.75, 0.75],
                        [-0.75, 3.25],
                        [0, 4],
                        [0.75, 3.25],
                        [0.75, 0.75],
                        [3.25, 0.75],
                        [4, 0]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [255, 255], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 2,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            },
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0, 0],
                        [0.14, 0],
                        [0, 0],
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14]
                      ],
                      "o": [
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14],
                        [0, 0],
                        [0.14, 0],
                        [0, 0]
                      ],
                      "v": [
                        [2.5, 2.25],
                        [2.25, 2.5],
                        [-2.25, 2.5],
                        [-2.5, 2.25],
                        [-2.5, -2.25],
                        [-2.25, -2.5],
                        [2.25, -2.5],
                        [2.5, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96],
                        [0, 0],
                        [-0.96, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0],
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96]
                      ],
                      "v": [
                        [2.25, -4],
                        [-2.25, -4],
                        [-4, -2.25],
                        [-4, 2.25],
                        [-2.25, 4],
                        [2.25, 4],
                        [4, 2.25],
                        [4, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [255, 245], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 2",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 2,
              "mn": "ADBE Vector Group",
              "hd": false
            },
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0, 0],
                        [0.14, 0],
                        [0, 0],
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14]
                      ],
                      "o": [
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14],
                        [0, 0],
                        [0.14, 0],
                        [0, 0]
                      ],
                      "v": [
                        [2.5, 2.25],
                        [2.25, 2.5],
                        [-2.25, 2.5],
                        [-2.5, 2.25],
                        [-2.5, -2.25],
                        [-2.25, -2.5],
                        [2.25, -2.5],
                        [2.5, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96],
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0],
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96]
                      ],
                      "v": [
                        [2.25, -4],
                        [-2.25, -4],
                        [-4, -2.25],
                        [-4, 2.25],
                        [-2.25, 4],
                        [2.25, 4],
                        [4, 2.25],
                        [4, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [245, 245], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 3",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 3,
              "mn": "ADBE Vector Group",
              "hd": false
            },
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0, 0],
                        [0.14, 0],
                        [0, 0],
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14]
                      ],
                      "o": [
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14],
                        [0, 0],
                        [0.14, 0],
                        [0, 0]
                      ],
                      "v": [
                        [2.5, 2.25],
                        [2.25, 2.5],
                        [-2.25, 2.5],
                        [-2.5, 2.25],
                        [-2.5, -2.25],
                        [-2.25, -2.5],
                        [2.25, -2.5],
                        [2.5, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96],
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0],
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96]
                      ],
                      "v": [
                        [2.25, -4],
                        [-2.25, -4],
                        [-4, -2.25],
                        [-4, 2.25],
                        [-2.25, 4],
                        [2.25, 4],
                        [4, 2.25],
                        [4, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [245, 255], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 4",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 4,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 60,
          "op": 300,
          "st": 0,
          "ct": 1,
          "bm": 0
        },
        {
          "ddd": 0,
          "ind": 7,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": { "a": 0, "k": 0, "ix": 10 },
            "p": { "a": 0, "k": [250.002, 250.002, 0], "ix": 2, "l": 2 },
            "a": { "a": 0, "k": [250, 250, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [2083, 2083, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.41, 0],
                        [0, 0],
                        [0, 0],
                        [0.41, 0],
                        [0, -0.41],
                        [0, 0],
                        [0, 0],
                        [0, -0.41],
                        [-0.41, 0],
                        [0, 0],
                        [0, 0],
                        [-0.41, 0],
                        [0, 0.41],
                        [0, 0],
                        [0, 0],
                        [0, 0.41]
                      ],
                      "o": [
                        [0, 0],
                        [0, 0],
                        [0, -0.41],
                        [-0.41, 0],
                        [0, 0],
                        [0, 0],
                        [-0.41, 0],
                        [0, 0.41],
                        [0, 0],
                        [0, 0],
                        [0, 0.41],
                        [0.41, 0],
                        [0, 0],
                        [0, 0],
                        [0.41, 0],
                        [0, -0.41]
                      ],
                      "v": [
                        [3.25, -0.75],
                        [0.75, -0.75],
                        [0.75, -3.25],
                        [0, -4],
                        [-0.75, -3.25],
                        [-0.75, -0.75],
                        [-3.25, -0.75],
                        [-4, 0],
                        [-3.25, 0.75],
                        [-0.75, 0.75],
                        [-0.75, 3.25],
                        [0, 4],
                        [0.75, 3.25],
                        [0.75, 0.75],
                        [3.25, 0.75],
                        [4, 0]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [255, 255], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 2,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            },
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0, 0],
                        [0.14, 0],
                        [0, 0],
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14]
                      ],
                      "o": [
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14],
                        [0, 0],
                        [0.14, 0],
                        [0, 0]
                      ],
                      "v": [
                        [2.5, 2.25],
                        [2.25, 2.5],
                        [-2.25, 2.5],
                        [-2.5, 2.25],
                        [-2.5, -2.25],
                        [-2.25, -2.5],
                        [2.25, -2.5],
                        [2.5, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96],
                        [0, 0],
                        [-0.96, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0],
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96]
                      ],
                      "v": [
                        [2.25, -4],
                        [-2.25, -4],
                        [-4, -2.25],
                        [-4, 2.25],
                        [-2.25, 4],
                        [2.25, 4],
                        [4, 2.25],
                        [4, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [255, 245], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 2",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 2,
              "mn": "ADBE Vector Group",
              "hd": false
            },
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0, 0],
                        [0.14, 0],
                        [0, 0],
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14]
                      ],
                      "o": [
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14],
                        [0, 0],
                        [0.14, 0],
                        [0, 0]
                      ],
                      "v": [
                        [2.5, 2.25],
                        [2.25, 2.5],
                        [-2.25, 2.5],
                        [-2.5, 2.25],
                        [-2.5, -2.25],
                        [-2.25, -2.5],
                        [2.25, -2.5],
                        [2.5, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96],
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0],
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96]
                      ],
                      "v": [
                        [2.25, -4],
                        [-2.25, -4],
                        [-4, -2.25],
                        [-4, 2.25],
                        [-2.25, 4],
                        [2.25, 4],
                        [4, 2.25],
                        [4, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [245, 245], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 3",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 3,
              "mn": "ADBE Vector Group",
              "hd": false
            },
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0, 0],
                        [0.14, 0],
                        [0, 0],
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14]
                      ],
                      "o": [
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14],
                        [0, 0],
                        [0.14, 0],
                        [0, 0]
                      ],
                      "v": [
                        [2.5, 2.25],
                        [2.25, 2.5],
                        [-2.25, 2.5],
                        [-2.5, 2.25],
                        [-2.5, -2.25],
                        [-2.25, -2.5],
                        [2.25, -2.5],
                        [2.5, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96],
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0],
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96]
                      ],
                      "v": [
                        [2.25, -4],
                        [-2.25, -4],
                        [-4, -2.25],
                        [-4, 2.25],
                        [-2.25, 4],
                        [2.25, 4],
                        [4, 2.25],
                        [4, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [0, 0, 0, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [245, 255], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 4",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 4,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 0,
          "op": 1,
          "st": 0,
          "ct": 1,
          "bm": 0
        }
      ]
    }
  ],
  "layers": [
    {
      "ddd": 0,
      "ind": 1,
      "ty": 3,
      "nm": "control",
      "sr": 1,
      "ks": {
        "o": { "a": 0, "k": 0, "ix": 11 },
        "r": { "a": 0, "k": 0, "ix": 10 },
        "p": { "a": 0, "k": [0, 0], "ix": 2, "l": 2 },
        "a": { "a": 0, "k": [0, 0, 0], "ix": 1, "l": 2 },
        "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
      },
      "ao": 0,
      "ef": [
        {
          "ty": 5,
          "nm": "primary",
          "np": 3,
          "mn": "ADBE Color Control",
          "ix": 1,
          "en": 1,
          "ef": [
            {
              "ty": 2,
              "nm": "Color",
              "mn": "ADBE Color Control-0001",
              "ix": 1,
              "v": { "a": 0, "k": [0, 0, 0], "ix": 1 }
            }
          ]
        }
      ],
      "ip": 0,
      "op": 131,
      "st": 0,
      "bm": 0
    },
    {
      "ddd": 0,
      "ind": 3,
      "ty": 0,
      "nm": "hover-add-card",
      "refId": "comp_1",
      "sr": 1,
      "ks": {
        "o": { "a": 0, "k": 100, "ix": 11 },
        "r": { "a": 0, "k": 0, "ix": 10 },
        "p": { "a": 0, "k": [250, 250, 0], "ix": 2, "l": 2 },
        "a": { "a": 0, "k": [250, 250, 0], "ix": 1, "l": 2 },
        "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
      },
      "ao": 0,
      "w": 500,
      "h": 500,
      "ip": 0,
      "op": 70,
      "st": 0,
      "bm": 0
    }
  ],
  "markers": [{ "tm": 0, "cm": "default:hover-add-card", "dr": 60 }],
  "props": {}
}
</file>

<file path="apps/dashboard/public/assets/setup-animation.json">
{
  "v": "5.12.1",
  "fr": 60,
  "ip": 0,
  "op": 60,
  "w": 500,
  "h": 500,
  "nm": "system-regular-40-add-card",
  "ddd": 0,
  "assets": [
    {
      "id": "comp_1",
      "nm": "hover-add-card",
      "fr": 60,
      "layers": [
        {
          "ddd": 0,
          "ind": 1,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": { "a": 0, "k": -90, "ix": 10 },
            "p": { "a": 0, "k": [354.165, 145.831, 0], "ix": 2, "l": 2 },
            "a": { "a": 0, "k": [0, 0, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": 0.833, "y": 0.833 },
                        "o": { "x": 0.6, "y": 0 },
                        "t": 1,
                        "s": [
                          {
                            "i": [
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505],
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0]
                            ],
                            "o": [
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0],
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505]
                            ],
                            "v": [
                              [46.875, -67.709],
                              [-46.875, -67.709],
                              [-67.709, -46.875],
                              [-67.709, 46.875],
                              [-46.875, 67.709],
                              [46.875, 67.709],
                              [67.709, 46.875],
                              [67.709, -46.875]
                            ],
                            "c": true
                          }
                        ]
                      },
                      {
                        "i": { "x": 0.833, "y": 0.833 },
                        "o": { "x": 0.167, "y": 0.167 },
                        "t": 16,
                        "s": [
                          {
                            "i": [
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505],
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0]
                            ],
                            "o": [
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0],
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505]
                            ],
                            "v": [
                              [46.581, 26.291],
                              [-47.169, 26.291],
                              [-68.003, 47.125],
                              [-67.709, 46.875],
                              [-46.875, 67.709],
                              [46.875, 67.709],
                              [67.709, 46.875],
                              [67.415, 47.125]
                            ],
                            "c": true
                          }
                        ]
                      },
                      {
                        "t": 18,
                        "s": [
                          {
                            "i": [
                              [11.506, 0],
                              [0, 0],
                              [0, 0.034],
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, -0.034],
                              [0, 0]
                            ],
                            "o": [
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, -0.034],
                              [0, 0],
                              [11.506, 0],
                              [0, 0],
                              [0, 0.034]
                            ],
                            "v": [
                              [46.581, 67.83],
                              [-47.169, 67.83],
                              [-68.003, 67.769],
                              [-67.709, 67.77],
                              [-46.875, 67.709],
                              [46.875, 67.709],
                              [67.709, 67.77],
                              [67.415, 67.769]
                            ],
                            "c": true
                          }
                        ]
                      }
                    ],
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "st",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 3,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 4 },
                  "w": { "a": 0, "k": 31.3, "ix": 5 },
                  "lc": 2,
                  "lj": 2,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Stroke",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [0, 0], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 2,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 1,
          "op": 18,
          "st": 0,
          "ct": 1,
          "bm": 0
        },
        {
          "ddd": 0,
          "ind": 2,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": {
              "a": 1,
              "k": [
                {
                  "i": { "x": [0.2], "y": [1] },
                  "o": { "x": [0.333], "y": [0] },
                  "t": 1,
                  "s": [0]
                },
                { "t": 35, "s": [90] }
              ],
              "ix": 10
            },
            "p": { "a": 0, "k": [354.171, 354.168, 0], "ix": 2, "l": 2 },
            "a": { "a": 0, "k": [354.171, 354.168, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": 0.667, "y": 1 },
                        "o": { "x": 0.333, "y": 0 },
                        "t": 1,
                        "s": [
                          {
                            "i": [[0, 0], [0, 0]],
                            "o": [[0, 0], [0, 0]],
                            "v": [[67.709, 0], [-67.709, 0]],
                            "c": false
                          }
                        ]
                      },
                      {
                        "i": { "x": 0.4, "y": 1 },
                        "o": { "x": 0.333, "y": 0 },
                        "t": 8,
                        "s": [
                          {
                            "i": [[0, 0], [0, 0]],
                            "o": [[0, 0], [0, 0]],
                            "v": [[43.168, 0], [-43.168, 0]],
                            "c": false
                          }
                        ]
                      },
                      {
                        "t": 20,
                        "s": [
                          {
                            "i": [[0, 0], [0, 0]],
                            "o": [[0, 0], [0, 0]],
                            "v": [[67.709, 0], [-67.709, 0]],
                            "c": false
                          }
                        ]
                      }
                    ],
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": 0.667, "y": 1 },
                        "o": { "x": 0.333, "y": 0 },
                        "t": 1,
                        "s": [
                          {
                            "i": [[0, 0], [0, 0]],
                            "o": [[0, 0], [0, 0]],
                            "v": [[0, -67.709], [0, 67.709]],
                            "c": false
                          }
                        ]
                      },
                      {
                        "i": { "x": 0.4, "y": 1 },
                        "o": { "x": 0.333, "y": 0 },
                        "t": 8,
                        "s": [
                          {
                            "i": [[0, 0], [0, 0]],
                            "o": [[0, 0], [0, 0]],
                            "v": [[0, -43.168], [0, 43.168]],
                            "c": false
                          }
                        ]
                      },
                      {
                        "t": 20,
                        "s": [
                          {
                            "i": [[0, 0], [0, 0]],
                            "o": [[0, 0], [0, 0]],
                            "v": [[0, -67.709], [0, 67.709]],
                            "c": false
                          }
                        ]
                      }
                    ],
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "st",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 3,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 4 },
                  "w": { "a": 0, "k": 31.3, "ix": 5 },
                  "lc": 2,
                  "lj": 2,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Stroke",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [354.171, 354.168], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 1,
          "op": 60,
          "st": 0,
          "ct": 1,
          "bm": 0
        },
        {
          "ddd": 0,
          "ind": 3,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": { "a": 0, "k": 0, "ix": 10 },
            "p": {
              "a": 1,
              "k": [
                {
                  "i": { "x": 0, "y": 1 },
                  "o": { "x": 0.333, "y": 0 },
                  "t": 8,
                  "s": [145.831, 145.831, 0],
                  "to": [34.722, 0, 0],
                  "ti": [-34.722, 0, 0]
                },
                { "t": 42, "s": [354.165, 145.831, 0] }
              ],
              "ix": 2,
              "l": 2
            },
            "a": { "a": 0, "k": [0, 0, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [11.506, 0],
                        [0, 0],
                        [0, -11.506],
                        [0, 0],
                        [-11.506, 0],
                        [0, 0],
                        [0, 11.505],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-11.506, 0],
                        [0, 0],
                        [0, 11.505],
                        [0, 0],
                        [11.506, 0],
                        [0, 0],
                        [0, -11.506]
                      ],
                      "v": [
                        [46.875, -67.709],
                        [-46.875, -67.709],
                        [-67.709, -46.875],
                        [-67.709, 46.875],
                        [-46.875, 67.709],
                        [46.875, 67.709],
                        [67.709, 46.875],
                        [67.709, -46.875]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "st",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 3,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 4 },
                  "w": { "a": 0, "k": 31.3, "ix": 5 },
                  "lc": 2,
                  "lj": 2,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Stroke",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [0, 0], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 2,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 1,
          "op": 60,
          "st": 0,
          "ct": 1,
          "bm": 0
        },
        {
          "ddd": 0,
          "ind": 4,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": { "a": 0, "k": 0, "ix": 10 },
            "p": {
              "a": 1,
              "k": [
                {
                  "i": { "x": 0, "y": 1 },
                  "o": { "x": 0.333, "y": 0 },
                  "t": 15,
                  "s": [145.831, 354.17, 0],
                  "to": [0, -34.723, 0],
                  "ti": [0, 34.723, 0]
                },
                { "t": 49, "s": [145.831, 145.831, 0] }
              ],
              "ix": 2,
              "l": 2
            },
            "a": { "a": 0, "k": [0, 0, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [11.506, 0],
                        [0, 0],
                        [0, -11.505],
                        [0, 0],
                        [-11.506, 0],
                        [0, 0],
                        [0, 11.506],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-11.506, 0],
                        [0, 0],
                        [0, 11.506],
                        [0, 0],
                        [11.506, 0],
                        [0, 0],
                        [0, -11.505]
                      ],
                      "v": [
                        [46.875, -67.709],
                        [-46.875, -67.709],
                        [-67.709, -46.875],
                        [-67.709, 46.875],
                        [-46.875, 67.709],
                        [46.875, 67.709],
                        [67.709, 46.875],
                        [67.709, -46.875]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "st",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 3,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 4 },
                  "w": { "a": 0, "k": 31.3, "ix": 5 },
                  "lc": 2,
                  "lj": 2,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Stroke",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [0, 0], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 2,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 1,
          "op": 60,
          "st": 0,
          "ct": 1,
          "bm": 0
        },
        {
          "ddd": 0,
          "ind": 5,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": { "a": 0, "k": 0, "ix": 10 },
            "p": { "a": 0, "k": [145.831, 354.17, 0], "ix": 2, "l": 2 },
            "a": { "a": 0, "k": [0, 0, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": 0.833, "y": 0.833 },
                        "o": { "x": 0.167, "y": 0.167 },
                        "t": 23,
                        "s": [
                          {
                            "i": [
                              [11.506, 0],
                              [0, 0],
                              [0, 0.034],
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, -0.034],
                              [0, 0]
                            ],
                            "o": [
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, -0.034],
                              [0, 0],
                              [11.506, 0],
                              [0, 0],
                              [0, 0.034]
                            ],
                            "v": [
                              [46.581, 67.83],
                              [-47.169, 67.83],
                              [-68.003, 67.769],
                              [-67.709, 67.77],
                              [-46.875, 67.709],
                              [46.875, 67.709],
                              [67.709, 67.77],
                              [67.415, 67.769]
                            ],
                            "c": true
                          }
                        ]
                      },
                      {
                        "i": { "x": 0, "y": 1 },
                        "o": { "x": 0.167, "y": 0.167 },
                        "t": 25,
                        "s": [
                          {
                            "i": [
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505],
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0]
                            ],
                            "o": [
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0],
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505]
                            ],
                            "v": [
                              [46.581, 26.291],
                              [-47.169, 26.291],
                              [-68.003, 47.125],
                              [-67.709, 46.875],
                              [-46.875, 67.709],
                              [46.875, 67.709],
                              [67.709, 46.875],
                              [67.415, 47.125]
                            ],
                            "c": true
                          }
                        ]
                      },
                      {
                        "t": 57,
                        "s": [
                          {
                            "i": [
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505],
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0]
                            ],
                            "o": [
                              [0, 0],
                              [-11.506, 0],
                              [0, 0],
                              [0, 11.506],
                              [0, 0],
                              [11.506, 0],
                              [0, 0],
                              [0, -11.505]
                            ],
                            "v": [
                              [46.875, -67.709],
                              [-46.875, -67.709],
                              [-67.709, -46.875],
                              [-67.709, 46.875],
                              [-46.875, 67.709],
                              [46.875, 67.709],
                              [67.709, 46.875],
                              [67.709, -46.875]
                            ],
                            "c": true
                          }
                        ]
                      }
                    ],
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "st",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 3,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 4 },
                  "w": { "a": 0, "k": 31.3, "ix": 5 },
                  "lc": 2,
                  "lj": 2,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Stroke",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [0, 0], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 2,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 23,
          "op": 60,
          "st": 0,
          "ct": 1,
          "bm": 0
        },
        {
          "ddd": 0,
          "ind": 6,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": { "a": 0, "k": 0, "ix": 10 },
            "p": { "a": 0, "k": [250.002, 250.002, 0], "ix": 2, "l": 2 },
            "a": { "a": 0, "k": [250, 250, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [2083, 2083, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.41, 0],
                        [0, 0],
                        [0, 0],
                        [0.41, 0],
                        [0, -0.41],
                        [0, 0],
                        [0, 0],
                        [0, -0.41],
                        [-0.41, 0],
                        [0, 0],
                        [0, 0],
                        [-0.41, 0],
                        [0, 0.41],
                        [0, 0],
                        [0, 0],
                        [0, 0.41]
                      ],
                      "o": [
                        [0, 0],
                        [0, 0],
                        [0, -0.41],
                        [-0.41, 0],
                        [0, 0],
                        [0, 0],
                        [-0.41, 0],
                        [0, 0.41],
                        [0, 0],
                        [0, 0],
                        [0, 0.41],
                        [0.41, 0],
                        [0, 0],
                        [0, 0],
                        [0.41, 0],
                        [0, -0.41]
                      ],
                      "v": [
                        [3.25, -0.75],
                        [0.75, -0.75],
                        [0.75, -3.25],
                        [0, -4],
                        [-0.75, -3.25],
                        [-0.75, -0.75],
                        [-3.25, -0.75],
                        [-4, 0],
                        [-3.25, 0.75],
                        [-0.75, 0.75],
                        [-0.75, 3.25],
                        [0, 4],
                        [0.75, 3.25],
                        [0.75, 0.75],
                        [3.25, 0.75],
                        [4, 0]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [255, 255], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 2,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            },
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0, 0],
                        [0.14, 0],
                        [0, 0],
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14]
                      ],
                      "o": [
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14],
                        [0, 0],
                        [0.14, 0],
                        [0, 0]
                      ],
                      "v": [
                        [2.5, 2.25],
                        [2.25, 2.5],
                        [-2.25, 2.5],
                        [-2.5, 2.25],
                        [-2.5, -2.25],
                        [-2.25, -2.5],
                        [2.25, -2.5],
                        [2.5, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96],
                        [0, 0],
                        [-0.96, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0],
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96]
                      ],
                      "v": [
                        [2.25, -4],
                        [-2.25, -4],
                        [-4, -2.25],
                        [-4, 2.25],
                        [-2.25, 4],
                        [2.25, 4],
                        [4, 2.25],
                        [4, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [255, 245], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 2",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 2,
              "mn": "ADBE Vector Group",
              "hd": false
            },
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0, 0],
                        [0.14, 0],
                        [0, 0],
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14]
                      ],
                      "o": [
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14],
                        [0, 0],
                        [0.14, 0],
                        [0, 0]
                      ],
                      "v": [
                        [2.5, 2.25],
                        [2.25, 2.5],
                        [-2.25, 2.5],
                        [-2.5, 2.25],
                        [-2.5, -2.25],
                        [-2.25, -2.5],
                        [2.25, -2.5],
                        [2.5, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96],
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0],
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96]
                      ],
                      "v": [
                        [2.25, -4],
                        [-2.25, -4],
                        [-4, -2.25],
                        [-4, 2.25],
                        [-2.25, 4],
                        [2.25, 4],
                        [4, 2.25],
                        [4, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [245, 245], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 3",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 3,
              "mn": "ADBE Vector Group",
              "hd": false
            },
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0, 0],
                        [0.14, 0],
                        [0, 0],
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14]
                      ],
                      "o": [
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14],
                        [0, 0],
                        [0.14, 0],
                        [0, 0]
                      ],
                      "v": [
                        [2.5, 2.25],
                        [2.25, 2.5],
                        [-2.25, 2.5],
                        [-2.5, 2.25],
                        [-2.5, -2.25],
                        [-2.25, -2.5],
                        [2.25, -2.5],
                        [2.5, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96],
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0],
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96]
                      ],
                      "v": [
                        [2.25, -4],
                        [-2.25, -4],
                        [-4, -2.25],
                        [-4, 2.25],
                        [-2.25, 4],
                        [2.25, 4],
                        [4, 2.25],
                        [4, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [245, 255], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 4",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 4,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 60,
          "op": 300,
          "st": 0,
          "ct": 1,
          "bm": 0
        },
        {
          "ddd": 0,
          "ind": 7,
          "ty": 4,
          "nm": ".primary.design",
          "cl": "primary design",
          "sr": 1,
          "ks": {
            "o": { "a": 0, "k": 100, "ix": 11 },
            "r": { "a": 0, "k": 0, "ix": 10 },
            "p": { "a": 0, "k": [250.002, 250.002, 0], "ix": 2, "l": 2 },
            "a": { "a": 0, "k": [250, 250, 0], "ix": 1, "l": 2 },
            "s": { "a": 0, "k": [2083, 2083, 100], "ix": 6, "l": 2 }
          },
          "ao": 0,
          "shapes": [
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.41, 0],
                        [0, 0],
                        [0, 0],
                        [0.41, 0],
                        [0, -0.41],
                        [0, 0],
                        [0, 0],
                        [0, -0.41],
                        [-0.41, 0],
                        [0, 0],
                        [0, 0],
                        [-0.41, 0],
                        [0, 0.41],
                        [0, 0],
                        [0, 0],
                        [0, 0.41]
                      ],
                      "o": [
                        [0, 0],
                        [0, 0],
                        [0, -0.41],
                        [-0.41, 0],
                        [0, 0],
                        [0, 0],
                        [-0.41, 0],
                        [0, 0.41],
                        [0, 0],
                        [0, 0],
                        [0, 0.41],
                        [0.41, 0],
                        [0, 0],
                        [0, 0],
                        [0.41, 0],
                        [0, -0.41]
                      ],
                      "v": [
                        [3.25, -0.75],
                        [0.75, -0.75],
                        [0.75, -3.25],
                        [0, -4],
                        [-0.75, -3.25],
                        [-0.75, -0.75],
                        [-3.25, -0.75],
                        [-4, 0],
                        [-3.25, 0.75],
                        [-0.75, 0.75],
                        [-0.75, 3.25],
                        [0, 4],
                        [0.75, 3.25],
                        [0.75, 0.75],
                        [3.25, 0.75],
                        [4, 0]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [255, 255], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 1",
              "np": 2,
              "cix": 2,
              "bm": 0,
              "ix": 1,
              "mn": "ADBE Vector Group",
              "hd": false
            },
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0, 0],
                        [0.14, 0],
                        [0, 0],
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14]
                      ],
                      "o": [
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14],
                        [0, 0],
                        [0.14, 0],
                        [0, 0]
                      ],
                      "v": [
                        [2.5, 2.25],
                        [2.25, 2.5],
                        [-2.25, 2.5],
                        [-2.5, 2.25],
                        [-2.5, -2.25],
                        [-2.25, -2.5],
                        [2.25, -2.5],
                        [2.5, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96],
                        [0, 0],
                        [-0.96, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0],
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96]
                      ],
                      "v": [
                        [2.25, -4],
                        [-2.25, -4],
                        [-4, -2.25],
                        [-4, 2.25],
                        [-2.25, 4],
                        [2.25, 4],
                        [4, 2.25],
                        [4, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [255, 245], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 2",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 2,
              "mn": "ADBE Vector Group",
              "hd": false
            },
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0, 0],
                        [0.14, 0],
                        [0, 0],
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14]
                      ],
                      "o": [
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14],
                        [0, 0],
                        [0.14, 0],
                        [0, 0]
                      ],
                      "v": [
                        [2.5, 2.25],
                        [2.25, 2.5],
                        [-2.25, 2.5],
                        [-2.5, 2.25],
                        [-2.5, -2.25],
                        [-2.25, -2.5],
                        [2.25, -2.5],
                        [2.5, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96],
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0],
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96]
                      ],
                      "v": [
                        [2.25, -4],
                        [-2.25, -4],
                        [-4, -2.25],
                        [-4, 2.25],
                        [-2.25, 4],
                        [2.25, 4],
                        [4, 2.25],
                        [4, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [245, 245], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 3",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 3,
              "mn": "ADBE Vector Group",
              "hd": false
            },
            {
              "ty": "gr",
              "it": [
                {
                  "ind": 0,
                  "ty": "sh",
                  "ix": 1,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0, 0],
                        [0.14, 0],
                        [0, 0],
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14]
                      ],
                      "o": [
                        [0, 0.14],
                        [0, 0],
                        [-0.14, 0],
                        [0, 0],
                        [0, -0.14],
                        [0, 0],
                        [0.14, 0],
                        [0, 0]
                      ],
                      "v": [
                        [2.5, 2.25],
                        [2.25, 2.5],
                        [-2.25, 2.5],
                        [-2.5, 2.25],
                        [-2.5, -2.25],
                        [-2.25, -2.5],
                        [2.25, -2.5],
                        [2.5, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ind": 1,
                  "ty": "sh",
                  "ix": 2,
                  "ks": {
                    "a": 0,
                    "k": {
                      "i": [
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96],
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0]
                      ],
                      "o": [
                        [0, 0],
                        [-0.97, 0],
                        [0, 0],
                        [0, 0.96],
                        [0, 0],
                        [0.96, 0],
                        [0, 0],
                        [0, -0.96]
                      ],
                      "v": [
                        [2.25, -4],
                        [-2.25, -4],
                        [-4, -2.25],
                        [-4, 2.25],
                        [-2.25, 4],
                        [2.25, 4],
                        [4, 2.25],
                        [4, -2.25]
                      ],
                      "c": true
                    },
                    "ix": 2
                  },
                  "nm": "Path 2",
                  "mn": "ADBE Vector Shape - Group",
                  "hd": false
                },
                {
                  "ty": "fl",
                  "c": {
                    "a": 0,
                    "k": [1, 1, 1, 1],
                    "ix": 4,
                    "x": "var $bm_rt;\n$bm_rt = comp('system-regular-40-add-card').layer('control').effect('primary')('Color');"
                  },
                  "o": { "a": 0, "k": 100, "ix": 5 },
                  "r": 1,
                  "bm": 0,
                  "nm": ".primary",
                  "mn": "ADBE Vector Graphic - Fill",
                  "hd": false,
                  "cl": "primary"
                },
                {
                  "ty": "tr",
                  "p": { "a": 0, "k": [245, 255], "ix": 2 },
                  "a": { "a": 0, "k": [0, 0], "ix": 1 },
                  "s": { "a": 0, "k": [100, 100], "ix": 3 },
                  "r": { "a": 0, "k": 0, "ix": 6 },
                  "o": { "a": 0, "k": 100, "ix": 7 },
                  "sk": { "a": 0, "k": 0, "ix": 4 },
                  "sa": { "a": 0, "k": 0, "ix": 5 },
                  "nm": "Transform"
                }
              ],
              "nm": "Group 4",
              "np": 3,
              "cix": 2,
              "bm": 0,
              "ix": 4,
              "mn": "ADBE Vector Group",
              "hd": false
            }
          ],
          "ip": 0,
          "op": 1,
          "st": 0,
          "ct": 1,
          "bm": 0
        }
      ]
    }
  ],
  "layers": [
    {
      "ddd": 0,
      "ind": 1,
      "ty": 3,
      "nm": "control",
      "sr": 1,
      "ks": {
        "o": { "a": 0, "k": 0, "ix": 11 },
        "r": { "a": 0, "k": 0, "ix": 10 },
        "p": { "a": 0, "k": [0, 0], "ix": 2, "l": 2 },
        "a": { "a": 0, "k": [0, 0, 0], "ix": 1, "l": 2 },
        "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
      },
      "ao": 0,
      "ef": [
        {
          "ty": 5,
          "nm": "primary",
          "np": 3,
          "mn": "ADBE Color Control",
          "ix": 1,
          "en": 1,
          "ef": [
            {
              "ty": 2,
              "nm": "Color",
              "mn": "ADBE Color Control-0001",
              "ix": 1,
              "v": { "a": 0, "k": [1, 1, 1], "ix": 1 }
            }
          ]
        }
      ],
      "ip": 0,
      "op": 131,
      "st": 0,
      "bm": 0
    },
    {
      "ddd": 0,
      "ind": 3,
      "ty": 0,
      "nm": "hover-add-card",
      "refId": "comp_1",
      "sr": 1,
      "ks": {
        "o": { "a": 0, "k": 100, "ix": 11 },
        "r": { "a": 0, "k": 0, "ix": 10 },
        "p": { "a": 0, "k": [250, 250, 0], "ix": 2, "l": 2 },
        "a": { "a": 0, "k": [250, 250, 0], "ix": 1, "l": 2 },
        "s": { "a": 0, "k": [100, 100, 100], "ix": 6, "l": 2 }
      },
      "ao": 0,
      "w": 500,
      "h": 500,
      "ip": 0,
      "op": 70,
      "st": 0,
      "bm": 0
    }
  ],
  "markers": [{ "tm": 0, "cm": "default:hover-add-card", "dr": 60 }],
  "props": {}
}
</file>

<file path="apps/dashboard/src/actions/ai/editor/generate-editor-content.ts">
"use server";

import { openai } from "@ai-sdk/openai";
import { streamText } from "ai";
import { createStreamableValue } from "ai/rsc";

type Params = {
  input: string;
  context?: string;
};

export async function generateEditorContent({ input, context }: Params) {
  const stream = createStreamableValue("");

  (async () => {
    const { textStream } = await streamText({
      model: openai("gpt-4o-mini"),
      prompt: input,
      temperature: 0.8,
      system: `
        You are an expert AI assistant specializing in invoice-related content generation and improvement. Your task is to enhance or modify invoice text based on specific instructions. Follow these guidelines:

        1. Language: Always respond in the same language as the input prompt.
        2. Conciseness: Keep responses brief and precise, with a maximum of 200 characters.

        You will perform one of these primary functions:
        - Fix grammar: Rectify any grammatical errors while preserving the original meaning.
        - Improve text: Refine the text to improve clarity and professionalism.
        - Condense text: Remove any unnecessary text and only keep the invoice-related content and make it more concise.

        Format your response as plain text, using '\n' for line breaks when necessary.
        Do not include any titles or headings in your response.
        Provide only invoice-relevant content without any extraneous information.
        Begin your response directly with the relevant invoice text or information.

        For custom prompts, maintain focus on invoice-related content. Ensure all generated text is appropriate for formal business communications and adheres to standard invoice practices.
        Current date is: ${new Date().toISOString().split("T")[0]} \n
      ${context}
`,
    });

    for await (const delta of textStream) {
      stream.update(delta);
    }

    stream.done();
  })();

  return { output: stream.value };
}
</file>

<file path="apps/dashboard/src/actions/ai/filters/generate-invoice-filters.ts">
"use server";

import { openai } from "@ai-sdk/openai";
import { streamObject } from "ai";
import { createStreamableValue } from "ai/rsc";
import { z } from "zod";

const schema = z.object({
  name: z.string().optional().describe("The name to search for"),
  statuses: z
    .array(z.enum(["draft", "overdue", "paid", "unpaid", "canceled"]))
    .optional()
    .describe("The statuses to filter by"),
  start: z
    .date()
    .optional()
    .describe("The start date when to retrieve from. Return ISO-8601 format."),
  end: z
    .date()
    .optional()
    .describe(
      "The end date when to retrieve data from. If not provided, defaults to the current date. Return ISO-8601 format.",
    ),
  customers: z
    .array(z.string())
    .optional()
    .describe("The customers to filter by"),
});

export async function generateInvoiceFilters(prompt: string, context?: string) {
  const stream = createStreamableValue();

  (async () => {
    const { partialObjectStream } = await streamObject({
      model: openai("gpt-4o-mini"),
      system: `You are a helpful assistant that generates filters for a given prompt. \n
                Current date is: ${new Date().toISOString().split("T")[0]} \n
                ${context}
        `,
      schema,
      prompt,
    });

    for await (const partialObject of partialObjectStream) {
      stream.update(partialObject);
    }

    stream.done();
  })();

  return { object: stream.value };
}
</file>

<file path="apps/dashboard/src/actions/ai/filters/generate-tracker-filters.ts">
"use server";

import { openai } from "@ai-sdk/openai";
import { streamObject } from "ai";
import { createStreamableValue } from "ai/rsc";
import { z } from "zod";

const schema = z.object({
  name: z.string().optional().describe("The name to search for"),
  start: z
    .date()
    .optional()
    .describe("The start date when to retrieve from. Return ISO-8601 format."),
  end: z
    .date()
    .optional()
    .describe(
      "The end date when to retrieve data from. If not provided, defaults to the current date. Return ISO-8601 format.",
    ),
  status: z
    .enum(["in_progress", "completed"])
    .optional()
    .describe("The status to filter by"),
});

export async function generateTrackerFilters(prompt: string, context?: string) {
  const stream = createStreamableValue();

  (async () => {
    const { partialObjectStream } = await streamObject({
      model: openai("gpt-4o-mini"),
      system: `You are a helpful assistant that generates filters for a given prompt. \n
               Current date is: ${new Date().toISOString().split("T")[0]} \n
               ${context}
      `,
      schema,
      prompt,
    });

    for await (const partialObject of partialObjectStream) {
      stream.update(partialObject);
    }

    stream.done();
  })();

  return { object: stream.value };
}
</file>

<file path="apps/dashboard/src/actions/ai/filters/generate-transactions-filters.ts">
"use server";

import { openai } from "@ai-sdk/openai";
import { streamObject } from "ai";
import { createStreamableValue } from "ai/rsc";
import { z } from "zod";

const schema = z.object({
  name: z.string().optional().describe("The name to search for"),
  start: z
    .date()
    .optional()
    .describe("The start date when to retrieve from. Return ISO-8601 format."),
  end: z
    .date()
    .optional()
    .describe(
      "The end date when to retrieve data from. If not provided, defaults to the current date. Return ISO-8601 format.",
    ),
  attachments: z
    .enum(["exclude", "include"])
    .optional()
    .describe(
      "Whether to include or exclude results with attachments or receipts.",
    ),
  categories: z
    .array(z.string())
    .optional()
    .describe("The categories to filter by"),
  tags: z.array(z.string()).optional().describe("The tags to filter by"),
  recurring: z
    .array(z.enum(["all", "weekly", "monthly", "annually"]))
    .optional()
    .describe("The recurring to filter by"),
  amount_range: z
    .array(z.number())
    .optional()
    .describe("The amount range to filter by"),
});

export async function generateTransactionsFilters(
  prompt: string,
  context?: string,
) {
  const stream = createStreamableValue();

  (async () => {
    const { partialObjectStream } = await streamObject({
      model: openai("gpt-4o-mini"),
      system: `You are a helpful assistant that generates filters for a given prompt. \n
               Current date is: ${new Date().toISOString().split("T")[0]} \n
               ${context}
      `,
      schema,
      prompt,
    });

    for await (const partialObject of partialObjectStream) {
      stream.update(partialObject);
    }

    stream.done();
  })();

  return { object: stream.value };
}
</file>

<file path="apps/dashboard/src/actions/ai/filters/generate-vault-filters.ts">
"use server";

import { openai } from "@ai-sdk/openai";
import { streamObject } from "ai";
import { createStreamableValue } from "ai/rsc";
import { z } from "zod";

const schema = z.object({
  name: z.string().optional().describe("The name or description to search for"),
  start: z
    .date()
    .optional()
    .describe("The start date when to retrieve from. Return ISO-8601 format."),
  end: z
    .date()
    .optional()
    .describe(
      "The end date when to retrieve data from. If not provided, defaults to the current date. Return ISO-8601 format.",
    ),
});

export async function generateVaultFilters(prompt: string, context?: string) {
  const stream = createStreamableValue();

  (async () => {
    const { partialObjectStream } = await streamObject({
      model: openai("gpt-4o-mini"),
      system: `You are a helpful assistant that generates filters for a given prompt. \n
               Current date is: ${new Date().toISOString().split("T")[0]} \n
               ${context}
      `,
      schema,
      prompt,
    });

    for await (const partialObject of partialObjectStream) {
      stream.update(partialObject);
    }

    stream.done();
  })();

  return { object: stream.value };
}
</file>

<file path="apps/dashboard/src/actions/ai/generate-csv-mapping.ts">
"use server";

import { openai } from "@ai-sdk/openai";
import { streamObject } from "ai";
import { createStreamableValue } from "ai/rsc";
import { z } from "zod";

export async function generateCsvMapping(
  fieldColumns: string[],
  firstRows: Record<string, string>[],
) {
  const stream = createStreamableValue();

  (async () => {
    const { partialObjectStream } = await streamObject({
      model: openai("gpt-4o-mini"),
      schema: z.object({
        date: z
          .date()
          .transform((value) => new Date(value))
          .describe(
            "The date of the transaction, return it in ISO-8601 format",
          ),
        description: z.string().describe("The text describing the transaction"),
        amount: z
          .number()
          .describe(
            "The amount involved in the transaction, including the minus sign if present",
          ),
        balance: z
          .number()
          .optional()
          .describe(
            "The balance of the account after the transaction, typically a cumulative value that changes with each transaction. It's usually a larger number compared to individual transaction amounts.",
          ),
      }),
      prompt: `
        The following columns are the headings from a CSV import file for importing a transactions. 
        Map these column names to the correct fields in our database (date, description, amount, balance) by providing the matching column name for each field.
        You may also consult the first few rows of data to help you make the mapping, but you are mapping the columns, not the values. 
        If you are not sure or there is no matching column, omit the value.

        Columns:
        ${fieldColumns.join(",")}

        First few rows of data:
        ${firstRows.map((row) => JSON.stringify(row)).join("\n")}
      `,
    });

    for await (const partialObject of partialObjectStream) {
      stream.update(partialObject);
    }

    stream.done();
  })();

  return { object: stream.value };
}
</file>

<file path="apps/dashboard/src/actions/ai/get-tax-rate.ts">
"use server";

import { openai } from "@ai-sdk/openai";
import { getCountry } from "@midday/location";
import { generateObject } from "ai";
import { z } from "zod";
import { authActionClient } from "../safe-action";

export const getTaxRateAction = authActionClient
  .schema(
    z.object({
      name: z.string().min(2),
    }),
  )
  .metadata({
    name: "get-tax-rate",
  })
  .action(async ({ parsedInput: { name } }) => {
    const country = await getCountry();

    const { object } = await generateObject({
      model: openai("gpt-5-mini"),
      schema: z.object({
        taxRate: z.number().min(5).max(50),
      }),
      prompt: `
        You are an expert tax consultant specializing in VAT/GST rates for businesses across different countries and industries.
        
        Please determine the standard VAT/GST rate that applies to businesses operating in the "${name}" category/industry in ${country?.name}.
        
        Consider the following:
        - Use the current standard VAT/GST rate for businesses in ${country?.name}
        - If the category "${name}" has specific exemptions or reduced rates, apply those instead
        - Focus on B2B transactions where businesses can typically reclaim input VAT
        - If multiple rates could apply, choose the most commonly applicable rate for this business category
        - Return the rate as a percentage (e.g., 20 for 20% VAT)
        
        Country: ${country?.name}
        Business Category: ${name}
      `,
      // temperature: 0,
    });

    return {
      taxRate: object.taxRate,
      country: country?.name,
    };
  });
</file>

<file path="apps/dashboard/src/actions/institutions/create-enablebanking-link.ts">
"use server";

import { client } from "@midday/engine-client";
import { LogEvents } from "@midday/events/events";
import { getCountryCode } from "@midday/location";
import { redirect } from "next/navigation";
import { z } from "zod";
import { authActionClient } from "../safe-action";

export const createEnableBankingLinkAction = authActionClient
  .schema(
    z.object({
      institutionId: z.string(),
      maximumConsentValidity: z.number(),
      country: z.string().optional().nullable(),
      isDesktop: z.boolean(),
      type: z.enum(["personal", "business"]),
    }),
  )
  .metadata({
    name: "create-enablebanking-link",
  })
  .action(
    async ({
      parsedInput: {
        institutionId,
        maximumConsentValidity,
        country: countryCode,
        isDesktop,
        type,
      },
      ctx: { analytics, teamId },
    }) => {
      analytics.track({
        event: LogEvents.EnableBankingLinkCreated.name,
        institutionId,
        isDesktop,
      });

      const country = countryCode ?? (await getCountryCode());

      try {
        const linkResponse = await client.auth.enablebanking.link.$post({
          json: {
            institutionId,
            country,
            type,
            teamId: teamId!,
            validUntil: new Date(Date.now() + maximumConsentValidity * 1000)
              .toISOString()
              .replace(/\.\d+Z$/, ".000000+00:00"),
            state: isDesktop ? "desktop:connect" : "web:connect",
          },
        });

        if (!linkResponse.ok) {
          throw new Error("Failed to create link");
        }

        const { data: linkData } = await linkResponse.json();

        return redirect(linkData.url);
      } catch (error) {
        // Ignore NEXT_REDIRECT error in analytics
        if (error instanceof Error && error.message !== "NEXT_REDIRECT") {
          analytics.track({
            event: LogEvents.EnableBankingLinkFailed.name,
            institutionId,
          });

          throw error;
        }

        throw error;
      }
    },
  );
</file>

<file path="apps/dashboard/src/actions/institutions/create-gocardless-link.ts">
"use server";

import { client } from "@midday/engine-client";
import { LogEvents } from "@midday/events/events";
import { redirect } from "next/navigation";
import { z } from "zod";
import { authActionClient } from "../safe-action";

export const createGoCardLessLinkAction = authActionClient
  .schema(
    z.object({
      institutionId: z.string(),
      step: z.string().optional(),
      availableHistory: z.number(),
      redirectBase: z.string(),
    }),
  )
  .metadata({
    name: "create-gocardless-link",
  })
  .action(
    async ({
      parsedInput: {
        institutionId,
        availableHistory,
        redirectBase,
        step = "account",
      },
      ctx: { analytics },
    }) => {
      const redirectTo = new URL(redirectBase);

      redirectTo.searchParams.append("step", step);
      redirectTo.searchParams.append("provider", "gocardless");

      analytics.track({
        event: LogEvents.GoCardLessLinkCreated.name,
        institutionId,
        availableHistory,
        redirectBase,
        step,
      });

      try {
        const agreementResponse = await client.auth.gocardless.agreement.$post({
          json: {
            institutionId,
            transactionTotalDays: availableHistory,
          },
        });

        if (!agreementResponse.ok) {
          throw new Error("Failed to create agreement");
        }

        const { data: agreementData } = await agreementResponse.json();

        const linkResponse = await client.auth.gocardless.link.$post({
          json: {
            agreement: agreementData.id,
            institutionId,
            redirect: redirectTo.toString(),
          },
        });

        if (!linkResponse.ok) {
          throw new Error("Failed to create link");
        }

        const { data: linkData } = await linkResponse.json();

        return redirect(linkData.link);
      } catch (error) {
        // Ignore NEXT_REDIRECT error in analytics
        if (error instanceof Error && error.message !== "NEXT_REDIRECT") {
          analytics.track({
            event: LogEvents.GoCardLessLinkFailed.name,
            institutionId,
            availableHistory,
            redirectBase,
          });

          throw error;
        }

        throw error;
      }
    },
  );
</file>

<file path="apps/dashboard/src/actions/institutions/create-plaid-link.ts">
"use server";

import { client } from "@midday/engine-client";
import { getSession } from "@midday/supabase/cached-queries";

export const createPlaidLinkTokenAction = async (accessToken?: string) => {
  const {
    data: { session },
  } = await getSession();

  const plaidResponse = await client.auth.plaid.link.$post({
    json: {
      userId: session?.user?.id,
      accessToken,
    },
  });

  if (!plaidResponse.ok) {
    throw new Error("Failed to create plaid link token");
  }

  const { data } = await plaidResponse.json();

  return data.link_token;
};
</file>

<file path="apps/dashboard/src/actions/institutions/exchange-public-token.ts">
"use server";

import { client } from "@midday/engine-client";

export const exchangePublicToken = async (token: string) => {
  const plaidResponse = await client.auth.plaid.exchange.$post({
    json: { token },
  });

  if (!plaidResponse.ok) {
    throw new Error("Failed to exchange public token");
  }

  const { data } = await plaidResponse.json();

  return data;
};
</file>

<file path="apps/dashboard/src/actions/institutions/reconnect-enablebanking-link.ts">
"use server";

import { client } from "@midday/engine-client";
import { LogEvents } from "@midday/events/events";
import { redirect } from "next/navigation";
import { z } from "zod";
import { authActionClient } from "../safe-action";

export const reconnectEnableBankingLinkAction = authActionClient
  .schema(
    z.object({
      institutionId: z.string(),
      isDesktop: z.boolean(),
      sessionId: z.string(),
    }),
  )
  .metadata({
    name: "reconnect-enablebanking-link",
  })
  .action(
    async ({
      parsedInput: { institutionId, isDesktop, sessionId },
      ctx: { analytics, teamId },
    }) => {
      analytics.track({
        event: LogEvents.EnableBankingLinkReconnected.name,
        institutionId,
        isDesktop,
      });

      const institutionResponse = await client.institutions[":id"].$get({
        param: {
          id: institutionId,
        },
      });

      if (!institutionResponse.ok) {
        throw new Error("Failed to get institution");
      }

      const { maximum_consent_validity, country, name, type } =
        await institutionResponse.json();

      const maxConsentSeconds =
        typeof maximum_consent_validity === "string"
          ? Number.parseInt(maximum_consent_validity, 10)
          : typeof maximum_consent_validity === "number"
            ? maximum_consent_validity
            : 0;

      const validUntil = new Date(Date.now() + maxConsentSeconds * 1000)
        .toISOString()
        .replace(/\.\d+Z$/, ".000000+00:00");

      try {
        const linkResponse = await client.auth.enablebanking.link.$post({
          json: {
            institutionId: name,
            country: country!,
            teamId: teamId!,
            type: type as "business" | "personal",
            validUntil,
            state: isDesktop
              ? `desktop:reconnect:${sessionId}`
              : `web:reconnect:${sessionId}`,
          },
        });

        if (!linkResponse.ok) {
          throw new Error("Failed to create link");
        }

        const { data: linkData } = await linkResponse.json();

        return redirect(linkData.url);
      } catch (error) {
        // Ignore NEXT_REDIRECT error in analytics
        if (error instanceof Error && error.message !== "NEXT_REDIRECT") {
          analytics.track({
            event: LogEvents.EnableBankingLinkFailed.name,
            institutionId,
          });

          throw error;
        }

        throw error;
      }
    },
  );
</file>

<file path="apps/dashboard/src/actions/institutions/reconnect-gocardless-link.ts">
"use server";

import { client } from "@midday/engine-client";
import { nanoid } from "nanoid";
import { redirect } from "next/navigation";
import { z } from "zod";
import { authActionClient } from "../safe-action";

export const reconnectGoCardLessLinkAction = authActionClient
  .schema(
    z.object({
      id: z.string(),
      institutionId: z.string(),
      availableHistory: z.number(),
      isDesktop: z.boolean(),
      redirectTo: z.string(),
    }),
  )
  .metadata({
    name: "create-gocardless-link",
  })
  .action(
    async ({
      parsedInput: {
        id,
        institutionId,
        availableHistory,
        redirectTo,
        isDesktop,
      },
      ctx: { teamId },
    }) => {
      const reference = `${teamId}:${nanoid()}`;

      const link = new URL(redirectTo);

      link.searchParams.append("id", id);

      if (isDesktop) {
        link.searchParams.append("desktop", "true");
      }

      const agreementResponse = await client.auth.gocardless.agreement.$post({
        json: {
          institutionId,
          transactionTotalDays: availableHistory,
        },
      });

      if (!agreementResponse.ok) {
        throw new Error("Failed to create agreement");
      }

      const { data: agreementData } = await agreementResponse.json();

      const linkResponse = await client.auth.gocardless.link.$post({
        json: {
          agreement: agreementData.id,
          institutionId,
          redirect: link.toString(),
          // In the reconnect flow we need the reference based on the team
          // so we can find the correct requestion id on success and update the current reference
          reference,
        },
      });

      if (!linkResponse.ok) {
        throw new Error("Failed to create link");
      }

      const { data: linkData } = await linkResponse.json();

      if (!linkResponse.ok) {
        throw new Error("Failed to create link");
      }

      return redirect(linkData.link);
    },
  );
</file>

<file path="apps/dashboard/src/actions/transactions/import-transactions.ts">
"use server";

import { LogEvents } from "@midday/events/events";
import { formatAmountValue } from "@midday/import";
import type { ImportTransactionsPayload } from "@midday/jobs/schema";
import { tasks } from "@trigger.dev/sdk";
import { z } from "zod";
import { authActionClient } from "../safe-action";

export const importTransactionsAction = authActionClient
  .schema(
    z.object({
      filePath: z.array(z.string()).optional(),
      bankAccountId: z.string(),
      currency: z.string(),
      currentBalance: z.string().optional(),
      inverted: z.boolean(),
      mappings: z.object({
        amount: z.string(),
        date: z.string(),
        description: z.string(),
        balance: z.string().optional(),
      }),
    }),
  )
  .metadata({
    name: "import-transactions",
    track: {
      event: LogEvents.ImportTransactions.name,
      channel: LogEvents.ImportTransactions.channel,
    },
  })
  .action(
    async ({
      parsedInput: {
        filePath,
        bankAccountId,
        currency,
        mappings,
        currentBalance,
        inverted,
      },
      ctx: { teamId, supabase },
    }) => {
      // Update currency for account
      const balance = currentBalance
        ? formatAmountValue({ amount: currentBalance })
        : null;

      await supabase
        .from("bank_accounts")
        .update({ currency, balance })
        .eq("id", bankAccountId);

      const event = await tasks.trigger("import-transactions", {
        filePath,
        bankAccountId,
        currency,
        mappings,
        teamId: teamId!,
        inverted,
      } satisfies ImportTransactionsPayload);

      return event;
    },
  );
</file>

<file path="apps/dashboard/src/actions/transactions/manual-sync-transactions-action.ts">
"use server";

import { authActionClient } from "@/actions/safe-action";
import { LogEvents } from "@midday/events/events";
import type { SyncConnectionPayload } from "@midday/jobs/schema";
import { tasks } from "@trigger.dev/sdk";
import { z } from "zod";

export const manualSyncTransactionsAction = authActionClient
  .schema(
    z.object({
      connectionId: z.string(),
    }),
  )
  .metadata({
    name: "manual-sync-transactions",
    track: {
      event: LogEvents.TransactionsManualSync.name,
      channel: LogEvents.TransactionsManualSync.channel,
    },
  })
  .action(async ({ parsedInput: { connectionId } }) => {
    const event = await tasks.trigger("sync-connection", {
      connectionId,
      manualSync: true,
    } satisfies SyncConnectionPayload);

    return event;
  });
</file>

<file path="apps/dashboard/src/actions/transactions/reconnect-connection-action.ts">
"use server";

import { authActionClient } from "@/actions/safe-action";
import { LogEvents } from "@midday/events/events";
import type { ReconnectConnectionPayload } from "@midday/jobs/schema";
import { tasks } from "@trigger.dev/sdk";
import { z } from "zod";

export const reconnectConnectionAction = authActionClient
  .schema(
    z.object({
      connectionId: z.string(),
      provider: z.string(),
    }),
  )
  .metadata({
    name: "reconnect-connection",
    track: {
      event: LogEvents.ReconnectConnection.name,
      channel: LogEvents.ReconnectConnection.channel,
    },
  })
  .action(
    async ({ parsedInput: { connectionId, provider }, ctx: { teamId } }) => {
      const event = await tasks.trigger("reconnect-connection", {
        teamId: teamId!,
        connectionId,
        provider,
      } satisfies ReconnectConnectionPayload);

      return event;
    },
  );
</file>

<file path="apps/dashboard/src/actions/export-transactions-action.ts">
"use server";

import { LogEvents } from "@midday/events/events";
import type { ExportTransactionsPayload } from "@midday/jobs/schema";
import { tasks } from "@trigger.dev/sdk";
import { z } from "zod";
import { authActionClient } from "./safe-action";

export const exportTransactionsAction = authActionClient
  .schema(
    z.object({
      transactionIds: z.array(z.string()),
      dateFormat: z.string().optional(),
      locale: z.string().optional().default("en"),
    }),
  )
  .metadata({
    name: "export-transactions",
    track: {
      event: LogEvents.ExportTransactions.name,
      channel: LogEvents.ExportTransactions.channel,
    },
  })
  .action(
    async ({
      parsedInput: { transactionIds, dateFormat, locale },
      ctx: { teamId },
    }) => {
      if (!teamId) {
        throw new Error("Team not found");
      }

      const event = await tasks.trigger("export-transactions", {
        teamId,
        locale,
        transactionIds,
        dateFormat,
      } satisfies ExportTransactionsPayload);

      return event;
    },
  );
</file>

<file path="apps/dashboard/src/actions/hide-connect-flow-action.ts">
"use server";

import { Cookies } from "@/utils/constants";
import { addYears } from "date-fns";
import { cookies } from "next/headers";
import { authActionClient } from "./safe-action";

export const hideConnectFlowAction = authActionClient
  .metadata({
    name: "hide-connect-flow",
  })
  .action(async () => {
    (await cookies()).set({
      name: Cookies.HideConnectFlow,
      value: "true",
      expires: addYears(new Date(), 1),
    });
  });
</file>

<file path="apps/dashboard/src/actions/mfa-verify-action.ts">
"use server";

import { LogEvents } from "@midday/events/events";
import { revalidatePath } from "next/cache";
import { z } from "zod";
import { authActionClient } from "./safe-action";

export const mfaVerifyAction = authActionClient
  .schema(
    z.object({
      factorId: z.string(),
      challengeId: z.string(),
      code: z.string(),
    }),
  )
  .metadata({
    name: "mfa-verify",
    track: {
      event: LogEvents.MfaVerify.name,
      channel: LogEvents.MfaVerify.channel,
    },
  })
  .action(
    async ({
      parsedInput: { factorId, challengeId, code },
      ctx: { supabase },
    }) => {
      const { data } = await supabase.auth.mfa.verify({
        factorId,
        challengeId,
        code,
      });

      revalidatePath("/account/security");

      return data;
    },
  );
</file>

<file path="apps/dashboard/src/actions/revalidate-action.ts">
"use server";

import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";

export async function revalidateAfterTeamChange() {
  // Revalidate the layout and all pages that depend on user/team data
  revalidatePath("/", "layout"); // This revalidates the entire layout
  revalidatePath("/"); // Revalidate the root page
  revalidatePath("/teams"); // Revalidate teams page

  // Redirect to home after revalidating
  redirect("/");
}
</file>

<file path="apps/dashboard/src/actions/safe-action.ts">
import { getQueryClient, trpc } from "@/trpc/server";
import { logger } from "@/utils/logger";
import { setupAnalytics } from "@midday/events/server";
import { createClient } from "@midday/supabase/server";
import {
  DEFAULT_SERVER_ERROR_MESSAGE,
  createSafeActionClient,
} from "next-safe-action";
import { z } from "zod";

export const actionClient = createSafeActionClient({
  handleServerError(e) {
    if (e instanceof Error) {
      return e.message;
    }

    return DEFAULT_SERVER_ERROR_MESSAGE;
  },
});

export const actionClientWithMeta = createSafeActionClient({
  defineMetadataSchema() {
    return z.object({
      name: z.string(),
      track: z
        .object({
          event: z.string(),
          channel: z.string(),
        })
        .optional(),
    });
  },
  handleServerError(e) {
    if (e instanceof Error) {
      return e.message;
    }

    return DEFAULT_SERVER_ERROR_MESSAGE;
  },
});

export const authActionClient = actionClientWithMeta
  .use(async ({ next, clientInput, metadata }) => {
    const result = await next({ ctx: {} });

    if (process.env.NODE_ENV === "development") {
      logger("Input ->", clientInput);
      logger("Result ->", result.data);
      logger("Metadata ->", metadata);

      return result;
    }

    return result;
  })
  .use(async ({ next, metadata }) => {
    const queryClient = getQueryClient();
    const user = await queryClient.fetchQuery(trpc.user.me.queryOptions());

    const supabase = await createClient();

    if (!user) {
      throw new Error("Unauthorized");
    }

    const analytics = await setupAnalytics({
      userId: user.id,
      fullName: user.fullName,
    });

    if (metadata?.track) {
      analytics.track(metadata.track);
    }

    return next({
      ctx: {
        supabase,
        analytics,
        user,
        teamId: user.teamId,
      },
    });
  });
</file>

<file path="apps/dashboard/src/actions/send-feedback-action.ts">
"use server";

import { LogEvents } from "@midday/events/events";
import { PlainClient } from "@team-plain/typescript-sdk";
import { z } from "zod";
import { authActionClient } from "./safe-action";

const client = new PlainClient({
  apiKey: process.env.PLAIN_API_KEY!,
});

export const sendFeebackAction = authActionClient
  .schema(
    z.object({
      feedback: z.string(),
    }),
  )
  .metadata({
    name: "send-feedback",
    track: {
      event: LogEvents.SendFeedback.name,
      channel: LogEvents.SendFeedback.channel,
    },
  })
  .action(async ({ parsedInput: { feedback }, ctx: { user } }) => {
    const customer = await client.upsertCustomer({
      identifier: {
        emailAddress: user.email,
      },
      onCreate: {
        fullName: user.fullName ?? "",
        externalId: user.id,
        email: {
          email: user.email!,
          isVerified: true,
        },
      },
      onUpdate: {},
    });

    const response = await client.createThread({
      title: "Feedback",
      customerIdentifier: {
        customerId: customer.data?.customer.id,
      },
      // Feedback
      labelTypeIds: ["lt_01HV93GFTZAKESXMVY8X371ADG"],
      components: [
        {
          componentText: {
            text: feedback,
          },
        },
      ],
    });

    return response;
  });
</file>

<file path="apps/dashboard/src/actions/send-support-action.tsx">
"use server";

import { LogEvents } from "@midday/events/events";
import { PlainClient, ThreadFieldSchemaType } from "@team-plain/typescript-sdk";
import { z } from "zod";
import { authActionClient } from "./safe-action";

const client = new PlainClient({
  apiKey: process.env.PLAIN_API_KEY!,
});

const mapToPriorityNumber = (priority: string) => {
  switch (priority) {
    case "low":
      return 0;
    case "normal":
      return 1;
    case "high":
      return 2;
    case "urgent":
      return 3;
    default:
      return 1;
  }
};

export const sendSupportAction = authActionClient
  .schema(
    z.object({
      subject: z.string(),
      priority: z.string(),
      type: z.string(),
      message: z.string(),
      url: z.string().optional(),
    }),
  )
  .metadata({
    name: "send-support",
    track: {
      event: LogEvents.SupportTicket.name,
      channel: LogEvents.SupportTicket.channel,
    },
  })
  .action(async ({ parsedInput: data, ctx: { user } }) => {
    const customer = await client.upsertCustomer({
      identifier: {
        emailAddress: user.email,
      },
      onCreate: {
        fullName: user.fullName ?? "",
        externalId: user.id,
        email: {
          email: user.email!,
          isVerified: true,
        },
      },
      onUpdate: {},
    });

    const response = await client.createThread({
      title: data.subject,
      description: data.message,
      priority: mapToPriorityNumber(data.priority),
      customerIdentifier: {
        customerId: customer.data?.customer.id,
      },
      // Support
      labelTypeIds: ["lt_01HV93FQT6NSC1EN2HHA6BG9WK"],
      components: [
        {
          componentText: {
            text: data.message,
          },
        },
      ],
      threadFields: data.url
        ? [
            {
              type: ThreadFieldSchemaType.String,
              key: "url",
              stringValue: data.url,
            },
          ]
        : undefined,
    });

    return response;
  });
</file>

<file path="apps/dashboard/src/actions/set-weekly-calendar-action.ts">
"use server";

import { Cookies } from "@/utils/constants";
import { addYears } from "date-fns";
import { cookies } from "next/headers";
import { z } from "zod";
import { actionClient } from "./safe-action";

export const setWeeklyCalendarAction = actionClient
  .schema(z.boolean())
  .action(async ({ parsedInput: value }) => {
    (await cookies()).set({
      name: Cookies.WeeklyCalendar,
      value: value ? "true" : "false",
      expires: addYears(new Date(), 1),
    });

    return value;
  });
</file>

<file path="apps/dashboard/src/actions/tracking-consent-action.ts">
"use server";

import { Cookies } from "@/utils/constants";
import { addYears } from "date-fns";
import { cookies } from "next/headers";
import { z } from "zod";
import { actionClient } from "./safe-action";

export const trackingConsentAction = actionClient
  .schema(z.boolean())
  .action(async ({ parsedInput: value }) => {
    (await cookies()).set({
      name: Cookies.TrackingConsent,
      value: value ? "1" : "0",
      expires: addYears(new Date(), 1),
    });

    return value;
  });
</file>

<file path="apps/dashboard/src/actions/unenroll-mfa-action.ts">
"use server";

import { revalidatePath } from "next/cache";
import { z } from "zod";
import { authActionClient } from "./safe-action";

export const unenrollMfaAction = authActionClient
  .schema(
    z.object({
      factorId: z.string(),
    }),
  )
  .metadata({
    name: "unenroll-mfa",
  })
  .action(async ({ parsedInput: { factorId }, ctx: { supabase } }) => {
    const { data, error } = await supabase.auth.mfa.unenroll({
      factorId,
    });

    if (error) {
      throw Error(error.message);
    }

    revalidatePath("/account/security");

    return data;
  });
</file>

<file path="apps/dashboard/src/actions/update-column-visibility-action.ts">
"use server";

import type { VisibilityState } from "@tanstack/react-table";
import { addYears } from "date-fns";
import { cookies } from "next/headers";

type Props = {
  key: string;
  data: VisibilityState;
};

export async function updateColumnVisibilityAction({ key, data }: Props) {
  (await cookies()).set(key, JSON.stringify(data), {
    expires: addYears(new Date(), 1),
  });

  return Promise.resolve(data);
}
</file>

<file path="apps/dashboard/src/actions/verify-otp-action.ts">
"use server";

import { Cookies } from "@/utils/constants";
import { createClient } from "@midday/supabase/server";
import { addYears } from "date-fns";
import { cookies } from "next/headers";
import { redirect } from "next/navigation";
import { z } from "zod";
import { actionClient } from "./safe-action";

export const verifyOtpAction = actionClient
  .schema(
    z.object({
      token: z.string(),
      email: z.string(),
      redirectTo: z.string(),
    }),
  )
  .action(async ({ parsedInput: { email, token, redirectTo } }) => {
    const supabase = await createClient();

    await supabase.auth.verifyOtp({
      email,
      token,
      type: "email",
    });

    // Validate that the session was actually established (similar to OAuth callback)
    const {
      data: { session },
    } = await supabase.auth.getSession();

    if (!session) {
      throw new Error("Failed to establish session after OTP verification");
    }

    (await cookies()).set(Cookies.PreferredSignInProvider, "otp", {
      expires: addYears(new Date(), 1),
    });

    redirect(redirectTo);
  });
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/account/date-and-locale/page.tsx">
import { ChangeTimezone } from "@/components/change-timezone";
import { DateFormatSettings } from "@/components/date-format-settings";
import { LocaleSettings } from "@/components/locale-settings";
import { TimeFormatSettings } from "@/components/time-format-settings";
import { WeekSettings } from "@/components/week-settings";
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Date & Locale | Midday",
};

export default async function Page() {
  return (
    <div className="space-y-12">
      <LocaleSettings />
      <ChangeTimezone />
      <TimeFormatSettings />
      <DateFormatSettings />
      <WeekSettings />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/account/security/page.tsx">
import { MfaSettingsList } from "@/components/mfa-settings-list";
import { AddNewDeviceModal } from "@/components/modals/add-new-device";
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Security | Midday",
};

export default async function Security() {
  return (
    <div className="space-y-12">
      <MfaSettingsList />
      <AddNewDeviceModal />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/account/support/page.tsx">
import { SupportForm } from "@/components/support-form";
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Support | Midday",
};

export default function Support() {
  return (
    <div className="space-y-12">
      <div className="max-w-[450px]">
        <SupportForm />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/account/teams/page.tsx">
import { TeamsTable } from "@/components/tables/teams";
import { TeamsSkeleton } from "@/components/tables/teams/skeleton";
import { prefetch, trpc } from "@/trpc/server";
import type { Metadata } from "next";
import { Suspense } from "react";

export const metadata: Metadata = {
  title: "Teams | Midday",
};

export default function Teams() {
  prefetch(trpc.team.list.queryOptions());
  prefetch(trpc.user.invites.queryOptions());

  return (
    <Suspense fallback={<TeamsSkeleton />}>
      <TeamsTable />
    </Suspense>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/account/layout.tsx">
import { SecondaryMenu } from "@/components/secondary-menu";

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <div className="max-w-[800px]">
      <SecondaryMenu
        items={[
          { path: "/account", label: "General" },
          { path: "/account/date-and-locale", label: "Date & Locale" },
          { path: "/account/security", label: "Security" },
          { path: "/account/teams", label: "Teams" },
          { path: "/account/support", label: "Support" },
        ]}
      />

      <main className="mt-8">{children}</main>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/account/page.tsx">
import { AccountSettings } from "@/components/account-settings";
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Account Settings | Midday",
};

export default async function Account() {
  return <AccountSettings />;
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/apps/page.tsx">
import { Apps } from "@/components/apps";
import { AppsHeader } from "@/components/apps-header";
import { AppsSkeleton } from "@/components/apps.skeleton";
import { HydrateClient, getQueryClient, trpc } from "@/trpc/server";
import type { Metadata } from "next";
import { Suspense } from "react";

export const metadata: Metadata = {
  title: "Apps | Midday",
};

export default async function Page() {
  const queryClient = getQueryClient();

  // Change this to prefetch once this is fixed: https://github.com/trpc/trpc/issues/6632
  await Promise.all([
    queryClient.fetchQuery(trpc.apps.get.queryOptions()),
    queryClient.fetchQuery(trpc.oauthApplications.list.queryOptions()),
    queryClient.fetchQuery(trpc.oauthApplications.authorized.queryOptions()),
  ]);

  return (
    <HydrateClient>
      <div className="mt-4">
        <AppsHeader />

        <Suspense fallback={<AppsSkeleton />}>
          <Apps />
        </Suspense>
      </div>
    </HydrateClient>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/customers/page.tsx">
import { CustomersHeader } from "@/components/customers-header";
import { ErrorFallback } from "@/components/error-fallback";
import { InactiveClients } from "@/components/inactive-clients";
import { InvoiceSummarySkeleton } from "@/components/invoice-summary";
import { MostActiveClient } from "@/components/most-active-client";
import { NewCustomersThisMonth } from "@/components/new-customers-this-month";
import { DataTable } from "@/components/tables/customers/data-table";
import { CustomersSkeleton } from "@/components/tables/customers/skeleton";
import { TopRevenueClient } from "@/components/top-revenue-client";
import { loadCustomerFilterParams } from "@/hooks/use-customer-filter-params";
import { loadSortParams } from "@/hooks/use-sort-params";
import {
  HydrateClient,
  batchPrefetch,
  getQueryClient,
  trpc,
} from "@/trpc/server";
import type { Metadata } from "next";
import { ErrorBoundary } from "next/dist/client/components/error-boundary";
import type { SearchParams } from "nuqs";
import { Suspense } from "react";

export const metadata: Metadata = {
  title: "Customers | Midday",
};

type Props = {
  searchParams: Promise<SearchParams>;
};

export default async function Page(props: Props) {
  const queryClient = getQueryClient();
  const searchParams = await props.searchParams;

  const filter = loadCustomerFilterParams(searchParams);
  const { sort } = loadSortParams(searchParams);

  // Change this to prefetch once this is fixed: https://github.com/trpc/trpc/issues/6632
  await queryClient.fetchInfiniteQuery(
    trpc.customers.get.infiniteQueryOptions({
      ...filter,
      sort,
    }),
  );

  // Prefetch customer analytics
  batchPrefetch([
    trpc.invoice.mostActiveClient.queryOptions(),
    trpc.invoice.inactiveClientsCount.queryOptions(),
    trpc.invoice.topRevenueClient.queryOptions(),
    trpc.invoice.newCustomersCount.queryOptions(),
  ]);

  return (
    <HydrateClient>
      <div className="flex flex-col gap-6">
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 pt-6">
          <Suspense fallback={<InvoiceSummarySkeleton />}>
            <MostActiveClient />
          </Suspense>
          <Suspense fallback={<InvoiceSummarySkeleton />}>
            <InactiveClients />
          </Suspense>
          <Suspense fallback={<InvoiceSummarySkeleton />}>
            <TopRevenueClient />
          </Suspense>
          <Suspense fallback={<InvoiceSummarySkeleton />}>
            <NewCustomersThisMonth />
          </Suspense>
        </div>

        <CustomersHeader />

        <ErrorBoundary errorComponent={ErrorFallback}>
          <Suspense fallback={<CustomersSkeleton />}>
            <DataTable />
          </Suspense>
        </ErrorBoundary>
      </div>
    </HydrateClient>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/inbox/settings/page.tsx">
import { InboxConnectedAccounts } from "@/components/inbox/inbox-connected-accounts";
import { InboxEmailSettings } from "@/components/inbox/inbox-email-settings";
import { prefetch, trpc } from "@/trpc/server";
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Inbox Settings | Midday",
};

export default async function Page() {
  prefetch(trpc.inboxAccounts.get.queryOptions());

  return (
    <div className="max-w-[800px]">
      <main className="mt-8">
        <div className="space-y-12">
          <InboxEmailSettings />
          <InboxConnectedAccounts />
        </div>
      </main>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/inbox/page.tsx">
import { Inbox } from "@/components/inbox";
import { InboxGetStarted } from "@/components/inbox/inbox-get-started";
import { InboxViewSkeleton } from "@/components/inbox/inbox-skeleton";
import { InboxView } from "@/components/inbox/inbox-view";
import { loadInboxFilterParams } from "@/hooks/use-inbox-filter-params";
import { loadInboxParams } from "@/hooks/use-inbox-params";
import { HydrateClient, getQueryClient, trpc } from "@/trpc/server";
import type { Metadata } from "next";
import type { SearchParams } from "nuqs";
import { Suspense } from "react";

export const metadata: Metadata = {
  title: "Inbox | Midday",
};

type Props = {
  searchParams: Promise<SearchParams>;
};

export default async function Page(props: Props) {
  const queryClient = getQueryClient();
  const searchParams = await props.searchParams;
  const filter = loadInboxFilterParams(searchParams);
  const params = loadInboxParams(searchParams);

  // Change this to prefetch once this is fixed: https://github.com/trpc/trpc/issues/6632
  const data = await queryClient.fetchInfiniteQuery(
    trpc.inbox.get.infiniteQueryOptions({
      order: params.order,
      ...filter,
    }),
  );

  if (
    !params.connected &&
    data.pages[0]?.data.length === 0 &&
    !Object.values(filter).some((value) => value !== null)
  ) {
    return <InboxGetStarted />;
  }

  return (
    <HydrateClient>
      <Inbox>
        <Suspense fallback={<InboxViewSkeleton />}>
          <InboxView />
        </Suspense>
      </Inbox>
    </HydrateClient>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/invoices/page.tsx">
import { ErrorFallback } from "@/components/error-fallback";
import { InvoiceHeader } from "@/components/invoice-header";
import {
  InvoicePaymentScore,
  InvoicePaymentScoreSkeleton,
} from "@/components/invoice-payment-score";
import { InvoiceSummarySkeleton } from "@/components/invoice-summary";
import { InvoicesOpen } from "@/components/invoices-open";
import { InvoicesOverdue } from "@/components/invoices-overdue";
import { InvoicesPaid } from "@/components/invoices-paid";
import { DataTable } from "@/components/tables/invoices/data-table";
import { InvoiceSkeleton } from "@/components/tables/invoices/skeleton";
import { loadInvoiceFilterParams } from "@/hooks/use-invoice-filter-params";
import { loadSortParams } from "@/hooks/use-sort-params";
import { batchPrefetch, trpc } from "@/trpc/server";
import { getInitialInvoicesColumnVisibility } from "@/utils/columns";
import type { Metadata } from "next";
import { ErrorBoundary } from "next/dist/client/components/error-boundary";
import type { SearchParams } from "nuqs";
import { Suspense } from "react";

export const metadata: Metadata = {
  title: "Invoices | Midday",
};

type Props = {
  searchParams: Promise<SearchParams>;
};

export default async function Page(props: Props) {
  const searchParams = await props.searchParams;

  const filter = loadInvoiceFilterParams(searchParams);
  const { sort } = loadSortParams(searchParams);

  const columnVisibility = getInitialInvoicesColumnVisibility();

  batchPrefetch([
    trpc.invoice.get.infiniteQueryOptions({
      ...filter,
      sort,
    }),
    trpc.invoice.invoiceSummary.queryOptions({
      status: "unpaid",
    }),
    trpc.invoice.invoiceSummary.queryOptions({
      status: "paid",
    }),
    trpc.invoice.invoiceSummary.queryOptions({
      status: "overdue",
    }),
    trpc.invoice.paymentStatus.queryOptions(),
  ]);

  return (
    <div className="flex flex-col gap-6">
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 pt-6">
        <Suspense fallback={<InvoiceSummarySkeleton />}>
          <InvoicesOpen />
        </Suspense>
        <Suspense fallback={<InvoiceSummarySkeleton />}>
          <InvoicesOverdue />
        </Suspense>
        <Suspense fallback={<InvoiceSummarySkeleton />}>
          <InvoicesPaid />
        </Suspense>
        <Suspense fallback={<InvoicePaymentScoreSkeleton />}>
          <InvoicePaymentScore />
        </Suspense>
      </div>

      <InvoiceHeader />

      <ErrorBoundary errorComponent={ErrorFallback}>
        <Suspense fallback={<InvoiceSkeleton />}>
          <DataTable columnVisibility={columnVisibility} />
        </Suspense>
      </ErrorBoundary>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/settings/accounts/page.tsx">
import { BaseCurrency } from "@/components/base-currency/base-currency";
import { ConnectedAccounts } from "@/components/connected-accounts";
import { prefetch, trpc } from "@/trpc/server";
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Accounts | Midday",
};

export default async function Page() {
  prefetch(trpc.bankConnections.get.queryOptions());
  prefetch(trpc.bankAccounts.get.queryOptions({ manual: true }));
  prefetch(trpc.team.current.queryOptions());

  return (
    <div className="space-y-12">
      <ConnectedAccounts />
      <BaseCurrency />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/settings/billing/page.tsx">
import { ManageSubscription } from "@/components/manage-subscription";
import { Orders } from "@/components/orders";
import { Plans } from "@/components/plans";
import { prefetch, trpc } from "@/trpc/server";
import { getQueryClient } from "@/trpc/server";
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Billing | Midday",
};

export default async function Billing() {
  const queryClient = getQueryClient();
  const user = await queryClient.fetchQuery(trpc.user.me.queryOptions());

  const team = user?.team;

  prefetch(
    trpc.billing.orders.infiniteQueryOptions({
      pageSize: 15,
    }),
  );

  return (
    <div className="space-y-12">
      {team?.plan !== "trial" && <ManageSubscription />}

      {team?.plan === "trial" && (
        <div>
          <h2 className="text-lg font-medium leading-none tracking-tight mb-4">
            Plans
          </h2>

          <Plans />
        </div>
      )}

      {(team?.plan !== "trial" || team?.canceledAt !== null) && <Orders />}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/settings/developer/page.tsx">
import { CreateApiKeyModal } from "@/components/modals/create-api-key-modal";
import { DeleteApiKeyModal } from "@/components/modals/delete-api-key-modal";
import { EditApiKeyModal } from "@/components/modals/edit-api-key-modal";
import { OAuthSecretModal } from "@/components/modals/oauth-secret-modal";
import { OAuthApplicationCreateSheet } from "@/components/sheets/oauth-application-create-sheet";
import { OAuthApplicationEditSheet } from "@/components/sheets/oauth-application-edit-sheet";
import { DataTable } from "@/components/tables/api-keys";
import { OAuthDataTable } from "@/components/tables/oauth-applications";
import { batchPrefetch, trpc } from "@/trpc/server";
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Developer | Midday",
};

export default async function Page() {
  batchPrefetch([
    trpc.apiKeys.get.queryOptions(),
    trpc.oauthApplications.list.queryOptions(),
  ]);

  return (
    <>
      <div className="space-y-12">
        <DataTable />
        <OAuthDataTable />
      </div>

      <EditApiKeyModal />
      <DeleteApiKeyModal />
      <CreateApiKeyModal />
      <OAuthSecretModal />
      <OAuthApplicationCreateSheet />
      <OAuthApplicationEditSheet />
    </>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/settings/members/page.tsx">
import { TeamMembers } from "@/components/team-members";
import { prefetch, trpc } from "@/trpc/server";
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Members | Midday",
};

export default function Members() {
  prefetch(trpc.team.members.queryOptions());
  prefetch(trpc.team.teamInvites.queryOptions());

  return <TeamMembers />;
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/settings/notifications/page.tsx">
import { NotificationsSettingsList } from "@/components/notifications-settings-list";
import type { Metadata } from "next";
import { Suspense } from "react";

export const metadata: Metadata = {
  title: "Notifications | Midday",
};

export default async function Notifications() {
  return (
    <Suspense>
      <NotificationsSettingsList />
    </Suspense>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/settings/layout.tsx">
import { Header } from "@/components/header";
import { SecondaryMenu } from "@/components/secondary-menu";

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <div className="max-w-[800px]">
      <SecondaryMenu
        items={[
          { path: "/settings", label: "General" },
          { path: "/settings/billing", label: "Billing" },
          { path: "/settings/accounts", label: "Bank Connections" },
          { path: "/settings/members", label: "Members" },
          { path: "/settings/notifications", label: "Notifications" },
          { path: "/settings/developer", label: "Developer" },
        ]}
      />

      <main className="mt-8">{children}</main>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/settings/page.tsx">
import { CompanyCountry } from "@/components/company-country";
import { CompanyEmail } from "@/components/company-email";
import { CompanyLogo } from "@/components/company-logo";
import { CompanyName } from "@/components/company-name";
import { DeleteTeam } from "@/components/delete-team";
import { prefetch, trpc } from "@/trpc/server";
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Team Settings | Midday",
};

export default async function Account() {
  prefetch(trpc.team.current.queryOptions());

  return (
    <div className="space-y-12">
      <CompanyLogo />
      <CompanyName />
      <CompanyEmail />
      <CompanyCountry />
      <DeleteTeam />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/tracker/page.tsx">
import { OpenTrackerSheet } from "@/components/open-tracker-sheet";
import { DataTable } from "@/components/tables/tracker";
import { Loading } from "@/components/tables/tracker/loading";
import { TrackerCalendar } from "@/components/tracker-calendar";
import { TrackerSearchFilter } from "@/components/tracker-search-filter";
import { loadSortParams } from "@/hooks/use-sort-params";
import { loadTrackerFilterParams } from "@/hooks/use-tracker-filter-params";
import { prefetch, trpc } from "@/trpc/server";
import { Cookies } from "@/utils/constants";
import type { Metadata } from "next";
import { cookies } from "next/headers";
import type { SearchParams } from "nuqs";
import { Suspense } from "react";

export const metadata: Metadata = {
  title: "Tracker | Midday",
};

type Props = {
  searchParams: Promise<SearchParams>;
};

export default async function Page(props: Props) {
  const searchParams = await props.searchParams;
  const filter = loadTrackerFilterParams(searchParams);
  const { sort } = loadSortParams(searchParams);
  const weeklyCalendar = (await cookies()).get(Cookies.WeeklyCalendar);

  prefetch(
    trpc.trackerProjects.get.infiniteQueryOptions({
      ...filter,
      sort,
    }),
  );

  return (
    <div>
      <TrackerCalendar weeklyCalendar={weeklyCalendar?.value === "true"} />

      <div className="mt-14 mb-6 flex items-center justify-between space-x-4">
        <h2 className="text-md font-medium">Projects</h2>

        <div className="flex space-x-2">
          <TrackerSearchFilter />
          <OpenTrackerSheet />
        </div>
      </div>

      <Suspense fallback={<Loading />}>
        <DataTable />
      </Suspense>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/transactions/categories/page.tsx">
import { CategoriesSkeleton } from "@/components/tables/categories/skeleton";
import { DataTable } from "@/components/tables/categories/table";
import { HydrateClient, prefetch, trpc } from "@/trpc/server";
import type { Metadata } from "next";
import { Suspense } from "react";

export const metadata: Metadata = {
  title: "Categories | Midday",
};

export default async function Categories() {
  prefetch(trpc.transactionCategories.get.queryOptions());

  return (
    <div className="max-w-screen-lg">
      <HydrateClient>
        <Suspense fallback={<CategoriesSkeleton />}>
          <DataTable />
        </Suspense>
      </HydrateClient>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/transactions/page.tsx">
import { DataTable } from "@/components/tables/transactions/data-table";
import { Loading } from "@/components/tables/transactions/loading";
import { TransactionsActions } from "@/components/transactions-actions";
import { TransactionsSearchFilter } from "@/components/transactions-search-filter";
import { loadSortParams } from "@/hooks/use-sort-params";
import { loadTransactionFilterParams } from "@/hooks/use-transaction-filter-params";
import { HydrateClient, getQueryClient, trpc } from "@/trpc/server";
import { getInitialTransactionsColumnVisibility } from "@/utils/columns";
import type { Metadata } from "next";
import type { SearchParams } from "nuqs/server";
import { Suspense } from "react";

export const metadata: Metadata = {
  title: "Transactions | Midday",
};

type Props = {
  searchParams: Promise<SearchParams>;
};

export default async function Transactions(props: Props) {
  const queryClient = getQueryClient();
  const searchParams = await props.searchParams;

  const filter = loadTransactionFilterParams(searchParams);
  const { sort } = loadSortParams(searchParams);

  const columnVisibility = getInitialTransactionsColumnVisibility();

  // Change this to prefetch once this is fixed: https://github.com/trpc/trpc/issues/6632
  await queryClient.fetchInfiniteQuery(
    trpc.transactions.get.infiniteQueryOptions({
      ...filter,
      sort,
    }),
  );

  return (
    <HydrateClient>
      <div className="flex justify-between py-6">
        <TransactionsSearchFilter />
        <TransactionsActions />
      </div>

      <Suspense fallback={<Loading />}>
        <DataTable columnVisibility={columnVisibility} />
      </Suspense>
    </HydrateClient>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/vault/page.tsx">
import { VaultHeader } from "@/components/vault/vault-header";
import { VaultSkeleton } from "@/components/vault/vault-skeleton";
import { VaultView } from "@/components/vault/vault-view";
import { loadDocumentFilterParams } from "@/hooks/use-document-filter-params";
import { prefetch, trpc } from "@/trpc/server";
import type { Metadata } from "next";
import type { SearchParams } from "nuqs/server";
import { Suspense } from "react";

export const metadata: Metadata = {
  title: "Vault | Midday",
};

type Props = {
  searchParams: Promise<SearchParams>;
};

export default async function Page(props: Props) {
  const searchParams = await props.searchParams;

  const filter = loadDocumentFilterParams(searchParams);

  prefetch(
    trpc.documents.get.infiniteQueryOptions({
      ...filter,
      pageSize: 20,
    }),
  );

  return (
    <div>
      <VaultHeader />

      <Suspense fallback={<VaultSkeleton />}>
        <VaultView />
      </Suspense>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/layout.tsx">
import { ExportStatus } from "@/components/export-status";
import { GlobalTimerProvider } from "@/components/global-timer-provider";
import { Header } from "@/components/header";
import { GlobalSheets } from "@/components/sheets/global-sheets";
import { Sidebar } from "@/components/sidebar";
import { TimezoneDetector } from "@/components/timezone-detector";
import {
  HydrateClient,
  batchPrefetch,
  getQueryClient,
  trpc,
} from "@/trpc/server";
import { getCountryCode, getCurrency } from "@midday/location";
import { redirect } from "next/navigation";
import { Suspense } from "react";

export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const queryClient = getQueryClient();
  const currencyPromise = getCurrency();
  const countryCodePromise = getCountryCode();

  // NOTE: These are used in the global sheets
  batchPrefetch([
    trpc.team.current.queryOptions(),
    trpc.invoice.defaultSettings.queryOptions(),
    trpc.search.global.queryOptions({ searchTerm: "" }),
  ]);

  // NOTE: Right now we want to fetch the user and hydrate the client
  // Next steps would be to prefetch and suspense
  const user = await queryClient.fetchQuery(trpc.user.me.queryOptions());

  if (!user) {
    redirect("/login");
  }

  if (!user.fullName) {
    redirect("/setup");
  }

  if (!user.teamId) {
    redirect("/teams");
  }

  return (
    <HydrateClient>
      <div className="relative">
        <Sidebar />

        <div className="md:ml-[70px] pb-8">
          <Header />
          <div className="px-6">{children}</div>
        </div>

        <ExportStatus />

        <Suspense>
          <GlobalSheets
            currencyPromise={currencyPromise}
            countryCodePromise={countryCodePromise}
          />
        </Suspense>

        <GlobalTimerProvider />
        <TimezoneDetector />
      </div>
    </HydrateClient>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/(sidebar)/page.tsx">
import { ChartSelectors } from "@/components/charts/chart-selectors";
import { Charts } from "@/components/charts/charts";
import { EmptyState } from "@/components/charts/empty-state";
import { OverviewModal } from "@/components/modals/overview-modal";
import { Widgets } from "@/components/widgets";
import { defaultPeriod } from "@/components/widgets/spending/data";
import { loadReportsParams } from "@/hooks/use-reports-params";
import { HydrateClient, batchPrefetch, trpc } from "@/trpc/server";
import { getQueryClient } from "@/trpc/server";
import { Cookies } from "@/utils/constants";
import type { Metadata } from "next";
import { cookies } from "next/headers";
import type { SearchParams } from "nuqs";

export const metadata: Metadata = {
  title: "Overview | Midday",
};

type Props = {
  searchParams: Promise<SearchParams>;
};

export default async function Overview(props: Props) {
  const queryClient = getQueryClient();
  const searchParams = await props.searchParams;
  const { from, to, currency } = loadReportsParams(searchParams);

  const cookieStore = await cookies();
  const hideConnectFlow =
    cookieStore.get(Cookies.HideConnectFlow)?.value === "true";

  batchPrefetch([
    trpc.invoice.get.queryOptions({ pageSize: 10 }),
    trpc.invoice.paymentStatus.queryOptions(),
    trpc.reports.expense.queryOptions({
      from,
      to,
      currency: currency ?? undefined,
    }),
    trpc.reports.profit.queryOptions({
      from,
      to,
      currency: currency ?? undefined,
    }),
    trpc.reports.burnRate.queryOptions({
      from,
      to,
      currency: currency ?? undefined,
    }),
    trpc.reports.runway.queryOptions({
      from,
      to,
      currency: currency ?? undefined,
    }),
    trpc.inbox.get.queryOptions(),
    trpc.bankAccounts.balances.queryOptions(),
    trpc.documents.get.queryOptions({ pageSize: 10 }),
    trpc.reports.spending.queryOptions({
      from: defaultPeriod.from,
      to: defaultPeriod.to,
      currency: currency ?? undefined,
    }),
    trpc.transactions.get.queryOptions({
      pageSize: 15,
    }),
  ]);

  // Load the data for the first visible chart
  await Promise.all([
    queryClient.fetchQuery(
      trpc.bankAccounts.get.queryOptions({
        enabled: true,
      }),
    ),
    queryClient.fetchQuery(
      trpc.reports.revenue.queryOptions({
        from,
        to,
        currency: currency ?? undefined,
      }),
    ),
  ]);

  return (
    <HydrateClient>
      <div>
        <div className="h-[530px] mb-4">
          <ChartSelectors />

          <div className="mt-8 relative">
            <EmptyState />
            <Charts />
          </div>
        </div>

        <Widgets />
      </div>

      <OverviewModal hideConnectFlow={hideConnectFlow} />
    </HydrateClient>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/desktop/checkout/success/page.tsx">
import { CheckoutSuccessDesktop } from "@/components/checkout-success-desktop";

export default async function Page(props: {
  searchParams: Promise<{ redirectPath: string }>;
}) {
  const searchParams = await props.searchParams;
  return <CheckoutSuccessDesktop redirectPath={searchParams.redirectPath} />;
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/desktop/search/page.tsx">
"use client";

import { Search } from "@/components/search/search";
import { SearchFooter } from "@/components/search/search-footer";

export default function Page() {
  // Always render the search interface - authentication gating happens at Tauri level
  return (
    <div className="desktop-search flex flex-col h-full rounded-[10px] overflow-hidden">
      <Search />
      <SearchFooter />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/mfa/setup/page.tsx">
import { SetupMfa } from "@/components/setup-mfa";
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Setup MFA | Midday",
};

export default function Setup() {
  return <SetupMfa />;
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/mfa/verify/page.tsx">
"use client";

import { VerifyMfa } from "@/components/verify-mfa";
import { Icons } from "@midday/ui/icons";
import Link from "next/link";

export default function Verify() {
  return (
    <div>
      <div className="absolute left-5 top-4 md:left-10 md:top-10">
        <Link href="https://midday.ai">
          <Icons.LogoSmall />
        </Link>
      </div>

      <div className="flex min-h-screen justify-center items-center overflow-hidden p-6 md:p-0">
        <div className="relative z-20 m-auto flex w-full max-w-[380px] flex-col">
          <VerifyMfa />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/oauth/authorize/page.tsx">
import { OAuthConsentScreen } from "@/components/oauth/oauth-consent-screen";
import { OAuthErrorMessage } from "@/components/oauth/oauth-error-message";
import { loadOAuthParams } from "@/hooks/use-oauth-params";
import { HydrateClient, getQueryClient } from "@/trpc/server";
import { trpc } from "@/trpc/server";
import { categorizeOAuthError, validateOAuthParams } from "@/utils/oauth-utils";
import type { Metadata } from "next";
import type { SearchParams } from "nuqs";
import { Suspense } from "react";

export const metadata: Metadata = {
  title: "Authorize API Access | Midday",
};

type Props = {
  searchParams: Promise<SearchParams>;
};

export default async function Page(props: Props) {
  const searchParams = await props.searchParams;
  const { response_type, client_id, redirect_uri, scope, state } =
    loadOAuthParams(searchParams);

  // Validate OAuth parameters
  const validation = validateOAuthParams({
    response_type: response_type || undefined,
    client_id: client_id || undefined,
    redirect_uri: redirect_uri || undefined,
    scope: scope || undefined,
  });

  if (!validation.isValid) {
    return (
      <HydrateClient>
        <OAuthErrorMessage errorType={validation.errorType!} />
      </HydrateClient>
    );
  }

  // Validate OAuth application and parameters
  try {
    const queryClient = getQueryClient();

    // Validate the OAuth application info first
    await queryClient.fetchQuery(
      trpc.oauthApplications.getApplicationInfo.queryOptions({
        clientId: client_id!,
        redirectUri: redirect_uri!,
        scope: scope!,
        state: state || undefined,
      }),
    );

    // If validation passes, prefetch additional data for hydration
    await Promise.all([
      queryClient.prefetchQuery(trpc.user.me.queryOptions()),
      queryClient.prefetchQuery(
        trpc.oauthApplications.getApplicationInfo.queryOptions({
          clientId: client_id!,
          redirectUri: redirect_uri!,
          scope: scope!,
          state: state || undefined,
        }),
      ),
      queryClient.prefetchQuery(trpc.team.list.queryOptions()),
      queryClient.prefetchQuery(trpc.team.current.queryOptions()),
    ]);

    // Render the consent screen
    return (
      <HydrateClient>
        <Suspense>
          <OAuthConsentScreen />
        </Suspense>
      </HydrateClient>
    );
  } catch (error) {
    // Handle different types of validation errors
    const { errorType, customMessage, details } = categorizeOAuthError(error);

    return (
      <HydrateClient>
        <OAuthErrorMessage
          errorType={errorType}
          customMessage={customMessage}
          details={details}
        />
      </HydrateClient>
    );
  }
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/oauth/layout.tsx">
import { Icons } from "@midday/ui/icons";
import Link from "next/link";

export default function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="h-screen p-2">
      <header className="absolute top-0 left-0 z-30 w-full">
        <div className="p-6 md:p-8">
          <Link href="/">
            <Icons.LogoSmall className="h-8 w-auto" />
          </Link>
        </div>
      </header>

      {children}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/setup/page.tsx">
import { SetupForm } from "@/components/setup-form";
import { getQueryClient, trpc } from "@/trpc/server";
import { HydrateClient } from "@/trpc/server";
import { Icons } from "@midday/ui/icons";
import type { Metadata } from "next";
import Link from "next/link";
import { redirect } from "next/navigation";

export const metadata: Metadata = {
  title: "Setup account | Midday",
};

export default async function Page() {
  const queryClient = getQueryClient();
  const user = await queryClient.fetchQuery(trpc.user.me.queryOptions());

  if (!user?.id) {
    return redirect("/");
  }

  return (
    <div>
      <div className="absolute left-5 top-4 md:left-10 md:top-10">
        <Link href="/">
          <Icons.LogoSmall />
        </Link>
      </div>

      <div className="flex min-h-screen justify-center items-center overflow-hidden p-6 md:p-0">
        <div className="relative z-20 m-auto flex w-full max-w-[380px] flex-col">
          <div className="text-center">
            <h1 className="text-lg mb-2 font-serif">Update your account</h1>
            <p className="text-[#878787] text-sm mb-8">
              Add your name and an optional avatar.
            </p>
          </div>

          <HydrateClient>
            <SetupForm />
          </HydrateClient>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/teams/create/page.tsx">
import { CreateTeamForm } from "@/components/forms/create-team-form";
import { getCountryCode, getCurrency } from "@midday/location";
import { Icons } from "@midday/ui/icons";
import type { Metadata } from "next";
import Link from "next/link";

export const metadata: Metadata = {
  title: "Create Team | Midday",
};

export default function CreateTeam() {
  const currency = getCurrency();
  const countryCode = getCountryCode();

  return (
    <>
      <header className="w-full absolute left-0 right-0 flex justify-between items-center">
        <div className="ml-5 mt-4 md:ml-10 md:mt-10">
          <Link href="/">
            <Icons.LogoSmall />
          </Link>
        </div>
      </header>

      <div className="flex min-h-screen justify-center items-center overflow-hidden p-6 md:p-0">
        <div className="relative z-20 m-auto flex w-full max-w-[400px] flex-col">
          <div className="text-center">
            <h1 className="text-lg mb-2 font-serif">Setup your team</h1>
            <p className="text-[#878787] text-sm mb-8">
              Add your company name, country and currency. We’ll use this to
              personalize your experience in Midday.
            </p>
          </div>

          <CreateTeamForm
            defaultCurrencyPromise={currency}
            defaultCountryCodePromise={countryCode}
          />
        </div>
      </div>
    </>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(app)/teams/page.tsx">
import { SelectTeamTable } from "@/components/tables/select-team/table";
import { TeamInvites } from "@/components/team-invites";
import { UserMenu } from "@/components/user-menu";
import { HydrateClient, getQueryClient, prefetch, trpc } from "@/trpc/server";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import type { Metadata } from "next";
import Link from "next/link";
import { redirect } from "next/navigation";

export const metadata: Metadata = {
  title: "Teams | Midday",
};

export default async function Teams() {
  const queryClient = getQueryClient();
  const teams = await queryClient.fetchQuery(trpc.team.list.queryOptions());
  const invites = await queryClient.fetchQuery(
    trpc.team.invitesByEmail.queryOptions(),
  );

  const user = await queryClient.fetchQuery(trpc.user.me.queryOptions());

  // If no teams and no invites, redirect to create team
  if (!teams?.length && !invites?.length) {
    redirect("/teams/create");
  }

  return (
    <HydrateClient>
      <header className="w-full absolute left-0 right-0 flex justify-between items-center">
        <div className="ml-5 mt-4 md:ml-10 md:mt-10">
          <Link href="/">
            <Icons.LogoSmall />
          </Link>
        </div>

        <div className="mr-5 mt-4 md:mr-10 md:mt-10">
          <UserMenu onlySignOut />
        </div>
      </header>

      <div className="flex min-h-screen justify-center items-center overflow-hidden p-6 md:p-0">
        <div className="relative z-20 m-auto flex w-full max-w-[480px] flex-col">
          <div>
            <div className="text-center">
              <h1 className="text-lg mb-2 font-serif">
                Welcome, {user?.fullName?.split(" ").at(0)}
              </h1>
              {invites?.length > 0 ? (
                <p className="text-[#878787] text-sm mb-8">
                  Join a team you’ve been invited to or create a new one.
                </p>
              ) : (
                <p className="text-[#878787] text-sm mb-8">
                  Select a team or create a new one.
                </p>
              )}
            </div>
          </div>

          {/* If there are teams, show them */}
          {teams?.length && (
            <>
              <span className="text-sm font-mono text-[#878787] mb-4">
                Teams
              </span>
              <div className="max-h-[260px] overflow-y-auto">
                <SelectTeamTable data={teams} />
              </div>
            </>
          )}

          {/* If there are invites, show them */}
          {invites?.length > 0 && <TeamInvites />}

          <div className="text-center mt-12 border-t-[1px] border-border pt-6 w-full relative border-dashed">
            <span className="absolute left-1/2 -translate-x-1/2 text-sm text-[#878787] bg-background -top-3 px-4">
              Or
            </span>
            <Link href="/teams/create" className="w-full">
              <Button className="w-full mt-2" variant="outline">
                Create team
              </Button>
            </Link>
          </div>
        </div>
      </div>
    </HydrateClient>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(public)/all-done/event-emitter.tsx">
"use client";

import { useEffect } from "react";
import type { WindowEvent } from "./schema";

type Props = {
  event: WindowEvent;
};

export const EventEmitter = ({ event }: Props) => {
  useEffect(() => {
    if (!window?.opener) {
      return;
    }

    if (event) {
      window.opener.postMessage(event, "*");
    }
  }, [event]);

  return null;
};
</file>

<file path="apps/dashboard/src/app/[locale]/(public)/all-done/page.tsx">
import Image from "next/image";
import { notFound } from "next/navigation";
import type { SearchParams } from "nuqs";
import appIcon from "public/appicon.png";
import { EventEmitter } from "./event-emitter";
import { searchParamsSchema } from "./schema";

type Props = {
  searchParams: Promise<SearchParams>;
};

const AllDonePage = async (props: Props) => {
  const searchParams = await props.searchParams;
  const parsedSearchParams = searchParamsSchema.safeParse(searchParams);

  if (!parsedSearchParams.success) {
    notFound();
  }

  return (
    <>
      <EventEmitter event={parsedSearchParams.data.event} />
      <div>
        <div className="h-screen flex flex-col items-center justify-center text-center text-sm text-[#606060]">
          <Image
            src={appIcon}
            width={80}
            height={80}
            alt="Midday"
            quality={100}
            className="mb-10"
          />

          <p>You may close this browser tab when done</p>
        </div>
      </div>
    </>
  );
};

export default AllDonePage;
</file>

<file path="apps/dashboard/src/app/[locale]/(public)/all-done/schema.ts">
import { z } from "zod";

export const searchParamsSchema = z.object({
  event: z.literal("app_oauth_completed"),
});

export type WindowEvent = z.infer<typeof searchParamsSchema>["event"];
</file>

<file path="apps/dashboard/src/app/[locale]/(public)/i/[token]/opengraph-image.tsx">
import { getQueryClient, trpc } from "@/trpc/server";
import { getWebsiteLogo } from "@/utils/logos";
import { OgTemplate, isValidLogoUrl } from "@midday/invoice";
import { ImageResponse } from "next/og";

export const contentType = "image/png";

const CDN_URL = "https://cdn.midday.ai";

type Props = {
  params: { token: string };
};

export default async function Image({ params }: Props) {
  const queryClient = getQueryClient();

  const invoice = await queryClient.fetchQuery(
    trpc.invoice.getInvoiceByToken.queryOptions({
      token: params.token,
    }),
  );

  if (!invoice) {
    return new Response("Not found", { status: 404 });
  }

  const geistMonoRegular = fetch(
    `${CDN_URL}/fonts/GeistMono/og/GeistMono-Regular.otf`,
  ).then((res) => res.arrayBuffer());

  const geistSansRegular = fetch(
    `${CDN_URL}/fonts/Geist/og/Geist-Regular.otf`,
  ).then((res) => res.arrayBuffer());

  const logoUrl = getWebsiteLogo(invoice.customer?.website);

  const isValidLogo = await isValidLogoUrl(logoUrl);

  return new ImageResponse(
    <OgTemplate data={invoice} isValidLogo={isValidLogo} />,
    {
      width: 1200,
      height: 630,
      fonts: [
        {
          name: "GeistMono",
          data: await geistMonoRegular,
          style: "normal",
          weight: 400,
        },
        {
          name: "GeistSans",
          data: await geistSansRegular,
          style: "normal",
          weight: 400,
        },
      ],
    },
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(public)/i/[token]/page.tsx">
import CustomerHeader from "@/components/customer-header";
import InvoiceToolbar from "@/components/invoice-toolbar";
import { getQueryClient, trpc } from "@/trpc/server";
import { decrypt } from "@midday/encryption";
import { HtmlTemplate } from "@midday/invoice/templates/html";
import { createClient } from "@midday/supabase/server";
import { waitUntil } from "@vercel/functions";
import type { Metadata } from "next";
import { notFound } from "next/navigation";
import type { SearchParams } from "nuqs";

export async function generateMetadata(props: {
  params: Promise<{ token: string }>;
}): Promise<Metadata> {
  const params = await props.params;
  const queryClient = getQueryClient();

  try {
    const invoice = await queryClient.fetchQuery(
      trpc.invoice.getInvoiceByToken.queryOptions({
        token: params.token,
      }),
    );

    if (!invoice) {
      return {
        title: "Invoice Not Found",
        robots: {
          index: false,
          follow: false,
        },
      };
    }

    const title = `Invoice ${invoice.invoiceNumber} | ${invoice.team?.name}`;
    const description = `Invoice for ${invoice.customerName || invoice.customer?.name || "Customer"}`;

    return {
      title,
      description,
      openGraph: {
        title,
        description,
      },
      twitter: {
        card: "summary",
        title,
        description,
      },
      robots: {
        index: false,
        follow: false,
      },
    };
  } catch (error) {
    return {
      title: "Invoice Not Found",
      robots: {
        index: false,
        follow: false,
      },
    };
  }
}

type Props = {
  params: Promise<{ token: string }>;
  searchParams: Promise<SearchParams>;
};

async function updateInvoiceViewedAt(id: string) {
  const supabase = await createClient({ admin: true });

  await supabase
    .from("invoices")
    .update({
      viewed_at: new Date().toISOString(),
    })
    .eq("id", id);
}

export default async function Page(props: Props) {
  const params = await props.params;
  const supabase = await createClient({ admin: true });
  const searchParams = await props.searchParams;
  const viewer = decodeURIComponent(searchParams?.viewer as string);

  const {
    data: { session },
  } = await supabase.auth.getSession();

  const queryClient = getQueryClient();

  const invoice = await queryClient.fetchQuery(
    trpc.invoice.getInvoiceByToken.queryOptions({
      token: params.token,
    }),
  );

  if (!invoice) {
    notFound();
  }

  if (viewer) {
    try {
      const decryptedEmail = decrypt(viewer);

      if (decryptedEmail === invoice?.customer?.email) {
        // Only update the invoice viewed_at if the user is a viewer
        waitUntil(updateInvoiceViewedAt(invoice.id!));
      }
    } catch (error) {
      console.log(error);
    }
  }

  // If the invoice is draft and the user is not logged in, return 404 or if the invoice is not found
  if (!invoice || (invoice.status === "draft" && !session)) {
    notFound();
  }

  const width = invoice.template.size === "letter" ? 750 : 595;
  const height = invoice.template.size === "letter" ? 1056 : 842;

  return (
    <div className="flex flex-col justify-center items-center min-h-screen dotted-bg p-4 sm:p-6 md:p-0">
      <div
        className="flex flex-col w-full max-w-full py-6"
        style={{ maxWidth: width }}
      >
        <CustomerHeader
          name={invoice.customerName || (invoice.customer?.name as string)}
          website={invoice.customer?.website}
          status={invoice.status}
        />
        <div className="pb-24 md:pb-0">
          <div className="shadow-[0_24px_48px_-12px_rgba(0,0,0,0.3)] dark:shadow-[0_24px_48px_-12px_rgba(0,0,0,0.6)]">
            <HtmlTemplate data={invoice} width={width} height={height} />
          </div>
        </div>
      </div>

      <InvoiceToolbar
        token={invoice.token}
        invoiceNumber={invoice.invoiceNumber || "invoice"}
      />

      <div className="fixed bottom-4 right-4 hidden md:block">
        <a
          href="https://midday.ai?utm_source=invoice"
          target="_blank"
          rel="noreferrer"
          className="text-[9px] text-[#878787]"
        >
          Powered by <span className="text-primary">midday</span>
        </a>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(public)/login/page.tsx">
import { AppleSignIn } from "@/components/apple-sign-in";
import { ConsentBanner } from "@/components/consent-banner";
import { GithubSignIn } from "@/components/github-sign-in";
import { GoogleSignIn } from "@/components/google-sign-in";
import { OTPSignIn } from "@/components/otp-sign-in";
import { Cookies } from "@/utils/constants";
import { isEU } from "@midday/location";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { Icons } from "@midday/ui/icons";
import type { Metadata } from "next";
import { cookies, headers } from "next/headers";
import Image from "next/image";
import Link from "next/link";
import { userAgent } from "next/server";
import backgroundDark from "public/assets/bg-login-dark.jpg";
import backgroundLight from "public/assets/bg-login.jpg";

export const metadata: Metadata = {
  title: "Login | Midday",
};

export default async function Page() {
  const cookieStore = await cookies();
  const preferred = cookieStore.get(Cookies.PreferredSignInProvider);
  const showTrackingConsent =
    (await isEU()) && !cookieStore.has(Cookies.TrackingConsent);
  const { device } = userAgent({ headers: await headers() });

  let moreSignInOptions = null;
  let preferredSignInOption =
    device?.vendor === "Apple" ? (
      <div className="flex flex-col space-y-2">
        <GoogleSignIn />
        <AppleSignIn />
      </div>
    ) : (
      <GoogleSignIn />
    );

  switch (preferred?.value) {
    case "apple":
      preferredSignInOption = <AppleSignIn />;
      moreSignInOptions = (
        <>
          <GoogleSignIn />
          <GithubSignIn />
          <OTPSignIn className="border-t-[1px] border-border pt-8" />
        </>
      );
      break;

    case "github":
      preferredSignInOption = <GithubSignIn />;
      moreSignInOptions = (
        <>
          <GoogleSignIn />
          <AppleSignIn />
          <OTPSignIn className="border-t-[1px] border-border pt-8" />
        </>
      );
      break;

    case "google":
      preferredSignInOption = <GoogleSignIn />;
      moreSignInOptions = (
        <>
          <AppleSignIn />
          <GithubSignIn />
          <OTPSignIn className="border-t-[1px] border-border pt-8" />
        </>
      );
      break;

    case "otp":
      preferredSignInOption = <OTPSignIn />;
      moreSignInOptions = (
        <>
          <GoogleSignIn />
          <AppleSignIn />
          <GithubSignIn />
        </>
      );
      break;

    default:
      if (device?.vendor === "Apple") {
        moreSignInOptions = (
          <>
            <GithubSignIn />
            <OTPSignIn className="border-t-[1px] border-border pt-8" />
          </>
        );
      } else {
        moreSignInOptions = (
          <>
            <AppleSignIn />
            <GithubSignIn />
            <OTPSignIn className="border-t-[1px] border-border pt-8" />
          </>
        );
      }
  }

  return (
    <div className="h-screen p-2">
      {/* Header - Logo */}
      <header className="absolute top-0 left-0 z-30 w-full">
        <div className="p-6 md:p-8">
          <Icons.LogoSmall className="h-8 w-auto" />
        </div>
      </header>

      {/* Main Layout */}
      <div className="flex h-full">
        {/* Background Image Section - Hidden on mobile, visible on desktop */}
        <div className="hidden lg:flex lg:w-1/2 relative">
          <Image
            src={backgroundLight}
            alt="Background"
            className="object-cover dark:hidden"
            priority
            fill
          />
          <Image
            src={backgroundDark}
            alt="Background"
            className="object-cover hidden dark:block"
            priority
            fill
          />
        </div>

        {/* Login Form Section */}
        <div className="w-full lg:w-1/2 relative">
          {/* Form Content */}
          <div className="relative z-10 flex h-full items-center justify-center p-6">
            <div className="w-full max-w-md space-y-8">
              {/* Welcome Section */}
              <div className="text-center">
                <h1 className="text-lg mb-4 font-serif">Welcome to Midday</h1>
                <p className="text-[#878787] text-sm mb-8">
                  New here or coming back? Choose how you want to continue
                </p>
              </div>

              {/* Sign In Options */}
              <div className="space-y-4">
                {/* Primary Sign In Option */}
                <div className="space-y-3">{preferredSignInOption}</div>

                <div className="flex items-center justify-center">
                  <span className="text-[#878787] text-sm">Or</span>
                </div>

                {/* More Options Accordion */}
                <Accordion type="single" collapsible className="w-full">
                  <AccordionItem value="item-1" className="border-0">
                    <AccordionTrigger className="flex justify-center items-center text-sm py-2 hover:no-underline">
                      <span>Other options</span>
                    </AccordionTrigger>
                    <AccordionContent className="pt-4">
                      <div className="space-y-3">{moreSignInOptions}</div>
                    </AccordionContent>
                  </AccordionItem>
                </Accordion>
              </div>

              {/* Terms and Privacy */}
              <div className="text-center absolute bottom-4 left-0 right-0">
                <p className="text-xs text-[#878787] leading-relaxed font-mono">
                  By signing in you agree to our{" "}
                  <Link href="https://midday.ai/terms" className="underline">
                    Terms of service
                  </Link>{" "}
                  &{" "}
                  <Link href="https://midday.ai/policy" className="underline">
                    Privacy policy
                  </Link>
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Consent Banner */}
      {showTrackingConsent && <ConsentBanner />}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(public)/s/[shortId]/page.tsx">
import { getQueryClient, trpc } from "@/trpc/server";
import { formatSize } from "@/utils/format";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import type { Metadata } from "next";
import { isRedirectError } from "next/dist/client/components/redirect-error";
import { notFound, redirect } from "next/navigation";

type Props = {
  params: Promise<{ shortId: string }>;
};

export const metadata: Metadata = {
  robots: {
    index: false,
    follow: false,
  },
};

export default async function Page({ params }: Props) {
  const { shortId } = await params;

  const queryClient = getQueryClient();

  const shortLink = await queryClient.fetchQuery(
    trpc.shortLinks.get.queryOptions({ shortId }),
  );

  if (!shortLink?.url) {
    notFound();
  }

  if (shortLink.expiresAt && new Date(shortLink.expiresAt) < new Date()) {
    notFound();
  }

  if (shortLink.type === "redirect")
    try {
      redirect(shortLink.url);
    } catch (error) {
      if (isRedirectError(error)) {
        throw error;
      }

      notFound();
    }

  return (
    <div className="h-screen p-2">
      <header className="absolute top-0 left-0 z-30 w-full">
        <div className="p-6 md:p-8">
          <Icons.LogoSmall className="h-8 w-auto" />
        </div>
      </header>

      <div className="flex h-full items-center justify-center">
        <div className="w-full max-w-[400px]">
          <div className="text-center">
            <h1 className="text-lg mb-2 font-serif">Download File</h1>

            <p className="text-[#878787] text-sm mb-8">
              {shortLink.teamName} has shared a file with you
            </p>
          </div>

          <div className="space-y-4">
            <div className="border-b-[1px] border-border mb-4 pb-4">
              <div className="flex items-center justify-between">
                <p className="text-sm text-muted-foreground truncate">
                  {shortLink.fileName?.split("/").pop() ?? "File"}
                </p>
                <p className="text-xs text-muted-foreground font-mono">
                  {shortLink.size && formatSize(shortLink.size)}
                </p>
              </div>
            </div>

            <a href={shortLink.url} rel="noreferrer" download>
              <Button className="w-full mt-6" size="lg">
                <div className="flex items-center space-x-2">
                  <span>Download File</span>
                  <Icons.ArrowCoolDown className="size-4" />
                </div>
              </Button>
            </a>
          </div>

          <p className="text-xs text-muted-foreground text-center mt-4">
            This download link is secure and will expire.
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/(public)/verify/page.tsx">
import { DesktopSignInVerifyCode } from "@/components/desktop-sign-in-verify-code";

type Props = {
  searchParams: Promise<{ code: string }>;
};

export default async function Verify(props: Props) {
  const searchParams = await props.searchParams;

  return <DesktopSignInVerifyCode code={searchParams?.code} />;
}
</file>

<file path="apps/dashboard/src/app/[locale]/error.tsx">
"use client";

import { Button } from "@midday/ui/button";
import Link from "next/link";

export default function ErrorPage({ reset }: { reset: () => void }) {
  return (
    <div className="h-[calc(100vh-200px)] w-full">
      <div className="mt-8 flex flex-col items-center justify-center h-full">
        <div className="flex justify-between items-center flex-col mt-8 text-center mb-8">
          <h2 className="font-medium mb-4">Something went wrong</h2>
          <p className="text-sm text-[#878787]">
            An unexpected error has occurred. Please try again
            <br /> or contact support if the issue persists.
          </p>
        </div>

        <div className="flex space-x-4">
          <Button onClick={() => reset()} variant="outline">
            Try again
          </Button>

          <Link href="/account/support">
            <Button>Contact us</Button>
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/layout.tsx">
import "@/styles/globals.css";
import { cn } from "@midday/ui/cn";
import "@midday/ui/globals.css";
import { DesktopHeader } from "@/components/desktop-header";
import { isDesktopApp } from "@/utils/desktop";
import { Provider as Analytics } from "@midday/events/client";
import { Toaster } from "@midday/ui/toaster";
import { GeistMono } from "geist/font/mono";
import { GeistSans } from "geist/font/sans";
import type { Metadata } from "next";
import { Lora } from "next/font/google";
import { NuqsAdapter } from "nuqs/adapters/next/app";
import type { ReactElement } from "react";
import { Providers } from "./providers";

export const metadata: Metadata = {
  metadataBase: new URL("https://app.midday.ai"),
  title: "Midday | Run your business smarter",
  description:
    "Automate financial tasks, stay organized, and make informed decisions effortlessly.",
  twitter: {
    title: "Midday | Run your business smarter",
    description:
      "Automate financial tasks, stay organized, and make informed decisions effortlessly.",
    images: [
      {
        url: "https://cdn.midday.ai/opengraph-image.jpg",
        width: 800,
        height: 600,
      },
      {
        url: "https://cdn.midday.ai/opengraph-image.jpg",
        width: 1800,
        height: 1600,
      },
    ],
  },
  openGraph: {
    title: "Midday | Run your business smarter",
    description:
      "Automate financial tasks, stay organized, and make informed decisions effortlessly.",
    url: "https://app.midday.ai",
    siteName: "Midday",
    images: [
      {
        url: "https://cdn.midday.ai/opengraph-image.jpg",
        width: 800,
        height: 600,
      },
      {
        url: "https://cdn.midday.ai/opengraph-image.jpg",
        width: 1800,
        height: 1600,
      },
    ],
    locale: "en_US",
    type: "website",
  },
};

const lora = Lora({
  weight: "400",
  subsets: ["latin"],
  display: "swap",
  variable: "--font-serif",
});

export const viewport = {
  width: "device-width",
  initialScale: 1,
  maximumScale: 1,
  userScalable: false,
  themeColor: [
    { media: "(prefers-color-scheme: light)" },
    { media: "(prefers-color-scheme: dark)" },
  ],
};

export default async function Layout({
  children,
  params,
}: {
  children: ReactElement;
  params: Promise<{ locale: string }>;
}) {
  const { locale } = await params;
  const isDesktop = await isDesktopApp();

  return (
    <html
      lang={locale}
      suppressHydrationWarning
      className={cn(isDesktop && "desktop")}
    >
      <body
        className={cn(
          `${GeistSans.variable} ${GeistMono.variable} ${lora.variable} font-sans`,
          "whitespace-pre-line overscroll-none antialiased",
        )}
      >
        <DesktopHeader />

        <NuqsAdapter>
          <Providers locale={locale}>{children}</Providers>
          <Toaster />
          <Analytics />
        </NuqsAdapter>
      </body>
    </html>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/not-found.tsx">
import Image from "next/image";
import Link from "next/link";
import appIcon from "public/appicon.png";

export default function NotFound() {
  return (
    <div className="h-screen flex flex-col items-center justify-center text-center text-sm text-[#606060]">
      <Image
        src={appIcon}
        width={80}
        height={80}
        alt="Midday"
        quality={100}
        className="mb-10"
      />
      <h2 className="text-xl font-semibold mb-2">Not Found</h2>
      <p className="mb-4">Could not find requested resource</p>
      <Link href="/" className="underline">
        Return Home
      </Link>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/app/[locale]/providers.tsx">
"use client";

import { DesktopProvider } from "@/components/desktop-provider";
import { ThemeProvider } from "@/components/theme-provider";
import { I18nProviderClient } from "@/locales/client";
import { TRPCReactProvider } from "@/trpc/client";
import type { ReactNode } from "react";

type ProviderProps = {
  locale: string;
  children: ReactNode;
};

export function Providers({ locale, children }: ProviderProps) {
  return (
    <TRPCReactProvider>
      <I18nProviderClient locale={locale}>
        <DesktopProvider />

        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          {children}
        </ThemeProvider>
      </I18nProviderClient>
    </TRPCReactProvider>
  );
}
</file>

<file path="apps/dashboard/src/app/api/apps/slack/install-url/route.ts">
import { trpc } from "@/trpc/server";
import { getQueryClient } from "@/trpc/server";
import { getInstallUrl } from "@midday/app-store/slack";
import { NextResponse } from "next/server";

export async function GET() {
  const queryClient = getQueryClient();
  const user = await queryClient.fetchQuery(trpc.user.me.queryOptions());

  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  if (!user.teamId) {
    return NextResponse.json({ error: "Team not found" }, { status: 401 });
  }

  const url = await getInstallUrl({
    teamId: user.teamId,
    userId: user.id,
  });

  return NextResponse.json({
    url,
  });
}
</file>

<file path="apps/dashboard/src/app/api/apps/slack/interactive/route.ts">
export async function POST() {
  return new Response(null, { status: 200 });
}
</file>

<file path="apps/dashboard/src/app/api/apps/slack/oauth_callback/route.ts">
import { createApp } from "@midday/app-store/db";
import {
  config,
  createSlackApp,
  getSlackInstaller,
} from "@midday/app-store/slack";
import { type NextRequest, NextResponse } from "next/server";
import { z } from "zod";

const paramsSchema = z.object({
  code: z.string(),
  state: z.string(),
});

const metadataSchema = z.object({
  teamId: z.string(),
  userId: z.string(),
});

const slackAuthResponseSchema = z.object({
  ok: z.literal(true),
  app_id: z.string(),
  authed_user: z.object({
    id: z.string(),
  }),
  scope: z.string(),
  token_type: z.literal("bot"),
  access_token: z.string(),
  bot_user_id: z.string(),
  team: z.object({
    id: z.string(),
    name: z.string(),
  }),
  incoming_webhook: z.object({
    channel: z.string(),
    channel_id: z.string(),
    configuration_url: z.string().url(),
    url: z.string().url(),
  }),
});

export async function GET(request: NextRequest) {
  const requestUrl = new URL(request.url);

  const rawParams = Object.fromEntries(requestUrl.searchParams.entries());
  const parsedParams = paramsSchema.safeParse(rawParams);

  if (!parsedParams.success) {
    console.error("Invalid params", parsedParams.error.errors);
    return NextResponse.json({ error: "Invalid params" }, { status: 400 });
  }

  const veryfiedState = await getSlackInstaller().stateStore?.verifyStateParam(
    new Date(),
    parsedParams.data.state,
  );
  const parsedMetadata = metadataSchema.safeParse(
    JSON.parse(veryfiedState?.metadata ?? "{}"),
  );

  if (!parsedMetadata.success) {
    console.error("Invalid metadata", parsedMetadata.error.errors);
    return NextResponse.json({ error: "Invalid metadata" }, { status: 400 });
  }

  try {
    const slackOauthAccessUrl = [
      "https://slack.com/api/oauth.v2.access",
      `?client_id=${process.env.NEXT_PUBLIC_SLACK_CLIENT_ID}`,
      `&client_secret=${process.env.SLACK_CLIENT_SECRET}`,
      `&code=${parsedParams.data.code}`,
      `&redirect_uri=${process.env.NEXT_PUBLIC_SLACK_OAUTH_REDIRECT_URL}`,
    ].join("");

    const response = await fetch(slackOauthAccessUrl);
    const json = await response.json();

    const parsedJson = slackAuthResponseSchema.safeParse(json);

    if (!parsedJson.success) {
      console.error(
        "Invalid JSON response from slack",
        parsedJson.error.errors,
      );
      return NextResponse.json(
        { error: "Failed to exchange code for token" },
        { status: 500 },
      );
    }

    const createdSlackIntegration = await createApp({
      team_id: parsedMetadata.data.teamId,
      created_by: parsedMetadata.data.userId,
      app_id: config.id,
      settings: config.settings,
      config: {
        access_token: parsedJson.data.access_token,
        team_id: parsedJson.data.team.id,
        team_name: parsedJson.data.team.name,
        channel: parsedJson.data.incoming_webhook.channel,
        channel_id: parsedJson.data.incoming_webhook.channel_id,
        slack_configuration_url:
          parsedJson.data.incoming_webhook.configuration_url,
        url: parsedJson.data.incoming_webhook.url,
        bot_user_id: parsedJson.data.bot_user_id,
      },
    });

    if (createdSlackIntegration?.config) {
      const slackApp = createSlackApp({
        // @ts-expect-error - config is JSONB
        token: createdSlackIntegration?.config?.access_token,
        // @ts-expect-error - config is JSONB
        botId: createdSlackIntegration?.config?.bot_user_id,
      });

      try {
        await slackApp.client.chat.postMessage({
          // @ts-expect-error - config is JSONB
          channel: createdSlackIntegration?.config?.channel_id,
          unfurl_links: false,
          unfurl_media: false,
          blocks: [
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: "Hello there! 👋 I'm your new Midday bot, I'll send notifications in this channel regarding new transactions and other important updates.",
              },
            },
            {
              type: "divider",
            },
            {
              type: "context",
              elements: [
                {
                  type: "mrkdwn",
                  text: "<https://app.midday.ai/apps?app=slack&settings=true|Notification settings>",
                },
              ],
            },
          ],
        });
      } catch (err) {
        console.error(err);
      }

      const requestUrl = new URL(request.url);

      if (process.env.NODE_ENV === "development") {
        requestUrl.protocol = "http";
      }

      // This window will be in a popup so we redirect to the all-done route which closes the window
      // and then sends a browser event to the parent window. Actions can be taken based on this event.
      return NextResponse.redirect(
        `${requestUrl.origin}/all-done?event=app_oauth_completed`,
      );
    }
  } catch (err) {
    return NextResponse.json(
      { error: "Failed to exchange code for token" },
      { status: 500 },
    );
  }

  return NextResponse.json(
    { error: "Failed to exchange code for token" },
    { status: 500 },
  );
}
</file>

<file path="apps/dashboard/src/app/api/auth/callback/route.ts">
import { Cookies } from "@/utils/constants";
import { LogEvents } from "@midday/events/events";
import { setupAnalytics } from "@midday/events/server";
import { getSession } from "@midday/supabase/cached-queries";
import { createClient } from "@midday/supabase/server";
import { addYears } from "date-fns";
import { cookies } from "next/headers";
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export async function GET(req: NextRequest) {
  const cookieStore = await cookies();
  const requestUrl = new URL(req.url);
  const code = requestUrl.searchParams.get("code");
  const client = requestUrl.searchParams.get("client");
  const returnTo = requestUrl.searchParams.get("return_to");
  const provider = requestUrl.searchParams.get("provider");
  const mfaSetupVisited = cookieStore.has(Cookies.MfaSetupVisited);

  if (client === "desktop") {
    return NextResponse.redirect(`${requestUrl.origin}/verify?code=${code}`);
  }

  if (provider) {
    cookieStore.set(Cookies.PreferredSignInProvider, provider, {
      expires: addYears(new Date(), 1),
    });
  }

  if (code) {
    const supabase = await createClient();
    await supabase.auth.exchangeCodeForSession(code);

    const {
      data: { session },
    } = await getSession();

    if (session) {
      const userId = session.user.id;

      const analytics = await setupAnalytics({
        userId,
        fullName: session.user.user_metadata?.full_name,
      });

      await analytics.track({
        event: LogEvents.SignIn.name,
        channel: LogEvents.SignIn.channel,
      });

      // If user is redirected from an invite, redirect to teams page to accept/decline the invite
      if (returnTo?.startsWith("teams/invite/")) {
        return NextResponse.redirect(`${requestUrl.origin}/teams`);
      }

      // If user have no teams, redirect to team creation
      const { count } = await supabase
        .from("users_on_team")
        .select("*", { count: "exact" })
        .eq("user_id", userId);

      if (count === 0 && !returnTo?.startsWith("teams/invite/")) {
        return NextResponse.redirect(`${requestUrl.origin}/teams/create`);
      }
    }
  }

  if (!mfaSetupVisited) {
    cookieStore.set(Cookies.MfaSetupVisited, "true", {
      expires: addYears(new Date(), 1),
    });

    return NextResponse.redirect(`${requestUrl.origin}/mfa/setup`);
  }

  if (returnTo) {
    return NextResponse.redirect(`${requestUrl.origin}/${returnTo}`);
  }

  return NextResponse.redirect(requestUrl.origin);
}
</file>

<file path="apps/dashboard/src/app/api/chat/route.ts">
import { getBurnRate } from "@/lib/tools/get-burn-rate";
import { getDocuments } from "@/lib/tools/get-documents";
import { getForecast } from "@/lib/tools/get-forecast";
import { getInbox } from "@/lib/tools/get-inbox";
import { getProfit } from "@/lib/tools/get-profit";
import { getRevenue } from "@/lib/tools/get-revenue";
import { getRunway } from "@/lib/tools/get-runway";
import { getSpending } from "@/lib/tools/get-spending";
import { getTaxSummary } from "@/lib/tools/get-tax-summary";
import { getTransactions } from "@/lib/tools/get-transactions";
import { openai } from "@ai-sdk/openai";
import { createDataStreamResponse, smoothStream, streamText } from "ai";

export async function POST(request: Request) {
  const { messages } = await request.json();

  return createDataStreamResponse({
    execute: (dataStream) => {
      const result = streamText({
        model: openai("gpt-4.1-mini"),
        system: `
        You are Midday AI, an expert financial assistant for the user's business.
        Your goal is to help users understand their business finances by analyzing transactions, revenue, tax, spending, and key financial metrics, as well as finding specific documents, receipts, and invoices.

        When responding to user queries:
        1. Identify the core question and the financial data or document needed.
        2. Select the appropriate tool(s) to retrieve the necessary information.
        3. If a question requires combining data from multiple tools (e.g., calculating profit margin using revenue and spending data), synthesize the information before responding.
        4. Prefer using default parameters (e.g., current month, latest period) unless the user specifies a date range or other parameters.
        5. If essential parameters are missing, ask the user for clarification.
        6. Present the information clearly and concisely.

        The current date is: ${new Date().toISOString().split("T")[0]}. Be accurate and helpful in your financial analysis.
        `,
        messages,
        maxSteps: 5,
        experimental_transform: smoothStream({ chunking: "word" }),
        tools: {
          getSpending,
          getDocuments,
          getBurnRate,
          getTransactions,
          getRevenue,
          getForecast,
          getProfit,
          getRunway,
          getInbox,
          getTaxSummary,
        },
      });

      result.consumeStream();

      result.mergeIntoDataStream(dataStream, {
        sendReasoning: true,
      });
    },
    onError: () => {
      return "Oops, an error occurred!";
    },
  });
}
</file>

<file path="apps/dashboard/src/app/api/checkout/success/route.ts">
import { type NextRequest, NextResponse } from "next/server";

export const GET = async (req: NextRequest) => {
  const { searchParams } = new URL(req.url);
  const isDesktop = searchParams.get("isDesktop") === "true";
  const redirectPath = searchParams.get("redirectPath") ?? "/";

  if (isDesktop) {
    const url = new URL(req.url);

    url.pathname = "/desktop/checkout/success";
    url.searchParams.set("redirectPath", redirectPath);

    return NextResponse.redirect(url);
  }

  return NextResponse.redirect(new URL(redirectPath, req.url));
};
</file>

<file path="apps/dashboard/src/app/api/checkout/route.ts">
import { getDiscount, getPlans } from "@/utils/plans";
import { api } from "@/utils/polar";
import { getSession } from "@midday/supabase/cached-queries";
import { getTeamByIdQuery } from "@midday/supabase/queries";
import { createClient } from "@midday/supabase/server";
import { type NextRequest, NextResponse } from "next/server";

export const GET = async (req: NextRequest) => {
  const supabase = await createClient();

  const {
    data: { session },
  } = await getSession();

  if (!session?.user?.id) {
    throw new Error("You must be logged in");
  }

  const plan = req.nextUrl.searchParams.get("plan");
  const redirectPath = req.nextUrl.searchParams.get("redirectPath") ?? "/";
  const teamId = req.nextUrl.searchParams.get("teamId");
  const isDesktop = req.nextUrl.searchParams.get("isDesktop") === "true";
  const planType = req.nextUrl.searchParams.get("planType");

  const plans = getPlans();

  const selectedPlan = plans[plan as keyof typeof plans];

  if (!selectedPlan) {
    throw new Error("Invalid plan");
  }

  const { data: team } = await getTeamByIdQuery(supabase, teamId!);

  if (!team) {
    throw new Error("Team not found");
  }

  const discountId = getDiscount(planType);

  const successUrl = new URL("/api/checkout/success", req.nextUrl.origin);
  successUrl.searchParams.set("redirectPath", redirectPath);

  if (isDesktop) {
    successUrl.searchParams.set("isDesktop", "true");
  }

  const checkout = await api.checkouts.create({
    products: [selectedPlan.id],
    successUrl: successUrl.toString(),
    customerExternalId: team.id,
    customerEmail: session.user.email ?? undefined,
    customerName: team.name ?? undefined,
    discountId: discountId?.id,
    metadata: {
      teamId: team.id,
      companyName: team.name ?? "",
    },
  });

  return NextResponse.redirect(checkout.url);
};
</file>

<file path="apps/dashboard/src/app/api/connector/callback/route.ts">
import { getQueryClient, trpc } from "@/trpc/server";
import type { InitialInboxSetupPayload } from "@midday/jobs/schema";
import { tasks } from "@trigger.dev/sdk";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const code = searchParams.get("code");
  const state = searchParams.get("state") as "gmail";
  const queryClient = getQueryClient();

  if (!code || !state) {
    return NextResponse.json(
      { error: "Missing required parameters" },
      { status: 400 },
    );
  }

  try {
    const account = await queryClient.fetchQuery(
      trpc.inboxAccounts.exchangeCodeForAccount.queryOptions({
        code,
        provider: state,
      }),
    );

    if (!account) {
      return NextResponse.redirect(
        new URL("/inbox?connected=failed", request.url),
        { status: 302 },
      );
    }

    await tasks.trigger("initial-inbox-setup", {
      id: account.id,
    } satisfies InitialInboxSetupPayload);

    return NextResponse.redirect(
      new URL(`/inbox?connected=true&provider=${state}`, request.url),
      {
        status: 302,
      },
    );
  } catch (error) {
    console.error(error);
    return NextResponse.redirect(
      new URL("/inbox?connected=false", request.url),
      { status: 302 },
    );
  }
}
</file>

<file path="apps/dashboard/src/app/api/download/file/route.ts">
import { createClient } from "@midday/supabase/server";
import { download } from "@midday/supabase/storage";
import type { NextRequest, NextResponse } from "next/server";

export async function GET(req: NextRequest, res: NextResponse) {
  const supabase = await createClient();
  const requestUrl = new URL(req.url);
  const path = requestUrl.searchParams.get("path");
  const filename = requestUrl.searchParams.get("filename");

  if (!path) {
    return new Response("Path is required", { status: 400 });
  }

  const { data } = await download(supabase, {
    bucket: "vault",
    path,
  });

  const responseHeaders = new Headers(res.headers);

  responseHeaders.set(
    "Content-Disposition",
    `attachment; filename="${filename}"`,
  );

  return new Response(data, {
    headers: responseHeaders,
  });
}
</file>

<file path="apps/dashboard/src/app/api/download/invoice/route.ts">
import { trpc } from "@/trpc/server";
import { getQueryClient } from "@/trpc/server";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { PdfTemplate, renderToStream } from "@midday/invoice";
import type { NextRequest } from "next/server";
import { z } from "zod";

const paramsSchema = z.object({
  id: z.string().uuid().optional(),
  token: z.string().optional(),
  preview: z.preprocess((val) => val === "true", z.boolean().default(false)),
});

export async function GET(req: NextRequest) {
  const requestUrl = new URL(req.url);

  const result = paramsSchema.safeParse(
    Object.fromEntries(requestUrl.searchParams.entries()),
  );

  if (!result.success) {
    return new Response("Invalid parameters", { status: 400 });
  }

  const queryClient = getQueryClient();

  const { id, token, preview } = result.data;

  let data: RouterOutputs["invoice"]["getInvoiceByToken"] | null = null;

  if (id) {
    data = await queryClient.fetchQuery(
      trpc.invoice.getById.queryOptions({ id }),
    );
  } else if (token) {
    data = await queryClient.fetchQuery(
      trpc.invoice.getInvoiceByToken.queryOptions({ token }),
    );
  }

  if (!data) {
    return new Response("Invoice not found", { status: 404 });
  }

  const stream = await renderToStream(await PdfTemplate(data));

  // @ts-expect-error - stream is not assignable to BodyInit
  const blob = await new Response(stream).blob();

  const headers: Record<string, string> = {
    "Content-Type": "application/pdf",
    "Cache-Control": "no-store, max-age=0",
  };

  if (!preview) {
    headers["Content-Disposition"] =
      `attachment; filename="${data.invoiceNumber}.pdf"`;
  }

  return new Response(blob, { headers });
}
</file>

<file path="apps/dashboard/src/app/api/enablebanking/session/route.ts">
import { client } from "@midday/engine-client";
import { getSession } from "@midday/supabase/cached-queries";
import { createClient } from "@midday/supabase/server";
import { type NextRequest, NextResponse } from "next/server";

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const code = searchParams.get("code");
  const state = searchParams.get("state");
  const requestUrl = new URL(request.url);
  const supabase = await createClient();

  const {
    data: { session },
  } = await getSession();

  if (!session) {
    return NextResponse.redirect(new URL("/", requestUrl.origin));
  }

  const [type, method, sessionId] = state?.split(":") ?? [];

  const isDesktop = type === "desktop";
  const redirectBase = isDesktop ? "midday://" : requestUrl.origin;

  if (!code) {
    return NextResponse.redirect(new URL("/?error=missing_code", redirectBase));
  }

  const sessionResponse = await client.auth.enablebanking.exchange.$get({
    query: {
      code,
    },
  });

  if (sessionResponse.status !== 200) {
    return NextResponse.redirect(new URL("/?error=invalid_code", redirectBase));
  }

  if (method === "connect") {
    const { data: sessionData } = await sessionResponse.json();

    if (sessionData?.session_id) {
      return NextResponse.redirect(
        new URL(
          `/?ref=${sessionData.session_id}&provider=enablebanking&step=account`,
          redirectBase,
        ),
      );
    }
  }

  if (method === "reconnect" && sessionId) {
    const { data: sessionData } = await sessionResponse.json();

    // Update the bank connection session
    if (sessionData?.session_id) {
      const { data } = await supabase
        .from("bank_connections")
        .update({
          expires_at: sessionData.expires_at,
          reference_id: sessionData.session_id,
          status: "connected",
        })
        .eq("reference_id", sessionId)
        .select("id, team_id")
        .single();

      // Update bank account_ids based on the persisted identification_hash (account_reference)
      await Promise.all(
        sessionData?.accounts?.map((account) =>
          supabase
            .from("bank_accounts")
            .update({
              account_id: account.account_id,
            })
            .eq("account_reference", account.account_reference)
            .eq("team_id", data?.team_id!),
        ),
      );

      return NextResponse.redirect(
        new URL(
          `/settings/accounts?id=${data?.id}&step=reconnect`,
          redirectBase,
        ),
      );
    }
  }

  return NextResponse.redirect(new URL("/", redirectBase));
}
</file>

<file path="apps/dashboard/src/app/api/gocardless/reconnect/route.ts">
import { getSession } from "@midday/supabase/cached-queries";
import { updateBankConnection } from "@midday/supabase/mutations";
import { createClient } from "@midday/supabase/server";
import { type NextRequest, NextResponse } from "next/server";

export async function GET(req: NextRequest) {
  const {
    data: { session },
  } = await getSession();

  if (!session) {
    return NextResponse.redirect(new URL("/", req.url));
  }

  const supabase = await createClient();
  const requestUrl = new URL(req.url);
  const id = requestUrl.searchParams.get("id");
  const referenceId = requestUrl.searchParams.get("reference_id") ?? undefined;
  const isDesktop = requestUrl.searchParams.get("desktop");

  if (id) {
    await updateBankConnection(supabase, { id, referenceId });
  }

  if (isDesktop === "true") {
    return NextResponse.redirect(
      `midday://settings/accounts?id=${id}&step=reconnect`,
    );
  }

  return NextResponse.redirect(
    `${requestUrl.origin}/settings/accounts?id=${id}&step=reconnect`,
  );
}
</file>

<file path="apps/dashboard/src/app/api/portal/route.ts">
import { api } from "@/utils/polar";
import { getSession } from "@midday/supabase/cached-queries";
import { type NextRequest, NextResponse } from "next/server";

export async function GET(req: NextRequest) {
  const {
    data: { session },
  } = await getSession();

  if (!session?.user?.id) {
    throw new Error("You must be logged in");
  }

  const teamId = req.nextUrl.searchParams.get("id");

  if (!teamId) {
    throw new Error("Team ID is required");
  }

  const result = await api.customerSessions.create({
    customerExternalId: teamId,
  });

  return NextResponse.redirect(result.customerPortalUrl);
}
</file>

<file path="apps/dashboard/src/app/api/preview/route.ts">
import { getPdfImage } from "@/utils/pdf-to-img";
import { createClient } from "@midday/supabase/server";
import type { NextRequest } from "next/server";

export async function GET(request: NextRequest) {
  const supabase = await createClient({ admin: true });
  const { searchParams } = new URL(request.url);
  let filePath = searchParams.get("filePath");

  if (!filePath) {
    return new Response("No file path provided", { status: 400 });
  }

  // Remove 'vault/' prefix if it exists
  if (filePath.startsWith("vault/")) {
    filePath = filePath.substring("vault/".length);
  }

  const { data: pdfBlob, error: downloadError } = await supabase.storage
    .from("vault")
    .download(filePath);

  if (downloadError) {
    return new Response("Error downloading file", { status: 500 });
  }

  if (pdfBlob.type !== "application/pdf") {
    return new Response("File is not a PDF", { status: 400 });
  }

  try {
    const pdfBuffer = await pdfBlob.arrayBuffer();
    const imageBuffer = await getPdfImage(pdfBuffer);

    if (!imageBuffer) {
      return new Response("Failed to convert PDF to image", { status: 500 });
    }

    return new Response(new Uint8Array(imageBuffer), {
      headers: {
        "Content-Type": "image/png",
        "Cache-Control": "public, max-age=31536000, immutable",
      },
    });
  } catch (error: unknown) {
    throw new Error(
      `PDF to PNG conversion failed: ${
        error instanceof Error ? error.message : String(error)
      }`,
    );
  }
}
</file>

<file path="apps/dashboard/src/app/api/proxy/route.ts">
import { getSession } from "@midday/supabase/cached-queries";
import { type NextRequest, NextResponse } from "next/server";

export async function GET(req: NextRequest) {
  const requestUrl = new URL(req.url);
  const filePath = requestUrl.searchParams.get("filePath");

  const {
    data: { session },
  } = await getSession();

  if (!session || !filePath) {
    return new NextResponse("Unauthorized", { status: 401 });
  }

  // Ensure filePath starts with 'vault/'
  const finalFilePath = filePath.startsWith("vault/")
    ? filePath
    : `vault/${filePath}`;

  // Fetch the object from Supabase Storage
  const response = await fetch(
    `${process.env.NEXT_PUBLIC_SUPABASE_URL}/storage/v1/object/${finalFilePath}`,
    {
      headers: {
        authorization: `Bearer ${session.access_token}`,
      },
    },
  );

  // Check if the fetch was successful
  if (!response.ok) {
    return new NextResponse(response.body, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers,
    });
  }

  return new NextResponse(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers: response.headers,
  });
}
</file>

<file path="apps/dashboard/src/app/api/webhook/inbox/route.ts">
import { logger } from "@/utils/logger";
import { resend } from "@api/services/resend";
import { getAllowedAttachments } from "@midday/documents";
import { LogEvents } from "@midday/events/events";
import { setupAnalytics } from "@midday/events/server";
import { getInboxIdFromEmail, inboxWebhookPostSchema } from "@midday/inbox";
import type { ProcessAttachmentPayload } from "@midday/jobs/schema";
import { createClient } from "@midday/supabase/server";
import { getExtensionFromMimeType } from "@midday/utils";
import { tasks } from "@trigger.dev/sdk";
import { nanoid } from "nanoid";
import { headers } from "next/headers";
import { NextResponse } from "next/server";

// https://postmarkapp.com/support/article/800-ips-for-firewalls#webhooks
const ipRange = [
  "3.134.147.250",
  "50.31.156.6",
  "50.31.156.77",
  "18.217.206.57",
];

const FORWARD_FROM_EMAIL = "inbox@midday.ai";

// These are used by Google Workspace to forward emails to our inbox
const ALLOWED_FORWARDING_EMAILS = ["forwarding-noreply@google.com"];

export async function POST(req: Request) {
  const clientIp = (await headers()).get("x-forwarded-for") ?? "";

  if (
    process.env.NODE_ENV !== "development" &&
    (!clientIp || !ipRange.includes(clientIp))
  ) {
    return NextResponse.json({ error: "Invalid IP address" }, { status: 403 });
  }

  const parsedBody = inboxWebhookPostSchema.safeParse(await req.json());

  if (!parsedBody.success) {
    const errors = parsedBody.error.errors.map((error) => ({
      path: error.path.join("."),
      message: error.message,
    }));

    return NextResponse.json(
      { error: "Invalid request body", errors },
      { status: 400 },
    );
  }

  const {
    MessageID,
    FromFull,
    Subject,
    Attachments,
    OriginalRecipient,
    TextBody,
    HtmlBody,
  } = parsedBody.data;

  const inboxId = getInboxIdFromEmail(OriginalRecipient);

  if (!inboxId) {
    return NextResponse.json(
      { error: "Invalid OriginalRecipient email" },
      { status: 400 },
    );
  }

  // Ignore emails from our own domain to fix infinite loop
  if (FromFull.Email === FORWARD_FROM_EMAIL) {
    return NextResponse.json({ success: true });
  }

  const supabase = await createClient({ admin: true });

  try {
    const { data: teamData } = await supabase
      .from("teams")
      .select("id, email")
      .eq("inbox_id", inboxId)
      .single()
      .throwOnError();

    const analytics = await setupAnalytics();

    analytics.track({
      event: LogEvents.InboxInbound.name,
      channel: LogEvents.InboxInbound.channel,
    });

    const teamId = teamData?.id;

    // If the email is forwarded from a Google Workspace account, we need to send a reply to the team email
    if (teamData?.email && ALLOWED_FORWARDING_EMAILS.includes(FromFull.Email)) {
      await resend.emails.send({
        from: `${FromFull?.Name} <${FORWARD_FROM_EMAIL}>`,
        to: teamData.email,
        subject: Subject ?? FromFull?.Name,
        text: TextBody,
        html: HtmlBody,
        react: null,
        headers: {
          "X-Entity-Ref-ID": nanoid(),
        },
      });

      return NextResponse.json({ success: true });
    }

    const allowedAttachments = getAllowedAttachments(Attachments);

    if (!allowedAttachments?.length) {
      logger("No allowed attachments");
      // No attachments
      return NextResponse.json({ success: true });
    }

    // Transform and upload files, filtering out attachments smaller than 100kb except PDFs
    // This helps avoid processing small images like logos, favicons and tracking pixels while keeping all PDFs for processing
    const uploadedAttachments = allowedAttachments
      ?.filter(
        (attachment) =>
          !(
            attachment.ContentLength < 100000 &&
            attachment.ContentType !== "application/pdf"
          ),
      )
      ?.map(async (attachment) => {
        // Add a random 4 character string to the end of the file name
        // to make it unique before the extension
        const hasExtension = /\.[^.]+$/.test(attachment.Name);
        const uniqueFileName = hasExtension
          ? attachment.Name.replace(
              /(\.[^.]+)$/,
              (ext) => `_${nanoid(4)}${ext}`,
            )
          : `${attachment.Name}_${nanoid(4)}${getExtensionFromMimeType(attachment.ContentType)}`;

        const { data } = await supabase.storage
          .from("vault")
          .upload(
            `${teamId}/inbox/${uniqueFileName}`,
            Buffer.from(attachment.Content, "base64"),
            {
              contentType: attachment.ContentType,
              upsert: true,
            },
          );

        return {
          // NOTE: If we can't parse the name using OCR this will be the fallback name
          display_name: Subject || attachment.Name,
          team_id: teamId,
          file_path: data?.path.split("/"),
          file_name: uniqueFileName,
          content_type: attachment.ContentType,
          reference_id: `${MessageID}_${attachment.Name}`,
          size: attachment.ContentLength,
        };
      });

    if (!uploadedAttachments?.length) {
      logger("No uploaded attachments");

      return NextResponse.json({
        success: true,
      });
    }

    const insertData = await Promise.all(uploadedAttachments ?? []);

    await tasks.batchTrigger(
      "process-attachment",
      insertData.map((item) => ({
        payload: {
          filePath: item.file_path!,
          mimetype: item.content_type!,
          size: item.size!,
          teamId: teamId!,
        } satisfies ProcessAttachmentPayload,
      })),
    );

    // Send notification for email attachments
    tasks.trigger("notification", {
      type: "inbox_new",
      teamId: teamId!,
      totalCount: insertData.length,
      inboxType: "email",
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";

    logger(message);

    return NextResponse.json(
      { error: `Failed to create record for ${inboxId}` },
      { status: 500 },
    );
  }

  return NextResponse.json({ success: true });
}
</file>

<file path="apps/dashboard/src/app/api/webhook/plaid/route.ts">
import { isTeamEligibleForSync } from "@/utils/check-team-eligibility";
import { logger } from "@/utils/logger";
import type { SyncConnectionPayload } from "@midday/jobs/schema";
import { createClient } from "@midday/supabase/server";
import { tasks } from "@trigger.dev/sdk";
import { isAfter, subDays } from "date-fns";
import { type NextRequest, NextResponse } from "next/server";
import { z } from "zod";

// https://plaid.com/docs/api/webhooks/#configuring-webhooks
const ALLOWED_IPS = [
  "52.21.26.131",
  "52.21.47.157",
  "52.41.247.19",
  "52.88.82.239",
];

const webhookSchema = z.object({
  webhook_type: z.enum(["TRANSACTIONS"]),
  webhook_code: z.enum([
    "SYNC_UPDATES_AVAILABLE",
    "HISTORICAL_UPDATE",
    "DEFAULT_UPDATE",
    "TRANSACTIONS_REMOVED",
    "INITIAL_UPDATE",
  ]),
  item_id: z.string(),
  error: z
    .object({
      error_type: z.string(),
      error_code: z.string(),
      error_code_reason: z.string(),
      error_message: z.string(),
      display_message: z.string(),
      request_id: z.string(),
      causes: z.array(z.string()),
      status: z.number(),
    })
    .nullable(),
  new_transactions: z.number().optional(),
  environment: z.enum(["sandbox", "production"]),
});

export async function POST(req: NextRequest) {
  const clientIp = req.headers.get("x-forwarded-for") || "";

  if (!ALLOWED_IPS.includes(clientIp)) {
    return NextResponse.json(
      { error: "Unauthorized IP address" },
      { status: 403 },
    );
  }

  const body = await req.json();

  const result = webhookSchema.safeParse(body);

  if (!result.success) {
    logger("Invalid plaid webhook payload", {
      details: result.error.issues,
    });

    return NextResponse.json(
      { error: "Invalid webhook payload", details: result.error.issues },
      { status: 400 },
    );
  }

  const supabase = await createClient({ admin: true });

  const { data: connectionData } = await supabase
    .from("bank_connections")
    .select("id, created_at, team:teams(id, plan, created_at)")
    .eq("reference_id", result.data.item_id)
    .single();

  if (!connectionData) {
    return NextResponse.json(
      { error: "Connection not found" },
      { status: 404 },
    );
  }

  // Check if team is eligible for sync operations
  if (
    !isTeamEligibleForSync({
      plan: connectionData.team.plan,
      created_at: connectionData.team.created_at,
    })
  ) {
    logger("Team not eligible for sync", {
      teamId: connectionData.team.id,
      plan: connectionData.team.plan,
      createdAt: connectionData.team.created_at,
    });

    return NextResponse.json({ success: true });
  }

  if (result.data.webhook_type === "TRANSACTIONS") {
    switch (result.data.webhook_code) {
      case "SYNC_UPDATES_AVAILABLE":
      case "DEFAULT_UPDATE":
      case "INITIAL_UPDATE":
      case "HISTORICAL_UPDATE": {
        // Only run manual sync if the historical update is complete and the connection was created in the last 24 hours
        const manualSync =
          result.data.webhook_code === "HISTORICAL_UPDATE" &&
          isAfter(new Date(connectionData.created_at), subDays(new Date(), 1));

        logger("Triggering manual sync", {
          connectionId: connectionData.id,
          manualSync,
        });

        await tasks.trigger("sync-connection", {
          connectionId: connectionData.id,
          manualSync,
        } satisfies SyncConnectionPayload);

        break;
      }
    }
  }

  return NextResponse.json({ success: true });
}
</file>

<file path="apps/dashboard/src/app/api/webhook/polar/route.ts">
import { getPlanByProductId } from "@/utils/plans";
import { updateTeamPlan } from "@midday/supabase/mutations";
import { createClient } from "@midday/supabase/server";
import { Webhooks } from "@polar-sh/nextjs";

export const POST = Webhooks({
  webhookSecret: process.env.POLAR_WEBHOOK_SECRET!,
  onPayload: async (payload) => {
    const supabase = await createClient({ admin: true });

    switch (payload.type) {
      case "subscription.active": {
        await updateTeamPlan(supabase, {
          id: payload.data.metadata.teamId as string,
          email: payload.data.customer.email ?? undefined,
          plan: getPlanByProductId(payload.data.productId) as "starter" | "pro",
          canceled_at: null,
        });

        break;
      }

      // Subscription has been explicitly canceled by the user
      case "subscription.canceled": {
        await updateTeamPlan(supabase, {
          id: payload.data.metadata.teamId as string,
          email: payload.data.customer.email ?? undefined,
          canceled_at: new Date().toISOString(),
        });

        break;
      }

      // Subscription has been revoked/peroid has ended with no renewal
      case "subscription.revoked": {
        if (!payload.data.metadata.teamId) {
          console.error("Customer ID or email is missing");
          break;
        }

        await updateTeamPlan(supabase, {
          id: payload.data.metadata.teamId as string,
          plan: "trial",
          canceled_at: new Date().toISOString(),
        });

        break;
      }
      default:
        console.log("Unknown event", payload.type);
        break;
    }
  },
});
</file>

<file path="apps/dashboard/src/app/api/webhook/registered/route.ts">
import * as crypto from "node:crypto";
import { LogEvents } from "@midday/events/events";
import { setupAnalytics } from "@midday/events/server";
import type { OnboardTeamPayload } from "@midday/jobs/schema";
import { tasks } from "@trigger.dev/sdk";
import { headers } from "next/headers";
import { NextResponse } from "next/server";

export const dynamic = "force-dynamic";

// NOTE: This is trigger from supabase database webhook
export async function POST(req: Request) {
  const text = await req.clone().text();
  const signature = (await headers()).get("x-supabase-signature");

  if (!signature) {
    return NextResponse.json({ message: "Missing signature" }, { status: 401 });
  }

  const decodedSignature = Buffer.from(signature, "base64");

  const calculatedSignature = crypto
    .createHmac("sha256", process.env.WEBHOOK_SECRET_KEY!)
    .update(text)
    .digest();

  const hmacMatch = crypto.timingSafeEqual(
    decodedSignature,
    calculatedSignature,
  );

  if (!hmacMatch) {
    return NextResponse.json({ message: "Not Authorized" }, { status: 401 });
  }

  const body = await req.json();

  const userId = body.record.id;
  const fullName = body.record.full_name;

  const analytics = await setupAnalytics({
    userId,
    fullName,
  });

  analytics.track({
    event: LogEvents.Registered.name,
    channel: LogEvents.Registered.channel,
  });

  await tasks.trigger(
    "onboard-team",
    {
      userId,
    } satisfies OnboardTeamPayload,
    {
      delay: "10m",
    },
  );

  return NextResponse.json({ success: true });
}
</file>

<file path="apps/dashboard/src/app/api/webhook/teller/route.ts">
import { isTeamEligibleForSync } from "@/utils/check-team-eligibility";
import { validateTellerSignature } from "@/utils/teller";
import type { SyncConnectionPayload } from "@midday/jobs/schema";
import { createClient } from "@midday/supabase/server";
import { tasks } from "@trigger.dev/sdk";
import { isAfter, subDays } from "date-fns";
import { type NextRequest, NextResponse } from "next/server";
import { z } from "zod";

const webhookSchema = z.object({
  id: z.string(),
  payload: z.object({
    enrollment_id: z.string().optional(),
    reason: z.string().optional(),
  }),
  timestamp: z.string(),
  type: z.enum([
    "enrollment.disconnected",
    "transactions.processed",
    "account.number_verification.processed",
    "webhook.test",
  ]),
});

export async function POST(req: NextRequest) {
  const text = await req.clone().text();
  const body = await req.json();

  const signatureValid = validateTellerSignature({
    signatureHeader: req.headers.get("teller-signature"),
    text,
  });

  if (!signatureValid) {
    return NextResponse.json(
      { error: "Invalid webhook signature" },
      { status: 401 },
    );
  }

  // Parse and validate webhook body
  const result = webhookSchema.safeParse(body);

  if (!result.success) {
    return NextResponse.json(
      { error: "Invalid webhook payload", details: result.error.issues },
      { status: 400 },
    );
  }

  const { type, payload } = result.data;

  if (type === "webhook.test") {
    return NextResponse.json({ success: true });
  }

  if (!payload.enrollment_id) {
    return NextResponse.json(
      { error: "Missing enrollment_id" },
      { status: 400 },
    );
  }

  const supabase = await createClient({ admin: true });

  const { data: connectionData, error: connectionError } = await supabase
    .from("bank_connections")
    .select("id, created_at, team:teams(id, plan, created_at)")
    .eq("enrollment_id", payload.enrollment_id)
    .single();

  console.log("payload", payload);
  console.log("connectionData", connectionData);
  console.log("connectionError", connectionError);

  if (!connectionData) {
    return NextResponse.json(
      { error: "Connection not found" },
      { status: 404 },
    );
  }

  // Check if team is eligible for sync operations
  if (
    !isTeamEligibleForSync({
      plan: connectionData.team.plan,
      created_at: connectionData.team.created_at,
    })
  ) {
    console.log("Team not eligible for sync", {
      teamId: connectionData.team.id,
      plan: connectionData.team.plan,
      createdAt: connectionData.team.created_at,
    });

    return NextResponse.json({ success: true });
  }

  switch (type) {
    case "transactions.processed":
      {
        // Only run manual sync if the connection was created in the last 24 hours
        const manualSync = isAfter(
          new Date(connectionData.created_at),
          subDays(new Date(), 1),
        );

        await tasks.trigger("sync-connection", {
          connectionId: connectionData.id,
          manualSync,
        } satisfies SyncConnectionPayload);
      }
      break;
  }

  return NextResponse.json({ success: true });
}
</file>

<file path="apps/dashboard/src/app/global-error.tsx">
"use client";

import NextError from "next/error";
import { useEffect } from "react";

export default function GlobalError({
  error,
}: {
  error: Error & { digest?: string };
}) {
  useEffect(() => {
    // Only capture exceptions in production
    if (process.env.NODE_ENV === "production") {
      // Dynamically import Sentry only in production
      import("@sentry/nextjs").then((Sentry) => {
        Sentry.captureException(error);
      });
    }
  }, [error]);

  return (
    <html lang="en">
      <body>
        <NextError statusCode={0} />
      </body>
    </html>
  );
}
</file>

<file path="apps/dashboard/src/components/assistant/assistant-modal.tsx">
"use client";

import { useAssistantStore } from "@/store/assistant";
import { Dialog, DialogContent } from "@midday/ui/dialog";
import { Assistant } from ".";

export function AssistantModal() {
  const { isOpen, setOpen } = useAssistantStore();

  const toggleOpen = () => setOpen();

  return (
    <Dialog open={isOpen} onOpenChange={toggleOpen}>
      <DialogContent
        className="overflow-hidden p-0 max-w-full w-full h-full md:max-w-[740px] md:h-[480px] m-0 select-text"
        hideClose
      >
        <Assistant />
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/assistant/header.tsx">
import { useAssistantStore } from "@/store/assistant";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";

export function Header() {
  const { setOpen } = useAssistantStore();

  return (
    <div className="px-4 py-3 flex justify-between items-center border-border border-b-[1px]">
      <div className="flex items-center space-x-3">
        <h2>Assistant</h2>
      </div>

      <Button
        className="flex md:hidden desktop:hidden"
        size="icon"
        variant="ghost"
        onClick={() => setOpen()}
      >
        <Icons.Close />
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/assistant/index.tsx">
import { Chat } from "@/components/chat";
import { Header } from "./header";

export function Assistant() {
  return (
    <div className="overflow-hidden p-0 h-full w-full desktop:max-w-[760px] md:max-w-[760px] md:h-[480px] desktop:h-[480px]">
      <Header />
      <Chat />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/assistant/toolbar.tsx">
type Props = {
  onNewChat: () => void;
};

export function Toolbar({ onNewChat }: Props) {
  return (
    <button onClick={onNewChat} type="button">
      <div className="left-4 right-4 absolute z-20 bottom-4 flex items-center justify-center">
        <div className="dark:bg-[#1A1A1A]/95 bg-[#F6F6F3]/95 h-8 w-full justify-between items-center flex px-2 space-x-4 text-[#878787]">
          <div className="flex items-center space-x-3">
            <kbd className="pointer-events-none h-5 select-none items-center gap-1.5 rounded border bg-accent px-1.5 font-mono text-[11px] font-medium flex bg-[#2C2C2C]">
              <span className="text-[16px]">⌘</span>J
            </kbd>
            <span className="text-xs">New chat</span>
          </div>
        </div>
      </div>
    </button>
  );
}
</file>

<file path="apps/dashboard/src/components/base-currency/base-currency.tsx">
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { SelectCurrency } from "./select-currency";

export function BaseCurrency() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Base currency</CardTitle>
        <CardDescription>
          If you have multiple currencies, you can set a base currency for your
          account to view your total balance in your preferred currency.
          Exchange rates are updated every 24 hours.
        </CardDescription>
      </CardHeader>

      <CardContent>
        <SelectCurrency />
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/base-currency/select-currency.tsx">
"use client";

import { SelectCurrency as SelectCurrencyBase } from "@/components/select-currency";
import { useSyncStatus } from "@/hooks/use-sync-status";
import { useTeamMutation } from "@/hooks/use-team";
import { useTeamQuery } from "@/hooks/use-team";
import { useTRPC } from "@/trpc/client";
import { uniqueCurrencies } from "@midday/location/currencies";
import { Button } from "@midday/ui/button";
import { useToast } from "@midday/ui/use-toast";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useState } from "react";

export function SelectCurrency() {
  const trpc = useTRPC();
  const { toast } = useToast();
  const [isSyncing, setSyncing] = useState(false);
  const [runId, setRunId] = useState<string | undefined>();
  const [accessToken, setAccessToken] = useState<string | undefined>();
  const updateTeamMutation = useTeamMutation();
  const { data: team } = useTeamQuery();

  const updateBaseCurrencyMutation = useMutation(
    trpc.team.updateBaseCurrency.mutationOptions({
      onMutate: () => {
        setSyncing(true);
      },
      onSuccess: (data) => {
        if (data) {
          setRunId(data.id);
          setAccessToken(data.publicAccessToken);
        }
      },
      onError: () => {
        setRunId(undefined);

        toast({
          duration: 3500,
          variant: "error",
          title: "Something went wrong pleaase try again.",
        });
      },
    }),
  );

  const { status, setStatus } = useSyncStatus({ runId, accessToken });

  const handleChange = async (baseCurrency: string) => {
    updateTeamMutation.mutate(
      {
        baseCurrency: baseCurrency.toUpperCase(),
      },
      {
        onSuccess: () => {
          toast({
            title: "Update base currency",
            description:
              "This will update the base currency for all transactions and account balances.",
            duration: 7000,
            footer: (
              <Button
                onClick={() =>
                  updateBaseCurrencyMutation.mutate({
                    baseCurrency: baseCurrency.toUpperCase(),
                  })
                }
              >
                Update
              </Button>
            ),
          });
        },
      },
    );
  };

  useEffect(() => {
    if (status === "COMPLETED") {
      setSyncing(false);
      setStatus(null);
      setRunId(undefined);
      toast({
        duration: 3500,
        variant: "success",
        title: "Transactions and account balances updated.",
      });
    }
  }, [status]);

  useEffect(() => {
    if (isSyncing) {
      toast({
        title: "Updating...",
        description: "We're updating your base currency, please wait.",
        duration: Number.POSITIVE_INFINITY,
        variant: "spinner",
      });
    }
  }, [isSyncing]);

  useEffect(() => {
    if (status === "FAILED") {
      setSyncing(false);
      setRunId(undefined);

      toast({
        duration: 3500,
        variant: "error",
        title: "Something went wrong pleaase try again.",
      });
    }
  }, [status]);

  return (
    <div className="w-[200px]">
      <SelectCurrencyBase
        onChange={handleChange}
        currencies={uniqueCurrencies}
        value={team?.baseCurrency ?? undefined}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/area-chart.tsx">
// @ts-nocheck

"use client";

import { useUserQuery } from "@/hooks/use-user";
import { formatAmount } from "@/utils/format";
import { format } from "date-fns";
import React from "react";
import {
  Area,
  AreaChart as BaseAreaChart,
  CartesianGrid,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts";

type ToolTipContentProps = {
  payload: any;
};

const ToolTipContent = ({ payload }: ToolTipContentProps) => {
  const { value = 0, date, currency } = payload.at(0)?.payload ?? {};
  const { data: user } = useUserQuery();

  return (
    <div className="w-[240px] border shadow-sm bg-background">
      <div className="py-2 px-3">
        <div className="flex items-center justify-between">
          <p className="font-medium text-[13px]">
            {formatAmount({
              maximumFractionDigits: 0,
              minimumFractionDigits: 0,
              currency,
              amount: value,
              locale: user?.locale,
            })}
          </p>
          <p className="text-xs text-[#606060] text-right">
            {date && format(new Date(date), "MMM, y")}
          </p>
        </div>
      </div>
    </div>
  );
};

type AreaChartProps = {
  data: any;
  height?: number;
};

export function AreaChart({ data, height = 290 }: AreaChartProps) {
  return (
    <ResponsiveContainer width="100%" height={height}>
      <BaseAreaChart data={data}>
        <defs>
          <pattern
            id="raster"
            patternUnits="userSpaceOnUse"
            width="64"
            height="64"
          >
            <path d="M-106 110L22 -18" stroke="#282828" />
            <path d="M-98 110L30 -18" stroke="#282828" />
            <path d="M-90 110L38 -18" stroke="#282828" />
            <path d="M-82 110L46 -18" stroke="#282828" />
            <path d="M-74 110L54 -18" stroke="#282828" />
            <path d="M-66 110L62 -18" stroke="#282828" />
            <path d="M-58 110L70 -18" stroke="#282828" />
            <path d="M-50 110L78 -18" stroke="#282828" />
            <path d="M-42 110L86 -18" stroke="#282828" />
            <path d="M-34 110L94 -18" stroke="#282828" />
            <path d="M-26 110L102 -18" stroke="#282828" />
            <path d="M-18 110L110 -18" stroke="#282828" />
            <path d="M-10 110L118 -18" stroke="#282828" />
            <path d="M-2 110L126 -18" stroke="#282828" />
            <path d="M6 110L134 -18" stroke="#282828" />
            <path d="M14 110L142 -18" stroke="#282828" />
            <path d="M22 110L150 -18" stroke="#282828" />
          </pattern>
        </defs>

        <CartesianGrid
          strokeDasharray="3 3"
          vertical={false}
          className="stoke-[#DCDAD2] dark:stroke-[#2C2C2C]"
        />

        <Tooltip
          content={(content) => <ToolTipContent {...content} />}
          cursor={false}
        />

        <XAxis
          dataKey="date"
          stroke="#888888"
          fontSize={12}
          tickLine={false}
          axisLine={false}
          tickMargin={15}
          tickFormatter={(value) => {
            return format(new Date(value), "MMM");
          }}
          tick={{
            fill: "#606060",
            fontSize: 12,
            fontFamily: "var(--font-sans)",
          }}
        />

        <YAxis
          stroke="#888888"
          fontSize={12}
          tickLine={false}
          axisLine={false}
          tickMargin={10}
          tick={{
            fill: "#606060",
            fontSize: 12,
            fontFamily: "var(--font-sans)",
          }}
        />

        <Tooltip />

        <Area
          strokeWidth={2.5}
          type="monotone"
          dataKey="value"
          stroke="hsl(var(--primary))"
          fill="url(#raster)"
        />
      </BaseAreaChart>
    </ResponsiveContainer>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/bar-chart.tsx">
// @ts-nocheck

"use client";

import { useUserQuery } from "@/hooks/use-user";
import { useI18n } from "@/locales/client";
import { formatAmount } from "@/utils/format";
import { cn } from "@midday/ui/cn";
import { format } from "date-fns";
import {
  Bar,
  BarChart as BaseBarChart,
  CartesianGrid,
  Cell,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts";
import { Status } from "./status";

const ToolTipContent = ({ payload = {} }) => {
  const t = useI18n();
  const { data: user } = useUserQuery();

  const [current, previous] = payload;

  return (
    <div className="w-[240px] border shadow-sm bg-background">
      <div className="border-b-[1px] px-4 py-2 flex justify-between items-center">
        <p className="text-sm">
          {t(`chart_type.${current?.payload?.meta?.type}`)}
        </p>
        <div>
          {current?.payload.percentage.value > 0 && (
            <Status
              value={`${current?.payload.percentage.value}%`}
              variant={current?.payload.percentage.status}
            />
          )}
        </div>
      </div>

      <div className="p-4">
        <div className="flex justify-between mb-2">
          <div className="flex items-center justify-center space-x-2">
            <div className="w-[8px] h-[8px] rounded-full bg-[#121212] dark:bg-[#F5F5F3]" />
            <p className="font-medium text-[13px]">
              {formatAmount({
                maximumFractionDigits: 0,
                minimumFractionDigits: 0,
                currency: current?.payload?.meta?.currency,
                amount: current?.payload?.current.value || 0,
                locale: user?.locale,
              })}
            </p>
          </div>

          <p className="text-xs text-[#606060] text-right">
            {current?.payload?.meta?.period === "weekly"
              ? current?.payload?.current?.date &&
                `Week ${format(
                  new Date(current.payload.current.date),
                  "ww, y",
                )}`
              : current?.payload?.current?.date &&
                format(new Date(current.payload.current.date), "MMM, y")}
          </p>
        </div>

        <div className="flex justify-between">
          <div className="flex items-center justify-center space-x-2">
            <div className="w-[8px] h-[8px] rounded-full bg-[#C6C6C6] dark:bg-[#606060]" />
            <p className="font-medium text-[13px]">
              {formatAmount({
                amount: previous?.payload?.previous.value || 0,
                currency: current?.payload?.meta?.currency,
                maximumFractionDigits: 0,
                minimumFractionDigits: 0,
                locale: user?.locale,
              })}
            </p>
          </div>

          <p className="text-xs text-[#606060] text-right">
            {previous?.payload?.meta?.period === "weekly"
              ? previous?.payload?.previous?.date &&
                `Week ${format(
                  new Date(previous.payload.previous.date),
                  "ww, y",
                )}`
              : previous?.payload?.previous?.date &&
                format(new Date(previous.payload.previous.date), "MMM, y")}
          </p>
        </div>
      </div>
    </div>
  );
};

export function BarChart({ data, height = 290 }) {
  const formattedData = data?.result?.map((item) => ({
    ...item,
    meta: data.meta,
    date: format(
      new Date(item.date),
      data.meta.period === "weekly" ? "w" : "MMM",
    ),
  }));

  return (
    <div className="relative h-full w-full">
      <div className="space-x-4 absolute right-0 -top-10 hidden md:flex">
        <div className="flex space-x-2 items-center">
          <span className="w-2 h-2 rounded-full bg-[#121212] dark:bg-[#F5F5F3]" />
          <span className="text-sm text-[#606060]">Current Period</span>
        </div>
        <div className="flex space-x-2 items-center">
          <span className="w-2 h-2 rounded-full bg-[#C6C6C6] dark:bg-[#606060]" />
          <span className="text-sm text-[#606060]">Last Period</span>
        </div>
      </div>

      <ResponsiveContainer width="100%" height={height}>
        <BaseBarChart data={formattedData} barGap={15}>
          <XAxis
            dataKey="date"
            stroke="#888888"
            fontSize={12}
            tickLine={false}
            axisLine={false}
            tickMargin={15}
            tick={{
              fill: "#606060",
              fontSize: 12,
              fontFamily: "var(--font-sans)",
            }}
          />

          <YAxis
            stroke="#888888"
            fontSize={12}
            tickMargin={10}
            tickLine={false}
            axisLine={false}
            tick={{
              fill: "#606060",
              fontSize: 12,
              fontFamily: "var(--font-sans)",
            }}
          />

          <CartesianGrid
            strokeDasharray="3 3"
            vertical={false}
            className="stoke-[#DCDAD2] dark:stroke-[#2C2C2C]"
          />

          <Tooltip content={ToolTipContent} cursor={false} />

          <Bar dataKey="previous.value" barSize={16}>
            {data?.result?.map((entry, index) => (
              <Cell
                key={`cell-${index.toString()}`}
                className={cn(
                  "fill-[#41191A]",
                  +entry.previous.value > 0 &&
                    "dark:fill-[#323232] fill-[#C6C6C6]",
                )}
              />
            ))}
          </Bar>

          <Bar dataKey="current.value" barSize={16}>
            {data?.result?.map((entry, index) => (
              <Cell
                key={`cell-${index.toString()}`}
                className={cn(
                  "fill-[#FF3638]",
                  +entry.current.value > 0 &&
                    "dark:fill-[#F5F5F3] fill-[#121212]",
                )}
              />
            ))}
          </Bar>
        </BaseBarChart>
      </ResponsiveContainer>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/burn-rate-chart.tsx">
"use client";

import { useReportsParams } from "@/hooks/use-reports-params";
import { useTRPC } from "@/trpc/client";
import { calculateAvgBurnRate } from "@/utils/format";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useQuery } from "@tanstack/react-query";
import Link from "next/link";
import { AnimatedNumber } from "../animated-number";
import { AreaChart } from "./area-chart";
import { burnRateExamleData } from "./data";

type Props = {
  disabled?: boolean;
};

export function BurnRateChart({ disabled }: Props) {
  const trpc = useTRPC();
  const { params } = useReportsParams();

  const { data } = useQuery({
    ...trpc.reports.burnRate.queryOptions({
      from: params.from,
      to: params.to,
      currency: params.currency ?? undefined,
    }),
    placeholderData: (previousData) => previousData ?? burnRateExamleData,
  });

  const { data: runway } = useQuery({
    ...trpc.reports.runway.queryOptions({
      from: params.from,
      to: params.to,
      currency: params.currency ?? undefined,
    }),
  });

  return (
    <div
      className={cn(
        disabled && "pointer-events-none select-none blur-[8px] opacity-20",
      )}
    >
      <div className="space-y-2 mb-14 select-text">
        <h1 className="text-4xl font-mono">
          <AnimatedNumber
            value={calculateAvgBurnRate(data ?? [])}
            currency={data?.at(0)?.currency ?? "USD"}
          />
        </h1>

        <div className="text-sm text-[#606060] flex items-center space-x-2">
          <span>
            {runway && runway > 0
              ? `${runway} ${runway === 1 ? "month" : "months"} runway`
              : "Average burn rate"}
          </span>
          <TooltipProvider delayDuration={100}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Icons.Info className="h-4 w-4 mt-1" />
              </TooltipTrigger>
              <TooltipContent
                className="text-xs text-[#878787] max-w-[240px] p-4 space-y-2"
                side="bottom"
                sideOffset={10}
              >
                <h3 className="font-medium text-primary">
                  The Burn Rate is your monthly expenses divided by your current
                  balance, estimating how long your funds will last.
                </h3>
                <p>
                  Explanation: This tracks how fast you're spending. If it's
                  incorrect, internal transfers may be counted as income. You
                  can adjust this by excluding the transactions from the
                  calculations.
                </p>

                <p>
                  All amounts are converted into your{" "}
                  <Link
                    href="/settings/accounts"
                    className="text-primary underline"
                  >
                    base currency
                  </Link>
                  .
                </p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>
      </div>

      <AreaChart data={data} />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/chart-filters.tsx">
"use client";

import { Button } from "@midday/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { parseAsString, useQueryStates } from "nuqs";

type Props = {
  currencies: {
    id: string;
    name: string;
  }[];
};

export function ChartFilters({ currencies }: Props) {
  const [{ currency }, setCurrency] = useQueryStates({
    currency: parseAsString,
  });

  const allCurrencies = [
    {
      id: "base",
      name: "Base currency",
    },
    ...currencies,
  ];

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Icons.Filter size={18} />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent sideOffset={10} align="end" className="w-[200px]">
        <DropdownMenuSub>
          <DropdownMenuSubTrigger>
            <Icons.Currency className="mr-2 h-4 w-4" />
            <span>Currency</span>
          </DropdownMenuSubTrigger>
          <DropdownMenuPortal>
            <DropdownMenuSubContent sideOffset={14} alignOffset={-4}>
              <DropdownMenuRadioGroup
                value={currency ?? "base"}
                onValueChange={(value) =>
                  setCurrency({ currency: value === "base" ? null : value })
                }
              >
                {allCurrencies.map((currency) => (
                  <DropdownMenuRadioItem key={currency.id} value={currency.id}>
                    {currency.name}
                  </DropdownMenuRadioItem>
                ))}
              </DropdownMenuRadioGroup>
            </DropdownMenuSubContent>
          </DropdownMenuPortal>
        </DropdownMenuSub>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/chart-period.tsx">
"use client";

import {
  chartPeriodOptions,
  useReportsParams,
} from "@/hooks/use-reports-params";
import { useUserQuery } from "@/hooks/use-user";
import { Button } from "@midday/ui/button";
import { Calendar } from "@midday/ui/calendar";
import { Icons } from "@midday/ui/icons";
import { Popover, PopoverContent, PopoverTrigger } from "@midday/ui/popover";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";
import { formatISO } from "date-fns";
import { formatDateRange } from "little-date";
import type { DateRange } from "react-day-picker";

type Props = {
  disabled?: string;
};

export function ChartPeriod({ disabled }: Props) {
  const { params, setParams } = useReportsParams();
  const { data: user } = useUserQuery();

  const handleChangePeriod = (
    range: DateRange | undefined,
    period?: string,
  ) => {
    const newRange = {
      from: range?.from
        ? formatISO(range.from, { representation: "date" })
        : params.from,
      to: range?.to
        ? formatISO(range.to, { representation: "date" })
        : params.to,
      period: period || params.period,
    };

    setParams(newRange);
  };

  // Handle calendar selection separately to match the expected type
  const handleCalendarSelect = (selectedRange: DateRange | undefined) => {
    handleChangePeriod(selectedRange);
  };

  return (
    <div className="flex space-x-4">
      <Popover>
        <PopoverTrigger asChild disabled={Boolean(disabled)}>
          <Button
            variant="outline"
            className="justify-start text-left font-medium space-x-2"
          >
            <span className="line-clamp-1 text-ellipsis">
              {params.from && params.to
                ? formatDateRange(new Date(params.from), new Date(params.to), {
                    includeTime: false,
                  })
                : "Select date range"}
            </span>
            <Icons.ChevronDown />
          </Button>
        </PopoverTrigger>
        <PopoverContent
          className="w-screen md:w-[550px] p-0 flex-col flex space-y-4"
          align="end"
          sideOffset={10}
        >
          <div className="p-4 pb-0">
            <Select
              value={params.period ?? undefined}
              onValueChange={(value) =>
                handleChangePeriod(
                  chartPeriodOptions.find((p) => p.value === value)?.range,
                  value,
                )
              }
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Select a period" />
              </SelectTrigger>
              <SelectContent>
                <SelectGroup>
                  {chartPeriodOptions.map((period) => (
                    <SelectItem key={period.value} value={period.value}>
                      {period.label}
                    </SelectItem>
                  ))}
                </SelectGroup>
              </SelectContent>
            </Select>
          </div>

          <Calendar
            mode="range"
            numberOfMonths={2}
            selected={{
              from: params.from ? new Date(params.from) : undefined,
              to: params.to ? new Date(params.to) : undefined,
            }}
            defaultMonth={
              params.from
                ? new Date(params.from)
                : new Date(new Date().setMonth(new Date().getMonth() - 1))
            }
            initialFocus
            toDate={new Date()}
            onSelect={handleCalendarSelect}
            weekStartsOn={user?.weekStartsOnMonday ? 1 : 0}
          />
        </PopoverContent>
      </Popover>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/chart-selectors.tsx">
"use client";

import { ChartPeriod } from "@/components/charts/chart-period";
import { ChartType } from "@/components/charts/chart-type";
import { useTRPC } from "@/trpc/client";
import { useQuery } from "@tanstack/react-query";
import { ChartFilters } from "./chart-filters";

export function ChartSelectors() {
  const trpc = useTRPC();
  const { data: currencies } = useQuery(
    trpc.bankAccounts.currencies.queryOptions(),
  );

  return (
    <div className="flex justify-between mt-6 space-x-2">
      <div className="flex space-x-2">
        <ChartType />
      </div>

      <div className="flex space-x-2">
        <ChartPeriod />
        <ChartFilters
          currencies={
            currencies?.map((currency) => {
              return {
                id: currency.currency,
                name: currency.currency,
              };
            }) ?? []
          }
        />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/chart-type.tsx">
"use client";

import { chartTypeOptions, useReportsParams } from "@/hooks/use-reports-params";
import { useI18n } from "@/locales/client";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectTrigger,
} from "@midday/ui/select";

type Props = {
  disabled?: boolean;
};

export function ChartType({ disabled }: Props) {
  const t = useI18n();
  const { params, setParams } = useReportsParams();

  return (
    <Select
      defaultValue={params.chart}
      onValueChange={(value) => {
        if (value) {
          setParams({
            ...params,
            chart: value as NonNullable<typeof params.chart>,
          });
        }
      }}
    >
      <SelectTrigger
        className="flex-1 space-x-1 font-medium"
        disabled={disabled}
      >
        <span>{t(`chart_type.${params.chart}`)}</span>
      </SelectTrigger>
      <SelectContent>
        <SelectGroup>
          {chartTypeOptions.map((option) => {
            return (
              <SelectItem key={option} value={option}>
                {t(`chart_type.${option}`)}
              </SelectItem>
            );
          })}
        </SelectGroup>
      </SelectContent>
    </Select>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/charts.tsx">
"use client";

import { useReportsParams } from "@/hooks/use-reports-params";
import { useTRPC } from "@/trpc/client";
import { useQuery } from "@tanstack/react-query";
import { BurnRateChart } from "./burn-rate-chart";
import { ExpenseChart } from "./expense-chart";
import { ProfitChart } from "./profit-chart";
import { RevenueChart } from "./revenue-chart";

export function Charts() {
  const { params } = useReportsParams();
  const trpc = useTRPC();

  const { data: accounts } = useQuery(
    trpc.bankAccounts.get.queryOptions({
      enabled: true,
    }),
  );

  // If the user has not connected any accounts, disable the charts
  const disabled = !accounts?.length;

  switch (params.chart) {
    case "revenue":
      return <RevenueChart disabled={disabled} />;
    case "profit":
      return <ProfitChart disabled={disabled} />;
    case "burn_rate":
      return <BurnRateChart disabled={disabled} />;
    case "expense":
      return <ExpenseChart disabled={disabled} />;
    default:
      return null;
  }
}
</file>

<file path="apps/dashboard/src/components/charts/data.ts">
export const chartExampleData = {
  summary: {
    currency: "USD",
    currentTotal: 0,
    prevTotal: 0,
  },
  meta: {
    type: "profit" as "profit" | "revenue",
    period: "monthly",
    currency: "USD",
  },
  result: [
    {
      date: "Sun Jan 01 2023",
      previous: {
        date: "2022-1-1",
        currency: "USD",
        value: 10000,
      },
      current: {
        date: "2023-1-1",
        currency: "USD",
        value: 20300,
      },
      percentage: {
        value: 110,
        status: "positive",
      },
    },
    {
      date: "Wed Feb 01 2023",
      previous: {
        date: "2022-2-1",
        currency: "USD",
        value: 8000,
      },
      current: {
        date: "2023-2-1",
        currency: "USD",
        value: 14000,
      },
      percentage: {
        value: 1000,
        status: "positive",
      },
    },
    {
      date: "Wed Mar 01 2023",
      previous: {
        date: "2022-3-1",
        currency: "USD",
        value: 15000,
      },
      current: {
        date: "2023-3-1",
        currency: "USD",
        value: 18000,
      },
      percentage: {
        value: 1000,
        status: "positive",
      },
    },
    {
      date: "Sat Apr 01 2023",
      previous: {
        date: "2022-4-1",
        currency: "USD",
        value: 7000,
        status: "positive",
      },
      current: {
        date: "2023-4-1",
        currency: "USD",
        value: 10000,
        status: "positive",
      },
      percentage: {
        value: 1000,
        status: "positive",
      },
    },
    {
      date: "Mon May 01 2023",
      previous: {
        date: "2022-5-1",
        currency: "USD",
        value: 10000,
        status: "positive",
      },
      current: {
        date: "2023-5-1",
        currency: "USD",
        value: 12000,
        status: "positive",
      },
      percentage: {
        value: 1000,
        status: "positive",
      },
    },
    {
      date: "Thu Jun 01 2023",
      previous: {
        date: "2022-6-1",
        currency: "USD",
        value: 300,
        status: "negative",
      },
      current: {
        date: "2023-6-1",
        currency: "USD",
        value: 2800,
        status: "positive",
      },
      percentage: {
        value: 1000,
        status: "positive",
      },
    },
    {
      date: "Sat Jul 01 2023",
      previous: {
        date: "2022-7-1",
        currency: "USD",
        value: 1000,
        status: "positive",
      },
      current: {
        date: "2023-7-1",
        currency: "USD",
        value: 1000,
        status: "positive",
      },
      percentage: {
        value: 1000,
        status: "positive",
      },
    },
    {
      date: "Tue Aug 01 2023",
      previous: {
        date: "2022-8-1",
        currency: "USD",
        value: 1000,
        status: "positive",
      },
      current: {
        date: "2023-8-1",
        currency: "USD",
        value: 1000,
        status: "positive",
      },
      percentage: {
        value: 43,
        status: "positive",
      },
    },
    {
      date: "Fri Sep 01 2023",
      previous: {
        date: "2022-9-1",
        currency: "USD",
        value: 1000,
        status: "positive",
      },
      current: {
        date: "2023-9-1",
        currency: "USD",
        value: -3000,
        status: "negative",
      },
      percentage: {
        value: 53,
        status: "positive",
      },
    },
    {
      date: "Sun Oct 01 2023",
      previous: {
        date: "2022-10-1",
        currency: "USD",
        value: 10000,
        status: "positive",
      },
      current: {
        date: "2023-10-1",
        currency: "USD",
        value: 20000,
        status: "negative",
      },
      percentage: {
        value: 0,
        status: "positive",
      },
    },
    {
      date: "Wed Nov 01 2023",
      previous: {
        date: "2022-11-1",
        currency: "USD",
        value: 10000,
        status: "positive",
      },
      current: {
        date: "2023-11-1",
        currency: "USD",
        value: 20000,
        status: "negative",
      },
      percentage: {
        value: 0,
        status: "negative",
      },
    },
  ],
};

export const expenseChartExampleData = {
  summary: {
    currency: "USD",
    averageExpense: 800000,
  },
  meta: {
    type: "expense",
    period: "monthly",
    currency: "USD",
  },
  result: [
    {
      date: "2023-01-01",
      value: 20300,
      recurring: 1000,
      total: 20300,
      recurring_value: 1000,
      currency: "USD",
    },
    {
      date: "2023-02-01",
      value: 14000,
      recurring: 1000,
      total: 14000,
      recurring_value: 1000,
      currency: "USD",
    },
    {
      date: "2023-03-01",
      value: 18000,
      recurring: 1000,
      total: 18000,
      recurring_value: 1000,
      currency: "USD",
    },
    {
      date: "2023-04-01",
      value: 10000,
      recurring: 1000,
      total: 10000,
      recurring_value: 1000,
      currency: "USD",
    },
    {
      date: "2023-05-01",
      value: 12000,
      recurring: 1000,
      total: 12000,
      recurring_value: 1000,
      currency: "USD",
    },
    {
      date: "2023-06-01",
      value: 2800,
      recurring: 1000,
      total: 2800,
      recurring_value: 1000,
      currency: "USD",
    },
    {
      date: "2023-07-01",
      value: 1000,
      recurring: 1000,
      total: 1000,
      recurring_value: 1000,
      currency: "USD",
    },
    {
      date: "2023-08-01",
      value: 1000,
      recurring: 1000,
      total: 1000,
      recurring_value: 1000,
      currency: "USD",
    },
    {
      date: "2023-09-01",
      value: 3000,
      recurring: 1000,
      total: 3000,
      recurring_value: 1000,
      currency: "USD",
    },
    {
      date: "2023-10-01",
      value: 20000,
      recurring: 1000,
      total: 20000,
      recurring_value: 1000,
      currency: "USD",
    },
    {
      date: "2023-11-01",
      value: 20000,
      recurring: 1000,
      total: 20000,
      recurring_value: 1000,
      currency: "USD",
    },
    {
      date: "2023-12-01",
      value: 15000,
      recurring: 1000,
      total: 15000,
      recurring_value: 1000,
      currency: "USD",
    },
  ],
};

export const burnRateExamleData = [
  { value: 1000, date: "2024-01-01", currency: "USD" },
  { value: 4000, date: "2024-01-02", currency: "USD" },
  { value: 3000, date: "2024-01-03", currency: "USD" },
  { value: 12000, date: "2024-01-04", currency: "USD" },
  { value: 5000, date: "2024-01-05", currency: "USD" },
  { value: 6000, date: "2024-01-06", currency: "USD" },
  { value: 4500, date: "2024-01-07", currency: "USD" },
  { value: 8000, date: "2024-01-08", currency: "USD" },
  { value: 9000, date: "2024-01-09", currency: "USD" },
  { value: 500, date: "2024-01-10", currency: "USD" },
  { value: 1000, date: "2024-01-11", currency: "USD" },
  { value: 500, date: "2024-01-12", currency: "USD" },
];
</file>

<file path="apps/dashboard/src/components/charts/empty-state.tsx">
"use client";

import { AddAccountButton } from "@/components/add-account-button";
import { useTRPC } from "@/trpc/client";
import { useQuery } from "@tanstack/react-query";

export function EmptyState() {
  const trpc = useTRPC();

  const { data: accounts } = useQuery(
    trpc.bankAccounts.get.queryOptions({
      enabled: true,
    }),
  );

  const isEmpty = !accounts?.length;

  if (!isEmpty) {
    return null;
  }

  return (
    <div className="absolute w-full h-full top-0 left-0 flex items-center justify-center z-20">
      <div className="text-center max-w-md mx-auto flex flex-col items-center justify-center">
        <h2 className="text-xl font-medium mb-2">Connect bank account</h2>
        <p className="text-sm text-[#878787] mb-6">
          Connect your bank account to unlock powerful financial insights. Track
          your spending, analyze trends, and make informed decisions.
        </p>

        <AddAccountButton />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/expense-chart.tsx">
"use client";

import { useReportsParams } from "@/hooks/use-reports-params";
import { useTRPC } from "@/trpc/client";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useQuery } from "@tanstack/react-query";
import Link from "next/link";
import { AnimatedNumber } from "../animated-number";
import { expenseChartExampleData } from "./data";
import { StackedBarChart } from "./stacked-bar-chart";

type Props = {
  disabled?: boolean;
};

export function ExpenseChart({ disabled }: Props) {
  const trpc = useTRPC();
  const { params } = useReportsParams();

  const { data } = useQuery({
    ...trpc.reports.expense.queryOptions({
      from: params.from,
      to: params.to,
      currency: params.currency ?? undefined,
    }),
    placeholderData: (previousData) => previousData ?? expenseChartExampleData,
  });

  return (
    <div
      className={cn(
        disabled && "pointer-events-none select-none blur-[8px] opacity-20",
      )}
    >
      <div className="space-y-2 mb-14 inline-block select-text">
        <h1 className="text-4xl font-mono">
          <AnimatedNumber
            value={data?.summary?.averageExpense ?? 0}
            currency={data?.summary?.currency ?? "USD"}
          />
        </h1>

        <div className="text-sm text-[#606060] flex items-center space-x-2">
          <p className="text-sm text-[#606060]">Average expenses</p>
          <TooltipProvider delayDuration={100}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Icons.Info className="h-4 w-4 mt-1" />
              </TooltipTrigger>
              <TooltipContent
                className="text-xs text-[#878787] max-w-[240px] p-4"
                side="bottom"
                sideOffset={10}
              >
                <div className="space-y-2">
                  <h3 className="font-medium text-primary">
                    Expenses Overview
                  </h3>
                  <p>
                    Expenses include all outgoing transactions, including
                    recurring ones. The chart shows total expenses and recurring
                    costs, helping you identify spending patterns and fixed
                    costs.
                  </p>
                  <p>
                    All amounts are converted into your{" "}
                    <Link
                      href="/settings/accounts"
                      className="text-primary underline"
                    >
                      base currency
                    </Link>
                    .
                  </p>
                </div>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>
      </div>

      <StackedBarChart data={data} />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/profit-chart.tsx">
import { useReportsParams } from "@/hooks/use-reports-params";
import { useTRPC } from "@/trpc/client";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useQuery } from "@tanstack/react-query";
import Link from "next/link";
import { AnimatedNumber } from "../animated-number";
import { FormatAmount } from "../format-amount";
import { BarChart } from "./bar-chart";
import { chartExampleData } from "./data";

type Props = {
  disabled?: boolean;
};

export function ProfitChart({ disabled }: Props) {
  const trpc = useTRPC();
  const { params } = useReportsParams();

  const { data } = useQuery({
    ...trpc.reports.profit.queryOptions({
      from: params.from,
      to: params.to,
      currency: params.currency ?? undefined,
    }),
    placeholderData: (previousData) => previousData ?? chartExampleData,
  });

  return (
    <div
      className={cn(
        disabled && "pointer-events-none select-none blur-[8px] opacity-20",
      )}
    >
      <div className="space-y-2 mb-14 inline-block select-text">
        <h1 className="text-4xl font-mono">
          <AnimatedNumber
            value={data?.summary?.currentTotal ?? 0}
            currency={data?.summary?.currency ?? "USD"}
          />
        </h1>

        <div className="text-sm text-[#606060] flex items-center space-x-2">
          <p className="text-sm text-[#606060]">
            vs{" "}
            <FormatAmount
              maximumFractionDigits={0}
              minimumFractionDigits={0}
              amount={data?.summary?.prevTotal ?? 0}
              currency={data?.meta?.currency ?? "USD"}
            />{" "}
            last period
          </p>
          <TooltipProvider delayDuration={100}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Icons.Info className="h-4 w-4 mt-1" />
              </TooltipTrigger>
              <TooltipContent
                className="text-xs text-[#878787] max-w-[240px] p-4"
                side="bottom"
                sideOffset={10}
              >
                <div className="space-y-2">
                  <h3 className="font-medium text-primary">
                    Profit is calculated as your income minus expenses.
                  </h3>
                  <p>
                    Explanation: This shows how much you're making after costs.
                    If the profit seems off, it may be due to internal transfers
                    labeled as income. You can adjust this by excluding the
                    transactions from the calculations.
                  </p>

                  <p>
                    All amounts are converted into your{" "}
                    <Link
                      href="/settings/accounts"
                      className="text-primary underline"
                    >
                      base currency
                    </Link>
                    .
                  </p>
                </div>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>
      </div>

      <BarChart data={data} />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/revenue-chart.tsx">
import { useReportsParams } from "@/hooks/use-reports-params";
import { useTRPC } from "@/trpc/client";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useQuery } from "@tanstack/react-query";
import Link from "next/link";
import { AnimatedNumber } from "../animated-number";
import { FormatAmount } from "../format-amount";
import { BarChart } from "./bar-chart";
import { chartExampleData } from "./data";

type Props = {
  disabled?: boolean;
};

export function RevenueChart({ disabled }: Props) {
  const trpc = useTRPC();
  const { params } = useReportsParams();

  const { data } = useQuery({
    ...trpc.reports.revenue.queryOptions({
      from: params.from,
      to: params.to,
      currency: params.currency ?? undefined,
    }),
    placeholderData: (previousData) => previousData ?? chartExampleData,
  });

  return (
    <div
      className={cn(
        disabled && "pointer-events-none select-none blur-[8px] opacity-20",
      )}
    >
      <div className="space-y-2 mb-14 inline-block select-text">
        <h1 className="text-4xl font-mono">
          <AnimatedNumber
            value={data?.summary?.currentTotal ?? 0}
            currency={data?.summary?.currency ?? "USD"}
          />
        </h1>

        <div className="text-sm text-[#606060] flex items-center space-x-2">
          <p className="text-sm text-[#606060]">
            vs{" "}
            <FormatAmount
              maximumFractionDigits={0}
              minimumFractionDigits={0}
              amount={data?.summary?.prevTotal ?? 0}
              currency={data?.meta?.currency ?? "USD"}
            />{" "}
            last period
          </p>
          <TooltipProvider delayDuration={100}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Icons.Info className="h-4 w-4 mt-1" />
              </TooltipTrigger>
              <TooltipContent
                className="text-xs text-[#878787] max-w-[240px] p-4"
                side="bottom"
                sideOffset={10}
              >
                <div className="space-y-2">
                  <h3 className="font-medium text-primary">
                    Revenue represents your total income from all sources.
                  </h3>
                  <p>
                    Explanation: This is your gross income before expenses. If
                    the revenue appears too high, internal transfers may have
                    been marked as income. You can fix this by excluding the
                    transactions from the calculations.
                  </p>

                  <p>
                    All amounts are converted into your{" "}
                    <Link
                      href="/settings/accounts"
                      className="text-primary underline"
                    >
                      base currency
                    </Link>
                    .
                  </p>
                </div>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>
      </div>

      <BarChart data={data} />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/stacked-bar-chart.tsx">
// @ts-nocheck

"use client";

import { useUserQuery } from "@/hooks/use-user";
import { useI18n } from "@/locales/client";
import { formatAmount } from "@/utils/format";
import { Icons } from "@midday/ui/icons";
import { format } from "date-fns";
import {
  Bar,
  CartesianGrid,
  ComposedChart,
  Line,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts";

const ToolTipContent = ({ payload = [] }) => {
  const t = useI18n();
  const { data: user } = useUserQuery();

  const current = payload[0]?.payload;

  if (!current) return null;

  return (
    <div className="w-[240px] border shadow-sm bg-background">
      <div className="border-b-[1px] px-4 py-2 flex justify-between items-center">
        <p className="text-sm">{t(`chart_type.${current.meta.type}`)}</p>
      </div>

      <div className="p-4">
        <div className="flex justify-between mb-2">
          <div className="flex items-center justify-center space-x-2">
            <div className="w-[8px] h-[8px] rounded-full bg-[#C6C6C6] dark:bg-[#606060]" />
            <p className="font-medium text-[13px]">
              {formatAmount({
                maximumFractionDigits: 0,
                minimumFractionDigits: 0,
                currency: current.currency,
                amount: current.total,
                locale: user?.locale,
              })}
            </p>
          </div>

          <p className="text-xs text-[#606060] text-right">Total</p>
        </div>

        <div className="flex justify-between">
          <div className="flex items-center justify-center space-x-2">
            <Icons.DotRaster />
            <p className="font-medium text-[13px]">
              {formatAmount({
                amount: current.recurring,
                currency: current.currency,
                maximumFractionDigits: 0,
                minimumFractionDigits: 0,
                locale: user?.locale,
              })}
            </p>
          </div>

          <p className="text-xs text-[#606060] text-right">Recurring</p>
        </div>
      </div>
    </div>
  );
};

export function StackedBarChart({ data, height = 290 }) {
  const formattedData = data.result.map((item) => ({
    ...item,
    value: item.value,
    recurring: item.recurring,
    total: item.total,
    meta: data.meta,
    date: format(new Date(item.date), "MMM"),
  }));

  return (
    <div className="relative h-full w-full">
      <div className="space-x-4 absolute right-0 -top-10 hidden md:flex">
        <div className="flex space-x-2 items-center">
          <span className="w-2 h-2 rounded-full bg-[#C6C6C6] dark:bg-[#606060]" />
          <span className="text-sm text-[#606060]">Total expenses</span>
        </div>
        <div className="flex space-x-2 items-center">
          <Icons.DotRaster />
          <span className="text-sm text-[#606060]">Recurring</span>
        </div>
      </div>

      <ResponsiveContainer width="100%" height={height}>
        <ComposedChart data={formattedData} barGap={15}>
          <defs>
            <pattern
              id="raster"
              patternUnits="userSpaceOnUse"
              width="64"
              height="64"
            >
              <rect
                width="64"
                height="64"
                className="dark:fill-[#323232] fill-[#C6C6C6]"
              />
              <path
                d="M-106 110L22 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-98 110L30 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-90 110L38 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-82 110L46 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-74 110L54 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-66 110L62 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-58 110L70 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-50 110L78 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-42 110L86 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-34 110L94 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-26 110L102 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-18 110L110 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-10 110L118 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M-2 110L126 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M6 110L134 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M14 110L142 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
              <path
                d="M22 110L150 -18"
                className="stroke-[#323232] dark:stroke-white"
              />
            </pattern>
          </defs>

          <XAxis
            dataKey="date"
            stroke="#888888"
            fontSize={12}
            tickLine={false}
            axisLine={false}
            tickMargin={15}
            tick={{
              fill: "#606060",
              fontSize: 12,
              fontFamily: "var(--font-sans)",
            }}
          />

          <YAxis
            stroke="#888888"
            fontSize={12}
            tickMargin={10}
            tickLine={false}
            axisLine={false}
            tick={{
              fill: "#606060",
              fontSize: 12,
              fontFamily: "var(--font-sans)",
            }}
          />

          <CartesianGrid
            strokeDasharray="3 3"
            vertical={false}
            className="stoke-[#DCDAD2] dark:stroke-[#2C2C2C]"
          />

          <Tooltip content={ToolTipContent} cursor={false} />

          <Bar
            barSize={16}
            dataKey="recurring"
            stackId="a"
            fill="url(#raster)"
          />

          <Bar
            barSize={16}
            dataKey="value"
            stackId="a"
            className="dark:fill-[#323232] fill-[#C6C6C6]"
          />

          <Line
            type="monotone"
            dataKey="recurring"
            strokeWidth={2.5}
            stroke="hsl(var(--border))"
            dot={false}
          />
        </ComposedChart>
      </ResponsiveContainer>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/charts/status.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";

type Props = {
  value: string;
  variant?: "positive" | "negative";
};

export function Status({ value, variant }: Props) {
  return (
    <div
      className={cn(
        "flex space-x-1 text-[#FF3638] items-center",
        variant === "positive" && "text-[#00C969]",
      )}
    >
      {variant === "positive" ? (
        <Icons.TrendingUp size={14} />
      ) : (
        <Icons.TrendingDown size={14} />
      )}

      <p className="text-[12px] font-medium">{value}</p>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/tools/burn-rate/burn-rate.tsx">
"use client";

import { AreaChart } from "@/components/charts/area-chart";
import { BotMessage } from "@/components/chat/messages";
import type { GetBurnRateResult } from "@/lib/tools/get-burn-rate";
import { useTRPC } from "@/trpc/client";
import { useQuery } from "@tanstack/react-query";

type Props = {
  result: GetBurnRateResult;
};

export function BurnRate({ result }: Props) {
  const trpc = useTRPC();

  const { from, to, currency } = result.params;

  const { data, isLoading } = useQuery(
    trpc.reports.burnRate.queryOptions({
      from,
      to,
      currency,
    }),
  );

  if (isLoading) {
    return null;
  }

  return (
    <BotMessage className="text-xs font-sans mb-8">
      <AreaChart data={data} height={200} />
    </BotMessage>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/tools/documents/documents.tsx">
"use client";

import { BotMessage } from "@/components/chat/messages";
import { FilePreview } from "@/components/file-preview";
import { VaultItemActions } from "@/components/vault/vault-item-actions";
import type { GetDocumentResult } from "@/lib/tools/get-documents";
import { useTRPC } from "@/trpc/client";
import { Skeleton } from "@midday/ui/skeleton";
import { useQuery } from "@tanstack/react-query";

type Props = {
  result: GetDocumentResult;
};

export function Documents({ result }: Props) {
  const trpc = useTRPC();
  const { data, isLoading } = useQuery(
    trpc.documents.get.queryOptions({
      q: result.params.name,
    }),
  );

  if (isLoading) {
    return null;
  }

  return (
    <BotMessage>
      <div className="overflow-auto space-x-4 flex scrollbar-hide pr-4">
        {data?.data.map((document) => (
          <div key={document.id} className="w-[150px] flex-shrink-0 relative">
            {/* @ts-expect-error - mimetype is not typed (JSONB) */}
            {document?.metadata?.mimetype === "image/heic" ? (
              // NOTE: We convert the heic images to jpeg in the backend, so we need to wait for the image to be processed
              // Otherwise the image will be a broken image, and the cache will not be updated
              <Skeleton className="absolute inset-0 w-full h-full" />
            ) : (
              <div className="relative group/file">
                <FilePreview
                  filePath={document?.pathTokens?.join("/") ?? ""}
                  mimeType={
                    (document?.metadata as { mimetype?: string })?.mimetype ??
                    ""
                  }
                />

                <div className="absolute top-2 right-2 opacity-0 group-hover/file:opacity-100 transition-opacity duration-200">
                  <VaultItemActions
                    id={document.id}
                    filePath={document?.pathTokens ?? []}
                    hideDelete
                  />
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
    </BotMessage>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/tools/inbox/inbox.tsx">
"use client";

import { BotMessage } from "@/components/chat/messages";
import { FilePreview } from "@/components/file-preview";
import { VaultItemActions } from "@/components/vault/vault-item-actions";
import type { GetInboxResult } from "@/lib/tools/get-inbox";
import { useTRPC } from "@/trpc/client";
import { Skeleton } from "@midday/ui/skeleton";
import { useQuery } from "@tanstack/react-query";

type Props = {
  result: GetInboxResult;
};

export function Inbox({ result }: Props) {
  const trpc = useTRPC();
  const { data, isLoading } = useQuery(
    trpc.inbox.get.queryOptions({
      q: result.params.name,
    }),
  );

  if (isLoading) {
    return null;
  }

  return (
    <BotMessage>
      <div className="overflow-auto space-x-4 flex scrollbar-hide pr-4">
        {data?.data.map((document) => (
          <div key={document.id} className="w-[150px] flex-shrink-0 relative">
            {/* @ts-expect-error - mimetype is not typed (JSONB) */}
            {document?.metadata?.mimetype === "image/heic" ? (
              <Skeleton className="absolute inset-0 w-full h-full" />
            ) : (
              <div className="relative group/file">
                <FilePreview
                  filePath={document?.filePath?.join("/") ?? ""}
                  mimeType={document.contentType ?? ""}
                />

                <div className="absolute top-2 right-2 opacity-0 group-hover/file:opacity-100 transition-opacity duration-200">
                  <VaultItemActions
                    id={document.id}
                    filePath={document?.filePath ?? []}
                    hideDelete
                  />
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
    </BotMessage>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/tools/profit/profit.tsx">
"use client";

import { BarChart } from "@/components/charts/bar-chart";
import { BotMessage } from "@/components/chat/messages";
import type { GetProfitResult } from "@/lib/tools/get-profit";
import { useTRPC } from "@/trpc/client";
import { useQuery } from "@tanstack/react-query";

type Props = {
  result: GetProfitResult;
};

export function Profit({ result }: Props) {
  const trpc = useTRPC();

  const { from, to, currency } = result.params;

  const { data, isLoading } = useQuery(
    trpc.reports.profit.queryOptions({
      from,
      to,
      currency,
    }),
  );

  if (isLoading) {
    return null;
  }

  return (
    <BotMessage className="text-xs font-sans mb-8">
      <BarChart data={data} height={200} />
    </BotMessage>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/tools/revenue/revenue.tsx">
"use client";

import { BarChart } from "@/components/charts/bar-chart";
import { BotMessage } from "@/components/chat/messages";
import type { GetRevenueResult } from "@/lib/tools/get-revenue";
import { useTRPC } from "@/trpc/client";
import { useQuery } from "@tanstack/react-query";

type Props = {
  result: GetRevenueResult;
};

export function Revenue({ result }: Props) {
  const trpc = useTRPC();

  const { from, to, currency } = result.params;

  const { data, isLoading } = useQuery(
    trpc.reports.revenue.queryOptions({
      from,
      to,
      currency,
    }),
  );

  if (isLoading) {
    return null;
  }

  return (
    <BotMessage className="text-xs font-sans mb-8">
      <BarChart data={data} height={200} />
    </BotMessage>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/tools/transactions/show-more-buttont.tsx">
"use client";

import type { GetTransactionsResult } from "@/lib/tools/get-transactions";
import { useAssistantStore } from "@/store/assistant";
import { useRouter } from "next/navigation";

type Props = {
  params: GetTransactionsResult["params"];
};

export function ShowMoreButton({ params }: Props) {
  const { setOpen } = useAssistantStore();
  const router = useRouter();

  const handleOnClick = () => {
    setOpen();
    router.push(`/transactions?q=${params.q}`);
  };

  // TODO: Handle more params
  if (!params.q) return null;

  return (
    <button
      type="button"
      onClick={handleOnClick}
      className="text-[#878787] font-sans text-sm mt-2"
    >
      Show more
    </button>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/tools/transactions/skeleton.tsx">
import { Skeleton } from "@midday/ui/skeleton";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@midday/ui/table";

export function TransactionsSkeleton() {
  return (
    <Table className="text-xs font-sans w-[640px]">
      <TableHeader>
        <TableRow>
          <TableHead className="w-[45%] h-10">Description</TableHead>
          <TableHead className="h-10 min-w-[80px]">Date</TableHead>
          <TableHead className="h-10">Amount</TableHead>
          <TableHead className="h-10 text-right w-[50px]">Status</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {Array.from({ length: 5 }).map((_, index) => (
          <TableRow key={index.toString()} className="h-[34px]">
            <TableCell>
              <Skeleton className="h-4 w-[80%]" />
            </TableCell>
            <TableCell>
              <Skeleton className="h-4 w-[60px]" />
            </TableCell>
            <TableCell>
              <Skeleton className="h-4 w-[50px]" />
            </TableCell>
            <TableCell className="flex justify-end">
              <Skeleton className="h-4 w-4 rounded-full" />
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/tools/transactions/transactions.tsx">
"use client";

import { BotMessage } from "@/components/chat/messages";
import { FormatAmount } from "@/components/format-amount";
import { TransactionStatus } from "@/components/transaction-status";
import { useUserQuery } from "@/hooks/use-user";
import type { GetTransactionsResult } from "@/lib/tools/get-transactions";
import { useTRPC } from "@/trpc/client";
import { formatDate } from "@/utils/format";
import { cn } from "@midday/ui/cn";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@midday/ui/table";
import { useQuery } from "@tanstack/react-query";
import { ShowMoreButton } from "./show-more-buttont";
import { TransactionsSkeleton } from "./skeleton";

type Props = {
  result: GetTransactionsResult;
};

export function Transactions({ result }: Props) {
  const trpc = useTRPC();
  const { data: user } = useUserQuery();
  const { pageSize, sort, ...filter } = result.params;

  const { data, isLoading } = useQuery(
    trpc.transactions.get.queryOptions({
      sort,
      pageSize,
      ...filter,
    }),
  );

  if (isLoading) {
    return (
      <BotMessage>
        <TransactionsSkeleton />
      </BotMessage>
    );
  }

  return (
    <BotMessage className="text-xs font-sans mb-8">
      <Table className="text-xs font-sans w-[640px]">
        <TableHeader>
          <TableRow>
            <TableHead className="w-[45%] h-10">Description</TableHead>
            <TableHead className="h-10 min-w-[80px]">Date</TableHead>
            <TableHead className="h-10">Amount</TableHead>
            <TableHead className="h-10 text-right w-[50px]">Status</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {data?.data?.map((transaction) => {
            const fullfilled = transaction.isFulfilled;

            return (
              <TableRow key={transaction.id} className="h-[34px]">
                <TableCell
                  className={cn(
                    "font-normal",
                    transaction.category?.slug === "income" && "text-[#00C969]",
                  )}
                >
                  <span className="line-clamp-1">{transaction.name}</span>
                </TableCell>
                <TableCell className="font-normal">
                  {formatDate(transaction.date, user?.dateFormat)}
                </TableCell>
                <TableCell
                  className={cn(
                    "font-normal",
                    transaction.category?.slug === "income" && "text-[#00C969]",
                  )}
                >
                  <FormatAmount
                    amount={transaction.amount}
                    currency={transaction.currency}
                  />
                </TableCell>
                <TableCell className="text-right font-normal">
                  <TransactionStatus
                    fullfilled={fullfilled}
                    hasPendingSuggestion={transaction.hasPendingSuggestion}
                  />
                </TableCell>
              </TableRow>
            );
          })}
        </TableBody>
      </Table>

      {result.meta.hasNextPage && <ShowMoreButton params={result.params} />}
    </BotMessage>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/chat-avatar.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { Avatar, AvatarImageNext } from "@midday/ui/avatar";
import { Icons } from "@midday/ui/icons";
import type { UIMessage } from "ai";

type Props = {
  role: UIMessage["role"];
};

export function ChatAvatar({ role }: Props) {
  const { data: user } = useUserQuery();

  switch (role) {
    case "user": {
      return (
        <div className="flex size-[25px] shrink-0 select-none items-center justify-center">
          <Avatar className="size-6">
            <AvatarImageNext
              src={user?.avatarUrl || ""}
              alt={user?.fullName ?? ""}
              width={24}
              height={24}
            />
          </Avatar>
        </div>
      );
    }

    case "assistant": {
      return (
        <div className="flex size-[25px] shrink-0 select-none items-center justify-center">
          <Icons.LogoSmall className="size-6" />
        </div>
      );
    }

    default:
      return null;
  }
}
</file>

<file path="apps/dashboard/src/components/chat/chat-empty.tsx">
import { Icons } from "@midday/ui/icons";

type Props = {
  firstName: string;
};

export function ChatEmpty({ firstName }: Props) {
  return (
    <div className="w-full mt-[200px] desktop:mt-24 md:mt-24 flex flex-col items-center justify-center text-center">
      <Icons.LogoSmall />
      <span className="font-medium text-xl mt-6">
        Hi {firstName}, how can I help <br />
        you today?
      </span>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/chat-examples.tsx">
"use client";

import { motion } from "framer-motion";
import { useMemo, useRef } from "react";
import { useDraggable } from "react-use-draggable-scroll";
import { chatExamples } from "./examples";

const listVariant = {
  hidden: { y: 45, opacity: 0 },
  show: {
    y: 0,
    opacity: 1,
    transition: {
      duration: 0.3,
      staggerChildren: 0.08,
    },
  },
};

const itemVariant = {
  hidden: { y: 45, opacity: 0 },
  show: { y: 0, opacity: 1 },
};

type Props = {
  handleSubmit: (example: string) => void;
};

export function ChatExamples({ handleSubmit }: Props) {
  const ref = useRef<HTMLDivElement | null>(null);
  // @ts-expect-error: react-use-draggable-scroll expects a MutableRefObject<HTMLElement>
  const { events } = useDraggable(ref);

  const totalLength = chatExamples.reduce((accumulator, currentString) => {
    return accumulator + currentString.length * 8.2 + 20;
  }, 0);

  return (
    <div
      className="absolute z-10 bottom-[100px] left-0 right-0 overflow-scroll scrollbar-hide cursor-grabbing hidden md:block"
      {...events}
      ref={ref}
    >
      <motion.ul
        variants={listVariant}
        initial="hidden"
        animate="show"
        className="flex space-x-4 ml-4 items-center"
        style={{ width: `${totalLength}px` }}
      >
        {chatExamples.map((example) => (
          <button
            key={example}
            type="button"
            onClick={() => handleSubmit(example)}
          >
            <motion.li
              variants={itemVariant}
              className="font-mono text-[#878787] bg-[#F2F1EF] text-xs dark:bg-[#1D1D1D] px-3 py-2 rounded-full cursor-default"
            >
              {example}
            </motion.li>
          </button>
        ))}
      </motion.ul>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/chat-footer.tsx">
import { Icons } from "@midday/ui/icons";

type Props = {
  handleSubmit: () => void;
};

export function ChatFooter({ handleSubmit }: Props) {
  return (
    <div className="hidden desktop:flex md:flex px-3 h-[40px] w-full border-t-[1px] items-center bg-background backdrop-filter dark:border-[#2C2C2C] backdrop-blur-lg dark:bg-[#151515]/[99]">
      <div className="scale-50 opacity-50 -ml-2">
        <Icons.LogoSmall />
      </div>

      <div className="ml-auto flex space-x-4">
        <button
          className="flex space-x-2 items-center text-xs"
          type="button"
          onClick={handleSubmit}
        >
          <span>Submit</span>
          <kbd className="pointer-events-none h-5 select-none items-center gap-1 border bg-accent px-1.5 font-mono text-[10px] font-medium">
            <span>↵</span>
          </kbd>
        </button>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/chat-input.tsx">
"use client";

import type { UseChatHelpers } from "@ai-sdk/react";
import { Textarea } from "@midday/ui/textarea";

type Props = {
  setInput: UseChatHelpers["setInput"];
  handleSubmit: UseChatHelpers["handleSubmit"];
  input: UseChatHelpers["input"];
};

export function ChatInput({ handleSubmit, input, setInput }: Props) {
  const handleInput = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
    setInput(event.target.value);
  };

  return (
    <Textarea
      onChange={handleInput}
      placeholder="Ask Midday a question..."
      value={input}
      className="flex w-full border bg-transparent px-3 py-2 text-sm placeholder:text-muted-foreground focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 h-12 min-h-12 pt-3 resize-none border-none"
      rows={1}
      autoFocus
      onKeyDown={(event) => {
        if (
          event.key === "Enter" &&
          !event.shiftKey &&
          !event.nativeEvent.isComposing
        ) {
          event.preventDefault();

          handleSubmit();
        }
      }}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/chat/examples.ts">
export const chatExamples = [
  `What's my burn rate`,
  `What's my runway`,
  "Show transactions without receipts",
  "What's my tax summary",
  "What is my spending on Software",
  "Find a receipt or invoice",
  "Find a transaction",
  `What's my profit for last year`,
  `What's my revenue`,
  "Forecast profit",
  "Forecast revenue",
  "Find a document",
  "Recurring transactions",
];
</file>

<file path="apps/dashboard/src/components/chat/index.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { useAssistantStore } from "@/store/assistant";
import { useChat } from "@ai-sdk/react";
import { useEffect } from "react";
import { ChatEmpty } from "./chat-empty";
import { ChatExamples } from "./chat-examples";
import { ChatFooter } from "./chat-footer";
import { ChatInput } from "./chat-input";
import { Messages } from "./messages";

export function Chat() {
  const { message } = useAssistantStore();

  const { messages, input, handleSubmit, status, setInput, append } = useChat({
    experimental_throttle: 100,
    sendExtraMessageFields: true,
  });

  const { data: user } = useUserQuery();

  const showExamples = messages.length === 0 && !input;

  const handleExampleSubmit = (example: string) => {
    append({ role: "user", content: example });
    handleSubmit();
  };

  useEffect(() => {
    if (message) {
      append({ role: "user", content: message });
      handleSubmit();
    }
  }, [message]);

  return (
    <div className="relative">
      <div className="desktop:h-[335px] md:h-[335px]">
        {messages.length ? (
          <Messages status={status} messages={messages} />
        ) : (
          <ChatEmpty firstName={user?.fullName?.split(" ").at(0) ?? ""} />
        )}
      </div>
      <div className="fixed bottom-[1px] left-[1px] right-[1px] desktop:h-[88px] md:h-[88px] bg-background border-border border-t-[1px]">
        {showExamples && <ChatExamples handleSubmit={handleExampleSubmit} />}

        <ChatInput
          handleSubmit={handleSubmit}
          input={input}
          setInput={setInput}
        />

        <ChatFooter handleSubmit={handleSubmit} />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/markdown.tsx">
import Link from "next/link";
import React, { memo } from "react";
import ReactMarkdown, { type Components } from "react-markdown";
import remarkGfm from "remark-gfm";

const components: Partial<Components> = {
  pre: ({ children }) => <>{children}</>,
  ol: ({ node, children, ...props }) => {
    return (
      <ol className="list-decimal list-outside ml-4 pl-1 space-y-0" {...props}>
        {children}
      </ol>
    );
  },
  li: ({ node, children, ...props }) => {
    return <li {...props}>{children}</li>;
  },
  ul: ({ node, children, ...props }) => {
    return (
      <ul className="list-decimal list-outside ml-4 pl-1 space-y-0" {...props}>
        {children}
      </ul>
    );
  },
  strong: ({ node, children, ...props }) => {
    return (
      <span className="font-semibold" {...props}>
        {children}
      </span>
    );
  },
  a: ({ node, children, ...props }) => {
    return (
      // @ts-expect-error
      <Link
        className="text-blue-500 hover:underline"
        target="_blank"
        rel="noreferrer"
        {...props}
      >
        {children}
      </Link>
    );
  },
  h1: ({ node, children, ...props }) => {
    return (
      <h1 className="text-3xl font-semibold mt-6 mb-2" {...props}>
        {children}
      </h1>
    );
  },
  h2: ({ node, children, ...props }) => {
    return (
      <h2 className="text-2xl font-semibold mt-6 mb-2" {...props}>
        {children}
      </h2>
    );
  },
  h3: ({ node, children, ...props }) => {
    return (
      <h3 className="text-xl font-semibold mt-6 mb-2" {...props}>
        {children}
      </h3>
    );
  },
  h4: ({ node, children, ...props }) => {
    return (
      <h4 className="text-lg font-semibold mt-6 mb-2" {...props}>
        {children}
      </h4>
    );
  },
  h5: ({ node, children, ...props }) => {
    return (
      <h5 className="text-base font-semibold mt-6 mb-2" {...props}>
        {children}
      </h5>
    );
  },
  h6: ({ node, children, ...props }) => {
    return (
      <h6 className="text-sm font-semibold mt-6 mb-2" {...props}>
        {children}
      </h6>
    );
  },
};

const remarkPlugins = [remarkGfm];

const NonMemoizedMarkdown = ({ children }: { children: string }) => {
  return (
    <ReactMarkdown remarkPlugins={remarkPlugins} components={components}>
      {children}
    </ReactMarkdown>
  );
};

export const Markdown = memo(
  NonMemoizedMarkdown,
  (prevProps, nextProps) => prevProps.children === nextProps.children,
);
</file>

<file path="apps/dashboard/src/components/chat/message.tsx">
"use client";

import type { UIMessage } from "ai";
import equal from "fast-deep-equal";
import { memo } from "react";
import { ChatAvatar } from "./chat-avatar";
import { Markdown } from "./markdown";
import { spinner } from "./spinner";
import { BurnRate } from "./tools/burn-rate/burn-rate";
import { Documents } from "./tools/documents/documents";
import { Inbox } from "./tools/inbox/inbox";
import { Profit } from "./tools/profit/profit";
import { Revenue } from "./tools/revenue/revenue";
import { Transactions } from "./tools/transactions/transactions";

type ToolResultProps = {
  part: UIMessage["parts"][number];
};

function ToolResult({ part }: ToolResultProps) {
  if (part.type !== "tool-invocation") {
    return null;
  }

  const { toolInvocation } = part;

  if (toolInvocation.state === "result") {
    switch (toolInvocation.toolName) {
      case "getDocuments":
        return <Documents result={toolInvocation.result} />;
      case "getBurnRate":
        return <BurnRate result={toolInvocation.result} />;
      case "getTransactions":
        return <Transactions result={toolInvocation.result} />;
      case "getRevenue":
        return <Revenue result={toolInvocation.result} />;
      case "getProfit":
        return <Profit result={toolInvocation.result} />;
      case "getInbox":
        return <Inbox result={toolInvocation.result} />;
      default:
        return null;
    }
  }
}

const PurePreviewMessage = ({
  message,
}: {
  message: UIMessage;
  isLoading: boolean;
}) => {
  return (
    <div
      className="group relative flex items-start w-full"
      data-role={message.role}
    >
      <div className="group relative flex items-start">
        <ChatAvatar role={message.role} />

        <div className="flex flex-col w-full pl-4">
          {message.parts?.map((part, index) => {
            const { type } = part;
            const key = `message-${message.id}-part-${index}`;

            if (type === "text") {
              return (
                <div
                  key={key}
                  className="space-y-2 text-xs font-mono leading-relaxed mb-2"
                >
                  <Markdown>{part.text}</Markdown>
                </div>
              );
            }

            if (type === "tool-invocation") {
              return <ToolResult part={part} key={key} />;
            }
          })}
        </div>
      </div>
    </div>
  );
};

export const PreviewMessage = memo(
  PurePreviewMessage,
  (prevProps, nextProps) => {
    if (prevProps.isLoading !== nextProps.isLoading) return false;
    if (prevProps.message.id !== nextProps.message.id) return false;
    if (!equal(prevProps.message.parts, nextProps.message.parts)) return false;

    return true;
  },
);

export const ThinkingMessage = () => {
  const role = "assistant";

  return (
    <div className="group relative flex items-start w-full" data-role={role}>
      <div className="group relative flex items-start">
        <ChatAvatar role={role} />
        <div className="flex flex-col w-full pl-4">{spinner}</div>
      </div>
    </div>
  );
};
</file>

<file path="apps/dashboard/src/components/chat/messages.tsx">
import { useScrollToBottom } from "@/hooks/use-scroll-to-bottom";
import type { UseChatHelpers } from "@ai-sdk/react";
import { cn } from "@midday/ui/cn";
import type { UIMessage } from "ai";
import equal from "fast-deep-equal";
import { memo } from "react";
import { PreviewMessage, ThinkingMessage } from "./message";

interface MessagesProps {
  status: UseChatHelpers["status"];
  messages: Array<UIMessage>;
}

function PureMessages({ status, messages }: MessagesProps) {
  const [messagesContainerRef, messagesEndRef] =
    useScrollToBottom<HTMLDivElement>();

  return (
    <div
      ref={messagesContainerRef}
      className="flex flex-col min-w-0 gap-6 flex-1 overflow-y-scroll select-text p-4 h-full"
    >
      {messages.map((message, index) => (
        <PreviewMessage
          key={message.id}
          message={message}
          isLoading={status === "streaming" && messages.length - 1 === index}
        />
      ))}

      {status === "submitted" &&
        messages.length > 0 &&
        messages[messages.length - 1]?.role === "user" && <ThinkingMessage />}

      <div
        ref={messagesEndRef}
        className="shrink-0 min-w-[24px] min-h-[24px]"
      />
    </div>
  );
}

export const Messages = memo(PureMessages, (prevProps, nextProps) => {
  if (prevProps.status !== nextProps.status) return false;
  if (prevProps.status && nextProps.status) return false;
  if (prevProps.messages.length !== nextProps.messages.length) return false;
  if (!equal(prevProps.messages, nextProps.messages)) return false;

  return true;
});

export function BotMessage({
  children,
  className,
}: { children: React.ReactNode; className?: string }) {
  return (
    <div
      className={cn(
        "space-y-2 text-xs font-mono leading-relaxed w-[640px] mb-2",
        className,
      )}
    >
      {children}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/chat/spinner.tsx">
"use client";

export const spinner = (
  <svg
    fill="none"
    stroke="currentColor"
    strokeWidth="1.5"
    viewBox="0 0 24 24"
    strokeLinecap="round"
    strokeLinejoin="round"
    xmlns="http://www.w3.org/2000/svg"
    className="size-5 animate-spin stroke-zinc-400"
  >
    <path d="M12 3v3m6.366-.366-2.12 2.12M21 12h-3m.366 6.366-2.12-2.12M12 21v-3m-6.366.366 2.12-2.12M3 12h3m-.366-6.366 2.12 2.12" />
  </svg>
);
</file>

<file path="apps/dashboard/src/components/forms/api-key-form.tsx">
"use client";

import { useZodForm } from "@/hooks/use-zod-form";
import { useTokenModalStore } from "@/store/token-modal";
import { useTRPC } from "@/trpc/client";
import { RESOURCES } from "@/utils/scopes";
import {
  SCOPES,
  type Scope,
  type ScopePreset,
  scopePresets,
  scopesToName,
} from "@api/utils/scopes";
import { AnimatedSizeContainer } from "@midday/ui/animated-size-container";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { Tabs, TabsList, TabsTrigger } from "@midday/ui/tabs";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useEffect, useState } from "react";
import { z } from "zod";
import { ScopeSelector } from "../scope-selector";

const formSchema = z.object({
  id: z.string().optional(),
  name: z.string().min(2, {
    message: "Team name must be at least 2 characters.",
  }),
  scopes: z.array(z.enum(SCOPES)).default(["apis.all"]),
});

type Props = {
  onSuccess: (key: string | null) => void;
};

export function ApiKeyForm({ onSuccess }: Props) {
  const { data } = useTokenModalStore();
  const [preset, setPreset] = useState<ScopePreset>(() =>
    data?.scopes
      ? (scopesToName(data.scopes).preset as ScopePreset)
      : "all_access",
  );

  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const upsertApiKeyMutation = useMutation(
    trpc.apiKeys.upsert.mutationOptions({
      onSuccess: (data) => {
        queryClient.invalidateQueries({
          queryKey: trpc.apiKeys.get.queryKey(),
        });

        onSuccess(data.key);
      },
    }),
  );

  const form = useZodForm(formSchema, {
    defaultValues: {
      id: data?.id ?? undefined,
      name: data?.name ?? "",
      scopes: (data?.scopes as Scope[]) ?? ["apis.all"],
    },
  });

  // Effect to ensure proper initialization when editing existing API key
  useEffect(() => {
    if (data?.scopes) {
      const detectedPreset = scopesToName(data.scopes).preset as ScopePreset;
      setPreset(detectedPreset);

      // If it's restricted, make sure the form has the correct scopes
      if (detectedPreset === "restricted") {
        form.setValue("scopes", data.scopes as Scope[], { shouldDirty: true });
      }
    }
  }, [data?.scopes, form]);

  // Update form scopes based on preset
  const updateScopesFromPreset = (newPreset: ScopePreset) => {
    let newScopes: Scope[] = [];

    switch (newPreset) {
      case "all_access":
        newScopes = ["apis.all"];
        break;
      case "read_only":
        newScopes = ["apis.read"];
        break;
      case "restricted": {
        // Keep existing scopes when switching to restricted mode
        const currentScopes = form.getValues("scopes");
        // Get all valid scopes from RESOURCES
        const validScopes = RESOURCES.flatMap((resource) =>
          resource.scopes.map((scope) => scope.scope),
        );
        // Only keep scopes that are defined in RESOURCES
        newScopes = currentScopes.filter((scope): scope is Scope =>
          validScopes.some((validScope) => validScope === scope),
        );
        break;
      }
    }

    form.setValue("scopes", newScopes, { shouldDirty: true });
  };

  const handlePresetChange = (value: string) => {
    const scopePreset = value as ScopePreset;
    setPreset(scopePreset);
    updateScopesFromPreset(scopePreset);
  };

  const handleResourceScopeChange = (resourceKey: string, scope: string) => {
    if (preset !== "restricted") return;

    const currentScopes = form.getValues("scopes");
    const resource = RESOURCES.find((r) => r.key === resourceKey);
    if (!resource) return;

    // Remove any existing scopes for this resource
    const filteredScopes = currentScopes.filter(
      (currentScope) => !resource.scopes.some((s) => s.scope === currentScope),
    );

    // Add the new scope if it's not empty
    const newScopes = scope
      ? [...filteredScopes, scope as Scope]
      : filteredScopes;

    form.setValue("scopes", newScopes, { shouldDirty: true });
  };

  function onSubmit(values: z.infer<typeof formSchema>) {
    upsertApiKeyMutation.mutate({
      id: values.id,
      name: values.name,
      scopes: values.scopes,
    });
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input
                  autoFocus
                  className="mt-2"
                  autoComplete="off"
                  autoCapitalize="none"
                  autoCorrect="off"
                  spellCheck="false"
                  {...field}
                />
              </FormControl>

              <FormMessage />
            </FormItem>
          )}
        />

        <Tabs
          value={preset}
          className="mt-4 w-full"
          onValueChange={handlePresetChange}
        >
          <TabsList className="w-full flex">
            {scopePresets.map((scope) => (
              <TabsTrigger
                value={scope.value}
                className="flex-1"
                key={scope.value}
              >
                {scope.label}
              </TabsTrigger>
            ))}
          </TabsList>
        </Tabs>

        <p className="text-sm text-[#878787] mt-4">
          This API key will have{" "}
          <span className="font-semibold">
            {scopePresets.find((scope) => scope.value === preset)?.description}
          </span>
          .
        </p>

        <AnimatedSizeContainer height className="mt-4">
          {preset === "restricted" && (
            <ScopeSelector
              selectedScopes={form.watch("scopes")}
              onResourceScopeChange={handleResourceScopeChange}
              description="Select which scopes this API key can access."
              height="max-h-[300px]"
            />
          )}
        </AnimatedSizeContainer>

        <SubmitButton
          className="mt-6 w-full"
          type="submit"
          disabled={!form.formState.isDirty}
          isSubmitting={upsertApiKeyMutation.isPending}
        >
          {data?.id ? "Update" : "Create"}
        </SubmitButton>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/forms/create-team-form.tsx">
"use client";

import { revalidateAfterTeamChange } from "@/actions/revalidate-action";
import { SelectCurrency } from "@/components/select-currency";
import { useZodForm } from "@/hooks/use-zod-form";
import { useTRPC } from "@/trpc/client";
import { uniqueCurrencies } from "@midday/location/currencies";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { use, useRef, useState } from "react";
import { z } from "zod";
import { CountrySelector } from "../country-selector";

const formSchema = z.object({
  name: z.string().min(2, {
    message: "Team name must be at least 2 characters.",
  }),
  countryCode: z.string(),
  baseCurrency: z.string(),
});

type Props = {
  defaultCurrencyPromise: Promise<string>;
  defaultCountryCodePromise: Promise<string>;
};

export function CreateTeamForm({
  defaultCurrencyPromise,
  defaultCountryCodePromise,
}: Props) {
  const currency = use(defaultCurrencyPromise);
  const countryCode = use(defaultCountryCodePromise);
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const [isLoading, setIsLoading] = useState(false);
  const isSubmittedRef = useRef(false);

  const createTeamMutation = useMutation(
    trpc.team.create.mutationOptions({
      onSuccess: async () => {
        // Lock the form permanently - never reset on success
        setIsLoading(true);
        isSubmittedRef.current = true;

        try {
          // Invalidate all queries to ensure fresh data everywhere
          await queryClient.invalidateQueries();
          // Revalidate server-side paths and redirect
          await revalidateAfterTeamChange();
        } catch (error) {
          // Even if redirect fails, keep the form locked to prevent duplicates
          console.error("Redirect failed, but keeping form locked:", error);
        }
        // Note: We NEVER reset loading state on success - user should be redirected
      },
      onError: () => {
        setIsLoading(false);
        isSubmittedRef.current = false; // Reset on error to allow retry
      },
    }),
  );

  const form = useZodForm(formSchema, {
    defaultValues: {
      name: "",
      baseCurrency: currency,
      countryCode: countryCode ?? "",
    },
  });

  // Computed loading state that can never be reset unexpectedly
  const isFormLocked = isLoading || isSubmittedRef.current;

  function onSubmit(values: z.infer<typeof formSchema>) {
    if (isFormLocked) {
      return;
    }

    setIsLoading(true);
    isSubmittedRef.current = true; // Permanent flag that survives re-renders

    createTeamMutation.mutate({
      name: values.name,
      baseCurrency: values.baseCurrency,
      countryCode: values.countryCode,
      switchTeam: true, // Automatically switch to the new team
    });
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem className="mt-4 w-full">
              <FormLabel className="text-xs text-[#666] font-normal">
                Company name
              </FormLabel>
              <FormControl>
                <Input
                  autoFocus
                  placeholder="Ex: Acme Marketing or Acme Co"
                  autoComplete="off"
                  autoCapitalize="none"
                  autoCorrect="off"
                  spellCheck="false"
                  {...field}
                />
              </FormControl>

              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="countryCode"
          render={({ field }) => (
            <FormItem className="mt-4 w-full">
              <FormLabel className="text-xs text-[#666] font-normal">
                Country
              </FormLabel>
              <FormControl className="w-full">
                <CountrySelector
                  defaultValue={field.value ?? ""}
                  onSelect={(code, name) => {
                    field.onChange(name);
                    form.setValue("countryCode", code);
                  }}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="baseCurrency"
          render={({ field }) => (
            <FormItem className="mt-4 border-b border-border pb-4">
              <FormLabel className="text-xs text-[#666] font-normal">
                Base currency
              </FormLabel>
              <FormControl>
                <SelectCurrency currencies={uniqueCurrencies} {...field} />
              </FormControl>

              <FormDescription>
                If you have multiple accounts in different currencies, this will
                be the default currency for your company. You can change it
                later.
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <SubmitButton
          className="mt-6 w-full"
          type="submit"
          isSubmitting={isFormLocked}
        >
          Create
        </SubmitButton>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/forms/customer-form.tsx">
"use client";

import { useCustomerParams } from "@/hooks/use-customer-params";
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { useZodForm } from "@/hooks/use-zod-form";
import { useTRPC } from "@/trpc/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { Button } from "@midday/ui/button";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { Label } from "@midday/ui/label";
import { SubmitButton } from "@midday/ui/submit-button";
import { Textarea } from "@midday/ui/textarea";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { z } from "zod";
import { CountrySelector } from "../country-selector";
import {
  type AddressDetails,
  SearchAddressInput,
} from "../search-address-input";
import { SelectTags } from "../select-tags";
import { VatNumberInput } from "../vat-number-input";

const formSchema = z.object({
  id: z.string().uuid().optional(),
  name: z.string().min(2, {
    message: "Name must be at least 2 characters.",
  }),
  email: z.string().email({
    message: "Email is not valid.",
  }),
  billingEmail: z
    .string()
    .email({
      message: "Email is not valid.",
    })
    .nullable()
    .optional(),
  phone: z.string().optional(),
  website: z
    .string()

    .optional()
    .transform((url) => url?.replace(/^https?:\/\//, "")),
  contact: z.string().optional(),
  addressLine1: z.string().optional(),
  addressLine2: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  country: z.string().optional(),
  countryCode: z.string().optional(),
  zip: z.string().optional(),
  vatNumber: z.string().optional(),
  note: z.string().optional(),
  tags: z
    .array(
      z.object({
        id: z.string().uuid(),
        value: z.string(),
      }),
    )
    .optional(),
});

const excludedDomains = [
  "gmail.com",
  "yahoo.com",
  "hotmail.com",
  "outlook.com",
  "google.com",
  "aol.com",
  "msn.com",
  "icloud.com",
  "me.com",
  "mac.com",
  "live.com",
  "hotmail.co.uk",
  "hotmail.com.au",
  "hotmail.com.br",
];

type Props = {
  data?: RouterOutputs["customers"]["getById"];
};

export function CustomerForm({ data }: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const isEdit = !!data;

  const { setParams: setCustomerParams, name } = useCustomerParams();
  const { setParams: setInvoiceParams, type } = useInvoiceParams();
  const fromInvoice = type === "create" || type === "edit";

  const upsertCustomerMutation = useMutation(
    trpc.customers.upsert.mutationOptions({
      onSuccess: (data) => {
        queryClient.invalidateQueries({
          queryKey: trpc.customers.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.customers.get.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.customers.getById.queryKey(),
        });

        // Invalidate global search
        queryClient.invalidateQueries({
          queryKey: trpc.search.global.queryKey(),
        });

        // Close the customer form
        setCustomerParams(null);

        // If the customer is created from an invoice, set the customer as the selected customer
        if (data && fromInvoice) {
          setInvoiceParams({ selectedCustomerId: data.id });
        }
      },
    }),
  );

  const form = useZodForm(formSchema, {
    defaultValues: {
      id: data?.id,
      name: name ?? data?.name ?? undefined,
      email: data?.email ?? undefined,
      billingEmail: data?.billingEmail ?? null,
      website: data?.website ?? undefined,
      addressLine1: data?.addressLine1 ?? undefined,
      addressLine2: data?.addressLine2 ?? undefined,
      city: data?.city ?? undefined,
      state: data?.state ?? undefined,
      country: data?.country ?? undefined,
      countryCode: data?.countryCode ?? undefined,
      zip: data?.zip ?? undefined,
      phone: data?.phone ?? undefined,
      contact: data?.contact ?? undefined,
      note: data?.note ?? undefined,
      vatNumber: data?.vatNumber ?? undefined,
      tags:
        data?.tags?.map((tag) => ({
          id: tag?.id ?? "",
          value: tag?.name ?? "",
        })) ?? undefined,
    },
  });

  const onSelectAddress = (address: AddressDetails) => {
    form.setValue("addressLine1", address.address_line_1);
    form.setValue("city", address.city);
    form.setValue("state", address.state);
    form.setValue("country", address.country);
    form.setValue("countryCode", address.country_code);
    form.setValue("zip", address.zip);
  };

  const handleEmailBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    const email = e.target.value.trim();
    const domain = email.split("@").at(1);
    if (domain && !excludedDomains.includes(domain)) {
      const currentWebsite = form.getValues("website");
      if (!currentWebsite) {
        form.setValue("website", domain, { shouldValidate: true });
      }
    }
  };

  const handleSubmit = (data: z.infer<typeof formSchema>) => {
    const formattedData = {
      ...data,
      id: data.id || undefined,
      addressLine1: data.addressLine1 || null,
      addressLine2: data.addressLine2 || null,
      billingEmail: data.billingEmail || null,
      city: data.city || null,
      state: data.state || null,
      country: data.country || null,
      contact: data.contact || null,
      note: data.note || null,
      website: data.website || null,
      phone: data.phone || null,
      zip: data.zip || null,
      vatNumber: data.vatNumber || null,
      tags: data.tags?.length
        ? data.tags.map((tag) => ({
            id: tag.id,
            name: tag.value,
          }))
        : undefined,
      countryCode: data.countryCode || null,
    };

    upsertCustomerMutation.mutate(formattedData);
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleSubmit)}>
        <div className="h-[calc(100vh-180px)] scrollbar-hide overflow-auto">
          <div>
            <Accordion
              type="multiple"
              defaultValue={["general"]}
              className="space-y-6"
            >
              <AccordionItem value="general">
                <AccordionTrigger>General</AccordionTrigger>
                <AccordionContent>
                  <div className="space-y-4">
                    <FormField
                      control={form.control}
                      name="name"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-xs text-[#878787] font-normal">
                            Name
                          </FormLabel>
                          <FormControl>
                            <Input
                              {...field}
                              value={field.value ?? ""}
                              autoFocus
                              placeholder="Acme Inc"
                              autoComplete="off"
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="email"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-xs text-[#878787] font-normal">
                            Email
                          </FormLabel>
                          <FormControl>
                            <Input
                              {...field}
                              value={field.value ?? ""}
                              placeholder="acme@example.com"
                              type="email"
                              autoComplete="off"
                              onBlur={handleEmailBlur}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="billingEmail"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-xs text-[#878787] font-normal">
                            Billing Email
                          </FormLabel>
                          <FormControl>
                            <Input
                              {...field}
                              value={field.value ?? ""}
                              onChange={(e) => {
                                field.onChange(
                                  e.target.value.trim().length > 0
                                    ? e.target.value.trim()
                                    : null,
                                );
                              }}
                              placeholder="finance@example.com"
                              type="email"
                              autoComplete="off"
                            />
                          </FormControl>
                          <FormDescription>
                            This is an additional email that will be used to
                            send invoices to.
                          </FormDescription>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="phone"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-xs text-[#878787] font-normal">
                            Phone
                          </FormLabel>
                          <FormControl>
                            <Input
                              {...field}
                              value={field.value ?? ""}
                              placeholder="+1 (555) 123-4567"
                              type="tel"
                              autoComplete="off"
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="website"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-xs text-[#878787] font-normal">
                            Website
                          </FormLabel>
                          <FormControl>
                            <Input
                              {...field}
                              value={field.value ?? ""}
                              placeholder="acme.com"
                              autoComplete="off"
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="contact"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-xs text-[#878787] font-normal">
                            Contact person
                          </FormLabel>
                          <FormControl>
                            <Input
                              {...field}
                              value={field.value ?? ""}
                              placeholder="John Doe"
                              autoComplete="off"
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>
                </AccordionContent>
              </AccordionItem>

              <AccordionItem value="details">
                <AccordionTrigger>Details</AccordionTrigger>

                <AccordionContent>
                  <div className="space-y-4">
                    <SearchAddressInput
                      onSelect={onSelectAddress}
                      placeholder="Search for an address"
                    />

                    <FormField
                      control={form.control}
                      name="addressLine1"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-xs text-[#878787] font-normal">
                            Address Line 1
                          </FormLabel>
                          <FormControl>
                            <Input
                              {...field}
                              value={field.value ?? ""}
                              placeholder="123 Main St"
                              autoComplete="off"
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="addressLine2"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-xs text-[#878787] font-normal">
                            Address Line 2
                          </FormLabel>
                          <FormControl>
                            <Input
                              {...field}
                              value={field.value ?? ""}
                              placeholder="Suite 100"
                              autoComplete="off"
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <div className="grid grid-cols-2 gap-4">
                      <FormField
                        control={form.control}
                        name="country"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel className="text-xs text-[#878787] font-normal">
                              Country
                            </FormLabel>
                            <FormControl>
                              <CountrySelector
                                defaultValue={field.value ?? ""}
                                onSelect={(code, name) => {
                                  field.onChange(name);
                                  form.setValue("countryCode", code);
                                }}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={form.control}
                        name="city"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel className="text-xs text-[#878787] font-normal">
                              City
                            </FormLabel>
                            <FormControl>
                              <Input
                                {...field}
                                value={field.value ?? ""}
                                placeholder="New York"
                                autoComplete="off"
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>

                    <div className="grid grid-cols-2 gap-4">
                      <FormField
                        control={form.control}
                        name="state"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel className="text-xs text-[#878787] font-normal">
                              State / Province
                            </FormLabel>
                            <FormControl>
                              <Input
                                {...field}
                                value={field.value ?? ""}
                                placeholder="NY"
                                autoComplete="off"
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={form.control}
                        name="zip"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel className="text-xs text-[#878787] font-normal">
                              ZIP Code / Postal Code
                            </FormLabel>
                            <FormControl>
                              <Input
                                {...field}
                                value={field.value ?? ""}
                                placeholder="10001"
                                autoComplete="off"
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>

                    <div className="mt-6">
                      <Label
                        htmlFor="tags"
                        className="mb-2 text-xs text-[#878787] font-normal block"
                      >
                        Expense Tags
                      </Label>

                      <SelectTags
                        tags={(form.getValues("tags") ?? []).map((tag) => ({
                          id: tag.id,
                          value: tag.value,
                          label: tag.value,
                        }))}
                        onRemove={(tag) => {
                          form.setValue(
                            "tags",
                            form
                              .getValues("tags")
                              ?.filter((t) => t.id !== tag.id),
                            {
                              shouldDirty: true,
                              shouldValidate: true,
                            },
                          );
                        }}
                        onSelect={(tag) => {
                          form.setValue(
                            "tags",
                            [
                              ...(form.getValues("tags") ?? []),
                              {
                                value: tag.value ?? "",
                                id: tag.id ?? "",
                              },
                            ],
                            {
                              shouldDirty: true,
                              shouldValidate: true,
                            },
                          );
                        }}
                      />

                      <FormDescription className="mt-2">
                        Tags help categorize and track customer expenses.
                      </FormDescription>
                    </div>

                    <div>
                      <FormField
                        control={form.control}
                        name="vatNumber"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel className="text-xs text-[#878787] font-normal">
                              Tax ID / VAT Number
                            </FormLabel>
                            <FormControl>
                              <VatNumberInput
                                {...field}
                                value={field.value ?? ""}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>

                    <FormField
                      control={form.control}
                      name="note"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-xs text-[#878787] font-normal">
                            Note
                          </FormLabel>
                          <FormControl>
                            <Textarea
                              {...field}
                              value={field.value ?? ""}
                              className="flex min-h-[80px] resize-none"
                              placeholder="Additional information..."
                              autoComplete="off"
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>
                </AccordionContent>
              </AccordionItem>
            </Accordion>
          </div>
        </div>

        <div className="absolute bottom-0 left-0 right-0 p-4">
          <div className="flex justify-end mt-auto space-x-4">
            <Button
              variant="outline"
              onClick={() => setCustomerParams(null)}
              type="button"
            >
              Cancel
            </Button>

            <SubmitButton
              isSubmitting={upsertCustomerMutation.isPending}
              disabled={
                upsertCustomerMutation.isPending || !form.formState.isDirty
              }
            >
              {isEdit ? "Update" : "Create"}
            </SubmitButton>
          </div>
        </div>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/forms/invite-form.tsx">
"use client";

import { useZodForm } from "@/hooks/use-zod-form";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import { Form, FormControl, FormField, FormItem } from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";
import { SubmitButton } from "@midday/ui/submit-button";
import { useToast } from "@midday/ui/use-toast";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import Link from "next/link";
import { useFieldArray } from "react-hook-form";
import { z } from "zod";

const formSchema = z.object({
  invites: z.array(
    z.object({
      email: z.string().email(),
      role: z.enum(["owner", "member"]),
    }),
  ),
});

type InviteFormProps = {
  onSuccess?: () => void;
  skippable?: boolean;
};

export function InviteForm({ onSuccess, skippable = true }: InviteFormProps) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { toast } = useToast();

  const inviteMutation = useMutation(
    trpc.team.invite.mutationOptions({
      onSuccess: (data) => {
        queryClient.invalidateQueries({
          queryKey: trpc.team.teamInvites.queryKey(),
        });

        // Show appropriate feedback based on results
        if (data.sent > 0 && data.skipped === 0) {
          toast({
            title: "Invites sent",
            description: `${data.sent} invite${data.sent > 1 ? "s" : ""} sent successfully`,
            variant: "success",
          });
        } else if (data.sent > 0 && data.skipped > 0) {
          toast({
            title: "Invites partially sent",
            description: `${data.sent} invite${data.sent > 1 ? "s" : ""} sent, ${data.skipped} skipped (already members or invited)`,
          });
        } else if (data.sent === 0 && data.skipped > 0) {
          toast({
            title: "No invites sent",
            description: `All ${data.skipped} invite${data.skipped > 1 ? "s" : ""} were skipped (already members or invited)`,
          });
        }

        onSuccess?.();
      },
    }),
  );

  const form = useZodForm(formSchema, {
    defaultValues: {
      invites: [
        {
          email: "",
          role: "member",
        },
      ],
    },
  });

  const onSubmit = form.handleSubmit((data) => {
    inviteMutation.mutate(data.invites.filter((invite) => invite.email !== ""));
  });

  const { fields, append } = useFieldArray({
    name: "invites",
    control: form.control,
  });

  return (
    <Form {...form}>
      <form onSubmit={onSubmit}>
        {fields.map((field, index) => (
          <div
            className="flex items-center justify-between mt-3 space-x-4"
            key={index.toString()}
          >
            <FormField
              control={form.control}
              key={field.id}
              name={`invites.${index}.email`}
              render={({ field }) => (
                <FormItem className="flex-1">
                  <FormControl>
                    <Input
                      placeholder="jane@example.com"
                      type="email"
                      autoComplete="off"
                      autoCapitalize="none"
                      autoCorrect="off"
                      spellCheck="false"
                      {...field}
                    />
                  </FormControl>
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name={`invites.${index}.role`}
              render={({ field }) => (
                <FormItem>
                  <Select
                    onValueChange={field.onChange}
                    defaultValue={field.value}
                  >
                    <FormControl>
                      <SelectTrigger className="min-w-[120px]">
                        <SelectValue placeholder="Select role" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="owner">Owner</SelectItem>
                      <SelectItem value="member">Member</SelectItem>
                    </SelectContent>
                  </Select>
                </FormItem>
              )}
            />
          </div>
        ))}

        <Button
          variant="outline"
          type="button"
          className="mt-4 border-none bg-[#F2F1EF] text-[11px] dark:bg-[#1D1D1D]"
          onClick={() => append({ email: "", role: "member" })}
        >
          Add more
        </Button>

        <div className="border-t-[1px] pt-4 mt-8 items-center justify-between">
          <div>
            {Object.values(form.formState.errors).length > 0 && (
              <span className="text-sm text-destructive">
                Please complete the fields above.
              </span>
            )}
          </div>

          <div className="flex items-center justify-between">
            {skippable ? (
              <Link href="/">
                <Button
                  variant="ghost"
                  className="p-0 hover:bg-transparent font-normal"
                >
                  Skip this step
                </Button>
              </Link>
            ) : (
              <div />
            )}

            <SubmitButton
              type="submit"
              isSubmitting={inviteMutation.isPending}
              disabled={inviteMutation.isPending}
            >
              Send invites
            </SubmitButton>
          </div>
        </div>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/forms/oauth-application-form.tsx">
"use client";

import { useOAuthApplicationParams } from "@/hooks/use-oauth-application-params";
import { useUpload } from "@/hooks/use-upload";
import { useUserQuery } from "@/hooks/use-user";
import { useZodForm } from "@/hooks/use-zod-form";
import { useOAuthSecretModalStore } from "@/store/oauth-secret-modal";
import { useTRPC } from "@/trpc/client";
import { RESOURCES } from "@/utils/scopes";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import {
  SCOPES,
  type Scope,
  type ScopePreset,
  scopePresets,
  scopesToName,
} from "@api/utils/scopes";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { Switch } from "@midday/ui/switch";
import { Tabs, TabsList, TabsTrigger } from "@midday/ui/tabs";
import { Textarea } from "@midday/ui/textarea";
import { useToast } from "@midday/ui/use-toast";
import { stripSpecialCharacters } from "@midday/utils";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { nanoid } from "nanoid";
import { useEffect, useState } from "react";
import { useDropzone } from "react-dropzone";
import { useFieldArray } from "react-hook-form";
import { z } from "zod";
import { LogoUpload } from "../logo-upload";
import { ScopeSelector } from "../scope-selector";

const formSchema = z.object({
  id: z.string().uuid().optional(),
  name: z.string().min(1, {
    message: "Name must be at least 1 character.",
  }),
  description: z.string().optional(),
  overview: z.string().optional(),
  developerName: z.string().optional(),
  logoUrl: z
    .string()
    .transform((val) => (val === "" ? undefined : val))
    .pipe(z.string().url().optional()),
  website: z
    .string()
    .transform((val) => (val === "" ? undefined : val))
    .pipe(z.string().url().optional()),
  installUrl: z
    .string()
    .transform((val) => (val === "" ? undefined : val))
    .pipe(z.string().url().optional()),
  screenshots: z.array(z.string()).max(4).default([]),
  redirectUris: z
    .array(
      z.object({
        url: z
          .string()
          .url()
          .refine(
            (url) => {
              try {
                const urlObj = new URL(url);
                // Allow localhost with HTTP, all others must use HTTPS
                if (
                  urlObj.hostname === "localhost" ||
                  urlObj.hostname === "127.0.0.1"
                ) {
                  return true;
                }
                return urlObj.protocol === "https:";
              } catch {
                return false;
              }
            },
            {
              message: "All URLs must use HTTPS, except for localhost.",
            },
          ),
      }),
    )
    .min(1, {
      message: "At least one redirect URI is required.",
    }),
  scopes: z
    .array(z.enum(SCOPES))
    .min(1, {
      message: "At least one scope must be selected.",
    })
    .default(["apis.all"]),
  isPublic: z.boolean().default(false),
  active: z.boolean().default(true),
});

type Props = {
  data?: RouterOutputs["oauthApplications"]["get"];
};

export function OAuthApplicationForm({ data }: Props) {
  const { setParams } = useOAuthApplicationParams();
  const { setSecret } = useOAuthSecretModalStore();
  const [preset, setPreset] = useState<ScopePreset>(() =>
    data?.scopes
      ? (scopesToName(data.scopes).preset as ScopePreset)
      : "all_access",
  );
  const { toast } = useToast();
  const { uploadFile } = useUpload();
  const { data: user } = useUserQuery();
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const form = useZodForm(formSchema, {
    defaultValues: {
      id: data?.id,
      name: data?.name || "",
      description: data?.description || "",
      overview: data?.overview || "",
      developerName: data?.developerName || "",
      logoUrl: data?.logoUrl || "",
      website: data?.website || "",
      installUrl: data?.installUrl || "",
      screenshots: data?.screenshots || [],
      redirectUris: data?.redirectUris?.map((uri) => ({ url: uri })) || [
        { url: "" },
      ],
      scopes: (data?.scopes as Scope[]) || ["apis.all"],
      isPublic: data?.isPublic || false,
      active: data?.active ?? true,
    },
  });

  const { fields, append, remove } = useFieldArray({
    control: form.control,
    name: "redirectUris",
  });

  // Effect to reset form and ensure proper initialization when editing existing OAuth application
  useEffect(() => {
    if (data) {
      form.reset({
        id: data.id,
        name: data.name || "",
        description: data.description || "",
        overview: data.overview || "",
        developerName: data.developerName || "",
        logoUrl: data.logoUrl || "",
        website: data.website || "",
        installUrl: data.installUrl || "",
        screenshots: data.screenshots || [],
        redirectUris: data.redirectUris?.map((uri) => ({ url: uri })) || [
          { url: "" },
        ],
        scopes: (data.scopes as Scope[]) || ["apis.all"],
        isPublic: data.isPublic || false,
        active: data.active ?? true,
      });

      // Update preset state based on the scopes
      const detectedPreset = scopesToName(data.scopes).preset as ScopePreset;
      setPreset(detectedPreset);

      // If it's restricted, make sure the form has the correct scopes with dirty flag
      if (detectedPreset === "restricted") {
        form.setValue("scopes", data.scopes as Scope[], { shouldDirty: true });
      }
    }
  }, [data, form]);

  const createMutation = useMutation(
    trpc.oauthApplications.create.mutationOptions({
      onSuccess: (result) => {
        queryClient.invalidateQueries({
          queryKey: trpc.oauthApplications.list.queryKey(),
        });

        // Also invalidate the individual get query for consistency
        queryClient.invalidateQueries({
          queryKey: trpc.oauthApplications.get.queryKey(),
        });

        // Close the sheet first
        setParams(null);
        // Then open the modal with the secret
        if (result.clientSecret && result.name) {
          setSecret(result.clientSecret, result.name);
        }
      },
    }),
  );

  const updateMutation = useMutation(
    trpc.oauthApplications.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.oauthApplications.list.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.oauthApplications.get.queryKey(),
        });

        setParams(null);
      },
    }),
  );

  const handleSubmit = (values: z.infer<typeof formSchema>) => {
    // Convert redirect URIs from object array to string array for API
    const formattedValues = {
      ...values,
      redirectUris: values.redirectUris
        .map((uri) => uri.url)
        .filter((url) => url.trim() !== ""),
    };

    if (data?.id) {
      updateMutation.mutate({
        id: data.id,
        ...formattedValues,
      });
    } else {
      createMutation.mutate(formattedValues);
    }
  };

  const handleResourceScopeChange = (resourceKey: string, scope: string) => {
    if (preset !== "restricted") return;

    const currentScopes = form.getValues("scopes");
    const resource = RESOURCES.find((r) => r.key === resourceKey);
    if (!resource) return;

    // Remove any existing scopes for this resource
    const filteredScopes = currentScopes.filter(
      (currentScope: string) =>
        !resource.scopes.some((s) => s.scope === currentScope),
    );

    // Add the new scope if it's not empty
    const newScopes = scope
      ? [...filteredScopes, scope as Scope]
      : filteredScopes;

    form.setValue("scopes", newScopes, { shouldDirty: true });
  };

  // Update form scopes based on preset
  const updateScopesFromPreset = (newPreset: ScopePreset) => {
    let newScopes: Scope[] = [];

    switch (newPreset) {
      case "all_access":
        newScopes = ["apis.all"];
        break;
      case "read_only":
        newScopes = ["apis.read"];
        break;
      case "restricted": {
        // Keep existing scopes when switching to restricted mode
        const currentScopes = form.getValues("scopes");
        // Get all valid scopes from RESOURCES
        const validScopes = RESOURCES.flatMap((resource) =>
          resource.scopes.map((scope) => scope.scope),
        );
        // Only keep scopes that are defined in RESOURCES
        newScopes = currentScopes.filter((scope: string): scope is Scope =>
          validScopes.some((validScope: string) => validScope === scope),
        );
        break;
      }
    }

    form.setValue("scopes", newScopes, { shouldDirty: true });
  };

  const handlePresetChange = (value: string) => {
    const scopePreset = value as ScopePreset;
    setPreset(scopePreset);
    updateScopesFromPreset(scopePreset);
  };

  const onScreenshotDrop = async (acceptedFiles: File[]) => {
    if (!user?.teamId) return;

    // Filter for image files only
    const imageFiles = acceptedFiles.filter((file) =>
      file.type.startsWith("image/"),
    );

    if (imageFiles.length === 0) {
      toast({
        title: "Invalid file type",
        description: "Please upload only image files",
      });
      return;
    }

    const currentScreenshots = form.getValues("screenshots");

    // Check if adding these files would exceed the limit
    if (currentScreenshots.length + imageFiles.length > 4) {
      toast({
        title: "Too many screenshots",
        description: "You can only upload up to 4 screenshots",
      });
      return;
    }

    try {
      const uploadedUrls = await Promise.all(
        imageFiles.map(async (file) => {
          const originalFilename = file.name ?? "";
          const extension = originalFilename.split(".").pop() || "";
          const filename = extension ? `${nanoid()}.${extension}` : nanoid();

          const { url } = await uploadFile({
            bucket: "apps",
            path: ["screenshots", filename],
            file,
          });

          return url;
        }),
      );

      // Add uploaded URLs to the form
      form.setValue("screenshots", [...currentScreenshots, ...uploadedUrls], {
        shouldDirty: true,
      });
    } catch (error) {
      toast({
        title: "Upload failed",
        description: "Failed to upload screenshots. Please try again.",
      });
    }
  };

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop: onScreenshotDrop,
    onDropRejected: (fileRejections) => {
      for (const rejection of fileRejections) {
        if (rejection.errors.find(({ code }) => code === "file-too-large")) {
          toast({
            title: "File too large",
            description: "Screenshots must be smaller than 3MB",
          });
        }
        if (rejection.errors.find(({ code }) => code === "file-invalid-type")) {
          toast({
            title: "Invalid file type",
            description: "Please upload only image files",
          });
        }
      }
    },
    maxSize: 3000000, // 3MB
    accept: {
      "image/*": [
        ".jpg",
        ".jpeg",
        ".png",
        ".gif",
        ".webp",
        ".heic",
        ".heif",
        ".avif",
        ".tiff",
        ".bmp",
      ],
    },
  });

  const removeScreenshot = (index: number) => {
    const currentScreenshots = form.getValues("screenshots");
    const newScreenshots = currentScreenshots.filter((_, i) => i !== index);
    form.setValue("screenshots", newScreenshots, { shouldDirty: true });
  };

  const isPending = createMutation.isPending || updateMutation.isPending;

  // Helper function to check if an accordion section has errors
  const hasErrors = (fields: string[]) => {
    return fields.some((field) => {
      const fieldError =
        form.formState.errors[field as keyof typeof form.formState.errors];
      return fieldError !== undefined;
    });
  };

  const generalErrors = hasErrors([
    "name",
    "description",
    "overview",
    "developerName",
    "logoUrl",
    "website",
    "installUrl",
  ]);
  const redirectErrors = hasErrors(["redirectUris"]);
  const permissionErrors = hasErrors(["scopes"]);
  const screenshotErrors = hasErrors(["screenshots"]);
  const settingsErrors = hasErrors(["isPublic", "active"]);

  return (
    <Form {...form}>
      <form
        onSubmit={form.handleSubmit(handleSubmit)}
        className="flex flex-col h-full"
      >
        <div className="flex-1 space-y-6 overflow-auto">
          <Accordion type="multiple" defaultValue={["general", "redirects"]}>
            <AccordionItem value="general">
              <AccordionTrigger
                className={cn(generalErrors && "text-destructive")}
              >
                General
              </AccordionTrigger>
              <AccordionContent>
                <div className="space-y-4 flex flex-col">
                  <div className="flex-shrink-0">
                    <FormField
                      control={form.control}
                      name="logoUrl"
                      render={({ field }) => (
                        <FormItem>
                          <FormControl>
                            <LogoUpload
                              logoUrl={field.value}
                              onUpload={(url) => field.onChange(url)}
                              size={80}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>

                  <FormField
                    control={form.control}
                    name="name"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Name</FormLabel>
                        <FormControl>
                          <Input
                            {...field}
                            placeholder="My Awesome App"
                            autoFocus
                          />
                        </FormControl>
                        <FormDescription>
                          Application name will be displayed in the OAuth
                          consent screen
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="description"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Description</FormLabel>
                        <FormControl>
                          <Textarea
                            {...field}
                            placeholder="A brief description of your application"
                            rows={3}
                          />
                        </FormControl>
                        <FormDescription>
                          Description of your application
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="overview"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Overview</FormLabel>
                        <FormControl>
                          <Textarea
                            {...field}
                            placeholder="Detailed overview of your application"
                            rows={5}
                          />
                        </FormControl>
                        <FormDescription>
                          Detailed overview of your application
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="developerName"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Developer Name</FormLabel>
                        <FormControl>
                          <Input {...field} placeholder="Acme Corp" />
                        </FormControl>
                        <FormDescription>
                          The person or company developing this application
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <div className="flex gap-6">
                    <div className="flex-1 space-y-4">
                      <FormField
                        control={form.control}
                        name="website"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Website</FormLabel>
                            <FormControl>
                              <Input
                                {...field}
                                value={field.value || ""}
                                placeholder="https://example.com"
                                type="url"
                              />
                            </FormControl>
                            <FormDescription>
                              URL to the developer's website or documentation
                            </FormDescription>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>

                    <div className="flex-1 space-y-4">
                      <FormField
                        control={form.control}
                        name="installUrl"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Install URL</FormLabel>
                            <FormControl>
                              <Input
                                {...field}
                                value={field.value || ""}
                                placeholder="https://example.com/install"
                                type="url"
                              />
                            </FormControl>
                            <FormDescription>
                              An optional URL for installing the application
                            </FormDescription>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>
                  </div>
                </div>
              </AccordionContent>
            </AccordionItem>

            <AccordionItem value="redirects">
              <AccordionTrigger
                className={cn(redirectErrors && "text-destructive")}
              >
                Redirect URIs
              </AccordionTrigger>
              <AccordionContent className="space-y-4">
                <FormDescription>
                  All OAuth redirect URLs, All URLs must use HTTPS, except for
                  localhost.
                </FormDescription>

                <div className="space-y-3 mt-2">
                  {fields.map((field, index) => (
                    <div key={field.id} className="flex gap-2">
                      <FormField
                        control={form.control}
                        name={`redirectUris.${index}.url`}
                        render={({ field }) => (
                          <FormItem className="flex-1">
                            <FormControl>
                              <Input
                                {...field}
                                placeholder="https://your-app.com/callback"
                                autoComplete="off"
                                autoCapitalize="none"
                                autoCorrect="off"
                                spellCheck="false"
                              />
                            </FormControl>
                          </FormItem>
                        )}
                      />
                      {fields.length > 1 && (
                        <Button
                          type="button"
                          variant="ghost"
                          size="sm"
                          onClick={() => remove(index)}
                          className="text-destructive hover:text-destructive"
                        >
                          Remove
                        </Button>
                      )}
                    </div>
                  ))}
                </div>

                <Button
                  type="button"
                  variant="outline"
                  onClick={() => append({ url: "" })}
                  className="border-none bg-[#F2F1EF] text-[11px] dark:bg-[#1D1D1D] mt-2"
                >
                  Add more
                </Button>

                {form.formState.errors.redirectUris && (
                  <p className="text-sm font-medium text-destructive">
                    {form.formState.errors.redirectUris.message}
                  </p>
                )}
              </AccordionContent>
            </AccordionItem>

            <AccordionItem value="permissions">
              <AccordionTrigger
                className={cn(permissionErrors && "text-destructive")}
              >
                Permissions
              </AccordionTrigger>
              <AccordionContent>
                <Tabs
                  value={preset}
                  className="w-full"
                  onValueChange={handlePresetChange}
                >
                  <TabsList className="w-full flex">
                    {scopePresets.map((scope) => (
                      <TabsTrigger
                        value={scope.value}
                        className="flex-1"
                        key={scope.value}
                      >
                        {scope.label}
                      </TabsTrigger>
                    ))}
                  </TabsList>
                </Tabs>

                <p className="text-sm text-[#878787] mt-4">
                  This OAuth application will have{" "}
                  <span className="font-semibold">
                    {
                      scopePresets.find((scope) => scope.value === preset)
                        ?.description
                    }
                  </span>
                  .
                </p>

                <div className="mt-4">
                  {preset === "restricted" && (
                    <ScopeSelector
                      selectedScopes={form.watch("scopes")}
                      onResourceScopeChange={handleResourceScopeChange}
                      description="Select which scopes this OAuth application can request access to."
                      height="max-h-full"
                      errorMessage={form.formState.errors.scopes?.message}
                    />
                  )}
                </div>
              </AccordionContent>
            </AccordionItem>

            <AccordionItem value="screenshots">
              <AccordionTrigger
                className={cn(screenshotErrors && "text-destructive")}
              >
                Screenshots
              </AccordionTrigger>
              <AccordionContent>
                <span className="text-[0.8rem] text-muted-foreground">
                  You can upload up to 4 screenshots that will be displayed on
                  the apps and integrations page.
                </span>
                <div className="space-y-4 mt-3">
                  <div
                    className={cn(
                      "w-full h-[120px] border-dotted border-2 border-border text-center flex flex-col justify-center space-y-1 transition-colors text-[#606060]",
                      isDragActive && "bg-secondary text-primary",
                    )}
                    {...getRootProps()}
                  >
                    <input {...getInputProps()} />
                    {isDragActive ? (
                      <div>
                        <p className="text-xs">Drop your screenshots here</p>
                      </div>
                    ) : (
                      <div>
                        <p className="text-xs">
                          Drop your files here, or{" "}
                          <span className="underline underline-offset-1">
                            click to browse.
                          </span>
                        </p>
                        <p className="text-xs text-muted-foreground">
                          3MB limit per file.
                        </p>
                      </div>
                    )}
                  </div>

                  {/* Display uploaded screenshots */}
                  {form.watch("screenshots").length > 0 && (
                    <div className="space-y-2">
                      <div className="grid grid-cols-2 gap-4">
                        {form.watch("screenshots").map((screenshot, index) => (
                          <div
                            key={`screenshot-${index}-${screenshot}`}
                            className="relative group"
                          >
                            <div className="aspect-video bg-muted overflow-hidden">
                              <img
                                src={screenshot}
                                alt={`Screenshot ${index + 1}`}
                                className="w-full h-full object-cover"
                              />
                            </div>
                            <Button
                              type="button"
                              variant="destructive"
                              size="sm"
                              className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity"
                              onClick={() => removeScreenshot(index)}
                            >
                              Remove
                            </Button>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {form.formState.errors.screenshots && (
                    <p className="text-sm font-medium text-destructive">
                      {form.formState.errors.screenshots.message}
                    </p>
                  )}
                </div>
              </AccordionContent>
            </AccordionItem>

            <AccordionItem value="settings">
              <AccordionTrigger
                className={cn(settingsErrors && "text-destructive")}
              >
                Settings
              </AccordionTrigger>
              <AccordionContent className="space-y-6">
                <div className="space-y-4">
                  <FormField
                    control={form.control}
                    name="isPublic"
                    render={({ field }) => (
                      <FormItem className="flex items-center justify-between space-x-2">
                        <div className="space-y-1">
                          <FormLabel className="!mt-0">Allow PKCE</FormLabel>
                          <FormDescription>
                            We strongly recommend using the PKCE flow for
                            increased security. Make sure your application
                            supports it.
                          </FormDescription>
                        </div>
                        <FormControl>
                          <Switch
                            checked={field.value}
                            onCheckedChange={field.onChange}
                          />
                        </FormControl>
                      </FormItem>
                    )}
                  />

                  {data?.id && (
                    <FormField
                      control={form.control}
                      name="active"
                      render={({ field }) => (
                        <FormItem className="flex items-center justify-between space-x-2">
                          <div className="space-y-1">
                            <FormLabel className="!mt-0">Active</FormLabel>
                            <FormDescription>
                              Inactive applications cannot be used for
                              authorization.
                            </FormDescription>
                          </div>
                          <FormControl>
                            <Switch
                              checked={field.value}
                              onCheckedChange={field.onChange}
                            />
                          </FormControl>
                        </FormItem>
                      )}
                    />
                  )}
                </div>
              </AccordionContent>
            </AccordionItem>
          </Accordion>
        </div>

        <div className="sticky bottom-0 bg-[#FAFAF9] dark:bg-[#121212] border-t pt-3 mt-4">
          <SubmitButton
            type="submit"
            className="w-full"
            isSubmitting={isPending}
            disabled={!form.formState.isDirty}
          >
            {data?.id ? "Update" : "Create"}
          </SubmitButton>
        </div>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/forms/tracker-entries-form.tsx">
"use client";

import { useLatestProjectId } from "@/hooks/use-latest-project-id";
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { useUserQuery } from "@/hooks/use-user";
import { NEW_EVENT_ID, parseTimeWithMidnightCrossing } from "@/utils/tracker";
import { TZDate } from "@date-fns/tz";
import { zodResolver } from "@hookform/resolvers/zod";
import { Form, FormControl, FormField, FormItem } from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { TimeRangeInput } from "@midday/ui/time-range-input";
import { startOfDay } from "date-fns";
import { useEffect } from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { AssignUser } from "../assign-user";
import { TrackerSelectProject } from "../tracker-select-project";

const formSchema = z.object({
  id: z.string().optional(),
  duration: z.number().min(1),
  projectId: z.string().uuid(),
  assignedId: z.string().uuid().optional(),
  description: z.string().optional(),
  start: z.string(),
  stop: z.string(),
});

type Props = {
  eventId?: string;
  userId: string;
  teamId: string;
  onCreate: (values: z.infer<typeof formSchema>) => void;
  projectId?: string | null;
  start?: string;
  stop?: string;
  onSelectProject: (selected: { id: string; name: string }) => void;
  description?: string;
  isSaving: boolean;
  onTimeChange: (time: { start: string; end: string }) => void;
};

export function TrackerEntriesForm({
  eventId,
  userId,
  onCreate,
  projectId,
  start,
  stop,
  onSelectProject,
  description,
  isSaving,
  onTimeChange,
}: Props) {
  const { projectId: selectedProjectId } = useTrackerParams();
  const { latestProjectId } = useLatestProjectId();
  const { data: user } = useUserQuery();

  // Helper to get user timezone with fallback
  const getUserTimezone = () => user?.timezone || "UTC";

  const isUpdate = eventId && eventId !== NEW_EVENT_ID;

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      id: eventId,
      assignedId: userId,
      projectId: selectedProjectId || latestProjectId || undefined,
      start,
      stop,
      description: description ?? undefined,
    },
  });

  useEffect(() => {
    if (eventId && eventId !== NEW_EVENT_ID) {
      form.setValue("id", eventId, { shouldValidate: true });
    }

    if (eventId === NEW_EVENT_ID) {
      form.setValue("id", undefined);
    }

    if (start) {
      form.setValue("start", start);
    }
    if (stop) {
      form.setValue("stop", stop);
    }

    if (projectId) {
      form.setValue("projectId", projectId, { shouldValidate: true });
    }

    if (description) {
      form.setValue("description", description);
    }

    if (start && stop) {
      // Use timezone-aware time parsing instead of manual conversion
      const timezone = getUserTimezone();
      let baseDate: Date;

      try {
        // Get "today" in user's timezone as reference date for parsing
        const now = new Date();
        const userTzDate = new TZDate(now, timezone);
        baseDate = startOfDay(userTzDate);
      } catch (error) {
        console.warn("TZDate failed in form, using browser date:", error);
        baseDate = startOfDay(new Date());
      }

      // Use the enhanced parseTimeWithMidnightCrossing function
      const { duration } = parseTimeWithMidnightCrossing(
        start,
        stop,
        baseDate,
        timezone,
      );

      if (duration) {
        form.setValue("duration", duration, { shouldValidate: true });
      }
    }
  }, [start, stop, projectId, description, eventId]);

  return (
    <Form {...form}>
      <form
        onSubmit={form.handleSubmit(onCreate)}
        className="mb-12 mt-6 space-y-4"
      >
        <TimeRangeInput
          value={{ start: form.watch("start"), stop: form.watch("stop") }}
          onChange={(value) => {
            form.setValue("start", value.start);
            form.setValue("stop", value.stop);

            onTimeChange({
              start: value.start,
              end: value.stop,
            });
          }}
        />

        <FormField
          control={form.control}
          name="projectId"
          render={({ field }) => (
            <FormItem className="w-full">
              <FormControl>
                <TrackerSelectProject
                  onCreate={(project) => {
                    if (project) {
                      field.onChange(project.id);
                      onSelectProject(project);
                    }
                  }}
                  selectedId={field.value}
                  onSelect={(selected) => {
                    if (selected) {
                      field.onChange(selected.id);
                      onSelectProject(selected);
                    }
                  }}
                />
              </FormControl>
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="assignedId"
          render={({ field }) => (
            <FormItem className="w-full">
              <FormControl>
                <AssignUser
                  selectedId={form.watch("assignedId")}
                  onSelect={(user) => {
                    if (user?.id) {
                      field.onChange(user.id);
                    }
                  }}
                />
              </FormControl>
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <Input placeholder="Description" {...field} />
              </FormControl>
            </FormItem>
          )}
        />

        <div className="flex mt-6 justify-between">
          <SubmitButton
            className="w-full"
            disabled={isSaving || !form.formState.isValid}
            isSubmitting={isSaving}
            type="submit"
          >
            {isUpdate ? "Update" : "Add"}
          </SubmitButton>
        </div>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/forms/tracker-project-form.tsx">
"use client";

import { SearchCustomers } from "@/components/search-customers";
import { SelectTags } from "@/components/select-tags";
import { useCustomerParams } from "@/hooks/use-customer-params";
import { useLatestProjectId } from "@/hooks/use-latest-project-id";
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { useZodForm } from "@/hooks/use-zod-form";
import { useTRPC } from "@/trpc/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { uniqueCurrencies } from "@midday/location/currencies";
import { Collapsible, CollapsibleContent } from "@midday/ui/collapsible";
import { CurrencyInput } from "@midday/ui/currency-input";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { Label } from "@midday/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";
import { SubmitButton } from "@midday/ui/submit-button";
import { Switch } from "@midday/ui/switch";
import { Textarea } from "@midday/ui/textarea";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useEffect } from "react";
import { z } from "zod";

const formSchema = z.object({
  id: z.string().uuid().optional(),
  name: z.string().min(1),
  description: z.string().optional(),
  estimate: z.number().optional(),
  billable: z.boolean().optional().default(false),
  rate: z.number().min(1).optional(),
  currency: z.string().optional(),
  status: z.enum(["in_progress", "completed"]).optional(),
  customerId: z.string().uuid().nullable().optional(),
  tags: z
    .array(
      z.object({
        id: z.string().uuid(),
        value: z.string(),
      }),
    )
    .optional(),
});

type Props = {
  data?: RouterOutputs["trackerProjects"]["getById"];
  defaultCurrency: string;
};

export function TrackerProjectForm({ data, defaultCurrency }: Props) {
  const isEdit = !!data;
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { setParams: setTrackerParams } = useTrackerParams();
  const { setParams: setCustomerParams } = useCustomerParams();
  const { setLatestProjectId } = useLatestProjectId();

  const upsertTrackerProjectMutation = useMutation(
    trpc.trackerProjects.upsert.mutationOptions({
      onSuccess: (result) => {
        setLatestProjectId(result?.id ?? null);

        queryClient.invalidateQueries({
          queryKey: trpc.trackerProjects.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.trackerProjects.getById.queryKey(),
        });

        // Close the tracker project form
        setTrackerParams({ create: null });
      },
    }),
  );

  const form = useZodForm(formSchema, {
    defaultValues: {
      id: data?.id,
      name: data?.name ?? undefined,
      description: data?.description ?? undefined,
      rate: data?.rate ?? undefined,
      status: data?.status ?? "in_progress",
      billable: data?.billable ?? false,
      estimate: data?.estimate ?? 0,
      currency: data?.currency ?? defaultCurrency,
      customerId: data?.customerId ?? undefined,
      tags:
        data?.tags?.map((tag) => ({
          id: tag.id ?? "",
          value: tag.name ?? "",
        })) ?? undefined,
    },
  });

  const onSubmit = (data: z.infer<typeof formSchema>) => {
    const formattedData = {
      ...data,
      id: data.id || undefined,
      description: data.description || null,
      rate: data.rate || null,
      currency: data.currency || null,
      billable: data.billable || false,
      estimate: data.estimate || null,
      status: data.status || "in_progress",
      customerId: data.customerId || null,
      tags: data.tags?.length ? data.tags : null,
    };

    upsertTrackerProjectMutation.mutate(formattedData);
  };

  useEffect(() => {
    if (data) {
      form.reset({
        id: data?.id,
        name: data?.name ?? undefined,
        description: data?.description ?? undefined,
        rate: data?.rate ?? undefined,
        status: data?.status ?? "in_progress",
        billable: data?.billable ?? false,
        estimate: data?.estimate ?? 0,
        currency: data?.currency ?? defaultCurrency,
        customerId: data?.customerId ?? undefined,
        tags:
          data?.tags?.map((tag) => ({
            id: tag.id ?? "",
            value: tag.name ?? "",
          })) ?? undefined,
      });
    }
  }, [data]);

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input
                  {...field}
                  value={field.value ?? ""}
                  autoComplete="off"
                  placeholder="Project name"
                  autoCapitalize="none"
                  autoCorrect="off"
                  spellCheck="false"
                  autoFocus
                />
              </FormControl>
              <FormDescription>
                This is the project display name.
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="customerId"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Customer</FormLabel>
              <FormControl>
                <SearchCustomers
                  onSelect={(id) =>
                    field.onChange(id, {
                      shouldDirty: true,
                      shouldValidate: true,
                    })
                  }
                  selectedId={field.value ?? undefined}
                  onCreate={(name) => {
                    setCustomerParams({
                      name,
                      createCustomer: true,
                    });
                  }}
                  onEdit={(id) => {
                    setCustomerParams({
                      customerId: id,
                    });
                  }}
                />
              </FormControl>
              <FormDescription>
                Link a customer to enable direct invoicing.
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="mt-6">
          <Label htmlFor="tags" className="mb-2 block">
            Expense Tags
          </Label>

          <SelectTags
            tags={(form.getValues("tags") ?? []).map((tag) => ({
              id: tag.id,
              value: tag.value,
              label: tag.value,
            }))}
            onRemove={(tag) => {
              form.setValue(
                "tags",
                form.getValues("tags")?.filter((t) => t.id !== tag.id),
                {
                  shouldDirty: true,
                  shouldValidate: true,
                },
              );
            }}
            onSelect={(tag) => {
              form.setValue(
                "tags",
                [
                  ...(form.getValues("tags") ?? []),
                  {
                    value: tag.value ?? "",
                    id: tag.id ?? "",
                  },
                ],
                {
                  shouldDirty: true,
                  shouldValidate: true,
                },
              );
            }}
          />

          <FormDescription className="mt-2">
            Tags help categorize and track project expenses.
          </FormDescription>
        </div>

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Textarea className="resize-none" {...field} />
              </FormControl>
              <FormDescription>
                Add a short description about the project.
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="flex space-x-4 mt-4">
          <FormField
            control={form.control}
            name="estimate"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Time Estimate</FormLabel>
                <FormControl>
                  <Input
                    placeholder="0"
                    {...field}
                    type="number"
                    min={0}
                    onChange={(evt) => field.onChange(+evt.target.value)}
                    autoComplete="off"
                    autoCapitalize="none"
                    autoCorrect="off"
                    spellCheck="false"
                  />
                </FormControl>
                <FormDescription>
                  Set a goal for how long your project should take to complete
                  in hours.
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="status"
            render={({ field }) => (
              <FormItem className="w-full">
                <FormLabel>Status</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="in_progress">In Progress</SelectItem>
                    <SelectItem value="completed">Completed</SelectItem>
                  </SelectContent>
                </Select>

                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <Collapsible open={form.watch("billable")}>
          <FormItem className="flex justify-between items-center">
            <FormLabel>Billable</FormLabel>

            <FormField
              control={form.control}
              name="billable"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Switch
                      checked={field.value}
                      onCheckedChange={field.onChange}
                    />
                  </FormControl>
                </FormItem>
              )}
            />
          </FormItem>

          <CollapsibleContent className="space-y-2 w-full">
            <div className="flex space-x-4 mt-4">
              <FormField
                control={form.control}
                name="rate"
                render={({ field }) => (
                  <FormItem className="w-full">
                    <FormLabel>Hourly Rate</FormLabel>
                    <FormControl>
                      <CurrencyInput
                        min={0}
                        value={field.value}
                        onValueChange={(values) => {
                          field.onChange(values.floatValue);
                        }}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="currency"
                render={({ field }) => (
                  <FormItem className="w-full">
                    <FormLabel>Currency</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent className="max-h-[300px]">
                        {uniqueCurrencies.map((currency) => (
                          <SelectItem value={currency} key={currency}>
                            {currency}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>

                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>
          </CollapsibleContent>
        </Collapsible>

        <div className="fixed bottom-8 w-full sm:max-w-[455px] right-8">
          <SubmitButton
            className="w-full"
            disabled={
              upsertTrackerProjectMutation.isPending || !form.formState.isDirty
            }
            isSubmitting={upsertTrackerProjectMutation.isPending}
          >
            {isEdit ? "Update" : "Create"}
          </SubmitButton>
        </div>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/forms/transaction-create-form.tsx">
"use client";

import { AssignUser } from "@/components/assign-user";
import { SelectAccount } from "@/components/select-account";
import { SelectCategory } from "@/components/select-category";
import { SelectCurrency } from "@/components/select-currency";
import { TransactionAttachments } from "@/components/transaction-attachments";
import { useTeamQuery } from "@/hooks/use-team";
import { useTransactionParams } from "@/hooks/use-transaction-params";
import { useUserQuery } from "@/hooks/use-user";
import { useZodForm } from "@/hooks/use-zod-form";
import { useTRPC } from "@/trpc/client";
import { uniqueCurrencies } from "@midday/location/currencies";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { Button } from "@midday/ui/button";
import { Calendar } from "@midday/ui/calendar";
import { CurrencyInput } from "@midday/ui/currency-input";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { Label } from "@midday/ui/label";
import { Popover, PopoverContent, PopoverTrigger } from "@midday/ui/popover";
import { Select } from "@midday/ui/select";
import { SubmitButton } from "@midday/ui/submit-button";
import { Switch } from "@midday/ui/switch";
import { Textarea } from "@midday/ui/textarea";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { format } from "date-fns";
import { nanoid } from "nanoid";
import { useEffect, useState } from "react";
import { z } from "zod";

const formSchema = z.object({
  name: z.string().min(1),
  amount: z.number(),
  currency: z.string(),
  date: z.string(),
  bankAccountId: z.string(),
  assignedId: z.string().optional(),
  categorySlug: z.string().optional(),
  note: z.string().optional(),
  internal: z.boolean().optional(),
  attachments: z
    .array(
      z.object({
        path: z.array(z.string()),
        name: z.string(),
        size: z.number(),
        type: z.string(),
      }),
    )
    .optional(),
});

export function TransactionCreateForm() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { setParams } = useTransactionParams();
  const [isOpen, setIsOpen] = useState(false);
  const { data: user } = useUserQuery();
  const { data: team } = useTeamQuery();
  const { data: accounts } = useQuery(
    trpc.bankAccounts.get.queryOptions({
      enabled: true,
    }),
  );

  const { data: categories } = useQuery(
    trpc.transactionCategories.get.queryOptions(),
  );

  const createTransactionMutation = useMutation(
    trpc.transactions.create.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });

        // Invalidate global search
        queryClient.invalidateQueries({
          queryKey: trpc.search.global.queryKey(),
        });

        setParams(null);
      },
    }),
  );

  const form = useZodForm(formSchema, {
    defaultValues: {
      name: undefined,
      categorySlug: undefined,
      date: new Date().toISOString(),
      bankAccountId: accounts?.at(0)?.id,
      assignedId: user?.id,
      note: undefined,
      currency: team?.baseCurrency ?? undefined,
      attachments: undefined,
      internal: undefined,
    },
  });

  const category = form.watch("categorySlug");
  const attachments = form.watch("attachments");
  const bankAccountId = form.watch("bankAccountId");

  useEffect(() => {
    if (!bankAccountId && accounts?.length) {
      const firstAccountId = accounts.at(0)?.id;
      if (firstAccountId) {
        form.setValue("bankAccountId", firstAccountId);
      }
    }
  }, [accounts, bankAccountId]);

  return (
    <Form {...form}>
      <form
        onSubmit={form.handleSubmit(() => {
          createTransactionMutation.mutate(form.getValues());
        })}
        className="space-y-8"
      >
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Input
                  {...field}
                  autoComplete="off"
                  autoCapitalize="none"
                  autoCorrect="off"
                  spellCheck="false"
                />
              </FormControl>

              <FormMessage />
            </FormItem>
          )}
        />

        <div className="flex space-x-4 mt-4">
          <FormField
            control={form.control}
            name="amount"
            render={({ field }) => (
              <FormItem className="w-full">
                <FormLabel>Amount</FormLabel>
                <FormControl>
                  <CurrencyInput
                    value={field.value}
                    onValueChange={(values) => {
                      field.onChange(values.floatValue);

                      if (values.floatValue && values.floatValue > 0) {
                        form.setValue("categorySlug", "income");
                      }

                      if (
                        category === "income" &&
                        values.floatValue !== undefined &&
                        values.floatValue < 0
                      ) {
                        form.setValue("categorySlug", undefined);
                      }
                    }}
                  />
                </FormControl>

                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="currency"
            render={({ field }) => (
              <FormItem className="w-full">
                <FormLabel>Currency</FormLabel>

                <FormControl>
                  <SelectCurrency
                    className="w-full"
                    currencies={uniqueCurrencies}
                    onChange={field.onChange}
                    value={field.value}
                  />
                </FormControl>

                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="flex space-x-4 mt-4">
          <FormField
            control={form.control}
            name="bankAccountId"
            render={({ field }) => (
              <FormItem className="w-full">
                <FormLabel>Account</FormLabel>
                <FormControl>
                  <SelectAccount
                    onChange={(value) => {
                      field.onChange(value.id);

                      if (value.currency) {
                        form.setValue("currency", value.currency);
                      }
                    }}
                    value={field.value}
                    placeholder="Select account"
                  />
                </FormControl>

                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="date"
            render={({ field }) => (
              <FormItem className="w-full">
                <FormLabel>Date</FormLabel>
                <Popover open={isOpen} onOpenChange={setIsOpen}>
                  <FormControl>
                    <PopoverTrigger asChild>
                      <Button
                        type="button"
                        variant="outline"
                        className="w-full justify-start"
                        onClick={() => setIsOpen(true)}
                      >
                        {field.value ? (
                          format(
                            new Date(field.value),
                            user?.dateFormat ?? "PPP",
                          )
                        ) : (
                          <span>Select date</span>
                        )}
                      </Button>
                    </PopoverTrigger>
                  </FormControl>

                  <PopoverContent className="w-auto p-0" align="end">
                    <Calendar
                      mode="single"
                      selected={field.value ? new Date(field.value) : undefined}
                      onSelect={(value) => {
                        field.onChange(value?.toISOString());
                        setIsOpen(false);
                      }}
                      initialFocus
                      toDate={new Date()}
                    />
                  </PopoverContent>
                </Popover>
              </FormItem>
            )}
          />
        </div>

        <div className="flex space-x-4 mt-4">
          <FormField
            control={form.control}
            name="categorySlug"
            render={({ field }) => (
              <FormItem className="w-full">
                <FormLabel>Category</FormLabel>
                <FormControl>
                  <SelectCategory
                    onChange={(value) => {
                      field.onChange(value?.slug);
                    }}
                    hideLoading
                    selected={categories
                      ?.map((category) => {
                        if (!category) return undefined;

                        const { id, name, color, slug } = category;
                        return {
                          id,
                          name,
                          color,
                          slug: slug!,
                        };
                      })
                      .filter(
                        (category): category is NonNullable<typeof category> =>
                          category !== undefined,
                      )
                      .find((category) => category.slug === field.value)}
                  />
                </FormControl>

                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="assignedId"
            render={({ field }) => (
              <FormItem className="w-full">
                <FormLabel>Assign</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <AssignUser
                      selectedId={field.value}
                      onSelect={field.onChange}
                    />
                  </FormControl>
                </Select>

                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <Accordion type="multiple" defaultValue={["attachment"]}>
          <AccordionItem value="attachment">
            <AccordionTrigger>Attachment</AccordionTrigger>
            <AccordionContent>
              <TransactionAttachments
                // NOTE: For manual attachments, we need to generate a unique id
                id={nanoid()}
                data={attachments?.map((attachment) => ({
                  ...attachment,
                  id: nanoid(),
                  filename: attachment.name,
                  path: attachment.path.join("/"),
                }))}
                onUpload={(files) => {
                  // @ts-expect-error
                  form.setValue("attachments", files);
                }}
              />
            </AccordionContent>
          </AccordionItem>

          <div className="mt-6 mb-4">
            <Label
              htmlFor="settings"
              className="mb-2 block font-medium text-md"
            >
              Exclude from analytics
            </Label>
            <div className="flex flex-row items-center justify-between">
              <div className="space-y-0.5 pr-4">
                <p className="text-xs text-muted-foreground">
                  Exclude this transaction from analytics like profit, expense
                  and revenue. This is useful for internal transfers between
                  accounts to avoid double-counting.
                </p>
              </div>

              <FormField
                control={form.control}
                name="internal"
                render={({ field }) => (
                  <Switch
                    checked={field.value ?? false}
                    onCheckedChange={(checked) => {
                      field.onChange(checked);
                    }}
                  />
                )}
              />
            </div>
          </div>

          <AccordionItem value="note">
            <AccordionTrigger>Note</AccordionTrigger>
            <AccordionContent>
              <Textarea
                placeholder="Note"
                className="min-h-[100px] resize-none"
                onChange={(e) => {
                  form.setValue("note", e.target.value);
                }}
              />
            </AccordionContent>
          </AccordionItem>
        </Accordion>

        <div className="fixed bottom-8 w-full sm:max-w-[455px] right-8">
          <SubmitButton
            isSubmitting={createTransactionMutation.isPending}
            className="w-full"
          >
            Create
          </SubmitButton>
        </div>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/connect-gmail.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { Icons } from "@midday/ui/icons";
import { SubmitButton } from "@midday/ui/submit-button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useMutation } from "@tanstack/react-query";
import { useRouter } from "next/navigation";

export function ConnectGmail() {
  const trpc = useTRPC();
  const router = useRouter();

  const connectMutation = useMutation(
    trpc.inboxAccounts.connect.mutationOptions({
      onSuccess: (authUrl) => {
        if (authUrl) {
          router.push(authUrl);
        }
      },
    }),
  );

  return (
    <TooltipProvider>
      <Tooltip delayDuration={0}>
        <TooltipTrigger asChild>
          <SubmitButton
            className="px-6 py-4 w-full font-medium h-[40px]"
            variant="outline"
            onClick={() => connectMutation.mutate({ provider: "gmail" })}
            isSubmitting={connectMutation.isPending}
          >
            <div className="flex items-center space-x-2">
              <Icons.Gmail />
              <span>Connect your Gmail</span>
            </div>
          </SubmitButton>
        </TooltipTrigger>
        <TooltipContent className="max-w-[300px] text-xs" sideOffset={10}>
          <p>
            We are currently in Google's verification review process. This is a
            standard procedure for all apps requesting Gmail access. You may see
            a warning screen - this is normal. Simply click{" "}
            <strong>Advanced</strong> →{" "}
            <strong>Go to midday.ai (unsafe)</strong> to safely proceed.
          </p>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/delete-inbox-account.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@midday/ui/alert-dialog";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { Input } from "@midday/ui/input";
import { Label } from "@midday/ui/label";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { Loader2 } from "lucide-react";
import { useState } from "react";

type Props = {
  accountId: string;
};

export function DeleteInboxAccount({ accountId }: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const [value, setValue] = useState("");
  const [open, setOpen] = useState(false);

  const deleteInboxAccountMutation = useMutation(
    trpc.inboxAccounts.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.inboxAccounts.get.queryKey(),
        });

        setOpen(false);
        setValue("");
      },
    }),
  );

  return (
    <AlertDialog open={open} onOpenChange={setOpen}>
      <TooltipProvider delayDuration={70}>
        <Tooltip>
          <AlertDialogTrigger asChild>
            <TooltipTrigger asChild>
              <Button
                variant="outline"
                size="icon"
                className="rounded-full w-7 h-7 flex items-center"
                disabled={deleteInboxAccountMutation.isPending}
              >
                <Icons.Delete size={16} />
              </Button>
            </TooltipTrigger>
          </AlertDialogTrigger>

          <TooltipContent className="px-3 py-1.5 text-xs" sideOffset={10}>
            Delete
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>

      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Delete Email Connection</AlertDialogTitle>
          <AlertDialogDescription>
            You are about to delete an email connection. If you proceed you will
            no longer receive new emails.
          </AlertDialogDescription>
        </AlertDialogHeader>

        <div className="flex flex-col gap-2 mt-2">
          <Label htmlFor="confirm-delete">
            Type <span className="font-medium">DELETE</span> to confirm.
          </Label>
          <Input
            id="confirm-delete"
            value={value}
            onChange={(e) => setValue(e.target.value)}
          />
        </div>

        <AlertDialogFooter>
          <AlertDialogCancel>Cancel</AlertDialogCancel>
          <AlertDialogAction
            disabled={
              value !== "DELETE" || deleteInboxAccountMutation.isPending
            }
            onClick={() => deleteInboxAccountMutation.mutate({ id: accountId })}
          >
            {deleteInboxAccountMutation.isPending ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              "Confirm"
            )}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-actions.tsx">
"use client";

import { AnimatePresence } from "framer-motion";
import { MatchTransaction } from "./match-transaction";
import { SuggestedMatch } from "./suggested-match";

import type { RouterOutputs } from "@api/trpc/routers/_app";

type Props = {
  data: RouterOutputs["inbox"]["getById"];
};

export function InboxActions({ data }: Props) {
  return (
    <AnimatePresence>
      {data?.status === "suggested_match" && !data?.transactionId && (
        <SuggestedMatch key="suggested-match" />
      )}

      {!data?.suggestion && <MatchTransaction key="match-transaction" />}
    </AnimatePresence>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-connected-accounts-skeleton.tsx">
import { Skeleton } from "@midday/ui/skeleton";

export function InboxAccountsListSkeleton() {
  return (
    <div className="px-6 divide-y">
      {Array.from({ length: 2 }).map((_, index) => (
        <div
          key={index.toString()}
          className="flex items-center justify-between py-4"
        >
          <div className="flex items-center space-x-4">
            <Skeleton className="size-[34px] rounded-full" />
            <div className="flex flex-col space-y-2">
              <Skeleton className="h-3.5 w-[180px] rounded-none" />
              <Skeleton className="h-2.5 w-[120px] rounded-none" />
            </div>
          </div>

          <div className="flex space-x-2 items-center">
            <Skeleton className="rounded-full w-7 h-7" />
            <Skeleton className="rounded-full w-7 h-7" />
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-connected-accounts.tsx">
"use client";

import { useSyncStatus } from "@/hooks/use-sync-status";
import { useTRPC } from "@/trpc/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Avatar, AvatarFallback } from "@midday/ui/avatar";
import { Badge } from "@midday/ui/badge";
import { Button } from "@midday/ui/button";
import {
  Card,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useToast } from "@midday/ui/use-toast";
import {
  useMutation,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";
import { formatDistanceToNow } from "date-fns";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { Suspense } from "react";
import { DeleteInboxAccount } from "./delete-inbox-account";
import { InboxAccountsListSkeleton } from "./inbox-connected-accounts-skeleton";
import { SyncInboxAccount } from "./sync-inbox-account";

type InboxAccount = NonNullable<RouterOutputs["inboxAccounts"]["get"]>[number];

function InboxAccountItem({ account }: { account: InboxAccount }) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const [runId, setRunId] = useState<string | undefined>();
  const [accessToken, setAccessToken] = useState<string | undefined>();
  const [isSyncing, setSyncing] = useState(false);
  const { toast, dismiss } = useToast();
  const router = useRouter();

  const { status, setStatus, result } = useSyncStatus({ runId, accessToken });

  const syncInboxAccountMutation = useMutation(
    trpc.inboxAccounts.sync.mutationOptions({
      onMutate: () => {
        setSyncing(true);
      },
      onSuccess: (data) => {
        if (data) {
          setRunId(data.id);
          setAccessToken(data.publicAccessToken);
        }
      },
      onError: () => {
        setSyncing(false);
        setRunId(undefined);
        setStatus("FAILED");

        toast({
          duration: 3500,
          variant: "error",
          title: "Something went wrong please try again.",
        });
      },
    }),
  );

  useEffect(() => {
    if (isSyncing) {
      toast({
        title: "Syncing...",
        description:
          "We're scanning for PDF attachments and receipts, please wait.",
        duration: Number.POSITIVE_INFINITY,
        variant: "spinner",
      });
    }
  }, [isSyncing]);

  useEffect(() => {
    if (status === "COMPLETED") {
      dismiss();
      setRunId(undefined);
      setSyncing(false);

      // Show success toast with attachment count
      const attachmentCount = result?.attachmentsProcessed || 0;
      const description =
        attachmentCount > 0
          ? `Found ${attachmentCount} new ${attachmentCount === 1 ? "attachment" : "attachments"}.`
          : "No new attachments found.";

      toast({
        title: "Sync completed successfully",
        description,
        variant: "success",
        duration: 3500,
      });

      queryClient.invalidateQueries({
        queryKey: trpc.inboxAccounts.get.queryKey(),
      });

      queryClient.invalidateQueries({
        queryKey: trpc.inbox.get.queryKey(),
      });
    }
  }, [status]);

  useEffect(() => {
    if (status === "FAILED") {
      setSyncing(false);
      setRunId(undefined);

      queryClient.invalidateQueries({
        queryKey: trpc.inboxAccounts.get.queryKey(),
      });

      toast({
        duration: 3500,
        variant: "error",
        title: "Inbox sync failed, please try again.",
      });
    }
  }, [status]);

  const handleManualSync = () => {
    syncInboxAccountMutation.mutate({
      id: account.id,
      manualSync: true,
    });
  };

  const connectMutation = useMutation(
    trpc.inboxAccounts.connect.mutationOptions({
      onSuccess: (authUrl) => {
        if (authUrl) {
          router.push(authUrl);
        }
      },
    }),
  );

  const isDisconnected = account.status === "disconnected";

  return (
    <div className="flex items-center justify-between py-4">
      <div className="flex items-center space-x-4">
        <Avatar className="size-[34px]">
          <AvatarFallback className="bg-white border border-border">
            <Icons.Gmail className="size-5" />
          </AvatarFallback>
        </Avatar>
        <div className="flex flex-col">
          <div className="flex items-center space-x-2">
            <span className="text-sm font-medium">{account.email}</span>
            {isDisconnected && (
              <Tooltip delayDuration={0}>
                <TooltipTrigger asChild>
                  <Badge variant="tag-rounded" className="text-xs cursor-help">
                    Disconnected
                  </Badge>
                </TooltipTrigger>
                <TooltipContent className="max-w-[300px] text-xs">
                  <p>
                    Account access has expired. Google typically expires access
                    tokens after 6 months as part of their security practices.
                    Simply reconnect to restore functionality.
                  </p>
                </TooltipContent>
              </Tooltip>
            )}
          </div>
          <span className="text-muted-foreground text-xs">
            {isSyncing ? (
              "Syncing..."
            ) : (
              <>
                Last accessed{" "}
                {formatDistanceToNow(new Date(account.lastAccessed))} ago
              </>
            )}
          </span>
        </div>
      </div>

      <div className="flex space-x-2 items-center">
        {isDisconnected ? (
          <Button
            size="sm"
            variant="outline"
            onClick={() => connectMutation.mutate({ provider: "gmail" })}
            className="text-xs"
          >
            Reconnect
          </Button>
        ) : (
          <SyncInboxAccount
            disabled={isSyncing || syncInboxAccountMutation.isPending}
            onClick={handleManualSync}
          />
        )}
        <DeleteInboxAccount accountId={account.id} />
      </div>
    </div>
  );
}

function InboxAccountsList() {
  const trpc = useTRPC();
  const { data } = useSuspenseQuery(trpc.inboxAccounts.get.queryOptions());

  if (!data?.length) {
    return (
      <div className="px-6 py-8 text-center">
        <p className="text-muted-foreground text-sm">
          No inbox connections found.
        </p>
      </div>
    );
  }

  return (
    <div className="px-6 divide-y">
      {data.map((account) => (
        <InboxAccountItem key={account.id} account={account} />
      ))}
    </div>
  );
}

export function InboxConnectedAccounts() {
  const trpc = useTRPC();
  const router = useRouter();

  const connectMutation = useMutation(
    trpc.inboxAccounts.connect.mutationOptions({
      onSuccess: (authUrl: string | null) => {
        if (authUrl) {
          router.push(authUrl);
        }
      },
    }),
  );

  return (
    <TooltipProvider>
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center space-x-2">
            <span>Email Connections</span>
            <Tooltip delayDuration={0}>
              <TooltipTrigger asChild>
                <div className="rounded-full text-[#878787] text-[9px] font-normal border px-2 py-1 font-mono cursor-help">
                  Beta
                </div>
              </TooltipTrigger>
              <TooltipContent className="max-w-[300px] text-xs">
                <p>
                  We are currently in Google's verification review process. This
                  is a standard procedure for all apps requesting Gmail access.
                  You may see a warning screen - this is normal. Simply click{" "}
                  <strong>Advanced</strong> →{" "}
                  <strong>Go to midday.ai (unsafe)</strong> to safely proceed.
                </p>
              </TooltipContent>
            </Tooltip>
          </CardTitle>
          <CardDescription>
            Manage your connected email accounts or connect a new one.
          </CardDescription>
        </CardHeader>

        <Suspense fallback={<InboxAccountsListSkeleton />}>
          <InboxAccountsList />
        </Suspense>

        <CardFooter className="flex justify-between">
          <div />

          <Tooltip delayDuration={0}>
            <TooltipTrigger asChild>
              <Button
                onClick={() => connectMutation.mutate({ provider: "gmail" })}
                disabled={connectMutation.isPending}
                data-event="Connect email"
                data-channel="email"
              >
                Connect email
              </Button>
            </TooltipTrigger>
            <TooltipContent className="max-w-[300px] text-xs">
              <p>
                We are currently in Google's verification review process. This
                is a standard procedure for all apps requesting Gmail access.
                You may see a warning screen - this is normal. Simply click{" "}
                <strong>Advanced</strong> →{" "}
                <strong>Go to midday.ai (unsafe)</strong> to safely proceed.
              </p>
            </TooltipContent>
          </Tooltip>
        </CardFooter>
      </Card>
    </TooltipProvider>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-details-skeleton.tsx">
"use client";

import { Separator } from "@midday/ui/separator";
import { Skeleton } from "@midday/ui/skeleton";

export function InboxDetailsSkeleton() {
  return (
    <div className="h-[calc(100vh-120px)] overflow-hidden flex-col border w-[614px] hidden md:flex shrink-0 -mt-[54px]">
      <div className="flex items-center p-2 h-[52px] w-full" />

      <Separator />
      <div className="flex flex-1 flex-col">
        <div className="flex items-start p-4">
          <div className="flex items-start gap-4 text-sm">
            <Skeleton className="h-[40px] w-[40px] rounded-full" />
            <div className="grid gap-1 space-y-1">
              <Skeleton className="h-4 w-[120px]" />
              <Skeleton className="h-3 w-[50px]" />
            </div>
          </div>
          <div className="grid gap-1 ml-auto text-right">
            <Skeleton className="h-3 w-[70px] ml-auto" />
          </div>
        </div>
        <Separator />
        <div className="relative h-full">
          <Skeleton className="h-full w-full" />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-details.tsx">
import { FileViewer } from "@/components/file-viewer";
import { FormatAmount } from "@/components/format-amount";
import { useInboxFilterParams } from "@/hooks/use-inbox-filter-params";
import { useInboxParams } from "@/hooks/use-inbox-params";
import { useUserQuery } from "@/hooks/use-user";
import { downloadFile } from "@/lib/download";
import { useTRPC } from "@/trpc/client";
import { getUrl } from "@/utils/environment";
import { formatDate } from "@/utils/format";
import { getInitials } from "@/utils/format";
import { getWebsiteLogo } from "@/utils/logos";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { DialogTrigger } from "@midday/ui/dialog";
import {
  DropdownMenuContent,
  DropdownMenuItem,
} from "@midday/ui/dropdown-menu";
import { DropdownMenu, DropdownMenuTrigger } from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { Separator } from "@midday/ui/separator";
import { Skeleton } from "@midday/ui/skeleton";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useToast } from "@midday/ui/use-toast";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

import { MoreVertical, Trash2 } from "lucide-react";
import { useEffect, useState } from "react";
import { useHotkeys } from "react-hotkeys-hook";
import { useCopyToClipboard } from "usehooks-ts";
import { EditInboxModal } from "../modals/edit-inbox-modal";
import { InboxActions } from "./inbox-actions";
import { InboxDetailsSkeleton } from "./inbox-details-skeleton";

export function InboxDetails() {
  const { setParams, params } = useInboxParams();

  const { params: filterParams } = useInboxFilterParams();
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const [showFallback, setShowFallback] = useState(false);
  const { data: user } = useUserQuery();
  const [, copy] = useCopyToClipboard();

  const id = params.inboxId;

  const { data, isLoading } = useQuery(
    trpc.inbox.getById.queryOptions(
      { id: id! },
      {
        enabled: !!id,
      },
    ),
  );

  const deleteInboxMutation = useMutation(
    trpc.inbox.delete.mutationOptions({
      onMutate: async ({ id }) => {
        // Cancel outgoing refetches
        await queryClient.cancelQueries({
          queryKey: trpc.inbox.get.infiniteQueryKey(),
        });

        // Get current data
        const previousData = queryClient.getQueriesData({
          queryKey: trpc.inbox.get.infiniteQueryKey(),
        });

        // Flatten the data from all pages to find the current index and the next item
        const allInboxes = previousData
          // @ts-expect-error
          .flatMap(([, data]) => data?.pages ?? [])
          .flatMap((page) => page.data ?? []);

        const currentIndex = allInboxes.findIndex((item) => item.id === id);
        let nextInboxId: string | null = null;

        if (allInboxes.length > 1) {
          if (currentIndex === allInboxes.length - 1) {
            // If it was the last item, select the previous one
            nextInboxId = allInboxes[currentIndex - 1]?.id ?? null;
          } else if (currentIndex !== -1) {
            // Otherwise, select the next one
            nextInboxId = allInboxes[currentIndex + 1]?.id ?? null;
          }
        }
        // If list had 0 or 1 item, or index not found, nextInboxId remains null

        // Optimistically update infinite query data
        queryClient.setQueriesData(
          { queryKey: trpc.inbox.get.infiniteQueryKey() },
          (old: any) => ({
            pages: old.pages.map((page: any) => ({
              ...page,
              data: page.data.filter((item: any) => item.id !== id),
            })),
            pageParams: old.pageParams,
          }),
        );

        setParams({
          ...params,
          inboxId: nextInboxId,
        });

        return { previousData };
      },
      onError: (_, __, context) => {
        // Restore previous data on error
        if (context?.previousData) {
          queryClient.setQueriesData(
            { queryKey: trpc.inbox.get.infiniteQueryKey() },
            context.previousData,
          );
        }
      },
      onSettled: () => {
        // Refetch after error or success
        queryClient.invalidateQueries({
          queryKey: trpc.inbox.get.infiniteQueryKey(),
        });
      },
    }),
  );

  const updateInboxMutation = useMutation(
    trpc.inbox.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.inbox.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });
      },
    }),
  );

  const retryMatchingMutation = useMutation(
    trpc.inbox.retryMatching.mutationOptions({
      onSuccess: () => {
        // Refresh queries after retry matching completes
        queryClient.invalidateQueries({
          queryKey: trpc.inbox.getById.queryKey({ id: data?.id }),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.inbox.get.infiniteQueryKey(),
        });
      },
    }),
  );

  const handleOnDelete = () => {
    if (data?.id) {
      deleteInboxMutation.mutate({ id: data.id });
    }
  };

  const handleRetryMatching = () => {
    if (data?.id) {
      updateInboxMutation.mutate({
        id: data.id,
        status: "analyzing",
      });

      retryMatchingMutation.mutate({ id: data.id });
    }
  };

  useHotkeys("meta+backspace", (event) => {
    event.preventDefault();
    handleOnDelete();
  });

  const isProcessing = data?.status === "processing" || data?.status === "new";

  useEffect(() => {
    setShowFallback(false);
  }, [data]);

  const handleCopyLink = () => {
    if (!data) return;

    copy(`${getUrl()}/inbox?inboxId=${data.id}`);

    toast({
      duration: 4000,
      title: "Copied link to clipboard.",
      variant: "success",
    });
  };

  const fallback = showFallback || (!data?.website && data?.displayName);

  if (isLoading) {
    return <InboxDetailsSkeleton />;
  }

  return (
    <div className="h-[calc(100vh-125px)] overflow-hidden flex-col border w-[614px] hidden md:flex shrink-0 -mt-[54px]">
      <div className="flex items-center p-2">
        <div className="flex items-center gap-2">
          <Button
            variant="ghost"
            size="icon"
            disabled={!data}
            onClick={handleOnDelete}
          >
            <Trash2 className="h-4 w-4" />
          </Button>
        </div>

        <div className="ml-auto flex items-center">
          {data?.inboxAccount?.provider === "gmail" && (
            <div className="border-r border-border pr-4">
              <TooltipProvider delayDuration={100}>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Icons.Gmail className="w-4 h-4" />
                  </TooltipTrigger>
                  <TooltipContent className="text-xs px-3 py-1.5">
                    {data.inboxAccount.email}
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
          )}
          <EditInboxModal>
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="icon" disabled={!data}>
                  <MoreVertical className="h-4 w-4" />
                  <span className="sr-only">More</span>
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end" className="w-48">
                <DropdownMenuItem
                  onClick={() =>
                    updateInboxMutation.mutate({
                      id: data?.id!,
                      status: data?.status === "done" ? "pending" : "done",
                    })
                  }
                >
                  {data?.status === "done" ? (
                    <>
                      <Icons.SubdirectoryArrowLeft className="mr-2 size-4" />
                      <span className="text-xs">Mark as unhandled</span>
                    </>
                  ) : (
                    <>
                      <Icons.Check className="mr-2 size-4" />
                      <span className="text-xs">Mark as done</span>
                    </>
                  )}
                </DropdownMenuItem>

                <DropdownMenuItem
                  onClick={handleRetryMatching}
                  disabled={retryMatchingMutation.isPending}
                >
                  {retryMatchingMutation.isPending ? (
                    <>
                      <Icons.Refresh className="mr-2 size-4 animate-spin" />
                      <span className="text-xs">Processing...</span>
                    </>
                  ) : (
                    <>
                      <Icons.Refresh className="mr-2 size-4" />
                      <span className="text-xs">Retry Matching</span>
                    </>
                  )}
                </DropdownMenuItem>

                <DropdownMenuItem>
                  <DialogTrigger className="w-full text-left flex items-center">
                    <Icons.Edit className="mr-2 size-4" />
                    <span className="text-xs">Edit</span>
                  </DialogTrigger>
                </DropdownMenuItem>

                <DropdownMenuItem
                  onClick={() => {
                    if (data?.filePath && data?.fileName) {
                      downloadFile(
                        `/api/download/file?path=${data.filePath.join("/")}&filename=${data.fileName}`,
                        data.fileName,
                      );
                    }
                  }}
                >
                  <Icons.ProjectStatus className="mr-2 size-4" />
                  <span className="text-xs">Download</span>
                </DropdownMenuItem>

                <DropdownMenuItem onClick={handleCopyLink}>
                  <Icons.Copy className="mr-2 size-4" />
                  <span className="text-xs">Copy Link</span>
                </DropdownMenuItem>

                {/* Destructive Actions - At Bottom */}
                <DropdownMenuItem
                  onClick={handleOnDelete}
                  className="text-destructive focus:text-destructive"
                >
                  <Trash2 className="mr-2 size-4" />
                  <span className="text-xs">Delete</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </EditInboxModal>
        </div>
      </div>
      <Separator />

      {data?.id ? (
        <div className="flex flex-col flex-grow min-h-0 relative">
          <div className="flex items-start p-4">
            <div className="flex items-start gap-4 text-sm relative">
              {isProcessing ? (
                <Skeleton className="h-[40px] w-[40px] rounded-full" />
              ) : (
                <div className="relative">
                  <Avatar>
                    {data.website && (
                      <AvatarImageNext
                        alt={data.website}
                        width={40}
                        height={40}
                        className={cn(
                          "rounded-full overflow-hidden",
                          showFallback && "hidden",
                        )}
                        src={getWebsiteLogo(data.website)}
                        quality={100}
                        onError={() => {
                          setShowFallback(true);
                        }}
                      />
                    )}

                    {fallback && (
                      <AvatarFallback>
                        {getInitials(data?.displayName ?? "")}
                      </AvatarFallback>
                    )}
                  </Avatar>
                </div>
              )}

              <div className="grid gap-1 select-text">
                <div className="font-semibold">
                  {isProcessing ? (
                    <Skeleton className="h-3 w-[120px] mb-1" />
                  ) : (
                    data.displayName
                  )}
                </div>
                <div className="line-clamp-1 text-xs">
                  {isProcessing && !data.currency && (
                    <Skeleton className="h-3 w-[50px]" />
                  )}
                  {data.currency && data.amount != null && (
                    <FormatAmount
                      amount={data.amount}
                      currency={data.currency}
                    />
                  )}
                </div>
              </div>
            </div>
            <div className="grid gap-1 ml-auto text-right">
              <div className="text-xs text-muted-foreground select-text">
                {isProcessing && !data.date && (
                  <Skeleton className="h-3 w-[50px]" />
                )}
                {data.date && formatDate(data.date, user?.dateFormat)}
              </div>
            </div>
          </div>

          <Separator />

          <div className="absolute bottom-4 left-4 right-4 z-50">
            <InboxActions data={data} key={data.id} />
          </div>

          {data?.filePath && (
            <FileViewer
              mimeType={data.contentType}
              url={`/api/proxy?filePath=vault/${data?.filePath.join("/")}`}
              // If the order changes, the file viewer will remount otherwise the PDF worker will crash
              key={`${params.order}-${JSON.stringify(filterParams)}`}
            />
          )}
        </div>
      ) : (
        <div className="p-8 text-center text-muted-foreground">
          No attachment selected
        </div>
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-email-settings.tsx">
"use client";

import { CopyInput } from "@/components/copy-input";
import { useUserQuery } from "@/hooks/use-user";
import { getInboxEmail } from "@midday/inbox";
import { Card, CardDescription, CardHeader, CardTitle } from "@midday/ui/card";

export function InboxEmailSettings() {
  const { data: user } = useUserQuery();
  const inboxEmail = getInboxEmail(user?.team?.inboxId ?? "");

  return (
    <Card>
      <CardHeader>
        <CardTitle>Email Address</CardTitle>
        <CardDescription>
          Use this unique email address for online purchases and receipts.
          Emails sent to this address will automatically appear in your inbox
          and can be matched against transactions.
        </CardDescription>
      </CardHeader>

      <div className="px-6 pb-6 max-w-[400px]">
        <CopyInput value={inboxEmail} />
      </div>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-empty.tsx">
"use client";

import { useInboxFilterParams } from "@/hooks/use-inbox-filter-params";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";

export function NoResults() {
  const { setParams } = useInboxFilterParams();

  return (
    <div className="h-screen -mt-[140px] w-full flex items-center justify-center flex-col">
      <div className="flex flex-col items-center">
        <Icons.Transactions2 className="mb-4" />
        <div className="text-center mb-6 space-y-2">
          <h2 className="font-medium text-lg">No results</h2>
          <p className="text-[#606060] text-sm">Try another search term</p>
        </div>

        <Button variant="outline" onClick={() => setParams(null)}>
          Clear search
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-get-started.tsx">
"use client";

import { ConnectGmail } from "@/components/inbox/connect-gmail";
import { useUserQuery } from "@/hooks/use-user";
import { getInboxEmail } from "@midday/inbox";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { useRouter } from "next/navigation";
import { CopyInput } from "../copy-input";
import { UploadZone } from "./inbox-upload-zone";

export function InboxGetStarted() {
  const { data: user } = useUserQuery();
  const router = useRouter();

  const handleUpload = () => {
    router.push("/inbox?connected=true", { scroll: false });
  };

  return (
    <UploadZone onUploadComplete={handleUpload}>
      <div className="h-[calc(100vh-150px)] flex items-center justify-center">
        <div className="relative z-20 m-auto flex w-full max-w-[380px] flex-col">
          <div className="flex w-full flex-col relative">
            <div className="pb-4 text-center">
              <h2 className="font-medium text-lg">Connect Your Gmail</h2>
              <p className="pb-6 text-sm text-[#878787]">
                Connect your Gmail to automatically import receipts and
                invoices. We'll extract the data and match it to your
                transactions seamlessly.
              </p>
            </div>

            <div className="pointer-events-auto flex flex-col space-y-4">
              <ConnectGmail />

              {user?.team?.inboxId && (
                <Accordion
                  type="single"
                  collapsible
                  className="border-t-[1px] pt-2 mt-6"
                >
                  <AccordionItem value="item-1" className="border-0">
                    <AccordionTrigger className="justify-center space-x-2 flex text-sm">
                      <span>More options</span>
                    </AccordionTrigger>
                    <AccordionContent className="mt-4">
                      <div className="flex flex-col space-y-4">
                        <CopyInput value={getInboxEmail(user.team.inboxId)} />
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                </Accordion>
              )}
            </div>

            <div className="text-center mt-8">
              <p className="text-xs text-[#878787]">
                You can also forward receipts to your unique Midday email or
                drag and drop files here
              </p>
            </div>
          </div>
        </div>
      </div>
    </UploadZone>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-header.tsx">
"use client";

import { InboxOrdering } from "@/components/inbox/inbox-ordering";
import { InboxSearch } from "@/components/inbox/inbox-search";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";

export function InboxHeader() {
  return (
    <div className="flex justify-center items-center space-x-4 mb-4 mt-6 w-full pr-[647px]">
      <InboxSearch />

      <div className="flex space-x-2">
        <InboxOrdering />

        <Button
          variant="outline"
          size="icon"
          onClick={() => document.getElementById("upload-files")?.click()}
        >
          <Icons.Add size={17} />
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-item.tsx">
import { FormatAmount } from "@/components/format-amount";
import { InboxStatus } from "@/components/inbox/inbox-status";
import { useInboxParams } from "@/hooks/use-inbox-params";
import { useUserQuery } from "@/hooks/use-user";
import { formatDate } from "@/utils/format";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { cn } from "@midday/ui/cn";
import { Skeleton } from "@midday/ui/skeleton";

type Props = {
  item: RouterOutputs["inbox"]["get"]["data"][number];
  index: number;
};

export function InboxItem({ item, index }: Props) {
  const { params, setParams } = useInboxParams();
  const { data: user } = useUserQuery();

  const isSelected =
    params.inboxId === item.id || (!params.inboxId && index === 0);
  const isProcessing = item.status === "processing" || item.status === "new";

  return (
    <button
      type="button"
      onClick={() => {
        setParams({ inboxId: item.id });
      }}
      key={item.id}
      className={cn(
        "flex flex-col w-full items-start gap-2 border p-4 text-left text-sm h-[90px]",
        isSelected && "bg-accent border-[#DCDAD2] dark:border-[#2C2C2C]",
      )}
    >
      <div className="flex w-full flex-col gap-1">
        <div className="flex items-center mb-1">
          <div className="flex items-center gap-2">
            <div className="flex items-center space-x-2 select-text">
              <div className="font-semibold">
                {isProcessing ? (
                  <Skeleton className="h-3 w-[120px] mb-1" />
                ) : (
                  item.displayName
                )}
              </div>
            </div>
          </div>
          <div
            className={cn(
              "ml-auto text-xs select-text",
              isSelected ? "text-foreground" : "text-muted-foreground",
            )}
          >
            {isProcessing && <Skeleton className="h-3 w-[50px]" />}
            {!isProcessing &&
              item?.date &&
              formatDate(item.date, user?.dateFormat)}
          </div>
        </div>

        <div className="flex">
          <div className="text-xs font-medium select-text">
            {isProcessing && <Skeleton className="h-3 w-[50px]" />}
            {!isProcessing && item?.currency && (
              <FormatAmount
                amount={item.amount ?? 0}
                currency={item.currency}
              />
            )}
          </div>

          <div className="ml-auto">
            {isProcessing ? (
              <Skeleton className="h-4 w-[60px]" />
            ) : (
              <InboxStatus item={item} />
            )}
          </div>
        </div>
      </div>
    </button>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-list-skeleton.tsx">
import { cn } from "@midday/ui/cn";
import { Skeleton } from "@midday/ui/skeleton";

type InboxSkeletonProps = {
  numberOfItems: number;
  className?: string;
};

export function InboxListSkeleton({
  numberOfItems,
  className,
}: InboxSkeletonProps) {
  return (
    <div className={cn("flex flex-col gap-4", className)}>
      {[...Array(numberOfItems)].map((_, index) => (
        <div
          className="flex flex-col items-start gap-2 border p-4 text-left text-sm transition-all h-[82px]"
          key={index.toString()}
        >
          <div className="flex w-full flex-col gap-1">
            <div className="flex items-center mb-4">
              <div className="flex items-center gap-2">
                <div className="font-semibold">
                  <Skeleton className="h-3 w-[140px]" />
                </div>
              </div>
              <div className="ml-auto text-xs text-muted-foreground">
                <Skeleton className="h-3 w-[40px]" />
              </div>
            </div>
            <div className="flex">
              <div className="text-xs font-medium">
                <Skeleton className="h-2 w-[110px]" />
              </div>
              <div className="ml-auto text-xs font-medium">
                <Skeleton className="h-2 w-[60px]" />
              </div>
            </div>
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-ordering.tsx">
"use client";

import { useInboxParams } from "@/hooks/use-inbox-params";
import { Button } from "@midday/ui/button";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";

export function InboxOrdering() {
  const { params, setParams } = useInboxParams();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Icons.Sort size={16} />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent>
        <DropdownMenuCheckboxItem
          checked={params.order === "asc"}
          onCheckedChange={() => setParams({ order: "asc" })}
        >
          Most recent
        </DropdownMenuCheckboxItem>

        <DropdownMenuCheckboxItem
          checked={params.order === "desc"}
          onCheckedChange={() => setParams({ order: "desc" })}
        >
          Oldest first
        </DropdownMenuCheckboxItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-search.tsx">
import { useInboxFilterParams } from "@/hooks/use-inbox-filter-params";
import { cn } from "@midday/ui/cn";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { Input } from "@midday/ui/input";
import { useState } from "react";
import { useHotkeys } from "react-hotkeys-hook";

const statusFilters = [
  { id: "all", name: "All" },
  { id: "done", name: "Matched" },
  { id: "pending", name: "Pending" },
  { id: "suggested_match", name: "Suggested Match" },
];

export function InboxSearch() {
  const [isOpen, setIsOpen] = useState(false);
  const { params, setParams, hasFilter } = useInboxFilterParams();

  useHotkeys("esc", () => setParams({ q: null }), {
    enableOnFormTags: true,
    enabled: Boolean(params.q),
  });

  const handleSearch = (evt: React.ChangeEvent<HTMLInputElement>) => {
    const value = evt.target.value;

    if (value) {
      setParams({ q: value });
    } else {
      setParams({ q: null });
    }
  };

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <div className="flex space-x-4 items-center w-full">
        <form
          className="relative w-full"
          onSubmit={(e) => {
            e.preventDefault();
            setIsOpen(false);
          }}
        >
          <Icons.Search className="absolute pointer-events-none left-3 top-[11px]" />
          <Input
            placeholder="Search or filter"
            className="pl-9 w-full"
            value={params.q ?? ""}
            onChange={handleSearch}
            autoComplete="off"
            autoCapitalize="none"
            autoCorrect="off"
            spellCheck="false"
          />

          <DropdownMenuTrigger asChild>
            <button
              onClick={() => setIsOpen((prev) => !prev)}
              type="button"
              className={cn(
                "absolute z-10 right-3 top-[10px] opacity-50 transition-opacity duration-300 hover:opacity-100",
                hasFilter && "opacity-100",
                isOpen && "opacity-100",
              )}
            >
              <Icons.Filter />
            </button>
          </DropdownMenuTrigger>
        </form>
      </div>

      <DropdownMenuContent
        className="w-[350px]"
        align="end"
        sideOffset={19}
        alignOffset={-11}
        side="bottom"
      >
        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.ProjectStatus className="mr-2 h-4 w-4 rotate-180" />
              <span>Status</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                alignOffset={-4}
                className="p-0"
              >
                <DropdownMenuRadioGroup
                  value={params.status ?? "all"}
                  onValueChange={(value) =>
                    setParams({
                      status:
                        value === "all"
                          ? null
                          : (value as "done" | "pending" | "suggested_match"),
                    })
                  }
                >
                  {statusFilters.map(({ id, name }) => (
                    <DropdownMenuRadioItem key={id} value={id}>
                      {name}
                    </DropdownMenuRadioItem>
                  ))}
                </DropdownMenuRadioGroup>
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-skeleton.tsx">
"use client";

import { InboxDetailsSkeleton } from "./inbox-details-skeleton";
import { InboxListSkeleton } from "./inbox-list-skeleton";

export function InboxViewSkeleton() {
  return (
    <div className="flex flex-row space-x-8 mt-4">
      <div className="w-full h-full">
        <InboxListSkeleton numberOfItems={10} />
      </div>

      <InboxDetailsSkeleton />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-status.tsx">
"use client";

import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Icons } from "@midday/ui/icons";
import { Spinner } from "@midday/ui/spinner";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";

type Props = {
  item: RouterOutputs["inbox"]["get"]["data"][number];
};

export function InboxStatus({ item }: Props) {
  // Don't show status for processing items - let skeleton handle the visual feedback
  if (item.status === "processing" || item.status === "new") {
    return null;
  }

  if (item.status === "analyzing") {
    return (
      <TooltipProvider delayDuration={0}>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className="flex space-x-1 items-center p-1 text-[#878787] text-[10px] px-1.5 py-0.5 cursor-default font-mono border">
              <Spinner size={14} className="stroke-primary" />
              <span>Analyzing</span>
            </div>
          </TooltipTrigger>
          <TooltipContent sideOffset={10} className="text-xs">
            <p>
              We're reviewing the file and checking <br />
              for a matching transaction
            </p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    );
  }

  if (item.status === "suggested_match") {
    return (
      <TooltipProvider delayDuration={0}>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className="flex space-x-1.5 items-center px-1.5 py-0.5 text-[10px] cursor-default font-mono border">
              <div className="w-1.5 h-1.5 bg-[#FFD02B] rounded-full" />
              <span>Suggested match</span>
            </div>
          </TooltipTrigger>
          <TooltipContent sideOffset={10} className="text-xs">
            <p>
              We found a possible match — confirm <br />
              or dismiss it
            </p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    );
  }

  if (item.status === "pending") {
    return (
      <TooltipProvider delayDuration={0}>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className="p-1 text-[10px] px-1.5 py-0.5 cursor-default font-mono inline-block border">
              <span>Pending</span>
            </div>
          </TooltipTrigger>
          <TooltipContent sideOffset={10} className="text-xs">
            <p>
              We didn't find a match yet — we'll check <br />
              again when new transactions arrive
            </p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    );
  }

  if (item.status === "done" || item?.transactionId) {
    return (
      <TooltipProvider delayDuration={0}>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className="flex space-x-1 items-center px-1.5 py-0.5 text-[10px] cursor-default font-mono border">
              <Icons.Check className="size-3.5 mt-[1px]" />
              <span>Matched</span>
            </div>
          </TooltipTrigger>
          <TooltipContent sideOffset={10} className="text-xs">
            <p>
              This file has been successfully <br />
              matched to a transaction
            </p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    );
  }

  return (
    <TooltipProvider delayDuration={0}>
      <Tooltip>
        <TooltipTrigger asChild>
          <div className="flex space-x-1 items-center px-1.5 py-0.5 text-[10px] cursor-default font-mono border">
            <span>No match</span>
          </div>
        </TooltipTrigger>
        <TooltipContent sideOffset={10} className="text-xs">
          <p>
            We couldn't find a match — please <br />
            select the transaction manually
          </p>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-upload-zone.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { resumableUpload } from "@/utils/upload";
import { createClient } from "@midday/supabase/client";
import { cn } from "@midday/ui/cn";
import { useToast } from "@midday/ui/use-toast";
import { stripSpecialCharacters } from "@midday/utils";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { type ReactNode, useEffect, useRef, useState } from "react";
import { useDropzone } from "react-dropzone";

type UploadResult = {
  filename: string;
  file: File;
};

type ProcessAttachmentInput = {
  filePath: string[];
  mimetype: string;
  size: number;
};

type Props = {
  children: ReactNode;
  onUploadComplete?: () => void;
};

export function UploadZone({ children, onUploadComplete }: Props) {
  const trpc = useTRPC();
  const { data: user } = useUserQuery();
  const supabase = createClient();
  const queryClient = useQueryClient();
  const [progress, setProgress] = useState(0);
  const [showProgress, setShowProgress] = useState(false);
  const [toastId, setToastId] = useState<string | undefined>(undefined);
  const uploadProgress = useRef<number[]>([]);
  const { toast, dismiss, update } = useToast();
  const processAttachmentsMutation = useMutation(
    trpc.inbox.processAttachments.mutationOptions(),
  );
  const createInboxItemMutation = useMutation(
    trpc.inbox.create.mutationOptions(),
  );

  useEffect(() => {
    if (!toastId && showProgress) {
      const { id } = toast({
        title: `Uploading ${uploadProgress.current.length} files`,
        progress,
        variant: "progress",
        description: "Please do not close browser until completed",
        duration: Number.POSITIVE_INFINITY,
      });

      if (id) {
        setToastId(id);
      }
    } else if (toastId) {
      update(toastId, {
        id: toastId,
        progress,
        title: `Uploading ${uploadProgress.current.length} files`,
      });
    }
  }, [showProgress, progress, toastId]);

  const onDrop = async (files: File[]) => {
    // NOTE: If onDropRejected
    if (!files.length) {
      return;
    }

    // Set default progress
    uploadProgress.current = files.map(() => 0);

    setShowProgress(true);

    const path = [user?.teamId, "inbox"] as string[];

    try {
      // First, create inbox items immediately for instant feedback
      const inboxItems = await Promise.all(
        files.map(async (file: File) => {
          // Use the same filename processing as resumableUpload
          const processedFilename = stripSpecialCharacters(file.name);
          const filePath = [...path, processedFilename];
          return createInboxItemMutation.mutateAsync({
            filename: processedFilename,
            mimetype: file.type,
            size: file.size,
            filePath,
          });
        }),
      );

      // Invalidate inbox queries to show new items immediately
      queryClient.invalidateQueries({
        queryKey: trpc.inbox.get.queryKey(),
      });

      const results = (await Promise.all(
        files.map(async (file: File, idx: number) =>
          resumableUpload(supabase, {
            bucket: "vault",
            path,
            file,
            onProgress: (bytesUploaded, bytesTotal) => {
              uploadProgress.current[idx] = (bytesUploaded / bytesTotal) * 100;

              const _progress = uploadProgress.current.reduce(
                (acc, currentValue) => {
                  return acc + currentValue;
                },
                0,
              );

              setProgress(Math.round(_progress / files.length));
            },
          }),
        ),
      )) as UploadResult[];

      // Trigger the upload jobs
      processAttachmentsMutation.mutate(
        results.map(
          (result): ProcessAttachmentInput => ({
            filePath: [...path, result.filename],
            mimetype: result.file.type,
            size: result.file.size,
          }),
        ),
      );

      // Reset once done
      uploadProgress.current = [];

      setProgress(0);
      toast({
        title: "Upload successful.",
        variant: "success",
        duration: 2000,
      });

      setShowProgress(false);
      setToastId(undefined);
      dismiss(toastId);
      onUploadComplete?.();
    } catch (error) {
      // Refresh inbox to show current state after error
      queryClient.invalidateQueries({
        queryKey: trpc.inbox.get.queryKey(),
      });

      setShowProgress(false);
      setToastId(undefined);
      dismiss(toastId);

      toast({
        duration: 2500,
        variant: "error",
        title: "Something went wrong please try again.",
      });
    }
  };

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    onDropRejected: ([reject]) => {
      if (reject?.errors.find(({ code }) => code === "file-too-large")) {
        toast({
          duration: 2500,
          variant: "error",
          title: "File size to large.",
        });
      }

      if (reject?.errors.find(({ code }) => code === "file-invalid-type")) {
        toast({
          duration: 2500,
          variant: "error",
          title: "File type not supported.",
        });
      }
    },
    maxSize: 5000000, // 5MB
    maxFiles: 25,
    accept: {
      "image/*": [".jpg", ".jpeg", ".png", ".webp", ".heic", ".heif", ".avif"],
      "application/pdf": [".pdf"],
    },
  });

  return (
    <div
      {...getRootProps({ onClick: (evt) => evt.stopPropagation() })}
      className="relative h-full"
    >
      <div className="absolute top-0 bottom-0 right-0 left-0 z-[51] pointer-events-none">
        <div
          className={cn(
            "bg-background dark:bg-[#1A1A1A] h-full flex items-center justify-center text-center invisible",
            isDragActive && "visible",
          )}
        >
          <input {...getInputProps()} id="upload-files" />
          <p className="text-xs">
            Drop your receipts here. <br />
            Maximum of 25 files at a time.
          </p>
        </div>
      </div>

      {children}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/inbox-view.tsx">
"use client";

import { LoadMore } from "@/components/load-more";
import { useInboxFilterParams } from "@/hooks/use-inbox-filter-params";
import { useInboxParams } from "@/hooks/use-inbox-params";
import { useRealtime } from "@/hooks/use-realtime";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { ScrollArea } from "@midday/ui/scroll-area";
import {
  useQueryClient,
  useSuspenseInfiniteQuery,
} from "@tanstack/react-query";
import { AnimatePresence, motion } from "framer-motion";
import { useEffect, useMemo, useRef } from "react";
import { useHotkeys } from "react-hotkeys-hook";
import { useInView } from "react-intersection-observer";
import { useBoolean, useCounter, useDebounceCallback } from "usehooks-ts";
import { InboxDetails } from "./inbox-details";
import { NoResults } from "./inbox-empty";
import { InboxItem } from "./inbox-item";
import { InboxViewSkeleton } from "./inbox-skeleton";

export function InboxView() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { ref, inView } = useInView();
  const { data: user } = useUserQuery();
  const { params, setParams } = useInboxParams();
  const { params: filter, hasFilter } = useInboxFilterParams();

  const allSeenIdsRef = useRef(new Set<string>());

  const infiniteQueryOptions = trpc.inbox.get.infiniteQueryOptions(
    {
      order: params.order,
      ...filter,
    },
    {
      getNextPageParam: ({ meta }) => meta?.cursor,
    },
  );

  const { data, fetchNextPage, hasNextPage, refetch } =
    useSuspenseInfiniteQuery(infiniteQueryOptions);

  const tableData = useMemo(() => {
    return data?.pages.flatMap((page) => page.data) ?? [];
  }, [data]);

  // Enhanced batching mechanism using usehooks-ts
  const {
    count: updateCount,
    increment: incrementUpdates,
    reset: resetUpdates,
  } = useCounter(0);
  const {
    value: hasMatchingChanges,
    setTrue: setHasMatchingChanges,
    setFalse: resetMatchingChanges,
  } = useBoolean(false);

  const MAX_BATCH_SIZE = 10;

  // Helper to check if update affects transaction matching
  const checkMatchingChanges = (payload: any) => {
    if (payload?.new) {
      const newRecord = payload.new;
      const oldRecord = payload.old;

      return (
        newRecord.status !== oldRecord?.status &&
        (newRecord.status === "done" ||
          newRecord.status === "suggested_match" ||
          oldRecord?.status === "done" ||
          oldRecord?.status === "suggested_match")
      );
    }
    return false;
  };

  // Refresh function that handles invalidations
  const performRefresh = (shouldInvalidateTransactions: boolean) => {
    refetch();

    queryClient.invalidateQueries({
      queryKey: trpc.inbox.getById.queryKey(),
    });

    if (shouldInvalidateTransactions) {
      queryClient.invalidateQueries({
        queryKey: trpc.transactions.get.infiniteQueryKey(),
      });
    }
  };

  // Debounced handler for regular updates
  const debouncedRefresh = useDebounceCallback(() => {
    performRefresh(hasMatchingChanges);
    resetUpdates();
    resetMatchingChanges();
  }, 200);

  // Main batch handler
  const batchedUpdateHandler = (payload: any) => {
    incrementUpdates();

    // Check if this update affects transaction matching
    if (checkMatchingChanges(payload)) {
      setHasMatchingChanges();
    }

    // Force immediate update for bulk operations
    if (updateCount >= MAX_BATCH_SIZE) {
      performRefresh(hasMatchingChanges);
      resetUpdates();
      resetMatchingChanges();
      return;
    }

    // Use debounced update for smaller batches
    debouncedRefresh();
  };

  useRealtime({
    channelName: "realtime_inbox",
    table: "inbox",
    filter: `team_id=eq.${user?.teamId}`,
    onEvent: (payload) => {
      if (payload.eventType === "INSERT" || payload.eventType === "UPDATE") {
        batchedUpdateHandler(payload);
      }
    },
  });

  useEffect(() => {
    if (inView) {
      fetchNextPage();
    }
  }, [inView]);

  const newItemIds = useMemo(() => {
    const newIds = new Set<string>();

    for (const item of tableData) {
      if (!allSeenIdsRef.current.has(item.id)) {
        newIds.add(item.id);
        allSeenIdsRef.current.add(item.id);
      }
    }

    return newIds;
  }, [tableData]);

  useEffect(() => {
    if (!params.inboxId && tableData.length > 0) {
      setParams({
        ...params,
        inboxId: tableData.at(0)?.id,
      });
    }
  }, [tableData, params.inboxId, setParams]);

  // Arrow key navigation
  useHotkeys(
    "up",
    (event) => {
      event.preventDefault();
      const currentIndex = tableData.findIndex(
        (item) => item.id === params.inboxId,
      );

      if (currentIndex > 0) {
        const prevItem = tableData[currentIndex - 1];
        setParams({
          ...params,
          inboxId: prevItem?.id,
        });
      }
    },
    [tableData, params, setParams],
  );

  useHotkeys(
    "down",
    (event) => {
      event.preventDefault();
      const currentIndex = tableData.findIndex(
        (item) => item.id === params.inboxId,
      );

      if (currentIndex < tableData.length - 1) {
        const nextItem = tableData[currentIndex + 1];
        setParams({
          ...params,
          inboxId: nextItem?.id,
        });
      }
    },
    [tableData, params, setParams],
  );

  // If user is connected, and we don't have any data, we need to show a skeleton
  if (params.connected && !tableData?.length) {
    return <InboxViewSkeleton />;
  }

  if (hasFilter && !tableData?.length) {
    return <NoResults />;
  }

  return (
    <div className="flex flex-row space-x-8 mt-4">
      <div className="w-full h-full">
        <ScrollArea
          className="relative w-full h-[calc(100vh-180px)] overflow-hidden"
          hideScrollbar
        >
          <AnimatePresence initial={false}>
            <div className="m-0 h-full space-y-4">
              {tableData.map((item, index) => {
                const isNewItem = newItemIds.has(item.id);

                return (
                  <motion.div
                    key={item.id}
                    initial={
                      isNewItem ? { opacity: 0, y: -30, scale: 0.95 } : false
                    }
                    animate={
                      isNewItem ? { opacity: 1, y: 0, scale: 1 } : "visible"
                    }
                    transition={
                      isNewItem
                        ? {
                            duration: 0.4,
                            ease: [0.23, 1, 0.32, 1],
                            delay: index < 5 ? index * 0.05 : 0,
                          }
                        : undefined
                    }
                    exit="exit"
                  >
                    <InboxItem item={item} index={index} />
                  </motion.div>
                );
              })}
            </div>
          </AnimatePresence>

          <LoadMore ref={ref} hasNextPage={hasNextPage} />
        </ScrollArea>
      </div>

      <InboxDetails />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/index.tsx">
"use client";

import type { ReactNode } from "react";
import { InboxHeader } from "./inbox-header";
import { UploadZone } from "./inbox-upload-zone";

type Props = {
  children: ReactNode;
};

export function Inbox({ children }: Props) {
  return (
    <UploadZone>
      <InboxHeader />
      {children}
    </UploadZone>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/match-transaction.tsx">
"use client";

import { useInboxParams } from "@/hooks/use-inbox-params";
import { useLocalStorage } from "@/hooks/use-local-storage";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { Combobox } from "@midday/ui/combobox";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { motion } from "framer-motion";
import { useEffect, useRef, useState } from "react";
import { useDebounceValue } from "usehooks-ts";
import { TransactionMatchItem } from "./transaction-match-item";
import { TransactionUnmatchItem } from "./transaction-unmatch-item";

export function MatchTransaction() {
  const trpc = useTRPC();
  const { params } = useInboxParams();
  const { data: user } = useUserQuery();
  const queryClient = useQueryClient();

  const [debouncedValue, setValue] = useDebounceValue("", 200);
  const [isOpen, onOpenChange] = useState(false);
  const [includeAlreadyMatched, setIncludeAlreadyMatched] = useLocalStorage(
    "inbox-include-already-matched",
    true,
  );
  const previousStatusRef = useRef<string | null>(null);

  const id = params.inboxId;

  const { data } = useQuery(
    trpc.inbox.getById.queryOptions(
      { id: id! },
      {
        enabled: !!id,
      },
    ),
  );

  const { data: transactionMatch, isLoading } = useQuery(
    trpc.transactions.searchTransactionMatch.queryOptions({
      query: debouncedValue,
      inboxId: id ?? undefined,
      maxResults: debouncedValue.length > 0 ? 200 : 3,
      includeAlreadyMatched,
    }),
  );

  const isSearching = isLoading && debouncedValue.length > 0;

  const options = transactionMatch?.map((transaction, index) => ({
    id: transaction.transaction_id,
    name: transaction.name,
    component: () => (
      <TransactionMatchItem
        date={transaction.transaction_date}
        name={transaction.name}
        dateFormat={user?.dateFormat}
        amount={transaction.transaction_amount}
        currency={transaction.transaction_currency}
        isAlreadyMatched={transaction.is_already_matched}
        matchedAttachmentFilename={transaction.matched_attachment_filename}
        showBestMatch={
          index === 0 && transactionMatch?.length > 1 && !debouncedValue.length
        }
      />
    ),
  }));

  const selectedOptionBase = data?.transaction
    ? { id: data.transaction.id, name: data.transaction.name }
    : options?.find((option) => option.id === debouncedValue);

  const selectedValue = selectedOptionBase
    ? { id: selectedOptionBase.id, name: selectedOptionBase.name }
    : undefined;

  const handleChange = (value: string) => {
    setValue(value);
  };

  const handleFocus = () => {
    if (options && options.length > 0) {
      onOpenChange(true);
    }
  };

  const toggleIncludeAlreadyMatched = () => {
    setIncludeAlreadyMatched(!includeAlreadyMatched);
  };

  const matchTransactionMutation = useMutation(
    trpc.inbox.matchTransaction.mutationOptions({
      onMutate: async (variables) => {
        const { id, transactionId } = variables;
        const queryKey = trpc.inbox.getById.queryKey({ id });

        await queryClient.cancelQueries({ queryKey });

        const previousInboxItem = queryClient.getQueryData(queryKey);

        const selectedTransaction = transactionMatch?.find(
          (t) => t.transaction_id === transactionId,
        );

        if (previousInboxItem && selectedTransaction) {
          queryClient.setQueryData(queryKey, {
            ...previousInboxItem,
            transactionId,
            transaction: {
              id: selectedTransaction.transaction_id,
              name: selectedTransaction.name,
              date: selectedTransaction.transaction_date,
              amount: selectedTransaction.transaction_amount,
              currency: selectedTransaction.transaction_currency,
            },
          });
        }

        return { previousInboxItem };
      },
      onError: (_, variables, context) => {
        if (context?.previousInboxItem) {
          queryClient.setQueryData(
            trpc.inbox.getById.queryKey({ id: variables.id }),
            context.previousInboxItem,
          );
        }
      },
      onSettled: (_, __, variables) => {
        queryClient.invalidateQueries({
          queryKey: trpc.inbox.getById.queryKey({ id: variables.id }),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.inbox.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.transactions.searchTransactionMatch.queryKey(),
        });
      },
    }),
  );

  const handleSelect = (option?: { id: string; name: string }) => {
    if (option) {
      matchTransactionMutation.mutate({
        id: id!,
        transactionId: option.id,
      });
    }
  };

  useEffect(() => {
    if (id) {
      onOpenChange(false);
    }
  }, [id]);

  // Track status changes to detect transitions from suggested_match
  useEffect(() => {
    if (data?.status) {
      previousStatusRef.current = data.status;
    }
  }, [data?.status]);

  // Check if we're transitioning from suggested_match to show manual search
  const isTransitioningFromSuggestion =
    previousStatusRef.current === "suggested_match" &&
    data?.status !== "suggested_match";

  if (data?.transactionId) {
    return (
      <motion.div
        key="transaction-unmatch"
        initial={{ y: 100, opacity: 0 }}
        animate={{ y: 0, opacity: 1 }}
        exit={{ y: 100, opacity: 0 }}
        transition={{ type: "spring", stiffness: 400, damping: 25 }}
      >
        <TransactionUnmatchItem />
      </motion.div>
    );
  }

  return (
    <motion.div
      key="match-transaction"
      initial={{
        y: isTransitioningFromSuggestion ? 100 : 0,
        opacity: isTransitioningFromSuggestion ? 0 : 1,
      }}
      animate={{ y: 0, opacity: 1 }}
      exit={{ y: 100, opacity: 0 }}
      transition={{ type: "spring", stiffness: 400, damping: 25 }}
      className="bg-background h-12 relative"
    >
      <Combobox
        key={data?.transaction?.id}
        placeholder="Select a transaction"
        className="w-full bg-transparent px-12 h-12 border border-border dark:border-none"
        classNameList="bottom-[50px] border border-border dark:border-none max-h-[270px]"
        onValueChange={handleChange}
        value={selectedValue}
        options={options ?? []}
        isLoading={isSearching}
        open={isOpen}
        onOpenChange={onOpenChange}
        onFocus={handleFocus}
        onSelect={handleSelect}
      />

      <TooltipProvider delayDuration={100}>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              variant="ghost"
              size="icon"
              onClick={toggleIncludeAlreadyMatched}
              className={cn(
                "absolute right-3 top-1/2 transform -translate-y-1/2 z-10 h-6 w-6",
                includeAlreadyMatched
                  ? "text-foreground hover:text-foreground"
                  : "text-muted-foreground hover:text-muted-foreground",
              )}
            >
              <Icons.Filter className="h-4 w-4" />
            </Button>
          </TooltipTrigger>
          <TooltipContent className="text-xs px-3 py-1.5">
            {includeAlreadyMatched
              ? "Hide already matched transactions"
              : "Show already matched transactions"}
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    </motion.div>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/suggested-match.tsx">
"use client";

import { useInboxParams } from "@/hooks/use-inbox-params";
import { useLocalStorage } from "@/hooks/use-local-storage";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { LocalStorageKeys } from "@/utils/constants";
import { formatDate } from "@/utils/format";
import { SubmitButton } from "@midday/ui/submit-button";
import { useToast } from "@midday/ui/use-toast";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { motion } from "framer-motion";
import { FormatAmount } from "../format-amount";

export function SuggestedMatch() {
  const trpc = useTRPC();
  const { params } = useInboxParams();
  const { data: user } = useUserQuery();
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const [hasSeenLearningToast, setHasSeenLearningToast] = useLocalStorage(
    LocalStorageKeys.MatchLearningToastSeen,
    false,
  );

  const id = params.inboxId;

  // Get the inbox data to check if it has status "suggested_match"
  const { data: inboxData } = useQuery(
    trpc.inbox.getById.queryOptions(
      { id: id! },
      {
        enabled: !!id,
      },
    ),
  );

  // Extract suggestion from inbox data
  const suggestion = inboxData?.suggestion;

  // Type guard to check if suggestion has suggestedTransaction
  const hasSuggestedTransaction = (
    s: any,
  ): s is {
    suggestedTransaction: {
      name: string;
      date: string;
      amount: number;
      currency: string;
    };
  } => {
    return s && "suggestedTransaction" in s && s.suggestedTransaction;
  };

  const confirmMatchMutation = useMutation(
    trpc.inbox.confirmMatch.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.inbox.getById.queryKey({ id: id! }),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.inbox.get.infiniteQueryKey(),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.searchTransactionMatch.queryKey(),
        });

        showLearningToast();
      },
    }),
  );

  const declineMatchMutation = useMutation(
    trpc.inbox.declineMatch.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.inbox.getById.queryKey({ id: id! }),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.inbox.get.infiniteQueryKey(),
        });

        showLearningToast();
      },
    }),
  );

  const showLearningToast = () => {
    if (!hasSeenLearningToast) {
      toast({
        title: "Midday AI",
        description: "We learn from your choices to improve matches over time.",
        variant: "ai",
        duration: 5000,
      });
      setHasSeenLearningToast(true);
    }
  };

  const handleConfirm = () => {
    if (suggestion && id) {
      confirmMatchMutation.mutate({
        suggestionId: suggestion.id,
        inboxId: id,
        transactionId: suggestion.transactionId,
      });
    }
  };

  const handleDecline = () => {
    if (suggestion && id) {
      declineMatchMutation.mutate({
        suggestionId: suggestion.id,
        inboxId: id,
      });
    }
  };

  return (
    <motion.div
      key="suggested-match"
      initial={{ y: 100, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      exit={{ y: 100, opacity: 0 }}
      transition={{ type: "spring", stiffness: 400, damping: 25 }}
      className="bg-white/95 dark:bg-black/95 p-4 space-y-4 border dark:border-[#2C2C2C] border-[#DCDAD2] shadow-sm"
    >
      <div className="flex items-center justify-between gap-2 text-sm bg-muted/50">
        <div className="flex flex-col gap-2">
          <div className="flex gap-2 items-center">
            <span className="truncate font-medium">
              {hasSuggestedTransaction(suggestion)
                ? suggestion.suggestedTransaction.name
                : "Transaction"}
            </span>
            <span className="text-muted-foreground">
              {hasSuggestedTransaction(suggestion) &&
                formatDate(
                  suggestion.suggestedTransaction.date,
                  user?.dateFormat,
                  true,
                )}
            </span>
          </div>

          <div className="text-xs text-muted-foreground">
            {suggestion && Math.round(suggestion.confidenceScore * 100)}%
            confidence
          </div>
        </div>

        <FormatAmount
          amount={
            hasSuggestedTransaction(suggestion)
              ? suggestion.suggestedTransaction.amount
              : 0
          }
          currency={
            hasSuggestedTransaction(suggestion)
              ? suggestion.suggestedTransaction.currency
              : "USD"
          }
        />
      </div>

      <div className="flex gap-2">
        <SubmitButton
          onClick={handleDecline}
          variant="outline"
          size="sm"
          isSubmitting={declineMatchMutation.isPending}
          className="w-full"
        >
          Decline
        </SubmitButton>
        <SubmitButton
          onClick={handleConfirm}
          size="sm"
          isSubmitting={confirmMatchMutation.isPending}
          className="w-full"
        >
          Confirm
        </SubmitButton>
      </div>
    </motion.div>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/sync-inbox-account.tsx">
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";

type Props = {
  disabled: boolean;
  onClick: () => void;
};

export function SyncInboxAccount({ onClick, disabled }: Props) {
  return (
    <TooltipProvider delayDuration={70}>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            variant="outline"
            size="icon"
            className="rounded-full w-7 h-7 flex items-center"
            disabled={disabled}
            onClick={onClick}
          >
            <Icons.Refresh size={16} />
          </Button>
        </TooltipTrigger>

        <TooltipContent className="px-3 py-1.5 text-xs" sideOffset={10}>
          Synchronize
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/transaction-match-item.tsx">
"use client";

import { formatDate } from "@/utils/format";
import { Badge } from "@midday/ui/badge";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { FormatAmount } from "../format-amount";

type Props = {
  date: string;
  name: string;
  dateFormat?: string | null;
  amount: number;
  currency: string;
  showBestMatch?: boolean;
  isAlreadyMatched?: boolean;
  matchedAttachmentFilename?: string;
};

export function TransactionMatchItem({
  date,
  name,
  dateFormat,
  amount,
  currency,
  showBestMatch = false,
  isAlreadyMatched = false,
  matchedAttachmentFilename,
}: Props) {
  const tooltipContent = matchedAttachmentFilename
    ? `Matched with "${matchedAttachmentFilename}"`
    : "Already matched";

  return (
    <div className="flex w-full items-center justify-between gap-2 text-sm">
      <div className="flex gap-2 items-center">
        <span className="truncate">{name}</span>
        <span className="text-muted-foreground">
          {formatDate(date, dateFormat, true)}
        </span>
        {isAlreadyMatched && (
          <TooltipProvider delayDuration={100}>
            <Tooltip>
              <TooltipTrigger asChild>
                <div className="flex items-center">
                  <Icons.Link className="size-3.5" />
                </div>
              </TooltipTrigger>
              <TooltipContent className="text-xs px-3 py-1.5">
                {tooltipContent}
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
      </div>

      <div className="flex flex-shrink-0 items-center gap-4">
        {showBestMatch && (
          <Badge variant="outline" className="px-2 py-0">
            Best Match
          </Badge>
        )}
        <FormatAmount amount={amount} currency={currency} />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox/transaction-unmatch-item.tsx">
"use client";

import { useInboxParams } from "@/hooks/use-inbox-params";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { Icons } from "@midday/ui/icons";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { TransactionMatchItem } from "./transaction-match-item";

export function TransactionUnmatchItem() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { params } = useInboxParams();
  const { data: user } = useUserQuery();

  const id = params.inboxId;

  const { data } = useQuery(
    trpc.inbox.getById.queryOptions(
      { id: id! },
      {
        enabled: !!id,
      },
    ),
  );

  const unmatchTransactionMutation = useMutation(
    trpc.inbox.unmatchTransaction.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.searchTransactionMatch.queryKey({
            inboxId: id ?? undefined,
          }),
        });
      },
      onMutate: async (variables) => {
        const { id } = variables;
        const queryKey = trpc.inbox.getById.queryKey({ id });

        await queryClient.cancelQueries({ queryKey });

        const previousInboxItem = queryClient.getQueryData(queryKey);

        if (previousInboxItem) {
          queryClient.setQueryData(queryKey, {
            ...previousInboxItem,
            transactionId: null,
            transaction: null,
          });
        }

        return { previousInboxItem };
      },
      onError: (_, variables, context) => {
        if (context?.previousInboxItem) {
          queryClient.setQueryData(
            trpc.inbox.getById.queryKey({ id: variables.id }),
            context.previousInboxItem,
          );
        }
      },
      onSettled: (_, __, variables) => {
        queryClient.invalidateQueries({
          queryKey: trpc.inbox.getById.queryKey({ id: variables.id }),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.inbox.get.infiniteQueryKey(),
        });
      },
    }),
  );

  if (!data?.transaction) {
    return null;
  }

  return (
    <div className="bg-background h-12 flex py-3 text-sm w-full px-4 gap-4 items-center overflow-hidden border border-border dark:border-none">
      <Icons.Check className="w-4 h-4" />

      <TransactionMatchItem
        date={data?.transaction?.date}
        name={data?.transaction?.name}
        dateFormat={user?.dateFormat}
        amount={data?.transaction?.amount}
        currency={data?.transaction?.currency}
      />

      <button
        onClick={() => unmatchTransactionMutation.mutate({ id: id! })}
        type="button"
      >
        <Icons.Delete className="w-4 h-4 text-[#878787]" />
      </button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/activity.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { cn } from "@midday/ui/cn";
import { format } from "date-fns";
import React from "react";

type ActivityItemProps = {
  label: string;
  date?: string | null;
  completed: boolean;
  isLast?: boolean;
  timeFormat?: number | null;
};

function ActivityItem({
  label,
  date,
  completed,
  isLast,
  timeFormat,
}: ActivityItemProps) {
  return (
    <li className="relative pb-6 last:pb-0">
      {!isLast && (
        <div className="absolute left-[3px] top-[20px] bottom-0 border-[0.5px] border-border" />
      )}

      <div className="flex items-center gap-3">
        <div
          className={cn(
            "relative z-10 flex size-[7px] items-center justify-center rounded-full border border-border",
            completed && "bg-[#666666] border-[#666666]",
          )}
        />

        <div className="flex flex-1 items-center justify-between">
          <span
            className={cn(
              "text-sm",
              completed ? "text-primary" : "text-[#666666]",
            )}
          >
            {label}
          </span>

          <span className="text-sm text-[#666666]">
            {date &&
              format(
                new Date(date),
                `MMM d, ${timeFormat === 24 ? "HH:mm" : "h:mm a"}`,
              )}
          </span>
        </div>
      </div>
    </li>
  );
}

type Props = {
  data: RouterOutputs["invoice"]["getById"];
};

export function InvoiceActivity({ data }: Props) {
  const { data: user } = useUserQuery();
  const completed = data?.paidAt !== null;

  return (
    <ul>
      {data?.createdAt && (
        <ActivityItem
          label="Created"
          date={data?.createdAt}
          completed
          timeFormat={user?.timeFormat ?? null}
        />
      )}
      {data?.sentAt && (
        <ActivityItem
          label="Sent"
          date={data?.sentAt}
          completed
          timeFormat={user?.timeFormat}
        />
      )}
      {data?.scheduledAt && data?.status === "scheduled" && (
        <ActivityItem
          label="Scheduled"
          date={data?.scheduledAt}
          completed={!!data?.sentAt}
          timeFormat={user?.timeFormat}
        />
      )}
      {data?.viewedAt && (
        <ActivityItem
          label="Viewed"
          date={data?.viewedAt}
          completed
          timeFormat={user?.timeFormat}
        />
      )}
      {data?.reminderSentAt && (
        <ActivityItem
          label="Reminder sent"
          date={data?.reminderSentAt}
          completed
          timeFormat={user?.timeFormat}
        />
      )}

      {data?.status !== "canceled" && (
        <ActivityItem
          label="Paid"
          date={data?.paidAt}
          completed={completed}
          isLast
          timeFormat={user?.timeFormat}
        />
      )}

      {data?.status === "canceled" && (
        <ActivityItem
          label="Canceled"
          completed
          date={data?.updatedAt}
          isLast
          timeFormat={user?.timeFormat}
        />
      )}
    </ul>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/amount-input.tsx">
import { cn } from "@midday/ui/cn";
import { CurrencyInput } from "@midday/ui/currency-input";
import { useState } from "react";
import { useController, useFormContext } from "react-hook-form";
import type { NumericFormatProps } from "react-number-format";

export function AmountInput({
  className,
  name,
  ...props
}: Omit<NumericFormatProps, "value" | "onChange"> & {
  name: string;
}) {
  const [isFocused, setIsFocused] = useState(false);
  const { control } = useFormContext();
  const {
    field: { value, onChange, onBlur },
  } = useController({
    name,
    control,
  });

  const isPlaceholder = !value && !isFocused;

  return (
    <div className="relative font-mono">
      <CurrencyInput
        autoComplete="off"
        value={value}
        onValueChange={(values) => {
          onChange(values.floatValue || 0, { shouldValidate: true });
        }}
        onFocus={() => setIsFocused(true)}
        onBlur={() => {
          setIsFocused(false);
          onBlur();
        }}
        {...props}
        className={cn(
          className,
          isPlaceholder && "opacity-0",
          "p-0 border-0 h-6 text-xs !bg-transparent border-b border-transparent focus:border-border",
        )}
        thousandSeparator={true}
      />

      {isPlaceholder && (
        <div className="absolute inset-0 pointer-events-none">
          <div className="h-full w-full bg-[repeating-linear-gradient(-60deg,#DBDBDB,#DBDBDB_1px,transparent_1px,transparent_5px)] dark:bg-[repeating-linear-gradient(-60deg,#2C2C2C,#2C2C2C_1px,transparent_1px,transparent_5px)]" />
        </div>
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/customer-details.tsx">
"use client";

import { Editor } from "@/components/invoice/editor";
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { useTRPC } from "@/trpc/client";
import { transformCustomerToContent } from "@midday/invoice/utils";
import { useMutation, useQuery } from "@tanstack/react-query";
import type { JSONContent } from "@tiptap/react";
import { useEffect } from "react";
import { Controller, useFormContext } from "react-hook-form";
import { SelectCustomer } from "../select-customer";
import { LabelInput } from "./label-input";

export function CustomerDetails() {
  const { control, setValue, watch } = useFormContext();
  const { setParams, selectedCustomerId } = useInvoiceParams();

  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  const content = watch("customerDetails");
  const id = watch("id");

  const { data: customer } = useQuery(
    trpc.customers.getById.queryOptions(
      { id: selectedCustomerId! },
      {
        enabled: !!selectedCustomerId,
      },
    ),
  );

  const handleLabelSave = (value: string) => {
    updateTemplateMutation.mutate({ customerLabel: value });
  };

  const handleOnChange = (content?: JSONContent | null) => {
    // Reset the selected customer id when the content is changed
    setParams({ selectedCustomerId: null });

    setValue("customerDetails", content, {
      shouldValidate: true,
      shouldDirty: true,
    });

    if (!content) {
      setValue("customerName", null, {
        shouldValidate: true,
        shouldDirty: true,
      });
      setValue("customerId", null, { shouldValidate: true, shouldDirty: true });
    }
  };

  useEffect(() => {
    if (customer) {
      const customerContent = transformCustomerToContent(customer);

      // Remove the selected customer id from the url so we don't introduce a race condition
      setParams({ selectedCustomerId: null });

      setValue("customerName", customer.name, {
        shouldValidate: true,
        shouldDirty: true,
      });
      setValue("customerId", customer.id, {
        shouldValidate: true,
        shouldDirty: true,
      });
      setValue("customerDetails", customerContent, {
        shouldValidate: true,
        shouldDirty: true,
      });
    }
  }, [customer]);

  return (
    <div>
      <LabelInput
        name="template.customerLabel"
        className="mb-2 block"
        onSave={handleLabelSave}
      />
      {content ? (
        <Controller
          name="customerDetails"
          control={control}
          render={({ field }) => (
            <Editor
              // NOTE: This is a workaround to get the new content to render
              key={id}
              initialContent={field.value}
              onChange={handleOnChange}
              className="min-h-[90px]"
            />
          )}
        />
      ) : (
        <SelectCustomer />
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/description.tsx">
"use client";

import { isValidJSON } from "@midday/invoice/content";
import { cn } from "@midday/ui/cn";
import type { JSONContent } from "@tiptap/react";
import { useFormContext } from "react-hook-form";
import { Editor } from "./editor";

export function Description({
  className,
  name,
  ...props
}: React.ComponentProps<typeof Editor> & { name: string }) {
  const { watch, setValue } = useFormContext();
  const fieldValue = watch(name);

  const handleOnChange = (content?: JSONContent | null) => {
    const value = content ? JSON.stringify(content) : null;

    setValue(name, value, {
      shouldValidate: true,
      shouldDirty: true,
    });
  };

  return (
    <div className="relative">
      <Editor
        key={name}
        initialContent={
          isValidJSON(fieldValue) ? JSON.parse(fieldValue) : fieldValue
        }
        onChange={handleOnChange}
        className={cn(
          "border-0 p-0 min-h-6 border-b border-transparent focus:border-border font-mono text-xs pt-1",
          "transition-colors duration-200",
          className,
        )}
        {...props}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/due-date.tsx">
import { useTRPC } from "@/trpc/client";
import { TZDate } from "@date-fns/tz";
import { Calendar } from "@midday/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@midday/ui/popover";
import { useMutation } from "@tanstack/react-query";
import { format } from "date-fns";
import { useState } from "react";
import { useFormContext } from "react-hook-form";
import { LabelInput } from "./label-input";

export function DueDate() {
  const { setValue, watch } = useFormContext();
  const dueDate = watch("dueDate");
  const dateFormat = watch("template.dateFormat");

  const [isOpen, setIsOpen] = useState(false);

  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  const handleSelect = (date: Date | undefined) => {
    if (date) {
      setValue("dueDate", date.toISOString(), {
        shouldValidate: true,
        shouldDirty: true,
      });
      setIsOpen(false);
    }
  };

  return (
    <div className="flex space-x-1 items-center">
      <div className="flex items-center">
        <LabelInput
          name="template.dueDateLabel"
          onSave={(value) => {
            updateTemplateMutation.mutate({ dueDateLabel: value });
          }}
        />
        <span className="text-[11px] text-[#878787] font-mono">:</span>
      </div>
      <Popover open={isOpen} onOpenChange={setIsOpen} modal>
        <PopoverTrigger className="text-primary text-[11px] font-mono whitespace-nowrap flex">
          {dueDate && format(dueDate, dateFormat)}
        </PopoverTrigger>
        <PopoverContent className="w-auto p-0">
          <Calendar
            mode="single"
            selected={dueDate ? new TZDate(dueDate, "UTC") : undefined}
            onSelect={handleSelect}
            initialFocus
          />
        </PopoverContent>
      </Popover>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/edit-block.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { Controller, useFormContext } from "react-hook-form";
import { Editor } from "./editor";
import type { InvoiceFormValues } from "./form-context";

type Props = {
  name: keyof InvoiceFormValues;
};

export function EditBlock({ name }: Props) {
  const { control, watch } = useFormContext();
  const id = watch("id");

  return (
    <div className="group">
      <Controller
        name={name}
        control={control}
        render={({ field }) => (
          <Editor
            // NOTE: This is a workaround to get the new content to render
            key={id}
            tabIndex={-1}
            initialContent={field.value}
            onChange={field.onChange}
            placeholder="Write something..."
            disablePlaceholder
            className={cn(
              "transition-opacity",
              field.value ? "opacity-100" : "opacity-0 group-hover:opacity-100",
            )}
          />
        )}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/editor.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { Editor as BaseEditor } from "@midday/ui/editor";
import type { Editor as EditorInstance, JSONContent } from "@tiptap/react";
import { useCallback, useState } from "react";

type Props = {
  initialContent?: JSONContent;
  className?: string;
  onChange?: (content?: JSONContent | null) => void;
  onBlur?: (content: JSONContent | null) => void;
  placeholder?: string;
  disablePlaceholder?: boolean;
  tabIndex?: number;
};

export function Editor({
  initialContent,
  className,
  onChange,
  onBlur,
  placeholder,
  disablePlaceholder = false,
  tabIndex,
}: Props) {
  const [isFocused, setIsFocused] = useState(false);
  const [content, setContent] = useState<JSONContent | null | undefined>(
    initialContent,
  );

  const handleUpdate = useCallback(
    (editor: EditorInstance) => {
      const json = editor.getJSON();
      const newIsEmpty = editor.state.doc.textContent.length === 0;

      setContent(newIsEmpty ? null : json);
      onChange?.(newIsEmpty ? null : json);
    },
    [onChange],
  );

  const handleBlur = useCallback(() => {
    setIsFocused(false);

    // Only call onBlur if the content has changed
    if (content !== initialContent) {
      onBlur?.(content ?? null);
    }
    onBlur?.(content ?? null);
  }, [content, onBlur]);

  const showPlaceholder = !disablePlaceholder && !content && !isFocused;

  return (
    <BaseEditor
      className={cn(
        "font-mono text-[11px] text-primary leading-[18px] invoice-editor",
        showPlaceholder &&
          "w-full bg-[repeating-linear-gradient(-60deg,#DBDBDB,#DBDBDB_1px,transparent_1px,transparent_5px)] dark:bg-[repeating-linear-gradient(-60deg,#2C2C2C,#2C2C2C_1px,transparent_1px,transparent_5px)]",
        className,
      )}
      placeholder={placeholder}
      initialContent={content ?? undefined}
      onUpdate={handleUpdate}
      onFocus={() => setIsFocused(true)}
      onBlur={handleBlur}
      tabIndex={tabIndex}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/form-context.tsx">
"use client";

import { useZodForm } from "@/hooks/use-zod-form";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { useEffect } from "react";
import { FormProvider } from "react-hook-form";
import { z } from "zod";

export const invoiceTemplateSchema = z.object({
  title: z.string().optional(),
  customerLabel: z.string(),
  fromLabel: z.string(),
  invoiceNoLabel: z.string(),
  issueDateLabel: z.string(),
  dueDateLabel: z.string(),
  descriptionLabel: z.string(),
  priceLabel: z.string(),
  quantityLabel: z.string(),
  totalLabel: z.string(),
  totalSummaryLabel: z.string().optional(),
  vatLabel: z.string().optional(),
  subtotalLabel: z.string().optional(),
  taxLabel: z.string().optional(),
  discountLabel: z.string().optional(),
  paymentLabel: z.string(),
  noteLabel: z.string(),
  logoUrl: z.string().optional().nullable(),
  currency: z.string(),
  paymentDetails: z.any().nullable().optional(),
  fromDetails: z.any().nullable().optional(),
  size: z.enum(["a4", "letter"]),
  includeVat: z.boolean().optional(),
  includeTax: z.boolean().optional(),
  includeDiscount: z.boolean().optional(),
  includeDecimals: z.boolean().optional(),
  includePdf: z.boolean().optional(),
  includeUnits: z.boolean().optional(),
  includeQr: z.boolean().optional(),
  taxRate: z.number().min(0).max(100).optional(),
  vatRate: z.number().min(0).max(100).optional(),
  dateFormat: z.enum(["dd/MM/yyyy", "MM/dd/yyyy", "yyyy-MM-dd", "dd.MM.yyyy"]),
  deliveryType: z.enum(["create", "create_and_send", "scheduled"]),
  locale: z.string().optional(),
  timezone: z.string().optional(),
});

export const lineItemSchema = z.object({
  name: z.string().min(1, "Name is required"),
  quantity: z.number().min(0, "Quantity must be at least 0"),
  unit: z.string().optional(),
  price: z.number(),
  vat: z.number().min(0, "VAT must be at least 0").optional(),
  tax: z.number().min(0, "Tax must be at least 0").optional(),
});

export const invoiceFormSchema = z.object({
  id: z.string().uuid(),
  status: z.string(),
  template: invoiceTemplateSchema,
  fromDetails: z.any(),
  customerDetails: z.any(),
  customerId: z.string().uuid(),
  customerName: z.string().optional(),
  paymentDetails: z.any(),
  noteDetails: z.any().optional(),
  dueDate: z.string(),
  issueDate: z.string(),
  invoiceNumber: z.string(),
  logoUrl: z.string().nullable().optional(),
  vat: z.number().nullable().optional(),
  tax: z.number().nullable().optional(),
  discount: z.number().nullable().optional(),
  subtotal: z.number().nullable().optional(),
  topBlock: z.any().nullable().optional(),
  bottomBlock: z.any().nullable().optional(),
  amount: z.number(),
  lineItems: z.array(lineItemSchema).min(1),
  token: z.string().optional(),
  scheduledAt: z.string().nullable().optional(),
});

export type InvoiceFormValues = z.infer<typeof invoiceFormSchema>;

type FormContextProps = {
  children: React.ReactNode;
  data?: RouterOutputs["invoice"]["getById"];
  defaultSettings?: RouterOutputs["invoice"]["defaultSettings"];
};

export function FormContext({
  children,
  data,
  defaultSettings,
}: FormContextProps) {
  const form = useZodForm(invoiceFormSchema, {
    // @ts-expect-error
    defaultValues: defaultSettings,
    mode: "onChange",
  });

  useEffect(() => {
    form.reset({
      ...(defaultSettings ?? {}),
      ...(data ?? {}),
      // @ts-expect-error
      template: {
        ...(defaultSettings?.template ?? {}),
        ...(data?.template ?? {}),
      },
      customerId: data?.customerId ?? defaultSettings?.customerId ?? undefined,
    });
  }, [data, defaultSettings]);

  return <FormProvider {...form}>{children}</FormProvider>;
}
</file>

<file path="apps/dashboard/src/components/invoice/form.tsx">
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { useTRPC } from "@/trpc/client";
import { getUrl } from "@/utils/environment";
import { formatRelativeTime } from "@/utils/format";
import { Icons } from "@midday/ui/icons";
import { ScrollArea } from "@midday/ui/scroll-area";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useEffect, useState } from "react";
import { useFormContext, useWatch } from "react-hook-form";
import { useDebounceValue } from "usehooks-ts";
import { OpenURL } from "../open-url";
import { CustomerDetails } from "./customer-details";
import { EditBlock } from "./edit-block";
import type { InvoiceFormValues } from "./form-context";
import { FromDetails } from "./from-details";
import { LineItems } from "./line-items";
import { Logo } from "./logo";
import { Meta } from "./meta";
import { NoteDetails } from "./note-details";
import { PaymentDetails } from "./payment-details";
import { SubmitButton } from "./submit-button";
import { Summary } from "./summary";
import { transformFormValuesToDraft } from "./utils";

export function Form() {
  const { invoiceId, setParams } = useInvoiceParams();
  const [lastUpdated, setLastUpdated] = useState<Date | undefined>();
  const [lastEditedText, setLastEditedText] = useState("");

  const form = useFormContext();
  const token = form.watch("token");

  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const draftInvoiceMutation = useMutation(
    trpc.invoice.draft.mutationOptions({
      onSuccess: (data) => {
        if (!invoiceId && data?.id) {
          setParams({ type: "edit", invoiceId: data.id });
        }

        setLastUpdated(new Date());

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.invoiceSummary.queryKey(),
        });
      },
    }),
  );

  const createInvoiceMutation = useMutation(
    trpc.invoice.create.mutationOptions({
      onSuccess: (data) => {
        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.getById.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.invoiceSummary.queryKey(),
        });

        // Invalidate global search
        queryClient.invalidateQueries({
          queryKey: trpc.search.global.queryKey(),
        });

        setParams({ type: "success", invoiceId: data.id });
      },
    }),
  );

  // Only watch the fields that are used in the upsert action
  const formValues = useWatch({
    control: form.control,
    name: [
      "customerDetails",
      "customerId",
      "customerName",
      "template",
      "lineItems",
      "amount",
      "vat",
      "tax",
      "discount",
      "dueDate",
      "issueDate",
      "noteDetails",
      "paymentDetails",
      "fromDetails",
      "invoiceNumber",
      "topBlock",
      "bottomBlock",
      "scheduledAt",
    ],
  });

  const isDirty = form.formState.isDirty;
  const invoiceNumberValid = !form.getFieldState("invoiceNumber").error;
  const [debouncedValue] = useDebounceValue(formValues, 500);

  useEffect(() => {
    if (isDirty && form.watch("customerId") && invoiceNumberValid) {
      const currentFormValues = form.getValues();
      draftInvoiceMutation.mutate(
        // @ts-expect-error
        transformFormValuesToDraft(currentFormValues),
      );
    }
  }, [debouncedValue, isDirty, invoiceNumberValid]);

  useEffect(() => {
    const updateLastEditedText = () => {
      if (!lastUpdated) {
        setLastEditedText("");
        return;
      }

      setLastEditedText(`Edited ${formatRelativeTime(lastUpdated)}`);
    };

    updateLastEditedText();
    const intervalId = setInterval(updateLastEditedText, 1000);

    return () => clearInterval(intervalId);
  }, [lastUpdated]);

  // Submit the form and the draft invoice
  const handleSubmit = (values: InvoiceFormValues) => {
    createInvoiceMutation.mutate({
      id: values.id,
      deliveryType: values.template.deliveryType ?? "create",
      scheduledAt: values.scheduledAt || undefined,
    });
  };

  // Prevent form from submitting when pressing enter
  const handleKeyDown = (e: React.KeyboardEvent<HTMLFormElement>) => {
    if (e.key === "Enter") {
      e.preventDefault();
    }
  };

  return (
    <form
      // @ts-expect-error
      onSubmit={form.handleSubmit(handleSubmit)}
      className="relative h-full"
      onKeyDown={handleKeyDown}
    >
      <ScrollArea className="h-[calc(100vh-200px)] bg-background" hideScrollbar>
        <div className="p-8 pb-4 h-full flex flex-col">
          <div className="flex justify-between">
            <Meta />
            <Logo />
          </div>

          <div className="grid grid-cols-2 gap-6 mt-8 mb-4">
            <div>
              <FromDetails />
            </div>
            <div>
              <CustomerDetails />
            </div>
          </div>

          <EditBlock name="topBlock" />

          <div className="mt-4">
            <LineItems />
          </div>

          <div className="mt-12 flex justify-end mb-8">
            <Summary />
          </div>

          <div className="flex flex-col mt-auto">
            <div className="grid grid-cols-2 gap-6 mb-4 overflow-hidden">
              <PaymentDetails />
              <NoteDetails />
            </div>

            <EditBlock name="bottomBlock" />
          </div>
        </div>
      </ScrollArea>

      <div className="absolute bottom-14 w-full h-9">
        <div className="flex justify-between items-center mt-auto">
          <div className="flex space-x-2 items-center text-xs text-[#808080]">
            {token && (
              <>
                <OpenURL
                  href={`${getUrl()}/i/${token}`}
                  className="flex items-center gap-1"
                >
                  <Icons.ExternalLink className="size-3" />
                  <span>Preview invoice</span>
                </OpenURL>

                {(draftInvoiceMutation.isPending || lastEditedText) && (
                  <span>-</span>
                )}
              </>
            )}

            {(draftInvoiceMutation.isPending || lastEditedText) && (
              <span>
                {draftInvoiceMutation.isPending ? "Saving" : lastEditedText}
              </span>
            )}
          </div>

          <SubmitButton
            isSubmitting={createInvoiceMutation.isPending}
            disabled={
              createInvoiceMutation.isPending || draftInvoiceMutation.isPending
            }
          />
        </div>
      </div>
    </form>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/from-details.tsx">
"use client";

import { Editor } from "@/components/invoice/editor";
import { useTRPC } from "@/trpc/client";
import { useMutation } from "@tanstack/react-query";
import { Controller, useFormContext } from "react-hook-form";
import { LabelInput } from "./label-input";

export function FromDetails() {
  const { control, watch } = useFormContext();
  const id = watch("id");

  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  return (
    <div>
      <LabelInput
        name="template.fromLabel"
        className="mb-2 block"
        onSave={(value) => {
          updateTemplateMutation.mutate({ fromLabel: value });
        }}
      />

      <Controller
        name="fromDetails"
        control={control}
        render={({ field }) => (
          <Editor
            // NOTE: This is a workaround to get the new content to render
            key={id}
            initialContent={field.value}
            onChange={field.onChange}
            onBlur={(content) => {
              updateTemplateMutation.mutate({
                fromDetails: content ? JSON.stringify(content) : null,
              });
            }}
            className="min-h-[90px] [&>div]:min-h-[90px]"
          />
        )}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/input.tsx">
import { cn } from "@midday/ui/cn";
import { Input as BaseInput, type InputProps } from "@midday/ui/input";
import { useState } from "react";
import { useFormContext } from "react-hook-form";

export function Input({ className, ...props }: InputProps) {
  const { register, watch } = useFormContext();
  const [isFocused, setIsFocused] = useState(false);
  const fieldName = props.name as string;
  const fieldValue = watch(fieldName);

  const { ref, ...rest } = register(fieldName, {
    valueAsNumber: props.type === "number",
  });

  const isPlaceholder = !fieldValue && !isFocused;

  return (
    <div className="relative">
      <BaseInput
        {...props}
        {...rest}
        ref={ref}
        autoComplete="off"
        value={fieldValue || ""}
        className={cn(
          "border-0 p-0 h-6 border-b border-transparent focus:border-border font-mono text-xs",
          isPlaceholder && "opacity-0",
          className,
        )}
        onFocus={(evt) => {
          setIsFocused(true);
          props.onFocus?.(evt);
        }}
        onBlur={(evt) => {
          setIsFocused(false);
          props.onBlur?.(evt);
        }}
      />
      {isPlaceholder && (
        <div className="absolute inset-0 pointer-events-none">
          <div className="h-full w-full bg-[repeating-linear-gradient(-60deg,#DBDBDB,#DBDBDB_1px,transparent_1px,transparent_5px)] dark:bg-[repeating-linear-gradient(-60deg,#2C2C2C,#2C2C2C_1px,transparent_1px,transparent_5px)]" />
        </div>
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/invoice-no.tsx">
"use client";

import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { useTRPC } from "@/trpc/client";
import { cn } from "@midday/ui/cn";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useMutation, useQuery } from "@tanstack/react-query";
import { useEffect } from "react";
import { useFormContext } from "react-hook-form";
import { Input } from "./input";
import { LabelInput } from "./label-input";

export function InvoiceNo() {
  const {
    watch,
    setError,
    clearErrors,
    formState: { errors },
  } = useFormContext();
  const invoiceNumber = watch("invoiceNumber");
  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  const { type } = useInvoiceParams();

  const { data } = useQuery(
    trpc.invoice.searchInvoiceNumber.queryOptions(
      {
        query: invoiceNumber,
      },
      {
        // Only search for invoice number if we are creating a new invoice
        enabled: type === "create" && invoiceNumber !== "",
        // Never cache the result
        gcTime: 0,
      },
    ),
  );

  useEffect(() => {
    if (data) {
      setError("invoiceNumber", {
        type: "manual",
        message: "Invoice number already exists",
      });
    } else {
      clearErrors("invoiceNumber");
    }
  }, [data]);

  return (
    <div className="flex space-x-1 items-center">
      <div className="flex items-center flex-shrink-0">
        <LabelInput
          name="template.invoiceNoLabel"
          onSave={(value) => {
            updateTemplateMutation.mutate({ invoiceNoLabel: value });
          }}
          className="truncate"
        />
        <span className="text-[11px] text-[#878787] font-mono flex-shrink-0">
          :
        </span>
      </div>

      <TooltipProvider delayDuration={100}>
        <Tooltip>
          <TooltipTrigger asChild>
            <div>
              <Input
                name="invoiceNumber"
                className={cn(
                  "w-28 flex-shrink p-0 border-none text-[11px] h-4.5 overflow-hidden",
                  errors.invoiceNumber ? "text-red-500" : "",
                )}
              />
            </div>
          </TooltipTrigger>
          {errors.invoiceNumber && (
            <TooltipContent className="text-xs px-3 py-1.5">
              <p>Invoice number already exists</p>
            </TooltipContent>
          )}
        </Tooltip>
      </TooltipProvider>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/invoice-title.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { useMutation } from "@tanstack/react-query";
import { useFormContext } from "react-hook-form";
import { Input } from "./input";

export function InvoiceTitle() {
  const { watch } = useFormContext();
  const invoiceTitle = watch("template.title");

  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  return (
    <Input
      className="text-[21px] font-medium mb-2 w-fit min-w-[100px] !border-none"
      name="template.title"
      onBlur={() => {
        updateTemplateMutation.mutate({ title: invoiceTitle });
      }}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/issue-date.tsx">
import { useTRPC } from "@/trpc/client";
import { TZDate } from "@date-fns/tz";
import { Calendar } from "@midday/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@midday/ui/popover";
import { useMutation } from "@tanstack/react-query";
import { format } from "date-fns";
import { useState } from "react";
import { useFormContext } from "react-hook-form";
import { LabelInput } from "./label-input";

export function IssueDate() {
  const { setValue, watch } = useFormContext();
  const issueDate = watch("issueDate");
  const dateFormat = watch("template.dateFormat");
  const [isOpen, setIsOpen] = useState(false);

  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  const handleSelect = (date: Date | undefined) => {
    if (date) {
      setValue("issueDate", date.toISOString(), {
        shouldValidate: true,
        shouldDirty: true,
      });
      setIsOpen(false);
    }
  };

  return (
    <div className="flex space-x-1 items-center">
      <div className="flex items-center">
        <LabelInput
          name="template.issueDateLabel"
          onSave={(value) => {
            updateTemplateMutation.mutate({ issueDateLabel: value });
          }}
        />
        <span className="text-[11px] text-[#878787] font-mono">:</span>
      </div>

      <Popover open={isOpen} onOpenChange={setIsOpen} modal>
        <PopoverTrigger className="text-primary text-[11px] font-mono whitespace-nowrap flex">
          {issueDate && format(issueDate, dateFormat)}
        </PopoverTrigger>
        <PopoverContent className="w-auto p-0">
          <Calendar
            mode="single"
            selected={issueDate ? new TZDate(issueDate, "UTC") : undefined}
            onSelect={handleSelect}
            initialFocus
          />
        </PopoverContent>
      </Popover>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/label-input.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { useFormContext } from "react-hook-form";

type Props = {
  name: string;
  required?: boolean;
  className?: string;
  onSave?: (value: string) => void;
};

export function LabelInput({ name, className, onSave }: Props) {
  const { setValue, watch } = useFormContext();
  const value = watch(name);

  return (
    <span
      className={cn(
        "text-[11px] text-[#878787] min-w-10 font-mono outline-none",
        className,
      )}
      id={name}
      contentEditable
      suppressContentEditableWarning
      onBlur={(e) => {
        const newValue = e.currentTarget.textContent || "";
        setValue(name, newValue, { shouldValidate: true, shouldDirty: true });

        // Only call onSave if the value has changed
        if (newValue !== value) {
          onSave?.(newValue);
        }
      }}
    >
      {value}
    </span>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/line-items.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { formatAmount } from "@/utils/format";
import { calculateLineItemTotal } from "@midday/invoice/calculate";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { useMutation } from "@tanstack/react-query";
import { Reorder, useDragControls } from "framer-motion";
import { useFieldArray, useFormContext, useWatch } from "react-hook-form";
import { AmountInput } from "./amount-input";
import { Description } from "./description";
import type { InvoiceFormValues } from "./form-context";
import { Input } from "./input";
import { LabelInput } from "./label-input";
import { QuantityInput } from "./quantity-input";

export function LineItems() {
  const { control } = useFormContext();
  const currency = useWatch({ control, name: "template.currency" });

  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  const includeDecimals = useWatch({
    control,
    name: "template.includeDecimals",
  });

  const includeUnits = useWatch({
    control,
    name: "template.includeUnits",
  });

  const maximumFractionDigits = includeDecimals ? 2 : 0;

  const { fields, append, remove, swap } = useFieldArray({
    control,
    name: "lineItems",
  });

  const reorderList = (newFields: typeof fields) => {
    const firstDiffIndex = fields.findIndex(
      (field, index) => field.id !== newFields[index]?.id,
    );

    if (firstDiffIndex !== -1) {
      const newIndex = newFields.findIndex(
        (field) => field.id === fields[firstDiffIndex]?.id,
      );

      if (newIndex !== -1) {
        swap(firstDiffIndex, newIndex);
      }
    }
  };

  const handleRemove = (index: number) => {
    if (fields.length > 1) {
      remove(index);
    }
  };

  return (
    <div className="space-y-4">
      <div
        className={`grid ${includeUnits ? "grid-cols-[1.5fr_15%25%_15%]" : "grid-cols-[1.5fr_15%_15%_15%]"} gap-4 items-end mb-2`}
      >
        <LabelInput
          name="template.descriptionLabel"
          onSave={(value) => {
            updateTemplateMutation.mutate({
              descriptionLabel: value,
            });
          }}
          className="truncate"
        />

        <LabelInput
          name="template.quantityLabel"
          onSave={(value) => {
            updateTemplateMutation.mutate({
              quantityLabel: value,
            });
          }}
          className="truncate"
        />

        <LabelInput
          name="template.priceLabel"
          onSave={(value) => {
            updateTemplateMutation.mutate({
              priceLabel: value,
            });
          }}
          className="truncate"
        />

        <LabelInput
          name="template.totalLabel"
          onSave={(value) => {
            updateTemplateMutation.mutate({
              totalLabel: value,
            });
          }}
          className="text-right truncate"
        />
      </div>

      <Reorder.Group
        axis="y"
        values={fields}
        onReorder={reorderList}
        className="!m-0"
      >
        {fields.map((field, index) => (
          <LineItemRow
            key={field.id}
            // @ts-expect-error
            item={field}
            index={index}
            handleRemove={handleRemove}
            isReorderable={fields.length > 1}
            currency={currency}
            maximumFractionDigits={maximumFractionDigits}
            includeUnits={includeUnits}
          />
        ))}
      </Reorder.Group>

      <button
        type="button"
        onClick={() =>
          append({
            name: "",
            quantity: 0,
            price: 0,
          })
        }
        className="flex items-center space-x-2 text-xs text-[#878787] font-mono"
      >
        <Icons.Add />
        <span className="text-[11px]">Add item</span>
      </button>
    </div>
  );
}

function LineItemRow({
  index,
  handleRemove,
  isReorderable,
  item,
  currency,
  maximumFractionDigits,
  includeUnits,
}: {
  index: number;
  handleRemove: (index: number) => void;
  isReorderable: boolean;
  item: InvoiceFormValues["lineItems"][number];
  currency: string;
  maximumFractionDigits: number;
  includeUnits?: boolean;
}) {
  const controls = useDragControls();
  const { control } = useFormContext();

  const locale = useWatch({ control, name: "template.locale" });

  const price = useWatch({
    control,
    name: `lineItems.${index}.price`,
  });

  const quantity = useWatch({
    control,
    name: `lineItems.${index}.quantity`,
  });

  return (
    <Reorder.Item
      className={`grid ${includeUnits ? "grid-cols-[1.5fr_15%25%_15%]" : "grid-cols-[1.5fr_15%_15%_15%]"} gap-4 items-start relative group mb-2 w-full`}
      value={item}
      dragListener={false}
      dragControls={controls}
    >
      {isReorderable && (
        <Button
          type="button"
          className="absolute -left-9 -top-[4px] opacity-0 group-hover:opacity-100 transition-opacity hover:bg-transparent cursor-grab"
          onPointerDown={(e) => controls.start(e)}
          variant="ghost"
        >
          <Icons.DragIndicator className="size-4 text-[#878787]" />
        </Button>
      )}

      <Description name={`lineItems.${index}.name`} />

      <QuantityInput name={`lineItems.${index}.quantity`} />

      <div className="flex items-center gap-2">
        <AmountInput name={`lineItems.${index}.price`} />
        {includeUnits && <span className="text-xs text-[#878787]">/</span>}
        {includeUnits && <Input name={`lineItems.${index}.unit`} />}
      </div>

      <div className="text-right">
        <span className="text-xs text-primary font-mono">
          {formatAmount({
            amount: calculateLineItemTotal({
              price,
              quantity,
            }),
            currency,
            locale,
            maximumFractionDigits,
          })}
        </span>
      </div>

      {index !== 0 && (
        <Button
          type="button"
          onClick={() => handleRemove(index)}
          className="absolute -right-9 -top-[4px] opacity-0 group-hover:opacity-100 transition-opacity hover:bg-transparent text-[#878787]"
          variant="ghost"
        >
          <Icons.Close />
        </Button>
      )}
    </Reorder.Item>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/logo.tsx">
"use client";

import { useUpload } from "@/hooks/use-upload";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { Icons } from "@midday/ui/icons";
import { Skeleton } from "@midday/ui/skeleton";
import { useToast } from "@midday/ui/use-toast";
import { useMutation } from "@tanstack/react-query";
import { useFormContext } from "react-hook-form";

export function Logo() {
  const { watch, setValue } = useFormContext();
  const logoUrl = watch("template.logoUrl");
  const { uploadFile, isLoading } = useUpload();
  const { toast } = useToast();

  const { data: user } = useUserQuery();

  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  const handleUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      try {
        const { url } = await uploadFile({
          file,
          path: [user?.teamId ?? "", "invoice", file.name],
          bucket: "avatars",
        });

        setValue("template.logoUrl", url, {
          shouldValidate: true,
          shouldDirty: true,
        });

        updateTemplateMutation.mutate({ logoUrl: url });
      } catch (error) {
        toast({
          title: "Something went wrong, please try again.",
          variant: "error",
        });
      }
    }
  };

  return (
    <div className="relative h-[80px] group">
      <label htmlFor="logo-upload" className="block h-full">
        {isLoading ? (
          <Skeleton className="w-full h-full" />
        ) : logoUrl ? (
          <>
            <img
              src={logoUrl}
              alt="Invoice logo"
              className="h-full w-auto max-w-none object-contain"
            />
            <button
              type="button"
              className="absolute inset-0 bg-black bg-opacity-50 text-white flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity flex-col gap-1"
              style={{ width: "auto" }}
              onClick={(e) => {
                e.preventDefault();
                setValue("template.logoUrl", undefined, {
                  shouldValidate: true,
                  shouldDirty: true,
                });
                updateTemplateMutation.mutate({ logoUrl: null });
              }}
            >
              <Icons.Clear className="size-4" />
              <span className="text-xs font-medium">Remove</span>
            </button>
          </>
        ) : (
          <div className="h-[80px] w-[80px] bg-[repeating-linear-gradient(-60deg,#DBDBDB,#DBDBDB_1px,transparent_1px,transparent_5px)] dark:bg-[repeating-linear-gradient(-60deg,#2C2C2C,#2C2C2C_1px,transparent_1px,transparent_5px)]" />
        )}
      </label>

      <input
        id="logo-upload"
        type="file"
        accept="image/jpeg,image/jpg,image/png"
        className="hidden"
        onChange={handleUpload}
        disabled={isLoading}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/meta.tsx">
import { DueDate } from "./due-date";
import { InvoiceNo } from "./invoice-no";
import { InvoiceTitle } from "./invoice-title";
import { IssueDate } from "./issue-date";

export function Meta() {
  return (
    <div>
      <InvoiceTitle />

      <div className="flex flex-col gap-0.5">
        <div>
          <InvoiceNo />
        </div>
        <div>
          <IssueDate />
        </div>
        <div>
          <DueDate />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/note-details.tsx">
"use client";

import { Editor } from "@/components/invoice/editor";
import { useTRPC } from "@/trpc/client";
import { useMutation } from "@tanstack/react-query";
import { Controller, useFormContext } from "react-hook-form";
import { LabelInput } from "./label-input";

export function NoteDetails() {
  const { control, watch } = useFormContext();
  const id = watch("id");

  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  return (
    <div>
      <LabelInput
        name="template.noteLabel"
        onSave={(value) => {
          updateTemplateMutation.mutate({ noteLabel: value });
        }}
        className="mb-2 block"
      />

      <Controller
        control={control}
        name="noteDetails"
        render={({ field }) => {
          return (
            <Editor
              // NOTE: This is a workaround to get the new content to render
              key={id}
              initialContent={field.value}
              onChange={field.onChange}
              className="min-h-[78px]"
            />
          );
        }}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/payment-details.tsx">
"use client";

import { Editor } from "@/components/invoice/editor";
import { useTRPC } from "@/trpc/client";
import { useMutation } from "@tanstack/react-query";
import { Controller, useFormContext } from "react-hook-form";
import { LabelInput } from "./label-input";

export function PaymentDetails() {
  const { control, watch } = useFormContext();
  const id = watch("id");

  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  return (
    <div>
      <LabelInput
        name="template.paymentLabel"
        onSave={(value) => {
          updateTemplateMutation.mutate({ paymentLabel: value });
        }}
        className="mb-2 block"
      />

      <Controller
        control={control}
        name="paymentDetails"
        render={({ field }) => (
          <Editor
            // NOTE: This is a workaround to get the new content to render
            key={id}
            initialContent={field.value}
            onChange={field.onChange}
            onBlur={(content) => {
              updateTemplateMutation.mutate({
                paymentDetails: content ? JSON.stringify(content) : null,
              });
            }}
            className="min-h-[78px]"
          />
        )}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/quantity-input.tsx">
import { cn } from "@midday/ui/cn";
import { QuantityInput as BaseQuantityInput } from "@midday/ui/quantity-input";
import { useState } from "react";
import { useController, useFormContext } from "react-hook-form";

export function QuantityInput({
  name,
  ...props
}: { name: string } & Omit<Parameters<typeof BaseQuantityInput>[0], "value">) {
  const [isFocused, setIsFocused] = useState(false);

  const { control } = useFormContext();
  const {
    field: { value, onChange, onBlur },
  } = useController({
    name,
    control,
  });

  const isPlaceholder = !value && !isFocused;

  return (
    <div className="relative">
      <BaseQuantityInput
        {...props}
        value={value}
        min={0}
        step={0.01}
        onChange={onChange}
        onFocus={() => setIsFocused(true)}
        className={cn(
          isPlaceholder && "opacity-0 [&_button]:pointer-events-none",
        )}
        onBlur={() => {
          setIsFocused(false);
          onBlur();
        }}
      />

      {isPlaceholder && (
        <div className="absolute inset-0 pointer-events-none">
          <div className="h-full w-full bg-[repeating-linear-gradient(-60deg,#DBDBDB,#DBDBDB_1px,transparent_1px,transparent_5px)] dark:bg-[repeating-linear-gradient(-60deg,#2C2C2C,#2C2C2C_1px,transparent_1px,transparent_5px)]" />
        </div>
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/settings-menu.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { uniqueCurrencies } from "@midday/location/currencies";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { useMutation } from "@tanstack/react-query";
import { useFormContext } from "react-hook-form";
import { SelectCurrency } from "../select-currency";

const dateFormats = [
  { value: "dd/MM/yyyy", label: "DD/MM/YYYY" },
  { value: "MM/dd/yyyy", label: "MM/DD/YYYY" },
  { value: "yyyy-MM-dd", label: "YYYY-MM-DD" },
  { value: "dd.MM.yyyy", label: "dd.MM.yyyy" },
];

const invoiceSizes = [
  { value: "a4", label: "A4" },
  { value: "letter", label: "Letter" },
];

const booleanOptions = [
  { value: true, label: "Yes" },
  { value: false, label: "No" },
];

const menuItems = [
  {
    icon: Icons.DateFormat,
    label: "Date format",
    options: dateFormats,
    key: "dateFormat",
  },
  {
    icon: Icons.CropFree,
    label: "Invoice size",
    options: invoiceSizes,
    key: "size",
  },
  {
    icon: Icons.Tax,
    label: "Add sales tax",
    options: booleanOptions,
    key: "includeTax",
  },
  {
    icon: Icons.Vat,
    label: "Add VAT",
    options: booleanOptions,
    key: "includeVat",
  },
  {
    icon: Icons.CurrencyOutline,
    label: "Currency",
    options: uniqueCurrencies.map((currency) => ({
      value: currency,
      label: currency,
    })),
    key: "currency",
  },
  {
    icon: Icons.ConfirmationNumber,
    label: "Add discount",
    options: booleanOptions,
    key: "includeDiscount",
  },
  {
    icon: Icons.AttachEmail,
    label: "Attach PDF in email",
    options: booleanOptions,
    key: "includePdf",
  },
  {
    icon: Icons.OutgoingMail,
    label: "Send copy (BCC)",
    options: booleanOptions,
    key: "sendCopy",
  },
  {
    icon: Icons.Straighten,
    label: "Add units",
    options: booleanOptions,
    key: "includeUnits",
  },
  {
    icon: Icons.Decimals,
    label: "Decimals",
    options: booleanOptions,
    key: "includeDecimals",
  },
  {
    icon: Icons.QrCode,
    label: "Add QR code",
    options: booleanOptions,
    key: "includeQr",
  },
];

export function SettingsMenu() {
  const { watch, setValue } = useFormContext();
  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <button type="button">
          <Icons.MoreVertical className="size-5" />
        </button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-48">
        {menuItems.map((item, index) => {
          const watchKey = `template.${item.key}`;

          if (item.key === "currency") {
            return (
              <DropdownMenuSub key={index.toString()}>
                <DropdownMenuSubTrigger>
                  <item.icon className="mr-2 size-4" />
                  <span className="text-xs">{item.label}</span>
                </DropdownMenuSubTrigger>
                <DropdownMenuSubContent className="p-0">
                  <SelectCurrency
                    headless
                    className="text-xs"
                    currencies={uniqueCurrencies}
                    value={watch(watchKey)}
                    onChange={(value) => {
                      setValue(watchKey, value, {
                        shouldValidate: true,
                        shouldDirty: true,
                      });
                      updateTemplateMutation.mutate({
                        [item.key]: value,
                      });
                    }}
                  />
                </DropdownMenuSubContent>
              </DropdownMenuSub>
            );
          }

          return (
            <DropdownMenuSub key={index.toString()}>
              <DropdownMenuSubTrigger>
                <item.icon className="mr-2 size-4" />
                <span className="text-xs">{item.label}</span>
              </DropdownMenuSubTrigger>
              <DropdownMenuSubContent className="p-0 max-h-48 overflow-y-auto">
                {item.options.map((option, optionIndex) => (
                  <DropdownMenuCheckboxItem
                    key={optionIndex.toString()}
                    className="text-xs"
                    checked={watch(watchKey) === option.value}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        setValue(watchKey, option.value, {
                          shouldValidate: true,
                          shouldDirty: true,
                        });

                        updateTemplateMutation.mutate({
                          [item.key]: option.value,
                        });
                      }
                    }}
                    onSelect={(event) => event.preventDefault()}
                  >
                    {option.label}
                  </DropdownMenuCheckboxItem>
                ))}
              </DropdownMenuSubContent>
            </DropdownMenuSub>
          );
        })}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/submit-button.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import { Calendar } from "@midday/ui/calendar";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { Input } from "@midday/ui/input";
import { SubmitButton as BaseSubmitButton } from "@midday/ui/submit-button";
import { useMutation } from "@tanstack/react-query";
import { format, setHours, startOfTomorrow } from "date-fns";
import * as React from "react";
import { useFormContext } from "react-hook-form";

type Props = {
  isSubmitting: boolean;
  disabled?: boolean;
};

export function SubmitButton({ isSubmitting, disabled }: Props) {
  const { watch, setValue, formState } = useFormContext();
  const { data: user } = useUserQuery();

  // Get next day date/time rounded to nearest hour
  const getDefaultScheduleDateTime = () => {
    const now = new Date();
    const roundedHour =
      now.getMinutes() >= 30 ? now.getHours() + 1 : now.getHours();

    // Start with tomorrow at midnight, then set the rounded hour
    return setHours(startOfTomorrow(), roundedHour);
  };

  const [scheduleDate, setScheduleDate] = React.useState<Date | undefined>(
    () => {
      const existingScheduledAt = watch("scheduledAt");
      return existingScheduledAt
        ? new Date(existingScheduledAt)
        : getDefaultScheduleDateTime();
    },
  );

  const [scheduleTime, setScheduleTime] = React.useState<string>(() => {
    const existingScheduledAt = watch("scheduledAt");
    const initialDateTime = existingScheduledAt
      ? new Date(existingScheduledAt)
      : getDefaultScheduleDateTime();
    return initialDateTime.toTimeString().slice(0, 5); // Format as HH:MM
  });

  // Sync with form scheduledAt changes (for when invoice data is loaded)
  React.useEffect(() => {
    const currentScheduledAt = watch("scheduledAt");
    if (currentScheduledAt) {
      const scheduledDateTime = new Date(currentScheduledAt);
      setScheduleDate(scheduledDateTime);
      setScheduleTime(scheduledDateTime.toTimeString().slice(0, 5));
    }
  }, [watch("scheduledAt")]);

  // Helper function to update scheduledAt with provided date and time
  const updateScheduledAt = (date: Date, time: string) => {
    const timeParts = time.split(":").map(Number);
    const hours = timeParts[0] || 0;
    const minutes = timeParts[1] || 0;
    const scheduledDateTime = new Date(date);
    scheduledDateTime.setHours(hours, minutes, 0, 0);

    setValue("scheduledAt", scheduledDateTime.toISOString(), {
      shouldValidate: true,
    });
  };

  // Handler to set date and automatically switch to scheduled
  const handleDateChange = (date: Date | undefined) => {
    setScheduleDate(date);
    if (date) {
      handleOptionChange("scheduled");
      // Update scheduledAt immediately with the new date
      updateScheduledAt(date, scheduleTime);
    }
  };

  // Handler to set time and automatically switch to scheduled
  const handleTimeChange = (time: string) => {
    setScheduleTime(time);
    if (scheduleDate) {
      handleOptionChange("scheduled");
      // Update scheduledAt immediately with the new time
      updateScheduledAt(scheduleDate, time);
    }
  };

  const selectedOption = watch("template.deliveryType");
  const canUpdate = watch("status") !== "draft";

  const invoiceNumberValid = !formState.errors.invoiceNumber;

  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  const cancelScheduleMutation = useMutation(
    trpc.invoice.cancelSchedule.mutationOptions(),
  );

  const handleOptionChange = (value: string) => {
    const deliveryType = value as "create" | "create_and_send" | "scheduled";
    const currentDeliveryType = watch("template.deliveryType");
    const invoiceId = watch("id");

    // Only save create and create_and_send to template, not scheduled
    if (deliveryType !== "scheduled") {
      updateTemplateMutation.mutate({
        deliveryType,
      });

      // If changing from scheduled to another type, cancel the scheduled job
      if (currentDeliveryType === "scheduled" && invoiceId) {
        cancelScheduleMutation.mutate({ id: invoiceId });
      }
    }

    setValue("template.deliveryType", deliveryType, {
      shouldValidate: true,
      shouldDirty: true,
    });

    // Handle scheduledAt based on delivery type
    if (deliveryType === "scheduled" && scheduleDate && scheduleTime) {
      // Update scheduledAt for scheduled delivery
      updateScheduledAt(scheduleDate, scheduleTime);
    } else {
      // Clear scheduledAt for non-scheduled delivery types
      setValue("scheduledAt", null, {
        shouldValidate: true,
        shouldDirty: true,
      });
    }
  };

  const isValid = formState.isValid && invoiceNumberValid;

  const options = [
    {
      label: canUpdate ? "Update" : "Create",
      value: "create",
    },
    {
      label: canUpdate ? "Update & Send" : "Create & Send",
      value: "create_and_send",
    },
    {
      label: canUpdate ? "Update" : "Schedule",
      value: "scheduled",
    },
  ];

  return (
    <div className="flex flex-col gap-4">
      <div className="flex divide-x">
        <BaseSubmitButton
          isSubmitting={isSubmitting}
          disabled={!isValid || disabled}
        >
          {selectedOption === "scheduled" && scheduleDate && scheduleTime
            ? `Schedule (${format(scheduleDate, "MMM d")} ${scheduleTime})`
            : options.find((o) => o.value === selectedOption)?.label}
        </BaseSubmitButton>

        {selectedOption === "scheduled" && canUpdate ? (
          // Show calendar and time input directly when invoice is already scheduled and can be updated
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                disabled={!isValid || isSubmitting || disabled}
                className="size-9 p-0 [&[data-state=open]>svg]:rotate-180"
              >
                <Icons.ChevronDown className="size-4 transition-transform duration-200" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" sideOffset={10}>
              <div className="p-4 space-y-4 min-w-[230px]">
                <div className="space-y-2">
                  <Calendar
                    mode="single"
                    weekStartsOn={user?.weekStartsOnMonday ? 1 : 0}
                    selected={scheduleDate}
                    defaultMonth={scheduleDate}
                    onSelect={handleDateChange}
                    disabled={(date) => {
                      const today = new Date();
                      today.setHours(0, 0, 0, 0);
                      return date < today;
                    }}
                    className="!p-0"
                  />
                </div>

                <div className="space-y-2">
                  <Input
                    type="time"
                    id="schedule-time"
                    value={scheduleTime}
                    onChange={(e) => handleTimeChange(e.target.value)}
                    className="bg-background appearance-none [&::-webkit-calendar-picker-indicator]:hidden [&::-webkit-calendar-picker-indicator]:appearance-none"
                  />
                </div>
              </div>
            </DropdownMenuContent>
          </DropdownMenu>
        ) : (
          // Show normal dropdown with all options when not scheduled or when creating new
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                disabled={!isValid || isSubmitting || disabled}
                className="size-9 p-0 [&[data-state=open]>svg]:rotate-180"
              >
                <Icons.ChevronDown className="size-4 transition-transform duration-200" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" sideOffset={10}>
              {options.map((option) => {
                if (option.value === "scheduled") {
                  return (
                    <DropdownMenuSub key={option.value}>
                      <DropdownMenuSubTrigger>
                        <div className="flex items-center pl-2">
                          {option.label}
                        </div>
                      </DropdownMenuSubTrigger>
                      <DropdownMenuPortal>
                        <DropdownMenuSubContent className="p-4 space-y-4 min-w-[230px] mb-2">
                          <div className="space-y-2">
                            <Calendar
                              mode="single"
                              weekStartsOn={user?.weekStartsOnMonday ? 1 : 0}
                              selected={scheduleDate}
                              defaultMonth={scheduleDate}
                              onSelect={handleDateChange}
                              disabled={(date) => {
                                const today = new Date();
                                today.setHours(0, 0, 0, 0);
                                return date < today;
                              }}
                              className="!p-0"
                            />
                          </div>

                          <div className="space-y-2">
                            <Input
                              type="time"
                              id="schedule-time"
                              value={scheduleTime}
                              onChange={(e) => handleTimeChange(e.target.value)}
                              className="bg-background appearance-none [&::-webkit-calendar-picker-indicator]:hidden [&::-webkit-calendar-picker-indicator]:appearance-none"
                            />
                          </div>
                        </DropdownMenuSubContent>
                      </DropdownMenuPortal>
                    </DropdownMenuSub>
                  );
                }

                return (
                  <DropdownMenuCheckboxItem
                    key={option.value}
                    checked={selectedOption === option.value}
                    onCheckedChange={() => handleOptionChange(option.value)}
                  >
                    {option.label}
                  </DropdownMenuCheckboxItem>
                );
              })}
            </DropdownMenuContent>
          </DropdownMenu>
        )}
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/summary.tsx">
import { useTRPC } from "@/trpc/client";
import { calculateTotal } from "@midday/invoice/calculate";
import { useMutation } from "@tanstack/react-query";
import { useCallback, useEffect } from "react";
import { useFormContext, useWatch } from "react-hook-form";
import { AnimatedNumber } from "../animated-number";
import { FormatAmount } from "../format-amount";
import { AmountInput } from "./amount-input";
import { LabelInput } from "./label-input";
import { TaxInput } from "./tax-input";
import { VATInput } from "./vat-input";

export function Summary() {
  const { control, setValue } = useFormContext();

  const trpc = useTRPC();
  const updateTemplateMutation = useMutation(
    trpc.invoiceTemplate.upsert.mutationOptions(),
  );

  const includeDecimals = useWatch({
    control,
    name: "template.includeDecimals",
  });

  const maximumFractionDigits = includeDecimals ? 2 : 0;

  const currency = useWatch({
    control,
    name: "template.currency",
  });

  const locale = useWatch({
    control,
    name: "template.locale",
  });

  const includeTax = useWatch({
    control,
    name: "template.includeTax",
  });

  const taxRate = useWatch({
    control,
    name: "template.taxRate",
  });

  const vatRate = useWatch({
    control,
    name: "template.vatRate",
  });

  const includeVat = useWatch({
    control,
    name: "template.includeVat",
  });

  const includeDiscount = useWatch({
    control,
    name: "template.includeDiscount",
  });

  const lineItems = useWatch({
    control,
    name: "lineItems",
  });

  const discount = useWatch({
    control,
    name: "discount",
  });

  const {
    subTotal,
    total,
    vat: totalVAT,
    tax: totalTax,
  } = calculateTotal({
    lineItems,
    taxRate,
    vatRate,
    includeTax,
    discount: discount ?? 0,
  });

  const updateFormValues = useCallback(() => {
    setValue("amount", total, { shouldValidate: true });
    setValue("vat", totalVAT, { shouldValidate: true });
    setValue("tax", totalTax, { shouldValidate: true });
    setValue("subtotal", subTotal, { shouldValidate: true });
    setValue("discount", discount ?? 0, { shouldValidate: true });
  }, [total, totalVAT, totalTax, subTotal, discount]);

  useEffect(() => {
    updateFormValues();
  }, [updateFormValues]);

  useEffect(() => {
    if (!includeTax) {
      setValue("template.taxRate", 0, {
        shouldValidate: true,
        shouldDirty: true,
      });
    }
  }, [includeTax]);

  useEffect(() => {
    if (!includeVat) {
      setValue("template.vatRate", 0, {
        shouldValidate: true,
        shouldDirty: true,
      });
    }
  }, [includeVat]);

  useEffect(() => {
    if (!includeDiscount) {
      setValue("discount", 0, { shouldValidate: true, shouldDirty: true });
    }
  }, [includeDiscount]);

  return (
    <div className="w-[320px] flex flex-col">
      <div className="flex justify-between items-center py-1">
        <LabelInput
          className="flex-shrink-0 min-w-6"
          name="template.subtotalLabel"
          onSave={(value) => {
            updateTemplateMutation.mutate({ subtotalLabel: value });
          }}
        />
        <span className="text-right font-mono text-[11px] text-[#878787]">
          <FormatAmount
            amount={subTotal}
            maximumFractionDigits={maximumFractionDigits}
            currency={currency}
            locale={locale}
          />
        </span>
      </div>

      {includeDiscount && (
        <div className="flex justify-between items-center py-1">
          <LabelInput
            name="template.discountLabel"
            onSave={(value) => {
              updateTemplateMutation.mutate({ discountLabel: value });
            }}
          />

          <AmountInput
            placeholder="0"
            allowNegative={false}
            name="discount"
            className="text-right font-mono text-[11px] text-[#878787] border-none"
          />
        </div>
      )}

      {includeVat && (
        <div className="flex justify-between items-center py-1">
          <div className="flex items-center gap-1">
            <LabelInput
              className="flex-shrink-0 min-w-5"
              name="template.vatLabel"
              onSave={(value) => {
                updateTemplateMutation.mutate({ vatLabel: value });
              }}
            />

            <VATInput />
          </div>

          <span className="text-right font-mono text-[11px] text-[#878787]">
            <FormatAmount
              amount={totalVAT}
              maximumFractionDigits={maximumFractionDigits}
              currency={currency}
              locale={locale}
            />
          </span>
        </div>
      )}

      {includeTax && (
        <div className="flex justify-between items-center py-1">
          <div className="flex items-center gap-1">
            <LabelInput
              className="flex-shrink-0 min-w-5"
              name="template.taxLabel"
              onSave={(value) => {
                updateTemplateMutation.mutate({ taxLabel: value });
              }}
            />

            <TaxInput />
          </div>

          <span className="text-right font-mono text-[11px] text-[#878787]">
            <FormatAmount
              amount={totalTax}
              maximumFractionDigits={maximumFractionDigits}
              currency={currency}
            />
          </span>
        </div>
      )}

      <div className="flex justify-between items-center py-4 mt-2 border-t border-border">
        <LabelInput
          name="template.totalSummaryLabel"
          onSave={(value) => {
            updateTemplateMutation.mutate({ totalSummaryLabel: value });
          }}
        />
        <span className="text-right font-mono font-medium text-[21px]">
          <AnimatedNumber
            value={total}
            currency={currency}
            maximumFractionDigits={maximumFractionDigits}
          />
        </span>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/tax-input.tsx">
import { CurrencyInput } from "@midday/ui/currency-input";
import { useController, useFormContext } from "react-hook-form";

export function TaxInput() {
  const { control } = useFormContext();
  const {
    field: { value, onChange },
  } = useController({
    name: "template.taxRate",
    control,
  });

  return (
    <CurrencyInput
      suffix="%)"
      prefix="("
      autoComplete="off"
      value={value}
      onValueChange={(values) => {
        onChange(values.floatValue);
      }}
      className="p-0 border-0 h-6 text-xs !bg-transparent font-mono flex-shrink-0 w-16 text-[11px] text-[#878787]"
      thousandSeparator={false}
      decimalScale={2}
      isAllowed={(values) => {
        const { floatValue } = values;
        return (
          floatValue === undefined || (floatValue >= 0 && floatValue <= 100)
        );
      }}
      allowNegative={false}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/invoice/utils.ts">
import type { InvoiceFormValues } from "./form-context";

export const transformFormValuesToDraft = (values: InvoiceFormValues) => {
  return {
    ...values,
    template: {
      ...values.template,
      ...(values.paymentDetails && {
        paymentDetails: JSON.stringify(values.paymentDetails),
      }),
      ...(values.fromDetails && {
        fromDetails: JSON.stringify(values.fromDetails),
      }),
    },
    ...(values.paymentDetails && {
      paymentDetails: JSON.stringify(values.paymentDetails),
    }),
    ...(values.fromDetails && {
      fromDetails: JSON.stringify(values.fromDetails),
    }),
    ...(values.customerDetails && {
      customerDetails: JSON.stringify(values.customerDetails),
    }),
    ...(values.noteDetails && {
      noteDetails: JSON.stringify(values.noteDetails),
    }),
  };
};
</file>

<file path="apps/dashboard/src/components/invoice/vat-input.tsx">
import { CurrencyInput } from "@midday/ui/currency-input";
import { useController, useFormContext } from "react-hook-form";

export function VATInput() {
  const { control } = useFormContext();
  const {
    field: { value, onChange },
  } = useController({
    name: "template.vatRate",
    control,
  });

  return (
    <CurrencyInput
      suffix="%)"
      prefix="("
      autoComplete="off"
      value={value}
      onValueChange={(values) => {
        onChange(values.floatValue);
      }}
      className="p-0 border-0 h-6 text-xs !bg-transparent font-mono flex-shrink-0 w-16 text-[11px] text-[#878787]"
      thousandSeparator={false}
      decimalScale={2}
      isAllowed={(values) => {
        const { floatValue } = values;
        return (
          floatValue === undefined || (floatValue >= 0 && floatValue <= 100)
        );
      }}
      allowNegative={false}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/modals/import-modal/context.tsx">
import { createContext, useContext } from "react";
import type { Control, UseFormSetValue, UseFormWatch } from "react-hook-form";
import { z } from "zod";

export const mappableFields = {
  date: {
    label: "Date",
    required: true,
  },
  description: {
    label: "Description",
    required: true,
  },
  amount: {
    label: "Amount",
    required: true,
  },
  balance: {
    label: "Balance",
    required: false,
  },
} as const;

export const importSchema = z.object({
  file: z.custom<File>(),
  currency: z.string(),
  bank_account_id: z.string(),
  amount: z.string(),
  balance: z.string().optional(),
  date: z.string(),
  description: z.string(),
  inverted: z.boolean(),
  table: z.array(z.record(z.string(), z.string())).optional(),
});

export type ImportCsvFormData = {
  file: File;
  currency: string;
  bank_account_id: string;
  amount: string;
  balance?: string;
  date: string;
  description: string;
  inverted: boolean;
  table?: Record<string, string>[];
};

export const ImportCsvContext = createContext<{
  fileColumns: string[] | null;
  setFileColumns: (columns: string[] | null) => void;
  firstRows: Record<string, string>[] | null;
  setFirstRows: (rows: Record<string, string>[] | null) => void;
  control: Control<ImportCsvFormData>;
  watch: UseFormWatch<ImportCsvFormData>;
  setValue: UseFormSetValue<ImportCsvFormData>;
} | null>(null);

export function useCsvContext() {
  const context = useContext(ImportCsvContext);

  if (!context)
    throw new Error(
      "useCsvContext must be used within an ImportCsvContext.Provider",
    );

  return context;
}
</file>

<file path="apps/dashboard/src/components/modals/import-modal/field-mapping.tsx">
"use client";

import { generateCsvMapping } from "@/actions/ai/generate-csv-mapping";
import { SelectAccount } from "@/components/select-account";
import { SelectCurrency } from "@/components/select-currency";
import { useUserQuery } from "@/hooks/use-user";
import { formatAmount } from "@/utils/format";
import { formatAmountValue, formatDate } from "@midday/import";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { Icons } from "@midday/ui/icons";
import { Label } from "@midday/ui/label";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";
import { Spinner } from "@midday/ui/spinner";
import { Switch } from "@midday/ui/switch";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { readStreamableValue } from "ai/rsc";
import { capitalCase } from "change-case";
import { useEffect, useState } from "react";
import { Controller } from "react-hook-form";
import { mappableFields, useCsvContext } from "./context";

export function FieldMapping({ currencies }: { currencies: string[] }) {
  const { fileColumns, firstRows, setValue, control, watch } = useCsvContext();
  const [isStreaming, setIsStreaming] = useState(true);
  const [showCurrency, setShowCurrency] = useState(false);

  useEffect(() => {
    if (!fileColumns || !firstRows) return;

    generateCsvMapping(fileColumns, firstRows)
      .then(async ({ object }) => {
        setIsStreaming(true);

        for await (const partialObject of readStreamableValue(object)) {
          if (partialObject) {
            for (const [field, value] of Object.entries(partialObject)) {
              if (
                Object.keys(mappableFields).includes(field) &&
                fileColumns.includes(value as string)
              ) {
                // @ts-expect-error
                setValue(field as keyof typeof mappableFields, value, {
                  shouldValidate: true,
                });
              }
            }
          }
        }
      })
      .finally(() => setIsStreaming(false));
  }, [fileColumns, firstRows]);

  return (
    <div className="mt-6">
      <div className="grid grid-cols-2 gap-x-4 gap-y-2">
        <div className="text-sm">CSV Data column</div>
        <div className="text-sm">Midday data column</div>
        {(Object.keys(mappableFields) as (keyof typeof mappableFields)[]).map(
          (field) => (
            <FieldRow
              key={field}
              field={field}
              isStreaming={isStreaming}
              currency={watch("currency")}
            />
          ),
        )}
      </div>

      <Accordion
        defaultValue={undefined}
        collapsible
        type="single"
        className="w-full mt-6 border-t-[1px] border-border"
      >
        <AccordionItem value="settings">
          <AccordionTrigger className="text-sm">Settings</AccordionTrigger>
          <AccordionContent>
            <div className="flex flex-col gap-4">
              <Controller
                control={control}
                name="inverted"
                render={({ field: { onChange, value } }) => (
                  <div className="space-y-1">
                    <Label htmlFor="inverted">Inverted amount</Label>
                    <p className="text-sm text-[#606060]">
                      If the transactions are from credit account, you can
                      invert the amount.
                    </p>
                    <div className="flex justify-end">
                      <Switch
                        id="inverted"
                        checked={value}
                        onCheckedChange={onChange}
                      />
                    </div>
                  </div>
                )}
              />
            </div>
          </AccordionContent>
        </AccordionItem>
      </Accordion>

      <div className="mt-6">
        <Label className="mb-2 block">Account</Label>
        <Controller
          control={control}
          name="bank_account_id"
          render={({ field: { value, onChange } }) => (
            <SelectAccount
              className="w-full"
              placeholder="Select account"
              value={value}
              onChange={(account) => {
                onChange(account.id);

                if (account.type === "credit") {
                  setValue("inverted", true, {
                    shouldValidate: true,
                  });
                }

                if (account?.currency) {
                  setValue("currency", account.currency, {
                    shouldValidate: true,
                  });

                  setShowCurrency(false);
                } else {
                  // Show currency select if account has no currency
                  setShowCurrency(!account.currency);
                }
              }}
            />
          )}
        />
      </div>

      {showCurrency && (
        <>
          <Label className="mb-2 mt-4 block">Currency</Label>
          <Controller
            control={control}
            name="currency"
            render={({ field: { onChange, value } }) => (
              <SelectCurrency
                className="w-full text-xs"
                value={value}
                onChange={onChange}
                currencies={Object.values(currencies)?.map(
                  (currency) => currency,
                )}
              />
            )}
          />
        </>
      )}
    </div>
  );
}

function FieldRow({
  field,
  isStreaming,
  currency,
}: {
  field: keyof typeof mappableFields;
  isStreaming: boolean;
  currency?: string;
}) {
  const { label, required } = mappableFields[field];
  const { control, watch, fileColumns, firstRows } = useCsvContext();
  const { data: user } = useUserQuery();

  const value = watch(field);
  const inverted = watch("inverted");

  const isLoading = isStreaming && !value;

  const firstRow = firstRows?.at(0);

  const description = firstRow?.[value as keyof typeof firstRow];

  const formatDescription = (description?: string) => {
    if (!description) return;

    if (field === "date") {
      return formatDate(description);
    }

    if (field === "amount") {
      const amount = formatAmountValue({ amount: description, inverted });

      if (currency) {
        return formatAmount({ currency, amount, locale: user?.locale });
      }

      return amount;
    }

    if (field === "balance") {
      const amount = formatAmountValue({ amount: description });

      // Always invert the amount for balance
      const balance = +(amount * -1);

      if (currency) {
        return formatAmount({
          currency,
          amount: balance,
          locale: user?.locale,
        });
      }

      return balance;
    }

    if (field === "description") {
      return capitalCase(description);
    }

    return description;
  };

  return (
    <>
      <div className="relative flex min-w-0 items-center gap-2">
        <Controller
          control={control}
          name={field}
          rules={{ required }}
          render={({ field }) => {
            return (
              <Select
                value={field?.value ?? undefined}
                onValueChange={field.onChange}
              >
                <SelectTrigger className="w-full relative" hideIcon={isLoading}>
                  <SelectValue placeholder={`Select ${label}`} />

                  {isLoading && (
                    <div className="absolute top-2 right-2">
                      <Spinner />
                    </div>
                  )}
                </SelectTrigger>
                <SelectContent>
                  <SelectGroup>
                    <SelectLabel>{label}</SelectLabel>
                    {[
                      // Filter out empty columns
                      ...(fileColumns?.filter((column) => column !== "") || []),
                      ...(field.value && !required ? ["None"] : []),
                    ]?.map((column) => {
                      return (
                        <SelectItem key={column} value={column}>
                          {column}
                        </SelectItem>
                      );
                    })}
                  </SelectGroup>
                </SelectContent>
              </Select>
            );
          }}
        />

        <div className="flex items-center justify-end">
          <Icons.ArrowRightAlt className="size-4 text-[#878787]" />
        </div>
      </div>

      <span className="flex h-9 w-full items-center justify-between whitespace-nowrap border border-border bg-transparent px-3 py-2 text-sm">
        <div className="grow whitespace-nowrap text-sm font-normal text-muted-foreground justify-between flex">
          <span>{label}</span>

          {description && (
            <TooltipProvider delayDuration={50}>
              <Tooltip>
                <TooltipTrigger>
                  <Icons.Info />
                </TooltipTrigger>
                <TooltipContent className="p-2 text-xs">
                  {formatDescription(description)}
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          )}
        </div>
      </span>
    </>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/import-modal/index.tsx">
"use client";

import { importTransactionsAction } from "@/actions/transactions/import-transactions";
import { useSyncStatus } from "@/hooks/use-sync-status";
import { useUpload } from "@/hooks/use-upload";
import { useUserQuery } from "@/hooks/use-user";
import { useZodForm } from "@/hooks/use-zod-form";
import { useTRPC } from "@/trpc/client";
import { AnimatedSizeContainer } from "@midday/ui/animated-size-container";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import { Icons } from "@midday/ui/icons";
import { SubmitButton } from "@midday/ui/submit-button";
import { useToast } from "@midday/ui/use-toast";
import { stripSpecialCharacters } from "@midday/utils";
import { useQueryClient } from "@tanstack/react-query";
import { useAction } from "next-safe-action/hooks";
import { parseAsBoolean, parseAsString, useQueryStates } from "nuqs";
import { useEffect, useState } from "react";
import { ImportCsvContext, importSchema } from "./context";
import { FieldMapping } from "./field-mapping";
import { SelectFile } from "./select-file";

const pages = ["select-file", "confirm-import"] as const;

type Props = {
  currencies: string[];
  defaultCurrency: string;
};

export function ImportModal({ currencies, defaultCurrency }: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const [runId, setRunId] = useState<string | undefined>();
  const [accessToken, setAccessToken] = useState<string | undefined>();
  const [isImporting, setIsImporting] = useState(false);
  const [fileColumns, setFileColumns] = useState<string[] | null>(null);
  const [firstRows, setFirstRows] = useState<Record<string, string>[] | null>(
    null,
  );

  const { data: user } = useUserQuery();

  const [pageNumber, setPageNumber] = useState<number>(0);
  const page = pages[pageNumber];

  const { uploadFile } = useUpload();

  const { toast } = useToast();

  const { status, setStatus } = useSyncStatus({ runId, accessToken });

  const [params, setParams] = useQueryStates({
    step: parseAsString,
    accountId: parseAsString,
    type: parseAsString,
    hide: parseAsBoolean.withDefault(false),
  });

  const isOpen = params.step === "import";

  const importTransactions = useAction(importTransactionsAction, {
    onSuccess: ({ data }) => {
      if (data) {
        setRunId(data.id);
        setAccessToken(data.publicAccessToken);
      }
    },
    onError: () => {
      setIsImporting(false);
      setRunId(undefined);
      setStatus("FAILED");

      toast({
        duration: 3500,
        variant: "error",
        title: "Something went wrong please try again.",
      });
    },
  });

  const {
    control,
    watch,
    setValue,
    handleSubmit,
    reset,
    formState: { isValid },
  } = useZodForm(importSchema, {
    defaultValues: {
      currency: defaultCurrency,
      bank_account_id: params.accountId ?? undefined,
      inverted: params.type === "credit",
    },
  });

  const file = watch("file");

  const onclose = () => {
    setFileColumns(null);
    setFirstRows(null);
    setPageNumber(0);
    reset();

    setParams({
      step: null,
      accountId: null,
      type: null,
      hide: null,
    });
  };

  useEffect(() => {
    if (params.accountId) {
      setValue("bank_account_id", params.accountId);
    }
  }, [params.accountId]);

  useEffect(() => {
    if (params.type) {
      setValue("inverted", params.type === "credit");
    }
  }, [params.type]);

  useEffect(() => {
    if (status === "FAILED") {
      setIsImporting(false);
      setRunId(undefined);

      toast({
        duration: 3500,
        variant: "error",
        title: "Something went wrong please try again or contact support.",
      });
    }
  }, [status]);

  useEffect(() => {
    if (status === "COMPLETED") {
      setRunId(undefined);
      setIsImporting(false);
      onclose();

      queryClient.invalidateQueries({
        queryKey: trpc.transactions.get.queryKey(),
      });

      queryClient.invalidateQueries({
        queryKey: trpc.bankAccounts.get.queryKey(),
      });

      queryClient.invalidateQueries({
        queryKey: trpc.bankConnections.get.queryKey(),
      });

      queryClient.invalidateQueries({
        queryKey: trpc.reports.pathKey(),
      });

      toast({
        duration: 3500,
        variant: "success",
        title: "Transactions imported successfully.",
      });
    }
  }, [status]);

  // Go to second page if file looks good
  useEffect(() => {
    if (file && fileColumns && pageNumber === 0) {
      setPageNumber(1);
    }
  }, [file, fileColumns, pageNumber]);

  return (
    <Dialog open={isOpen} onOpenChange={onclose}>
      <DialogContent>
        <div className="p-4 pb-0">
          <DialogHeader>
            <div className="flex space-x-4 items-center mb-4">
              {!params.hide && (
                <button
                  type="button"
                  className="items-center border bg-accent p-1"
                  onClick={() => setParams({ step: "connect" })}
                >
                  <Icons.ArrowBack />
                </button>
              )}
              <DialogTitle className="m-0 p-0">
                {page === "select-file" && "Select file"}
                {page === "confirm-import" && "Confirm import"}
              </DialogTitle>
            </div>
            <DialogDescription>
              {page === "select-file" &&
                "Upload a CSV file of your transactions."}
              {page === "confirm-import" &&
                "We’ve mapped each column to what we believe is correct, but please review the data below to confirm it’s accurate."}
            </DialogDescription>
          </DialogHeader>

          <div className="relative">
            <AnimatedSizeContainer height>
              <ImportCsvContext.Provider
                value={{
                  fileColumns,
                  setFileColumns,
                  firstRows,
                  setFirstRows,
                  control,
                  watch,
                  setValue,
                }}
              >
                <div>
                  <form
                    className="flex flex-col gap-y-4"
                    onSubmit={handleSubmit(async (data) => {
                      setIsImporting(true);

                      const filename = stripSpecialCharacters(data.file.name);
                      const { path } = await uploadFile({
                        bucket: "vault",
                        path: [user?.team?.id ?? "", "imports", filename],
                        file,
                      });

                      importTransactions.execute({
                        filePath: path,
                        currency: data.currency,
                        bankAccountId: data.bank_account_id,
                        currentBalance: data.balance,
                        inverted: data.inverted,
                        mappings: {
                          amount: data.amount,
                          date: data.date,
                          description: data.description,
                        },
                      });
                    })}
                  >
                    {page === "select-file" && <SelectFile />}
                    {page === "confirm-import" && (
                      <>
                        <FieldMapping currencies={currencies} />

                        <SubmitButton
                          isSubmitting={isImporting}
                          disabled={!isValid}
                          className="mt-4"
                        >
                          Confirm import
                        </SubmitButton>

                        <button
                          type="button"
                          className="text-sm mb-4 text-[#878787]"
                          onClick={() => {
                            setPageNumber(0);
                            reset();
                            setFileColumns(null);
                            setFirstRows(null);
                          }}
                        >
                          Choose another file
                        </button>
                      </>
                    )}
                  </form>
                </div>
              </ImportCsvContext.Provider>
            </AnimatedSizeContainer>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/import-modal/select-file.tsx">
import { cn } from "@midday/ui/cn";
import { Spinner } from "@midday/ui/spinner";
import Papa from "papaparse";
import { useEffect, useState } from "react";
import Dropzone from "react-dropzone";
import { Controller } from "react-hook-form";
import { useCsvContext } from "./context";
import { readLines } from "./utils";

export function SelectFile() {
  const { watch, control, setFileColumns, setFirstRows } = useCsvContext();
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const file = watch("file");

  async function processFile() {
    if (!file) {
      setFileColumns(null);
      return;
    }

    setIsLoading(true);

    readLines(file, 4)
      .then((lines) => {
        const { data, meta } = Papa.parse(lines, {
          worker: false,
          skipEmptyLines: true,
          header: true,
        });

        if (!data || data.length < 2) {
          setError("CSV file must have at least 2 rows.");
          setFileColumns(null);
          setFirstRows(null);
          setIsLoading(false);
          return;
        }

        if (!meta || !meta.fields || meta.fields.length <= 1) {
          setError("Failed to retrieve CSV column data.");
          setFileColumns(null);
          setFirstRows(null);
          setIsLoading(false);
          return;
        }

        setFileColumns(meta.fields);
        // @ts-expect-error
        setFirstRows(data);
        setIsLoading(false);
      })
      .catch(() => {
        setError("Failed to read CSV file.");
        setFileColumns(null);
        setFirstRows(null);
        setIsLoading(false);
      });
  }

  useEffect(() => {
    processFile();
  }, [file]);

  return (
    <div className="flex flex-col gap-3">
      <Controller
        control={control}
        name="file"
        render={({ field: { onChange, onBlur } }) => (
          <Dropzone
            onDrop={([file]) => onChange(file)}
            maxFiles={1}
            accept={{
              "text/csv": [".csv"],
            }}
            maxSize={5000000}
          >
            {({ getRootProps, getInputProps, isDragActive, isDragReject }) => (
              <div
                {...getRootProps()}
                className={cn(
                  "w-full border border-dashed h-[200px] mt-8 mb-8 flex items-center justify-center",
                  isDragActive && "bg-secondary text-primary",
                  isDragReject && "border-destructive",
                )}
              >
                <div className="text-center flex items-center justify-center flex-col text-xs text-[#878787]">
                  <input {...getInputProps()} onBlur={onBlur} />

                  {isLoading ? (
                    <div className="flex space-x-1 items-center">
                      <Spinner />
                      <span>Loading...</span>
                    </div>
                  ) : (
                    <div>
                      <p>Drop your file here, or click to browse.</p>
                      <span>5MB file limit. </span>
                      <span className="mt-2 text-[10px]">CSV format</span>
                    </div>
                  )}

                  {error && (
                    <p className="text-center text-sm text-red-600 mt-4">
                      {error}
                    </p>
                  )}
                </div>
              </div>
            )}
          </Dropzone>
        )}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/import-modal/utils.ts">
export const readLines = async (file: File, count = 4): Promise<string> => {
  const reader = file.stream().getReader();
  const decoder = new TextDecoder("utf-8");
  let { value: chunk, done: readerDone } = await reader.read();
  let content = "";
  const result: string[] = [];

  while (!readerDone) {
    content += decoder.decode(chunk, { stream: true });
    const lines = content.split("\n");
    if (lines.length >= count) {
      reader.cancel();
      return lines.slice(0, count).join("\n");
    }
    ({ value: chunk, done: readerDone } = await reader.read());
  }

  return result.join("\n");
};
</file>

<file path="apps/dashboard/src/components/modals/add-new-device.tsx">
"use client";

import { mfaVerifyAction } from "@/actions/mfa-verify-action";
import { createClient } from "@midday/supabase/client";
import { Button } from "@midday/ui/button";
import { Dialog, DialogContent } from "@midday/ui/dialog";
import { InputOTP, InputOTPGroup, InputOTPSlot } from "@midday/ui/input-otp";
import { Spinner } from "@midday/ui/spinner";
import { useAction } from "next-safe-action/hooks";
import Image from "next/image";
import { usePathname, useRouter, useSearchParams } from "next/navigation";
import { useEffect, useState } from "react";

export function AddNewDeviceModal() {
  const supabase = createClient();
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();
  const [isValidating, setValidating] = useState(false);
  const [isRedirecting, setIsRedirecting] = useState(false);
  const [factorId, setFactorId] = useState("");
  const [error, setError] = useState(false);
  const [qr, setQR] = useState("");
  const isOpen = searchParams.get("add") === "device";

  const verify = useAction(mfaVerifyAction, {
    onSuccess: () => {
      setIsRedirecting(true);
      router.push(pathname);
    },
  });

  const onComplete = async (code: string) => {
    if (!isValidating) {
      setValidating(true);

      const challenge = await supabase.auth.mfa.challenge({ factorId });

      if (!challenge.data) {
        setError(true);
        return;
      }

      verify.execute({
        factorId,
        challengeId: challenge.data.id,
        code,
      });
    }
  };

  useEffect(() => {
    setValidating(false);
    setError(false);

    async function enroll() {
      const { data, error } = await supabase.auth.mfa.enroll({
        factorType: "totp",
      });

      if (error) {
        throw error;
      }

      setFactorId(data.id);

      setQR(data.totp.qr_code);
    }

    if (isOpen) {
      enroll();
    }
  }, [isOpen]);

  const handleOnClose = () => {
    router.push(pathname);

    supabase.auth.mfa.unenroll({
      factorId,
    });
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOnClose}>
      <DialogContent
        className="max-w-[455px]"
        onInteractOutside={(evt) => {
          evt.preventDefault();
        }}
      >
        <div className="p-6">
          <div className="flex items-center justify-center mt-8">
            <div className="w-[190px] h-[190px] bg-white rounded-md">
              {qr && (
                <Image
                  src={qr}
                  alt="qr"
                  width={190}
                  height={190}
                  quality={100}
                />
              )}
            </div>
          </div>

          <div className="my-8">
            <p className="font-medium pb-1 text-2xl text-[#606060]">
              Use an authenticator app to scan the following QR code, and
              provide the code to complete the setup.
            </p>
          </div>

          <div className="flex w-full justify-center">
            <div className="h-16 w-full max-w-fit flex items-center justify-center">
              {isValidating || isRedirecting ? (
                <div className="flex items-center justify-center h-full bg-background/95 border border-input px-4">
                  <div className="flex items-center space-x-2 bg-background px-4 py-2 rounded-md shadow-sm">
                    <Spinner size={16} className="text-primary" />
                    <span className="text-sm text-foreground font-medium">
                      {isRedirecting ? "Closing..." : "Adding device..."}
                    </span>
                  </div>
                </div>
              ) : (
                <InputOTP
                  maxLength={6}
                  onComplete={onComplete}
                  autoFocus
                  disabled={isValidating || isRedirecting}
                  className={error ? "invalid" : ""}
                  render={({ slots }) => (
                    <InputOTPGroup>
                      {slots.map((slot, index) => (
                        <InputOTPSlot key={index.toString()} {...slot} />
                      ))}
                    </InputOTPGroup>
                  )}
                />
              )}
            </div>
          </div>

          <div className="flex border-t-[1px] pt-4 mt-4 justify-center">
            <Button
              onClick={handleOnClose}
              variant="ghost"
              className="text-medium text-sm hover:bg-transparent"
            >
              Cancel
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/choose-plan-modal.tsx">
"use client";

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import Link from "next/link";
import { Plans } from "../plans";

export function ChoosePlanModal({
  isOpen,
  onOpenChange,
  daysLeft,
  hasDiscount,
  discountPrice,
}: {
  isOpen: boolean;
  onOpenChange: (isOpen: boolean) => void;
  daysLeft?: number;
  hasDiscount?: boolean;
  discountPrice?: number;
}) {
  const handleClose = (value: boolean) => {
    onOpenChange(value);
  };

  const getTitle = () => {
    if (daysLeft && daysLeft > 0) {
      return `Pro trial - ${daysLeft} ${daysLeft === 1 ? "day" : "days"} left`;
    }

    return hasDiscount ? "Special Discount Offer" : "Choose plan";
  };

  const getDescription = () => {
    if (daysLeft !== undefined) {
      if (daysLeft > 0) {
        return `Your trial will end in ${daysLeft} ${daysLeft === 1 ? "day" : "days"}, after the trial period you will have read access only.`;
      }

      return "Your trial period has ended. Please choose a plan to continue using Midday.";
    }

    if (hasDiscount && discountPrice) {
      const saveAmount = 99 - discountPrice;
      const savePercentage = Math.round((saveAmount / 99) * 100);

      return `As a valued early customer, you qualify for our special discount pricing. Get the Pro plan for $${discountPrice}/month instead of the regular $99/month and save ${savePercentage}%.`;
    }

    return "Choose a plan to continue using Midday.";
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="max-w-[696px]">
        <div className="p-8">
          <DialogHeader>
            <DialogTitle>{getTitle()}</DialogTitle>
          </DialogHeader>
          <DialogDescription className="mb-8">
            {getDescription()}
          </DialogDescription>

          <Plans />

          <p className="text-xs text-muted-foreground mt-4">
            After the trial period ends, you'll have read-only access,{" "}
            <Link href="/support">contact us</Link> if you have any questions.
          </p>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/connect-transactions-modal.tsx">
"use client";

import { createPlaidLinkTokenAction } from "@/actions/institutions/create-plaid-link";
import { exchangePublicToken } from "@/actions/institutions/exchange-public-token";
import { useConnectParams } from "@/hooks/use-connect-params";
import { useTRPC } from "@/trpc/client";
import { track } from "@midday/events/client";
import { LogEvents } from "@midday/events/events";
import { Button } from "@midday/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import { Input } from "@midday/ui/input";
import { Skeleton } from "@midday/ui/skeleton";
import { useQuery } from "@tanstack/react-query";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { usePlaidLink } from "react-plaid-link";
import { useDebounceValue, useScript } from "usehooks-ts";
import { BankLogo } from "../bank-logo";
import { ConnectBankProvider } from "../connect-bank-provider";
import { CountrySelector } from "../country-selector";
import { InstitutionInfo } from "../institution-info";

function SearchSkeleton() {
  return (
    <div className="space-y-4">
      {Array.from(new Array(10), (_, index) => (
        <div className="flex items-center space-x-4" key={index.toString()}>
          <Skeleton className="h-9 w-9 rounded-full" />
          <div className="flex flex-col space-y-1">
            <Skeleton className="h-2 rounded-none w-[140px]" />
            <Skeleton className="h-2 rounded-none w-[40px]" />
          </div>
        </div>
      ))}
    </div>
  );
}

function formatProvider(provider: string) {
  switch (provider) {
    case "enablebanking":
      return "Enable Banking";
    case "gocardless":
      return "GoCardLess";
    case "plaid":
      return "Plaid";
    case "teller":
      return "Teller";
  }
}

type SearchResultProps = {
  id: string;
  name: string;
  logo: string | null;
  provider: string;
  availableHistory: number;
  maximumConsentValidity: number;
  openPlaid: () => void;
  type?: "personal" | "business";
};

function SearchResult({
  id,
  name,
  logo,
  provider,
  availableHistory,
  openPlaid,
  maximumConsentValidity,
  type,
}: SearchResultProps) {
  return (
    <div className="flex justify-between">
      <div className="flex items-center">
        <BankLogo src={logo} alt={name} />

        <div className="ml-4 space-y-1 cursor-default">
          <p className="text-sm font-medium leading-none">{name}</p>
          <InstitutionInfo provider={provider}>
            <span className="text-[#878787] text-xs capitalize">
              Via {formatProvider(provider)}
              {type ? ` • ${type}` : ""}
            </span>
          </InstitutionInfo>
        </div>
      </div>

      <ConnectBankProvider
        id={id}
        name={name}
        provider={provider}
        openPlaid={openPlaid}
        maximumConsentValidity={maximumConsentValidity}
        availableHistory={availableHistory}
        type={type}
      />
    </div>
  );
}

type ConnectTransactionsModalProps = {
  countryCode: string;
};

export function ConnectTransactionsModal({
  countryCode: initialCountryCode,
}: ConnectTransactionsModalProps) {
  const trpc = useTRPC();
  const router = useRouter();
  const [plaidToken, setPlaidToken] = useState<string | undefined>();
  const {
    countryCode,
    search: query,
    step,
    setParams,
  } = useConnectParams(initialCountryCode);

  const isOpen = step === "connect";

  // NOTE: Load SDKs here so it's not unmonted
  useScript("https://cdn.teller.io/connect/connect.js", {
    removeOnUnmount: false,
  });

  const { open: openPlaid } = usePlaidLink({
    token: plaidToken,
    publicKey: "",
    env: process.env.NEXT_PUBLIC_PLAID_ENVIRONMENT!,
    clientName: "Midday",
    product: ["transactions"],
    onSuccess: async (public_token, metadata) => {
      const { access_token, item_id } = await exchangePublicToken(public_token);

      setParams({
        step: "account",
        provider: "plaid",
        token: access_token,
        ref: item_id,
        institution_id: metadata.institution?.institution_id,
      });
      track({
        event: LogEvents.ConnectBankAuthorized.name,
        channel: LogEvents.ConnectBankAuthorized.channel,
        provider: "plaid",
      });
    },
    onExit: () => {
      setParams({ step: "connect" });

      track({
        event: LogEvents.ConnectBankCanceled.name,
        channel: LogEvents.ConnectBankCanceled.channel,
        provider: "plaid",
      });
    },
  });

  const handleOnClose = () => {
    setParams({
      step: null,
      countryCode: null,
      search: null,
      ref: null,
    });
  };

  const [debouncedQuery] = useDebounceValue(query ?? "", 200);

  const { data, isLoading } = useQuery(
    trpc.institutions.get.queryOptions(
      {
        q: debouncedQuery,
        countryCode,
      },
      {
        enabled: isOpen,
      },
    ),
  );

  useEffect(() => {
    async function createLinkToken() {
      const token = await createPlaidLinkTokenAction();

      if (token) {
        setPlaidToken(token);
      }
    }

    // NOTE: Only run where Plaid is supported
    if ((isOpen && countryCode === "US") || (isOpen && countryCode === "CA")) {
      createLinkToken();
    }
  }, [isOpen, countryCode]);

  return (
    <Dialog open={isOpen} onOpenChange={handleOnClose}>
      <DialogContent>
        <div className="p-4">
          <DialogHeader>
            <DialogTitle>Connect bank account</DialogTitle>

            <DialogDescription>
              We work with a variety of banking providers to support as many
              banks as possible. If you can't find yours,{" "}
              <button
                type="button"
                className="underline"
                onClick={() => setParams({ step: "import" })}
              >
                manual import
              </button>{" "}
              is available as an alternative.
            </DialogDescription>

            <div className="pt-4">
              <div className="flex space-x-2 relative">
                <Input
                  placeholder="Search bank..."
                  type="search"
                  onChange={(evt) =>
                    setParams({ search: evt.target.value || null })
                  }
                  autoComplete="off"
                  autoCapitalize="none"
                  autoCorrect="off"
                  spellCheck="false"
                  autoFocus
                  value={query ?? ""}
                />

                <div className="absolute right-0">
                  <CountrySelector
                    defaultValue={countryCode}
                    onSelect={(countryCode) => {
                      setParams({ countryCode });
                    }}
                  />
                </div>
              </div>

              <div className="h-[430px] space-y-4 overflow-auto scrollbar-hide pt-2 mt-2">
                {isLoading && <SearchSkeleton />}

                {data?.map((institution) => {
                  if (!institution) {
                    return null;
                  }

                  return (
                    <SearchResult
                      key={institution.id}
                      id={institution.id}
                      name={institution.name}
                      logo={institution.logo}
                      provider={institution.provider}
                      // GoCardLess
                      availableHistory={
                        institution.availableHistory
                          ? +institution.availableHistory
                          : 0
                      }
                      // EnableBanking
                      maximumConsentValidity={
                        institution.maximumConsentValidity
                          ? +institution.maximumConsentValidity
                          : 0
                      }
                      type={institution?.type ?? undefined}
                      openPlaid={() => {
                        setParams({ step: null });
                        openPlaid();
                      }}
                    />
                  );
                })}

                {!isLoading && data?.length === 0 && (
                  <div className="flex flex-col items-center justify-center min-h-[350px]">
                    <p className="font-medium mb-2">No banks found</p>
                    <p className="text-sm text-center text-[#878787]">
                      We couldn't find a bank matching your criteria.
                      <br /> Let us know, or start with manual import.
                    </p>

                    <div className="mt-4 flex space-x-2">
                      <Button
                        variant="outline"
                        onClick={() => setParams({ step: "import" })}
                      >
                        Import
                      </Button>

                      <Button
                        onClick={() => {
                          router.push("/account/support");
                        }}
                      >
                        Contact us
                      </Button>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </DialogHeader>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/create-api-key-modal.tsx">
"use client";

import { ApiKeyForm } from "@/components/forms/api-key-form";
import { useTokenModalStore } from "@/store/token-modal";
import { Button } from "@midday/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import { CopyInput } from "../copy-input";

export function CreateApiKeyModal() {
  const { setData, createdKey, type, setCreatedKey } = useTokenModalStore();

  let content = null;

  if (createdKey) {
    content = (
      <div className="p-4 space-y-4">
        <DialogHeader>
          <DialogTitle>API Key Created</DialogTitle>
          <DialogDescription>
            For security reasons, the key will only be shown once. Please copy
            and store it in a secure location.
          </DialogDescription>
        </DialogHeader>

        <CopyInput value={createdKey} />

        <DialogFooter>
          <Button onClick={() => setData(undefined)} className="w-full">
            Done
          </Button>
        </DialogFooter>
      </div>
    );
  } else {
    content = (
      <div className="p-4 space-y-4">
        <DialogHeader>
          <DialogTitle>Create New API Key</DialogTitle>
          <DialogDescription>
            Create a new API key for your team.
          </DialogDescription>
        </DialogHeader>

        <ApiKeyForm
          onSuccess={(key) => {
            if (key) {
              setCreatedKey(key);
            }
          }}
        />
      </div>
    );
  }

  return (
    <Dialog
      open={type === "create"}
      onOpenChange={() => {
        setData(undefined);
        setTimeout(() => {
          setCreatedKey(undefined);
        }, 500);
      }}
    >
      <DialogContent className="max-w-[455px]">{content}</DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/create-categories-modal.tsx">
import { InputColor } from "@/components/input-color";
import { useUserQuery } from "@/hooks/use-user";
import { useZodForm } from "@/hooks/use-zod-form";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import {
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
} from "@midday/ui/form";
import { Icons } from "@midday/ui/icons";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { Switch } from "@midday/ui/switch";
import { getTaxTypeForCountry, taxTypes } from "@midday/utils/tax";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useEffect } from "react";
import { useFieldArray } from "react-hook-form";
import { z } from "zod";
import { SelectTaxType } from "../select-tax-type";
import { TaxRateInput } from "../tax-rate-input";

type Props = {
  onOpenChange: (isOpen: boolean) => void;
  isOpen: boolean;
};

interface CategoryFormValues {
  name: string;
  description?: string;
  color?: string;
  taxRate?: number;
  taxType?: string;
  taxReportingCode?: string;
  excluded?: boolean;
}

interface CreateCategoriesFormValues {
  categories: CategoryFormValues[];
}

const formSchema = z.object({
  categories: z.array(
    z.object({
      name: z.string().min(1, "Name is required"),
      description: z.string().optional(),
      color: z.string().optional(),
      taxRate: z.number().optional(),
      taxType: z.string().optional(),
      taxReportingCode: z.string().optional(),
      excluded: z.boolean().optional(),
    }),
  ),
});

export function CreateCategoriesModal({ onOpenChange, isOpen }: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { data: user } = useUserQuery();

  const categoriesMutation = useMutation(
    trpc.transactionCategories.createMany.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.transactionCategories.get.queryKey(),
        });

        onOpenChange(false);
      },
    }),
  );

  const newItem = {
    name: "",
    description: "",
    color: undefined,
    taxType: getTaxTypeForCountry(user?.team?.countryCode ?? "").value,
    taxRate: undefined,
    taxReportingCode: "",
    excluded: false,
  };

  const form = useZodForm(formSchema, {
    defaultValues: {
      categories: [newItem],
    },
  });

  useEffect(() => {
    form.reset({
      categories: [newItem],
    });
  }, [isOpen, form]);

  const onSubmit = (data: CreateCategoriesFormValues) => {
    categoriesMutation.mutate(data.categories);
  };

  const { fields, append } = useFieldArray({
    name: "categories",
    control: form.control,
  });

  return (
    <DialogContent className="max-w-[455px]">
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)}>
          <div className="p-4">
            <DialogHeader className="mb-4">
              <DialogTitle>Create categories</DialogTitle>
              <DialogDescription>
                You can add your own categories here.
              </DialogDescription>
            </DialogHeader>

            <div className="flex flex-col space-y-6 max-h-[420px] overflow-auto">
              {fields.map((field, index) => (
                <div key={field.id} className="flex flex-col space-y-2">
                  <FormField
                    control={form.control}
                    name={`categories.${index}.name`}
                    render={({ field }) => (
                      <FormItem className="flex-1 space-y-1">
                        <FormLabel className="text-xs text-[#878787] font-normal">
                          Name
                        </FormLabel>
                        <FormControl>
                          <InputColor
                            autoFocus
                            placeholder="Name"
                            onChange={({ name, color }) => {
                              field.onChange(name);
                              form.setValue(`categories.${index}.color`, color);
                            }}
                            defaultValue={field.value}
                            defaultColor={form.watch(
                              `categories.${index}.color`,
                            )}
                          />
                        </FormControl>
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name={`categories.${index}.description`}
                    render={({ field }) => (
                      <FormItem className="flex-1 space-y-1">
                        <FormLabel className="text-xs text-[#878787] font-normal">
                          Description
                        </FormLabel>
                        <FormControl>
                          <Input
                            {...field}
                            autoFocus={false}
                            placeholder="Description"
                          />
                        </FormControl>
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name={`categories.${index}.taxReportingCode`}
                    render={({ field }) => (
                      <FormItem className="flex-1 space-y-1">
                        <FormLabel className="text-xs text-[#878787] font-normal">
                          Report Code
                        </FormLabel>
                        <FormControl>
                          <Input
                            {...field}
                            autoFocus={false}
                            placeholder="Report Code"
                          />
                        </FormControl>
                      </FormItem>
                    )}
                  />

                  <div className="flex relative gap-2">
                    <FormField
                      control={form.control}
                      name={`categories.${index}.taxType`}
                      render={({ field }) => (
                        <FormItem className="w-[300px] space-y-1">
                          <FormLabel className="text-xs text-[#878787] font-normal">
                            Tax Type
                          </FormLabel>
                          <FormControl>
                            <SelectTaxType
                              value={field.value ?? ""}
                              onChange={(value) => {
                                field.onChange(value);
                              }}
                            />
                          </FormControl>
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name={`categories.${index}.taxRate`}
                      render={({ field }) => (
                        <FormItem className="flex-1 space-y-1">
                          <FormLabel className="text-xs text-[#878787] font-normal">
                            Tax Rate
                          </FormLabel>
                          <FormControl>
                            <TaxRateInput
                              value={field.value}
                              name={
                                form.watch(`categories.${index}.name`) ?? ""
                              }
                              onChange={(value: string) => {
                                field.onChange(
                                  value ? Number(value) : undefined,
                                );
                              }}
                              onSelect={(taxRate) => {
                                if (taxRate) {
                                  field.onChange(taxRate);
                                }
                              }}
                            />
                          </FormControl>
                        </FormItem>
                      )}
                    />
                  </div>

                  <div className="flex relative gap-2">
                    <span className="text-xs text-muted-foreground flex-1">
                      {
                        taxTypes.find(
                          (taxType) =>
                            taxType.value ===
                            form.watch(`categories.${index}.taxType`),
                        )?.description
                      }
                    </span>
                  </div>

                  <FormField
                    control={form.control}
                    name={`categories.${index}.excluded`}
                    render={({ field }) => (
                      <FormItem className="flex-1 space-y-1">
                        <div className="border border-border p-3 mt-2 pt-1.5">
                          <div className="flex items-center justify-between space-x-2">
                            <div className="space-y-0.5">
                              <FormLabel className="text-xs text-[#878787] font-normal">
                                Exclude from Reports
                              </FormLabel>
                              <div className="text-xs text-muted-foreground">
                                Transactions in this category won't appear in
                                financial reports
                              </div>
                            </div>
                            <FormControl>
                              <Switch
                                checked={field.value ?? false}
                                onCheckedChange={field.onChange}
                              />
                            </FormControl>
                          </div>
                        </div>
                      </FormItem>
                    )}
                  />
                </div>
              ))}
            </div>

            <Button
              variant="outline"
              type="button"
              className="mt-4 space-x-1"
              onClick={() => {
                append(newItem);
              }}
            >
              <Icons.Add />
              <span>Add more</span>
            </Button>

            <DialogFooter className="border-t-[1px] pt-4 mt-8 items-center !justify-between">
              <div>
                {Object.values(form.formState.errors).length > 0 && (
                  <span className="text-sm text-destructive">
                    Please complete the fields above.
                  </span>
                )}
              </div>
              <SubmitButton isSubmitting={categoriesMutation.isPending}>
                Create
              </SubmitButton>
            </DialogFooter>
          </div>
        </form>
      </Form>
    </DialogContent>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/create-sub-category-modal.tsx">
import { useZodForm } from "@/hooks/use-zod-form";
import { useTRPC } from "@/trpc/client";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { Switch } from "@midday/ui/switch";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { z } from "zod";
import { InputColor } from "../input-color";
import { SelectTaxType } from "../select-tax-type";
import { TaxRateInput } from "../tax-rate-input";

type Props = {
  onOpenChange: (isOpen: boolean) => void;
  isOpen: boolean;
  parentId: string;
  defaultTaxRate?: number;
  defaultTaxType?: string;
  defaultColor?: string;
  defaultTaxReportingCode?: string;
  defaultExcluded?: boolean;
};

const formSchema = z.object({
  name: z.string().min(1, "Name is required"),
  description: z.string().optional().nullable(),
  color: z.string().optional().nullable(),
  taxRate: z.number().optional().nullable(),
  taxType: z.string().optional().nullable(),
  taxReportingCode: z.string().optional().nullable(),
  excluded: z.boolean().optional().nullable(),
  parentId: z.string().uuid(),
});

type CreateSubCategoryFormValues = z.infer<typeof formSchema>;

export function CreateSubCategoryModal({
  parentId,
  onOpenChange,
  isOpen,
  defaultTaxRate,
  defaultTaxType,
  defaultColor,
  defaultTaxReportingCode,
  defaultExcluded,
}: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const createSubCategoryMutation = useMutation(
    trpc.transactionCategories.create.mutationOptions({
      onSuccess: () => {
        onOpenChange(false);
        queryClient.invalidateQueries({
          queryKey: trpc.transactionCategories.get.queryKey(),
        });
      },
    }),
  );

  const form = useZodForm(formSchema, {
    defaultValues: {
      name: "",
      description: "",
      parentId,
      taxRate: defaultTaxRate,
      taxType: defaultTaxType,
      color: defaultColor,
      taxReportingCode: defaultTaxReportingCode,
      excluded: defaultExcluded ?? false,
    },
  });

  function onSubmit(values: CreateSubCategoryFormValues) {
    createSubCategoryMutation.mutate({
      ...values,
      description: values.description ?? undefined,
      color: values.color ?? undefined,
      taxRate: values.taxRate ?? undefined,
      taxType: values.taxType ?? undefined,
      taxReportingCode: values.taxReportingCode ?? undefined,
      excluded: values.excluded ?? false,
    });
  }

  return (
    <Dialog open={isOpen} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-[455px]">
        <div className="p-4">
          <DialogHeader>
            <DialogTitle>Create Sub Category</DialogTitle>
          </DialogHeader>

          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="mt-2 mb-6">
              <div className="flex flex-col space-y-2">
                <FormField
                  control={form.control}
                  name="name"
                  render={({ field }) => (
                    <FormItem className="flex-1 space-y-1">
                      <FormLabel className="text-xs text-[#878787] font-normal">
                        Name
                      </FormLabel>
                      <FormControl>
                        <div className="relative">
                          <InputColor
                            placeholder="Category"
                            onChange={({ name, color }) => {
                              form.setValue("color", color);
                              field.onChange(name);
                            }}
                            defaultValue={field.value}
                            defaultColor={form.watch("color") ?? undefined}
                          />
                          <FormMessage />
                        </div>
                      </FormControl>
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="description"
                  render={({ field }) => (
                    <FormItem className="flex-1 space-y-1">
                      <FormLabel className="text-xs text-[#878787] font-normal">
                        Description
                      </FormLabel>
                      <FormControl>
                        <Input
                          {...field}
                          autoFocus={false}
                          placeholder="Description"
                          value={field.value ?? ""}
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="taxReportingCode"
                  render={({ field }) => (
                    <FormItem className="flex-1 space-y-1">
                      <FormLabel className="text-xs text-[#878787] font-normal">
                        Report Code
                      </FormLabel>
                      <FormControl>
                        <Input
                          {...field}
                          autoFocus={false}
                          placeholder="Report Code"
                          value={field.value ?? ""}
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />

                <div className="flex relative gap-2">
                  <FormField
                    control={form.control}
                    name="taxType"
                    render={({ field }) => (
                      <FormItem className="w-[300px] space-y-1">
                        <FormLabel className="text-xs text-[#878787] font-normal">
                          Tax Type
                        </FormLabel>
                        <FormControl>
                          <SelectTaxType
                            value={field.value ?? ""}
                            onChange={(value) => {
                              field.onChange(value);
                            }}
                          />
                        </FormControl>
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="taxRate"
                    render={({ field }) => (
                      <FormItem className="flex-1 space-y-1">
                        <FormLabel className="text-xs text-[#878787] font-normal">
                          Tax Rate
                        </FormLabel>
                        <FormControl>
                          <TaxRateInput
                            value={field.value}
                            name={form.watch("name")}
                            onChange={(value: string) => {
                              field.onChange(value ? Number(value) : undefined);
                            }}
                            onSelect={(taxRate) => {
                              if (taxRate) {
                                form.setValue("taxRate", +taxRate);
                              }
                            }}
                          />
                        </FormControl>
                      </FormItem>
                    )}
                  />
                </div>

                <FormField
                  control={form.control}
                  name="excluded"
                  render={({ field }) => (
                    <FormItem className="flex-1 space-y-1">
                      <div className="border border-border p-3 mt-4">
                        <div className="flex items-center justify-between space-x-2">
                          <div className="space-y-0.5">
                            <FormLabel className="text-xs text-[#878787] font-normal">
                              Exclude from Reports
                            </FormLabel>
                            <div className="text-xs text-muted-foreground">
                              Transactions in this category won't appear in
                              financial reports
                            </div>
                          </div>
                          <FormControl>
                            <Switch
                              checked={field.value ?? false}
                              onCheckedChange={field.onChange}
                            />
                          </FormControl>
                        </div>
                      </div>
                    </FormItem>
                  )}
                />
              </div>

              <DialogFooter className="mt-8 w-full">
                <div className="space-y-4 w-full">
                  <SubmitButton
                    isSubmitting={createSubCategoryMutation.isPending}
                    className="w-full"
                  >
                    Save
                  </SubmitButton>
                </div>
              </DialogFooter>
            </form>
          </Form>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/delete-api-key-modal.tsx">
"use client";

import { useTokenModalStore } from "@/store/token-modal";
import { useTRPC } from "@/trpc/client";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import { SubmitButton } from "@midday/ui/submit-button";
import { useMutation, useQueryClient } from "@tanstack/react-query";

export function DeleteApiKeyModal() {
  const { setData, type, data } = useTokenModalStore();
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const deleteApiKeyMutation = useMutation(
    trpc.apiKeys.delete.mutationOptions({
      onSuccess: () => {
        setData(undefined);
        queryClient.invalidateQueries(trpc.apiKeys.get.queryOptions());
      },
    }),
  );

  return (
    <Dialog open={type === "delete"} onOpenChange={() => setData(undefined)}>
      <DialogContent
        className="max-w-[455px]"
        onOpenAutoFocus={(evt) => evt.preventDefault()}
      >
        <div className="p-4 space-y-4">
          <DialogHeader>
            <DialogTitle>Delete API Key</DialogTitle>
            <DialogDescription>
              This will permanently delete the API key{" "}
              <span className="text-primary">{data?.name}</span> for and revoke
              all access to your account. Are you sure you want to continue?
            </DialogDescription>
          </DialogHeader>

          <SubmitButton
            className="w-full mt-4"
            onClick={() => deleteApiKeyMutation.mutate({ id: data?.id! })}
            isSubmitting={deleteApiKeyMutation.isPending}
          >
            Delete
          </SubmitButton>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/delete-oauth-application-modal.tsx">
"use client";

import { useOAuthApplicationParams } from "@/hooks/use-oauth-application-params";
import { useTRPC } from "@/trpc/client";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@midday/ui/alert-dialog";
import { Input } from "@midday/ui/input";
import { Label } from "@midday/ui/label";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { Loader2 } from "lucide-react";
import { useState } from "react";

type Props = {
  applicationId: string;
  applicationName: string;
  isOpen: boolean;
  onOpenChange: (open: boolean) => void;
};

export function DeleteOAuthApplicationModal({
  applicationId,
  applicationName,
  isOpen,
  onOpenChange,
}: Props) {
  const [value, setValue] = useState("");
  const { setParams } = useOAuthApplicationParams();
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const deleteApplicationMutation = useMutation(
    trpc.oauthApplications.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.oauthApplications.list.queryKey(),
        });
        onOpenChange(false);
        setParams(null);
        setValue("");
      },
    }),
  );

  const handleClose = () => {
    onOpenChange(false);
    setValue("");
  };

  return (
    <AlertDialog open={isOpen} onOpenChange={handleClose}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
          <AlertDialogDescription>
            This action cannot be undone. This will permanently delete the OAuth
            application <strong>&quot;{applicationName}&quot;</strong> and all
            associated data.
          </AlertDialogDescription>
        </AlertDialogHeader>

        <div className="space-y-4 mt-4">
          <div className="p-4 bg-muted">
            <h4 className="font-medium mb-2">What will happen:</h4>
            <ul className="text-sm space-y-1 text-muted-foreground">
              <li>• All active OAuth tokens will be revoked immediately</li>
              <li>• Applications using this OAuth app will stop working</li>
              <li>• All authorization codes will be invalidated</li>
              <li>• Client credentials will be permanently deleted</li>
              <li>• This action cannot be undone</li>
            </ul>
          </div>

          <div className="space-y-2">
            <Label htmlFor="confirm-delete">
              Type <span className="font-medium">DELETE</span> to confirm.
            </Label>
            <Input
              id="confirm-delete"
              value={value}
              onChange={(e) => setValue(e.target.value)}
              placeholder="DELETE"
            />
          </div>
        </div>

        <AlertDialogFooter>
          <AlertDialogCancel>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={() =>
              deleteApplicationMutation.mutate({
                id: applicationId,
              })
            }
            disabled={value !== "DELETE" || deleteApplicationMutation.isPending}
            className="bg-destructive hover:bg-destructive"
          >
            {deleteApplicationMutation.isPending ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              "Delete"
            )}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/edit-api-key-modal.tsx">
"use client";

import { ApiKeyForm } from "@/components/forms/api-key-form";
import { useTokenModalStore } from "@/store/token-modal";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";

export function EditApiKeyModal() {
  const { setData, data, type } = useTokenModalStore();

  return (
    <Dialog open={type === "edit"} onOpenChange={() => setData(undefined)}>
      <DialogContent
        className="max-w-[455px]"
        onOpenAutoFocus={(evt) => evt.preventDefault()}
      >
        <div className="p-4 space-y-4">
          <DialogHeader>
            <DialogTitle>Edit API Key</DialogTitle>
          </DialogHeader>

          <ApiKeyForm onSuccess={() => setData(undefined)} />
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/edit-bank-account-modal.tsx">
import { useZodForm } from "@/hooks/use-zod-form";
import { useI18n } from "@/locales/client";
import { useTRPC } from "@/trpc/client";
import { CurrencyInput } from "@midday/ui/currency-input";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";
import { SubmitButton } from "@midday/ui/submit-button";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { z } from "zod";

const formSchema = z.object({
  name: z.string().min(1, {
    message: "Account Name must be at least 1 characters.",
  }),
  type: z.string(),
  balance: z.number().min(0, {
    message: "Balance must be at least 0.",
  }),
});

type Props = {
  id: string;
  onOpenChange: (isOpen: boolean) => void;
  isOpen: boolean;
  defaultName: string | null;
  defaultType?: string | null;
  defaultBalance: number | null;
};

export function EditBankAccountModal({
  id,
  onOpenChange,
  isOpen,
  defaultName,
  defaultType,
  defaultBalance,
}: Props) {
  const t = useI18n();
  const queryClient = useQueryClient();
  const trpc = useTRPC();

  const form = useZodForm(formSchema, {
    defaultValues: {
      name: defaultName ?? undefined,
      type: defaultType ?? undefined,
      balance: defaultBalance ?? undefined,
    },
  });

  const updateAccountMutation = useMutation(
    trpc.bankAccounts.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.bankConnections.get.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.bankAccounts.get.queryKey(),
        });

        onOpenChange(false);
      },
    }),
  );

  function onSubmit(values: z.infer<typeof formSchema>) {
    updateAccountMutation.mutate({
      id,
      name: values.name,
      balance: values.balance,
      type: values.type as
        | "depository"
        | "credit"
        | "other_asset"
        | "loan"
        | "other_liability",
    });
  }

  const accountTypes = () => {
    return [
      "depository",
      "credit",
      "other_asset",
      "loan",
      "other_liability",
    ].map((type) => (
      <SelectItem key={type} value={type}>
        {/* @ts-expect-error */}
        {t(`account_type.${type}`)}
      </SelectItem>
    ));
  };

  return (
    <Dialog open={isOpen} onOpenChange={onOpenChange}>
      <DialogContent
        className="max-w-[455px]"
        onOpenAutoFocus={(evt) => evt.preventDefault()}
      >
        <div className="p-4">
          <DialogHeader>
            <DialogTitle className="flex justify-between">
              Edit Account
            </DialogTitle>
          </DialogHeader>

          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="mt-6">
              <FormField
                control={form.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Name</FormLabel>
                    <FormControl>
                      <Input
                        autoFocus
                        placeholder="Company Account"
                        autoComplete="off"
                        autoCapitalize="none"
                        autoCorrect="off"
                        spellCheck="false"
                        {...field}
                      />
                    </FormControl>
                    <FormDescription>
                      You can change the name of the account here
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="type"
                render={({ field }) => (
                  <FormItem className="mt-4">
                    <FormLabel>Type</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Change account type" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>{accountTypes()}</SelectContent>
                    </Select>
                    <FormDescription>Change the account type</FormDescription>
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="balance"
                render={({ field }) => (
                  <FormItem className="mt-4">
                    <FormLabel>Balance</FormLabel>

                    <FormControl>
                      <CurrencyInput
                        min={0}
                        value={field.value}
                        onValueChange={(values) => {
                          field.onChange(values.floatValue);
                        }}
                      />
                    </FormControl>

                    <FormDescription>
                      Change the account balance
                    </FormDescription>
                  </FormItem>
                )}
              />

              <DialogFooter className="mt-10 w-full">
                <div className="space-y-4 w-full">
                  <SubmitButton
                    isSubmitting={updateAccountMutation.isPending}
                    className="w-full"
                    type="submit"
                  >
                    Save
                  </SubmitButton>
                </div>
              </DialogFooter>
            </form>
          </Form>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/edit-category-modal.tsx">
import { useZodForm } from "@/hooks/use-zod-form";
import { useTRPC } from "@/trpc/client";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { Switch } from "@midday/ui/switch";
import { taxTypes } from "@midday/utils/tax";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { z } from "zod";
import { InputColor } from "../input-color";
import { SelectTaxType } from "../select-tax-type";
import { TaxRateInput } from "../tax-rate-input";

type Props = {
  id: string;
  onOpenChange: (isOpen: boolean) => void;
  isOpen: boolean;
  defaultValue: {
    name: string;
    color: string | null;
    description?: string | null;
    taxRate?: number | null;
    taxType?: string | null;
    taxReportingCode?: string | null;
    excluded?: boolean | null;
  };
};

const formSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1, "Name is required"),
  description: z.string().optional().nullable(),
  color: z.string().optional().nullable(),
  taxRate: z.number().optional().nullable(),
  taxType: z.string().optional().nullable(),
  taxReportingCode: z.string().optional().nullable(),
  excluded: z.boolean().optional().nullable(),
});

type UpdateCategoriesFormValues = z.infer<typeof formSchema>;

export function EditCategoryModal({
  id,
  onOpenChange,
  isOpen,
  defaultValue,
}: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const updateCategoryMutation = useMutation(
    trpc.transactionCategories.update.mutationOptions({
      onSuccess: () => {
        onOpenChange(false);
        queryClient.invalidateQueries({
          queryKey: trpc.transactionCategories.get.queryKey(),
        });
      },
    }),
  );

  const form = useZodForm(formSchema, {
    defaultValues: {
      id,
      name: defaultValue.name,
      color: defaultValue.color,
      description: defaultValue.description ?? undefined,
      taxRate: defaultValue?.taxRate ? Number(defaultValue.taxRate) : undefined,
      taxType: defaultValue?.taxType ?? undefined,
      taxReportingCode: defaultValue?.taxReportingCode ?? undefined,
      excluded: defaultValue?.excluded ?? false,
    },
  });

  function onSubmit(values: UpdateCategoriesFormValues) {
    updateCategoryMutation.mutate({
      ...values,
      description: values.description ?? null,
      taxRate: values.taxRate
        ? values.taxRate > 0
          ? values.taxRate
          : null
        : null,
      taxType: values.taxType ?? null,
      color: values.color ?? null,
      taxReportingCode: values.taxReportingCode ?? null,
      excluded: values.excluded ?? false,
    });
  }

  return (
    <Dialog open={isOpen} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-[455px]">
        <div className="p-4">
          <DialogHeader>
            <DialogTitle>Edit Category</DialogTitle>
          </DialogHeader>

          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="mt-2 mb-6">
              <div className="flex flex-col space-y-2">
                <FormField
                  control={form.control}
                  name="name"
                  render={({ field }) => (
                    <FormItem className="flex-1 space-y-1">
                      <FormLabel className="text-xs text-[#878787] font-normal">
                        Name
                      </FormLabel>
                      <FormControl>
                        <div className="relative">
                          <InputColor
                            placeholder="Category"
                            onChange={({ name, color }) => {
                              form.setValue("color", color);
                              field.onChange(name);
                            }}
                            defaultValue={field.value}
                            defaultColor={form.watch("color") ?? undefined}
                          />
                          <FormMessage />
                        </div>
                      </FormControl>
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="description"
                  render={({ field }) => (
                    <FormItem className="flex-1 space-y-1">
                      <FormLabel className="text-xs text-[#878787] font-normal">
                        Description
                      </FormLabel>
                      <FormControl>
                        <Input
                          {...field}
                          autoFocus={false}
                          placeholder="Description"
                          value={field.value ?? ""}
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="taxReportingCode"
                  render={({ field }) => (
                    <FormItem className="flex-1 space-y-1">
                      <FormLabel className="text-xs text-[#878787] font-normal">
                        Report Code
                      </FormLabel>
                      <FormControl>
                        <Input
                          {...field}
                          autoFocus={false}
                          placeholder="Report Code"
                          value={field.value ?? ""}
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />

                <div className="flex relative gap-2">
                  <FormField
                    control={form.control}
                    name="taxType"
                    render={({ field }) => (
                      <FormItem className="w-[300px] space-y-1">
                        <FormLabel className="text-xs text-[#878787] font-normal">
                          Tax Type
                        </FormLabel>
                        <FormControl>
                          <SelectTaxType
                            value={field.value ?? ""}
                            onChange={(value) => {
                              field.onChange(value);
                            }}
                          />
                        </FormControl>
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="taxRate"
                    render={({ field }) => (
                      <FormItem className="flex-1 space-y-1">
                        <FormLabel className="text-xs text-[#878787] font-normal">
                          Tax Rate
                        </FormLabel>
                        <FormControl>
                          <TaxRateInput
                            value={field.value}
                            name={form.watch("name")}
                            onChange={(value: string) => {
                              field.onChange(value ? Number(value) : undefined);
                            }}
                            onSelect={(taxRate) => {
                              if (taxRate) {
                                form.setValue("taxRate", +taxRate);
                              }
                            }}
                          />
                        </FormControl>
                      </FormItem>
                    )}
                  />
                </div>

                <div className="flex relative gap-2">
                  <span className="text-xs text-muted-foreground flex-1">
                    {
                      taxTypes.find(
                        (taxType) => taxType.value === form.watch("taxType"),
                      )?.description
                    }
                  </span>
                </div>

                <FormField
                  control={form.control}
                  name="excluded"
                  render={({ field }) => (
                    <FormItem className="flex-1 space-y-1">
                      <div className="border border-border p-3 mt-4">
                        <div className="flex items-center justify-between space-x-2">
                          <div className="space-y-0.5">
                            <FormLabel className="text-xs text-[#878787] font-normal">
                              Exclude from Reports
                            </FormLabel>
                            <div className="text-xs text-muted-foreground">
                              Transactions in this category won't appear in
                              financial reports
                            </div>
                          </div>
                          <FormControl>
                            <Switch
                              checked={field.value ?? false}
                              onCheckedChange={field.onChange}
                            />
                          </FormControl>
                        </div>
                      </div>
                    </FormItem>
                  )}
                />
              </div>

              <DialogFooter className="mt-8 w-full">
                <div className="space-y-4 w-full">
                  <SubmitButton
                    isSubmitting={updateCategoryMutation.isPending}
                    className="w-full"
                  >
                    Save
                  </SubmitButton>
                </div>
              </DialogFooter>
            </form>
          </Form>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/edit-inbox-modal.tsx">
"use client";

import { useInboxParams } from "@/hooks/use-inbox-params";
import { useZodForm } from "@/hooks/use-zod-form";
import { useTRPC } from "@/trpc/client";
import { CurrencyInput } from "@midday/ui/currency-input";
import { DialogContent, DialogHeader, DialogTitle } from "@midday/ui/dialog";
import { Dialog } from "@midday/ui/dialog";
import {
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@midday/ui/form";
import { Form } from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useEffect } from "react";
import { z } from "zod";

type Props = {
  children: React.ReactNode;
};

const formSchema = z.object({
  displayName: z.string().min(1),
  amount: z.number(),
});

export function EditInboxModal({ children }: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { params } = useInboxParams();

  const { data } = useQuery(
    trpc.inbox.getById.queryOptions(
      {
        id: params.inboxId!,
      },
      {
        enabled: !!params.inboxId,
      },
    ),
  );

  const form = useZodForm(formSchema, {
    defaultValues: {
      displayName: data?.displayName ?? undefined,
      amount: data?.amount ?? undefined,
    },
  });

  const updateInboxMutation = useMutation(
    trpc.inbox.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.inbox.get.queryKey(),
        });
      },
    }),
  );

  function onSubmit(values: z.infer<typeof formSchema>) {
    updateInboxMutation.mutate({
      id: data?.id!,
      displayName: values.displayName,
      amount: values.amount,
    });
  }

  useEffect(() => {
    if (data) {
      form.reset({
        displayName: data.displayName ?? undefined,
        amount: data.amount ?? undefined,
      });
    }
  }, [data]);

  return (
    <Dialog>
      <DialogContent
        className="max-w-[455px]"
        onOpenAutoFocus={(evt) => evt.preventDefault()}
      >
        <div className="p-4">
          <DialogHeader className="mb-4">
            <DialogTitle>Edit</DialogTitle>
          </DialogHeader>

          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="displayName"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Display Name</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="amount"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Amount</FormLabel>
                    <FormControl>
                      <CurrencyInput
                        min={0}
                        decimalScale={2}
                        fixedDecimalScale={true}
                        value={field.value}
                        onValueChange={(values) => {
                          field.onChange(values.floatValue);
                        }}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <SubmitButton
                type="submit"
                isSubmitting={updateInboxMutation.isPending}
                className="mt-4 w-full"
              >
                Save
              </SubmitButton>
            </form>
          </Form>
        </div>
      </DialogContent>

      {children}
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/invite-team-members-modal.tsx">
"use client";

import {
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import { InviteForm } from "../forms/invite-form";

type InviteTeamMembersModalProps = {
  onOpenChange: (open: boolean) => void;
};

export function InviteTeamMembersModal({
  onOpenChange,
}: InviteTeamMembersModalProps) {
  return (
    <DialogContent className="max-w-[455px]">
      <div className="p-4">
        <DialogHeader>
          <DialogTitle>Invite Members</DialogTitle>
          <DialogDescription>
            Invite new members by email address.
          </DialogDescription>
        </DialogHeader>

        <InviteForm onSuccess={() => onOpenChange(false)} skippable={false} />
      </div>
    </DialogContent>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/oauth-secret-modal.tsx">
"use client";

import { useOAuthSecretModalStore } from "@/store/oauth-secret-modal";
import { Button } from "@midday/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import { Label } from "@midday/ui/label";
import { CopyInput } from "../copy-input";

export function OAuthSecretModal() {
  const { isOpen, clientSecret, applicationName, close } =
    useOAuthSecretModalStore();

  return (
    <Dialog open={isOpen} onOpenChange={() => close()}>
      <DialogContent className="max-w-[455px]">
        <div className="p-4 space-y-4">
          <DialogHeader>
            <DialogTitle>OAuth Application Created</DialogTitle>
            <DialogDescription>
              Your OAuth application "{applicationName}" has been created
              successfully. For security reasons, the client secret will only be
              shown once. Please copy and store it in a secure location.
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-3">
            <div>
              <Label className="text-sm font-medium mb-1 block">
                Client Secret
              </Label>
              <CopyInput value={clientSecret || ""} />
            </div>
          </div>

          <DialogFooter>
            <Button onClick={close} className="w-full">
              Done
            </Button>
          </DialogFooter>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/overview-modal.tsx">
"use client";

import { hideConnectFlowAction } from "@/actions/hide-connect-flow-action";
import { AddAccountButton } from "@/components/add-account-button";
import { useTRPC } from "@/trpc/client";
import { cn } from "@midday/ui/cn";
import { Dialog, DialogContent } from "@midday/ui/dialog";
import { useQuery } from "@tanstack/react-query";
import { useAction } from "next-safe-action/hooks";
import Image from "next/image";
import OverViewScreenOneLight from "public/assets/overview-1-light.png";
import OverViewScreenOne from "public/assets/overview-1.png";
import OverViewScreenTwoLight from "public/assets/overview-2-light.png";
import OverViewScreenTwo from "public/assets/overview-2.png";
import { Fragment, useEffect, useState } from "react";

const images = [
  { id: 1, src: OverViewScreenOne, src2: OverViewScreenOneLight },
  { id: 2, src: OverViewScreenTwo, src2: OverViewScreenTwoLight },
];

type Props = {
  hideConnectFlow: boolean;
};

export function OverviewModal({ hideConnectFlow: hasHideConnectFlow }: Props) {
  const trpc = useTRPC();
  const [activeId, setActive] = useState(1);
  const [isOpen, setIsOpen] = useState(false);

  const hideConnectFlow = useAction(hideConnectFlowAction);

  const { data: accounts } = useQuery(
    trpc.bankAccounts.get.queryOptions({
      enabled: true,
    }),
  );

  const handleOnOpenChange = () => {
    setIsOpen(!isOpen);

    if (isOpen) {
      hideConnectFlow.execute();
    }
  };

  useEffect(() => {
    // If the user has not connected any accounts and the modal is defaultOpen, open the modal
    if (!accounts?.length && !hasHideConnectFlow) {
      setIsOpen(true);
    }
  }, [accounts, hasHideConnectFlow]);

  return (
    <Dialog open={isOpen} onOpenChange={handleOnOpenChange}>
      <DialogContent
        onInteractOutside={(e) => {
          e.preventDefault();
        }}
      >
        <div className="bg-background p-2">
          <div className="p-4">
            <div className="mb-8 space-y-5">
              <h2 className="font-medium text-xl">
                Get insights of your business you didn't know
              </h2>
              <p className="text-[#878787] text-sm">
                View real-time profit/revenue as well as revenue numbers.
                Compare to previous years. See what you spend your money on and
                where you can save.
              </p>
            </div>

            <div className="pb-8 relative h-[272px]">
              {images.map((image) => (
                <Fragment key={image.id}>
                  <Image
                    quality={100}
                    src={image.src}
                    width={486}
                    height={251}
                    alt="Overview"
                    className={cn(
                      "w-full opacity-0 absolute transition-all hidden dark:block",
                      image.id === activeId && "opacity-1",
                    )}
                  />

                  <Image
                    quality={100}
                    src={image.src2}
                    width={486}
                    height={251}
                    alt="Overview"
                    className={cn(
                      "w-full opacity-0 absolute transition-all block dark:hidden",
                      image.id === activeId && "opacity-1",
                    )}
                  />
                </Fragment>
              ))}
            </div>

            <div className="flex justify-between mt-12 items-center">
              <div className="flex space-x-2">
                {images.map((image) => (
                  <button
                    type="button"
                    onMouseEnter={() => setActive(image.id)}
                    onClick={() => setActive(image.id)}
                    key={image.id}
                    className={cn(
                      "w-[16px] h-[6px] rounded-full bg-[#1D1D1D] dark:bg-[#D9D9D9] opacity-30 transition-all cursor-pointer",
                      image.id === activeId && "opacity-1",
                    )}
                  />
                ))}
              </div>

              <AddAccountButton onClick={handleOnOpenChange} />
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/select-bank-accounts.tsx">
"use client";

import { sendSupportAction } from "@/actions/send-support-action";
import { useConnectParams } from "@/hooks/use-connect-params";
import { useZodForm } from "@/hooks/use-zod-form";
import { useI18n } from "@/locales/client";
import { useTRPC } from "@/trpc/client";
import { getInitials } from "@/utils/format";
import { zodResolver } from "@hookform/resolvers/zod";
import { Avatar, AvatarFallback } from "@midday/ui/avatar";
import { Button } from "@midday/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
} from "@midday/ui/form";
import { Icons } from "@midday/ui/icons";
import { Skeleton } from "@midday/ui/skeleton";
import { SubmitButton } from "@midday/ui/submit-button";
import { Switch } from "@midday/ui/switch";
import { Tabs, TabsContent } from "@midday/ui/tabs";
import { Textarea } from "@midday/ui/textarea";
import { useToast } from "@midday/ui/use-toast";
import { useQuery } from "@tanstack/react-query";
import { useMutation } from "@tanstack/react-query";
import { Loader2 } from "lucide-react";
import { useAction } from "next-safe-action/hooks";
import { useEffect, useState } from "react";
import { useForm } from "react-hook-form";
import z from "zod";
import { FormatAmount } from "../format-amount";
import { LoadingTransactionsEvent } from "../loading-transactions-event";

function RowsSkeleton() {
  return (
    <div className="space-y-6">
      {Array.from({ length: 3 }).map((_, index) => (
        <div key={index.toString()} className="flex items-center space-x-4">
          <Skeleton className="h-9 w-9 rounded-full" />
          <div className="space-y-2">
            <Skeleton className="h-3.5 w-[250px] rounded-none" />
            <Skeleton className="h-2.5 w-[200px] rounded-none" />
          </div>
        </div>
      ))}
    </div>
  );
}

function SupportForm() {
  const form = useForm({
    resolver: zodResolver(z.object({ message: z.string() })),
    defaultValues: {
      message: "",
    },
  });

  const sendSupport = useAction(sendSupportAction, {
    onSuccess: () => {
      form.reset();
    },
  });

  const handleOnSubmit = form.handleSubmit((values) => {
    sendSupport.execute({
      message: values.message,
      type: "bank-connection",
      priority: "3",
      subject: "Select bank accounts",
      url: document.URL,
    });
  });

  if (sendSupport.status === "hasSucceeded") {
    return (
      <div className="h-[250px] flex items-center justify-center flex-col space-y-1">
        <p className="font-medium text-sm">Thank you!</p>
        <p className="text-sm text-[#4C4C4C]">
          We will be back with you as soon as possible.
        </p>
      </div>
    );
  }

  return (
    <Form {...form}>
      <form onSubmit={handleOnSubmit}>
        <FormField
          control={form.control}
          name="message"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Message</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Describe the issue you're facing, along with any relevant information. Please be as detailed and specific as possible."
                  className="resize-none min-h-[150px]"
                  autoFocus
                  {...field}
                />
              </FormControl>
            </FormItem>
          )}
        />

        <div className="flex justify-end">
          <Button
            type="submit"
            disabled={
              sendSupport.status === "executing" || !form.formState.isValid
            }
            className="mt-4"
          >
            {sendSupport.status === "executing" ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              "Submit"
            )}
          </Button>
        </div>
      </form>
    </Form>
  );
}

const formSchema = z.object({
  referenceId: z.string().nullable().optional(), // GoCardLess
  accessToken: z.string().nullable().optional(), // Teller
  enrollmentId: z.string().nullable().optional(), // Teller
  provider: z.enum(["gocardless", "plaid", "teller", "enablebanking"]),
  accounts: z
    .array(
      z.object({
        accountId: z.string(),
        bankName: z.string(),
        balance: z.number().optional(),
        currency: z.string(),
        name: z.string(),
        institutionId: z.string(),
        accountReference: z.string().nullable().optional(), // EnableBanking & GoCardLess
        enabled: z.boolean(),
        logoUrl: z.string().nullable().optional(),
        expiresAt: z.string().nullable().optional(), // EnableBanking & GoCardLess
        type: z.enum([
          "credit",
          "depository",
          "other_asset",
          "loan",
          "other_liability",
        ]),
      }),
    )
    .refine((accounts) => accounts.some((account) => account.enabled), {
      message: "At least one account must be selected.", // You might want a more specific message depending on UI context
    }),
});

export function SelectBankAccountsModal() {
  const { toast } = useToast();
  const trpc = useTRPC();
  const t = useI18n();

  const [runId, setRunId] = useState<string>();
  const [accessToken, setAccessToken] = useState<string>();
  const [activeTab, setActiveTab] = useState<
    "select-accounts" | "loading" | "support"
  >("select-accounts");

  const {
    step,
    error,
    setParams,
    provider,
    ref,
    institution_id,
    token,
    enrollment_id,
  } = useConnectParams();

  const isOpen = step === "account";

  const { data, isLoading } = useQuery(
    trpc.institutions.accounts.queryOptions(
      {
        id: ref ?? undefined,
        accessToken: token ?? undefined,
        institutionId: institution_id ?? undefined,
        provider: provider as
          | "gocardless"
          | "plaid"
          | "teller"
          | "enablebanking",
      },
      {
        enabled: isOpen,
      },
    ),
  );

  const connectBankConnectionMutation = useMutation(
    trpc.bankConnections.create.mutationOptions({
      onError: () => {
        toast({
          duration: 3500,
          variant: "error",
          title: "Something went wrong please try again.",
        });
      },
      onSuccess: (data) => {
        if (data?.id) {
          setRunId(data.id);
          setAccessToken(data.publicAccessToken);
          setActiveTab("loading");
        }
      },
    }),
  );

  useEffect(() => {
    if (error) {
      // NOTE: On GoCardLess cancel flow
      setParams({
        step: "connect",
        error: null,
        details: null,
        provider: null,
      });
    }
  }, [error, setParams]);

  const onClose = () => {
    setParams(null);
  };

  const form = useZodForm(formSchema, {
    defaultValues: {
      accessToken: token ?? undefined,
      enrollmentId: enrollment_id ?? undefined,
      referenceId: ref ?? undefined,
      provider: provider as "gocardless" | "plaid" | "teller" | "enablebanking",
      accounts: [],
    },
  });

  useEffect(() => {
    form.reset({
      provider: provider as "gocardless" | "plaid" | "teller" | "enablebanking",
      accessToken: token ?? undefined,
      enrollmentId: enrollment_id ?? undefined,
      // GoCardLess Requestion ID or Plaid Item ID
      referenceId: ref ?? undefined,
      accounts: data?.map((account) => ({
        name: account.name,
        institutionId: account.institution.id,
        logoUrl: account.institution?.logo,
        accountId: account.id,
        accountReference: account.resource_id,
        bankName: account.institution.name,
        // TODO: Remove once we have a fix and return currency from engine
        currency: account.currency ?? account.balance.currency,
        balance: account.balance.amount,
        enabled: true,
        type: account.type,
        expiresAt: account.expires_at,
      })),
    });
  }, [data, ref]);

  function onSubmit(values: z.infer<typeof formSchema>) {
    connectBankConnectionMutation.mutate(values);
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent
        onPointerDownOutside={(event) => event.preventDefault()}
        onEscapeKeyDown={(event) => event.preventDefault()}
      >
        <div className="p-4">
          <Tabs defaultValue="select-accounts" value={activeTab}>
            <TabsContent value="select-accounts">
              <>
                <DialogHeader className="mb-8">
                  <DialogTitle>Select Accounts</DialogTitle>
                  <DialogDescription>
                    Select the accounts to receive transactions. You can enable
                    or disable them later in settings if needed. Note: Initial
                    loading may take some time.
                  </DialogDescription>
                </DialogHeader>

                <Form {...form}>
                  <form
                    onSubmit={form.handleSubmit(onSubmit)}
                    className="space-y-6 h-[300px] overflow-auto pb-[100px] relative scrollbar-hide"
                  >
                    {isLoading && <RowsSkeleton />}

                    {data?.map((account) => (
                      <FormField
                        key={account.id}
                        control={form.control}
                        name="accounts"
                        render={({ field }) => {
                          return (
                            <FormItem
                              key={account.id}
                              className="flex justify-between"
                            >
                              <FormLabel className="flex items-center space-x-4 w-full mr-8">
                                <Avatar className="size-[34px]">
                                  <AvatarFallback className="text-[11px]">
                                    {getInitials(account.name)}
                                  </AvatarFallback>
                                </Avatar>

                                <div className="flex items-center justify-between w-full">
                                  <div className="flex flex-col">
                                    <p className="font-medium leading-none mb-1 text-sm">
                                      {account.name}
                                    </p>
                                    <span className="text-xs text-[#878787] font-normal">
                                      {t(`account_type.${account.type}`)}
                                    </span>
                                  </div>

                                  <span className="text-[#878787] text-sm">
                                    <FormatAmount
                                      amount={account.balance.amount}
                                      currency={account.balance.currency}
                                    />
                                  </span>
                                </div>
                              </FormLabel>

                              <div>
                                <FormControl>
                                  <Switch
                                    checked={
                                      field.value?.find(
                                        (value) =>
                                          value.accountId === account.id,
                                      )?.enabled
                                    }
                                    onCheckedChange={(checked) => {
                                      return field.onChange(
                                        field.value.map((value) => {
                                          if (value.accountId === account.id) {
                                            return {
                                              ...value,
                                              enabled: checked,
                                            };
                                          }

                                          return value;
                                        }),
                                      );
                                    }}
                                  />
                                </FormControl>
                              </div>
                            </FormItem>
                          );
                        }}
                      />
                    ))}

                    <div className="fixed bottom-0 left-0 right-0 z-10 bg-background pt-4 px-6 pb-6">
                      <SubmitButton
                        className="w-full"
                        type="submit"
                        isSubmitting={connectBankConnectionMutation.isPending}
                        disabled={
                          connectBankConnectionMutation.isPending ||
                          !form.formState.isValid
                        }
                      >
                        Save
                      </SubmitButton>

                      <div className="flex justify-center mt-4">
                        <button
                          type="button"
                          className="text-xs text-[#878787]"
                          onClick={() => setActiveTab("support")}
                        >
                          Need support
                        </button>
                      </div>
                    </div>
                  </form>
                </Form>
              </>
            </TabsContent>

            <TabsContent value="loading">
              <LoadingTransactionsEvent
                accessToken={accessToken}
                runId={runId}
                setRunId={setRunId}
                onClose={onClose}
                setActiveTab={setActiveTab}
              />
            </TabsContent>

            <TabsContent value="support">
              <div className="flex items-center space-x-3 mb-6">
                <button
                  type="button"
                  className="items-center border bg-accent p-1"
                  onClick={() => setActiveTab("select-accounts")}
                >
                  <Icons.ArrowBack />
                </button>
                <h2>Support</h2>
              </div>
              <SupportForm />
            </TabsContent>
          </Tabs>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/transactions-modal.tsx">
"use client";

import { hideConnectFlowAction } from "@/actions/hide-connect-flow-action";
import { AddAccountButton } from "@/components/add-account-button";
import { cn } from "@midday/ui/cn";
import { Dialog, DialogContent } from "@midday/ui/dialog";
import { useAction } from "next-safe-action/hooks";
import Image from "next/image";
import TransactionsScreenOneLight from "public/assets/transactions-1-light.png";
import TransactionsScreenOne from "public/assets/transactions-1.png";
import TransactionsScreenTwoLight from "public/assets/transactions-2-light.png";
import TransactionsScreenTwo from "public/assets/transactions-2.png";
import { Fragment, useState } from "react";

const images = [
  { id: 1, src: TransactionsScreenOne, src2: TransactionsScreenOneLight },
  { id: 2, src: TransactionsScreenTwo, src2: TransactionsScreenTwoLight },
];

export function TransactionsModal({
  defaultOpen = false,
}: {
  defaultOpen?: boolean;
}) {
  const [activeId, setActive] = useState(1);
  const [isOpen, setIsOpen] = useState(defaultOpen);

  const hideConnectFlow = useAction(hideConnectFlowAction);

  const handleOnOpenChange = () => {
    setIsOpen(!isOpen);

    if (isOpen) {
      hideConnectFlow.execute();
    }
  };

  return (
    <Dialog
      defaultOpen={defaultOpen}
      open={isOpen}
      onOpenChange={handleOnOpenChange}
    >
      <DialogContent
        onInteractOutside={(e) => {
          e.preventDefault();
        }}
      >
        <div className="bg-background p-2">
          <div className="p-4">
            <div className="mb-8 space-y-5">
              <h2 className="font-medium text-xl">
                Get real-time transaction data
              </h2>
              <p className="text-[#878787] text-sm">
                Get instant transaction insights. Easily spot missing receipts,
                categorize expenses, and reconcile everything seamlessly for
                accounting.
              </p>
            </div>

            <div className="pb-8 relative h-[272px]">
              {images.map((image) => (
                <Fragment key={image.id}>
                  <Image
                    quality={100}
                    src={image.src}
                    width={486}
                    height={251}
                    alt="Overview"
                    className={cn(
                      "w-full opacity-0 absolute transition-all hidden dark:block",
                      image.id === activeId && "opacity-1",
                    )}
                  />

                  <Image
                    quality={100}
                    src={image.src2}
                    width={486}
                    height={251}
                    alt="Overview"
                    className={cn(
                      "w-full opacity-0 absolute transition-all block dark:hidden",
                      image.id === activeId && "opacity-1",
                    )}
                  />
                </Fragment>
              ))}
            </div>

            <div className="flex justify-between mt-12 items-center">
              <div className="flex space-x-2">
                {images.map((image) => (
                  <button
                    type="button"
                    onMouseEnter={() => setActive(image.id)}
                    onClick={() => setActive(image.id)}
                    key={image.id}
                    className={cn(
                      "w-[16px] h-[6px] rounded-full bg-[#1D1D1D] dark:bg-[#D9D9D9] opacity-30 transition-all cursor-pointer",
                      image.id === activeId && "opacity-1",
                    )}
                  />
                ))}
              </div>

              <AddAccountButton />
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/modals/trial-ended-modal.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { UTCDate } from "@date-fns/utc";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import { addDays, differenceInDays, isSameDay, parseISO } from "date-fns";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { Plans } from "../plans";

export function TrialEndedModal() {
  const { data: user } = useUserQuery();
  const pathname = usePathname();

  if (!user?.team?.createdAt) {
    return null;
  }

  // Parse dates using UTCDate for consistent timezone handling
  const rawCreatedAt = parseISO(user?.team?.createdAt!);
  const today = new UTCDate();

  // Convert to UTCDate for consistent calculation
  const createdAt = new UTCDate(rawCreatedAt);

  // Set trial end date 14 days from creation
  const trialEndDate = addDays(createdAt, 14);

  const daysLeft = isSameDay(createdAt, today)
    ? 14
    : Math.max(0, differenceInDays(trialEndDate, today));
  const isTrialEnded = daysLeft <= 0;

  const showModal = user?.team?.plan === "trial" && isTrialEnded;

  if (
    pathname.includes("/settings") ||
    pathname.includes("/support") ||
    !showModal
  ) {
    return null;
  }

  if (!user?.team?.id) {
    return null;
  }

  return (
    <Dialog open={true} onOpenChange={() => {}}>
      <DialogContent className="max-w-[696px]" hideClose>
        <div className="p-8">
          <DialogHeader>
            <DialogTitle>Trial expired</DialogTitle>
          </DialogHeader>
          <DialogDescription className="mb-8">
            Hope you've enjoyed using Midday so far! Your trial has now ended,
            and it's time to choose a plan to continue using Midday.
          </DialogDescription>

          <Plans />

          <p className="text-xs text-muted-foreground mt-4">
            If you decide not to continue, you can remove your account and data
            by going to{" "}
            <Link href="/settings" className="underline">
              Settings
            </Link>
            .
          </p>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/notification-center/empty-state.tsx">
import { Icons } from "@midday/ui/icons";

interface EmptyStateProps {
  description: string;
}

export function EmptyState({ description }: EmptyStateProps) {
  return (
    <div className="h-[460px] flex items-center justify-center flex-col space-y-4">
      <div className="w-12 h-12 rounded-full bg-accent flex items-center justify-center">
        <Icons.Inbox className="w-[18px] h-[18px]" />
      </div>
      <p className="text-[#606060] text-sm">{description}</p>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/notification-center/index.ts">
export { EmptyState } from "./empty-state";
export { NotificationItem } from "./notification-item";
export { NotificationCenter } from "./notification-center";
</file>

<file path="apps/dashboard/src/components/notification-center/notification-center.tsx">
"use client";

import { ErrorFallback } from "@/components/error-fallback";
import { useNotifications } from "@/hooks/use-notifications";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { Popover, PopoverContent, PopoverTrigger } from "@midday/ui/popover";
import { ScrollArea } from "@midday/ui/scroll-area";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@midday/ui/tabs";
import { ErrorBoundary } from "next/dist/client/components/error-boundary";
import Link from "next/link";
import { useEffect, useState } from "react";
import { EmptyState } from "./empty-state";
import { NotificationItem } from "./notification-item";

export function NotificationCenter() {
  const [isOpen, setOpen] = useState(false);

  const {
    hasUnseenNotifications,
    notifications,
    archived,
    markMessageAsRead,
    markAllMessagesAsSeen,
    markAllMessagesAsRead,
    isLoading,
  } = useNotifications();

  const unreadNotifications = notifications; // Main notifications (unread/read)
  const archivedNotifications = archived; // Archived notifications

  useEffect(() => {
    if (isOpen && hasUnseenNotifications) {
      markAllMessagesAsSeen();
    }
  }, [hasUnseenNotifications, isOpen]);

  return (
    <Popover onOpenChange={setOpen} open={isOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          size="icon"
          className="rounded-full w-8 h-8 flex items-center relative"
        >
          {hasUnseenNotifications && (
            <div className="w-1.5 h-1.5 bg-[#FFD02B] rounded-full absolute top-0 right-0" />
          )}
          <Icons.Notifications size={16} />
        </Button>
      </PopoverTrigger>
      <PopoverContent
        className="h-[535px] w-screen md:w-[400px] p-0 overflow-hidden relative"
        align="end"
        sideOffset={10}
      >
        <ErrorBoundary errorComponent={ErrorFallback}>
          <Tabs defaultValue="inbox">
            <TabsList className="w-full justify-between bg-transparent border-b-[1px] rounded-none py-6">
              <div className="flex">
                <TabsTrigger value="inbox" className="font-normal">
                  Inbox
                </TabsTrigger>
                <TabsTrigger value="archive" className="font-normal">
                  Archive
                </TabsTrigger>
              </div>
              <Link
                href="/settings/notifications"
                onClick={() => setOpen(false)}
              >
                <Button
                  variant="ghost"
                  size="icon"
                  className="items-center justify-center transition-colors h-9 w-9 rounded-full bg-ransparent hover:bg-accent mr-2"
                >
                  <Icons.Settings size={16} />
                </Button>
              </Link>
            </TabsList>

            <TabsContent value="inbox" className="relative mt-0">
              {!isLoading && !unreadNotifications.length && (
                <EmptyState description="No new notifications" />
              )}

              {!isLoading && unreadNotifications.length > 0 && (
                <ScrollArea className="pb-12 h-[485px]">
                  <div className="divide-y">
                    {unreadNotifications.map((notification) => {
                      return (
                        <NotificationItem
                          key={notification.id}
                          id={notification.id}
                          markMessageAsRead={markMessageAsRead}
                          setOpen={setOpen}
                          activity={notification}
                        />
                      );
                    })}
                  </div>
                </ScrollArea>
              )}

              {!isLoading && unreadNotifications.length > 0 && (
                <div className="h-12 w-full absolute bottom-0 flex items-center justify-center border-t-[1px]">
                  <Button
                    variant="secondary"
                    className="bg-transparent"
                    onClick={markAllMessagesAsRead}
                  >
                    Archive all
                  </Button>
                </div>
              )}
            </TabsContent>

            <TabsContent value="archive" className="mt-0">
              {!isLoading && !archivedNotifications.length && (
                <EmptyState description="Nothing in the archive" />
              )}

              {!isLoading && archivedNotifications.length > 0 && (
                <ScrollArea className="h-[490px]">
                  <div className="divide-y">
                    {archivedNotifications.map((notification) => {
                      return (
                        <NotificationItem
                          key={notification.id}
                          id={notification.id}
                          setOpen={setOpen}
                          activity={notification}
                        />
                      );
                    })}
                  </div>
                </ScrollArea>
              )}
            </TabsContent>
          </Tabs>
        </ErrorBoundary>
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="apps/dashboard/src/components/notification-center/notification-descriptions.ts">
import type { useI18n } from "@/locales/client";
import { formatAmount } from "@midday/utils/format";
import { format } from "date-fns";

type UseI18nReturn = ReturnType<typeof useI18n>;

interface NotificationUser {
  locale?: string | null;
  dateFormat?: string | null;
}

interface NotificationMetadata {
  [key: string]: any;
}

type NotificationDescriptionHandler = (
  metadata: NotificationMetadata,
  user: NotificationUser | undefined,
  t: UseI18nReturn,
) => string;

const handleTransactionsCreated: NotificationDescriptionHandler = (
  metadata,
  user,
  t,
) => {
  const count = metadata?.count || metadata?.transactionCount || 1;
  const transaction = metadata?.transaction;

  // For single transactions, show rich details
  if (count === 1 && transaction) {
    const formattedAmount =
      formatAmount({
        currency: transaction.currency,
        amount: transaction.amount,
        locale: user?.locale || "en-US",
      }) || `${transaction.amount} ${transaction.currency}`;

    const userDateFormat = user?.dateFormat || "dd/MM/yyyy";
    const formattedDate = format(new Date(transaction.date), userDateFormat);

    return t("notifications.transactions_created.single_transaction", {
      name: transaction.name,
      amount: formattedAmount,
      date: formattedDate,
    });
  }

  // For multiple transactions, use count-based messages
  if (count <= 5) {
    return t("notifications.transactions_created.title", { count });
  }
  return t("notifications.transactions_created.title_many", { count });
};

const handleInboxNew: NotificationDescriptionHandler = (metadata, user, t) => {
  const count = metadata?.totalCount || 1;
  const type = metadata?.type;
  const provider = metadata?.provider ?? "";

  switch (type) {
    case "email":
      return t("notifications.inbox_new.type.email", { count });
    case "sync":
      // @ts-expect-error
      return t("notifications.inbox_new.type.sync", { count, provider });
    case "slack":
      return t("notifications.inbox_new.type.slack", { count });
    case "upload":
      return t("notifications.inbox_new.type.upload", { count });
    default:
      return t("notifications.inbox_new.title", { count });
  }
};

const handleInvoicePaid: NotificationDescriptionHandler = (
  metadata,
  user,
  t,
) => {
  const invoiceNumber = metadata?.invoiceNumber;
  const customerName = metadata?.customerName;
  const source = metadata?.source;
  const paidAt = metadata?.paidAt;

  if (invoiceNumber && source === "manual" && paidAt) {
    const userDateFormat = user?.dateFormat || "dd/MM/yyyy";
    const paidDate = new Date(paidAt);
    const formattedDate = format(paidDate, userDateFormat);

    if (customerName) {
      return t("notifications.invoice_paid.manual_with_date", {
        invoiceNumber,
        customerName,
        date: formattedDate,
      });
    }
    return t("notifications.invoice_paid.manual_with_date_no_customer", {
      invoiceNumber,
      date: formattedDate,
    });
  }

  if (invoiceNumber && source === "manual") {
    return customerName
      ? t("notifications.invoice_paid.manual", {
          invoiceNumber,
          customerName,
        })
      : t("notifications.invoice_paid.manual_no_customer", {
          invoiceNumber,
        });
  }

  return invoiceNumber
    ? t("notifications.invoice_paid.automatic", { invoiceNumber })
    : t("notifications.invoice_paid.title");
};

const handleInvoiceOverdue: NotificationDescriptionHandler = (
  metadata,
  user,
  t,
) => {
  const invoiceNumber = metadata?.invoiceNumber;
  return invoiceNumber
    ? t("notifications.invoice_overdue.with_number", { invoiceNumber })
    : t("notifications.invoice_overdue.title");
};

const handleInvoiceScheduled: NotificationDescriptionHandler = (
  metadata,
  user,
  t,
) => {
  const invoiceNumber = metadata?.invoiceNumber;
  const scheduledAt = metadata?.scheduledAt;
  const customerName = metadata?.customerName;

  if (invoiceNumber && scheduledAt) {
    const scheduledDate = new Date(scheduledAt);
    const userDateFormat = user?.dateFormat || "dd/MM/yyyy";
    const formattedDate = format(scheduledDate, userDateFormat);
    const formattedTime = format(scheduledDate, "HH:mm");

    if (customerName) {
      return t("notifications.invoice_scheduled.with_customer", {
        invoiceNumber,
        customerName,
        date: formattedDate,
        time: formattedTime,
      });
    }
    return t("notifications.invoice_scheduled.without_customer", {
      invoiceNumber,
      date: formattedDate,
      time: formattedTime,
    });
  }
  if (invoiceNumber) {
    return t("notifications.invoice_scheduled.simple", { invoiceNumber });
  }
  return t("notifications.invoice_scheduled.title");
};

const handleInvoiceSent: NotificationDescriptionHandler = (
  metadata,
  user,
  t,
) => {
  const invoiceNumber = metadata?.invoiceNumber;
  const customerName = metadata?.customerName;
  if (invoiceNumber && customerName) {
    return t("notifications.invoice_sent.with_customer", {
      invoiceNumber,
      customerName,
    });
  }
  if (invoiceNumber) {
    return t("notifications.invoice_sent.without_customer", {
      invoiceNumber,
    });
  }
  return t("notifications.invoice_sent.title");
};

const handleInvoiceReminderSent: NotificationDescriptionHandler = (
  metadata,
  user,
  t,
) => {
  const invoiceNumber = metadata?.invoiceNumber;
  const customerName = metadata?.customerName;
  if (invoiceNumber && customerName) {
    return t("notifications.invoice_reminder_sent.with_customer", {
      customerName,
      invoiceNumber,
    });
  }
  if (invoiceNumber) {
    return t("notifications.invoice_reminder_sent.without_customer", {
      invoiceNumber,
    });
  }
  return t("notifications.invoice_reminder_sent.title");
};

const handleInvoiceCancelled: NotificationDescriptionHandler = (
  metadata,
  user,
  t,
) => {
  const invoiceNumber = metadata?.invoiceNumber;
  const customerName = metadata?.customerName;

  if (invoiceNumber && customerName) {
    return t("notifications.invoice_cancelled.with_customer", {
      invoiceNumber,
      customerName,
    });
  }
  if (invoiceNumber) {
    return t("notifications.invoice_cancelled.without_customer", {
      invoiceNumber,
    });
  }
  return t("notifications.invoice_cancelled.title");
};

const handleInvoiceCreated: NotificationDescriptionHandler = (
  metadata,
  user,
  t,
) => {
  const invoiceNumber = metadata?.invoiceNumber;
  const customerName = metadata?.customerName;
  const amount = metadata?.amount;
  const currency = metadata?.currency;

  if (invoiceNumber && customerName && amount && currency) {
    const formattedAmount =
      formatAmount({
        currency: currency,
        amount: amount,
        locale: user?.locale || "en-US",
      }) ||
      new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: currency,
      }).format(amount);
    return t("notifications.invoice_created.with_customer_and_amount", {
      invoiceNumber,
      customerName,
      amount: formattedAmount,
    });
  }
  if (invoiceNumber && customerName) {
    return t("notifications.invoice_created.with_customer", {
      invoiceNumber,
      customerName,
    });
  }
  if (invoiceNumber) {
    return t("notifications.invoice_created.without_customer", {
      invoiceNumber,
    });
  }
  return t("notifications.invoice_created.title");
};

const handleInboxAutoMatched: NotificationDescriptionHandler = (
  metadata,
  user,
  t,
) => {
  const documentName = metadata?.documentName;
  const transactionName = metadata?.transactionName;
  const documentAmount = metadata?.documentAmount;
  const documentCurrency = metadata?.documentCurrency;
  const transactionAmount = metadata?.transactionAmount;
  const transactionCurrency = metadata?.transactionCurrency;
  const amount = metadata?.amount; // Fallback
  const currency = metadata?.currency; // Fallback

  // Handle cross-currency auto-matches with both amounts
  if (
    documentName &&
    transactionName &&
    documentAmount &&
    documentCurrency &&
    transactionAmount &&
    transactionCurrency &&
    documentCurrency !== transactionCurrency
  ) {
    const formattedDocAmount =
      formatAmount({
        currency: documentCurrency,
        amount: documentAmount,
        locale: user?.locale || "en-US",
      }) || `${documentAmount} ${documentCurrency}`;

    const formattedTransAmount =
      formatAmount({
        currency: transactionCurrency,
        amount: transactionAmount,
        locale: user?.locale || "en-US",
      }) || `${transactionAmount} ${transactionCurrency}`;

    return t("notifications.inbox_auto_matched.cross_currency_details", {
      documentName,
      transactionName,
      documentAmount: formattedDocAmount,
      transactionAmount: formattedTransAmount,
    });
  }

  // Handle same-currency or fallback to original logic
  if (
    documentName &&
    transactionName &&
    (documentAmount || amount) &&
    (documentCurrency || currency)
  ) {
    const finalAmount = documentAmount || amount;
    const finalCurrency = documentCurrency || currency;

    const formattedAmount =
      formatAmount({
        currency: finalCurrency,
        amount: finalAmount,
        locale: user?.locale || "en-US",
      }) ||
      new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: finalCurrency,
      }).format(finalAmount);

    return t("notifications.inbox_auto_matched.with_details", {
      documentName,
      transactionName,
      amount: formattedAmount,
    });
  }

  if (documentName && transactionName) {
    return t("notifications.inbox_auto_matched.with_names", {
      documentName,
      transactionName,
    });
  }

  return t("notifications.inbox_auto_matched.title");
};

const handleInboxNeedsReview: NotificationDescriptionHandler = (
  metadata,
  user,
  t,
) => {
  const documentName = metadata?.documentName;
  const transactionName = metadata?.transactionName;
  const matchType = metadata?.matchType;
  const documentAmount = metadata?.documentAmount;
  const documentCurrency = metadata?.documentCurrency;
  const transactionAmount = metadata?.transactionAmount;
  const transactionCurrency = metadata?.transactionCurrency;

  // Handle cross-currency matches (both high confidence and suggested)
  if (
    documentName &&
    transactionName &&
    documentAmount &&
    documentCurrency &&
    transactionAmount &&
    transactionCurrency &&
    documentCurrency !== transactionCurrency
  ) {
    const formattedDocAmount =
      formatAmount({
        currency: documentCurrency,
        amount: documentAmount,
        locale: user?.locale || "en-US",
      }) || `${documentAmount} ${documentCurrency}`;

    const formattedTransAmount =
      formatAmount({
        currency: transactionCurrency,
        amount: transactionAmount,
        locale: user?.locale || "en-US",
      }) || `${transactionAmount} ${transactionCurrency}`;

    if (matchType === "high_confidence") {
      return t(
        "notifications.inbox_needs_review.cross_currency_high_confidence",
        {
          documentName,
          transactionName,
          documentAmount: formattedDocAmount,
          transactionAmount: formattedTransAmount,
        },
      );
    }
    return t("notifications.inbox_needs_review.cross_currency_suggested", {
      documentName,
      transactionName,
      documentAmount: formattedDocAmount,
      transactionAmount: formattedTransAmount,
    });
  }

  // Handle same-currency matches
  if (documentName && transactionName && documentAmount && documentCurrency) {
    const formattedAmount =
      formatAmount({
        currency: documentCurrency,
        amount: documentAmount,
        locale: user?.locale || "en-US",
      }) || `${documentAmount} ${documentCurrency}`;

    if (matchType === "high_confidence") {
      return t("notifications.inbox_needs_review.high_confidence_details", {
        documentName,
        transactionName,
        amount: formattedAmount,
      });
    }
    return t("notifications.inbox_needs_review.with_details", {
      documentName,
      transactionName,
      amount: formattedAmount,
    });
  }

  if (documentName && transactionName) {
    if (matchType === "high_confidence") {
      return t("notifications.inbox_needs_review.high_confidence_names", {
        documentName,
        transactionName,
      });
    }
    return t("notifications.inbox_needs_review.with_names", {
      documentName,
      transactionName,
    });
  }

  return t("notifications.inbox_needs_review.title");
};

const handleInboxCrossCurrencyMatched: NotificationDescriptionHandler = (
  metadata,
  user,
  t,
) => {
  const documentName = metadata?.documentName;
  const transactionName = metadata?.transactionName;
  const documentAmount = metadata?.documentAmount;
  const documentCurrency = metadata?.documentCurrency;
  const transactionAmount = metadata?.transactionAmount;
  const transactionCurrency = metadata?.transactionCurrency;
  const matchType = metadata?.matchType;

  if (
    documentName &&
    transactionName &&
    documentAmount &&
    documentCurrency &&
    transactionAmount &&
    transactionCurrency
  ) {
    const formattedDocAmount =
      formatAmount({
        currency: documentCurrency,
        amount: documentAmount,
        locale: user?.locale || "en-US",
      }) ||
      new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: documentCurrency,
      }).format(documentAmount);

    const formattedTxAmount =
      formatAmount({
        currency: transactionCurrency,
        amount: transactionAmount,
        locale: user?.locale || "en-US",
      }) ||
      new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: transactionCurrency,
      }).format(transactionAmount);

    // Use different messaging based on match confidence
    if (matchType === "high_confidence") {
      return t(
        "notifications.inbox_cross_currency_matched.high_confidence_details",
        {
          documentName,
          transactionName,
          documentAmount: formattedDocAmount,
          transactionAmount: formattedTxAmount,
        },
      );
    }
    return t("notifications.inbox_cross_currency_matched.with_details", {
      documentName,
      transactionName,
      documentAmount: formattedDocAmount,
      transactionAmount: formattedTxAmount,
    });
  }

  if (documentName && transactionName) {
    if (matchType === "high_confidence") {
      return t(
        "notifications.inbox_cross_currency_matched.high_confidence_names",
        {
          documentName,
          transactionName,
        },
      );
    }
    return t("notifications.inbox_cross_currency_matched.with_names", {
      documentName,
      transactionName,
    });
  }

  return t("notifications.inbox_cross_currency_matched.title");
};

const notificationHandlers: Record<string, NotificationDescriptionHandler> = {
  transactions_created: handleTransactionsCreated,
  inbox_new: handleInboxNew,
  inbox_auto_matched: handleInboxAutoMatched,
  inbox_needs_review: handleInboxNeedsReview,
  inbox_cross_currency_matched: handleInboxCrossCurrencyMatched,
  invoice_paid: handleInvoicePaid,
  invoice_overdue: handleInvoiceOverdue,
  invoice_scheduled: handleInvoiceScheduled,
  invoice_sent: handleInvoiceSent,
  invoice_reminder_sent: handleInvoiceReminderSent,
  invoice_cancelled: handleInvoiceCancelled,
  invoice_created: handleInvoiceCreated,
};

export function getNotificationDescription(
  activityType: string,
  metadata: NotificationMetadata,
  user: NotificationUser | undefined,
  t: UseI18nReturn,
): string {
  const handler = notificationHandlers[activityType];
  if (handler) {
    return handler(metadata, user, t);
  }
  return t("notifications.default.title");
}
</file>

<file path="apps/dashboard/src/components/notification-center/notification-item.tsx">
"use client";

import {
  type Activity,
  getMetadata,
  getMetadataProperty,
} from "@/hooks/use-notifications";
import { useUserQuery } from "@/hooks/use-user";
import { useI18n } from "@/locales/client";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import { formatDistanceToNow } from "date-fns";
import { getNotificationDescription } from "./notification-descriptions";
import { NotificationLink } from "./notification-link";

interface NotificationItemProps {
  id: string;
  setOpen: (open: boolean) => void;
  activity: Activity;
  markMessageAsRead?: (id: string) => void;
}

export function NotificationItem({
  id,
  setOpen,
  activity,
  markMessageAsRead,
}: NotificationItemProps) {
  const t = useI18n();
  const { data: user } = useUserQuery();

  const recordId = getMetadataProperty(activity, "recordId");
  const metadata = getMetadata(activity);

  const getNotificationIcon = (activityType: string) => {
    if (activityType.startsWith("invoice_"))
      return <Icons.Invoice className="size-4" />;
    if (activityType.startsWith("transaction"))
      return <Icons.Transactions className="size-4" />;
    if (activityType === "inbox_new")
      return <Icons.Inbox2 className="size-4" />;
    if (activityType.startsWith("inbox_") && activityType.includes("matched"))
      return <Icons.Match className="size-4" />;
    if (activityType === "inbox_needs_review")
      return <Icons.AlertCircle className="size-4" />;
    if (activityType === "match") return <Icons.Match className="size-4" />;
    return <Icons.Notifications className="size-4" />;
  };

  const description = getNotificationDescription(
    activity.type,
    metadata,
    user,
    t,
  );

  const notificationContent = (
    <>
      <div>
        <div className="h-9 w-9 flex items-center justify-center space-y-0 border rounded-full">
          {getNotificationIcon(activity.type)}
        </div>
      </div>
      <div>
        <p
          className={cn(
            "text-sm",
            activity.status === "unread" && "font-medium",
          )}
        >
          {description}
        </p>
        <span className="text-xs text-[#606060]">
          {t("notifications.time_ago", {
            time: formatDistanceToNow(new Date(activity.createdAt)),
          })}
        </span>
      </div>
    </>
  );

  const actionButton = markMessageAsRead && (
    <div>
      <Button
        size="icon"
        variant="secondary"
        className="rounded-full bg-transparent dark:hover:bg-[#1A1A1A] hover:bg-[#F6F6F3]"
        onClick={() => markMessageAsRead(id)}
        title={t("notifications.archive_button")}
      >
        <Icons.Inventory2 />
      </Button>
    </div>
  );

  return (
    <NotificationLink
      activityType={activity.type}
      recordId={recordId}
      metadata={metadata}
      onNavigate={() => setOpen(false)}
      className="flex items-between space-x-4 flex-1 text-left"
      actionButton={actionButton}
    >
      {notificationContent}
    </NotificationLink>
  );
}
</file>

<file path="apps/dashboard/src/components/notification-center/notification-link.tsx">
"use client";

import { useInboxParams } from "@/hooks/use-inbox-params";
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { useTransactionParams } from "@/hooks/use-transaction-params";
import { useRouter } from "next/navigation";
import type { ReactNode } from "react";

const SUPPORTED_NOTIFICATION_TYPES = [
  "invoice_paid",
  "invoice_overdue",
  "invoice_created",
  "invoice_sent",
  "invoice_scheduled",
  "invoice_reminder_sent",
  "invoice_cancelled",
  "transactions_created",
  "inbox_new",
  "inbox_needs_review",
  "inbox_auto_matched",
  "inbox_cross_currency_matched",
];

export function isNotificationClickable(activityType: string): boolean {
  return SUPPORTED_NOTIFICATION_TYPES.includes(activityType);
}

interface NotificationLinkProps {
  activityType: string;
  recordId: string | null | undefined;
  metadata?: Record<string, any>;
  onNavigate?: () => void;
  children: ReactNode;
  className?: string;
  actionButton?: ReactNode;
}

export function NotificationLink({
  activityType,
  recordId,
  metadata,
  onNavigate,
  children,
  className,
  actionButton,
}: NotificationLinkProps) {
  const { setParams: setInvoiceParams } = useInvoiceParams();
  const { setParams: setTransactionParams } = useTransactionParams();
  const { setParams: setInboxParams } = useInboxParams();
  const router = useRouter();

  const isClickable = isNotificationClickable(activityType);

  const handleClick = () => {
    onNavigate?.();

    try {
      switch (activityType) {
        case "invoice_paid":
        case "invoice_overdue":
        case "invoice_created":
        case "invoice_sent":
        case "invoice_scheduled":
        case "invoice_reminder_sent":
        case "invoice_cancelled":
          setInvoiceParams({ invoiceId: recordId!, type: "details" });
          break;

        case "transactions_created":
          if (metadata?.recordId) {
            setTransactionParams({ transactionId: recordId! });
          } else if (metadata?.dateRange) {
            router.push(
              `/transactions?start=${metadata.dateRange.from}&end=${metadata.dateRange.to}`,
            );
          }
          break;

        case "inbox_new":
          router.push("/inbox");
          break;

        case "inbox_needs_review":
        case "inbox_auto_matched":
        case "inbox_cross_currency_matched":
          // Use the inboxId from metadata to open the inbox details sheet
          if (metadata?.inboxId) {
            setInboxParams({ inboxId: metadata.inboxId, type: "details" });
          } else {
            // Fallback to inbox page if no inboxId
            router.push("/inbox");
          }
          break;

        default:
          console.warn(`Unhandled notification type: ${activityType}`);
      }
    } catch (error) {
      console.error(`Error navigating for ${activityType}:`, error);
    }
  };

  if (isClickable) {
    return (
      <div className="flex items-between justify-between space-x-4 px-3 py-3 hover:bg-secondary">
        <button className={className} onClick={handleClick} type="button">
          {children}
        </button>
        {actionButton}
      </div>
    );
  }

  // Non-clickable notification
  return (
    <div className="flex items-between space-x-4 px-3 py-3">
      <div className="flex items-between justify-between space-x-4 flex-1">
        {children}
      </div>
      {actionButton}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/oauth/oauth-consent-screen.tsx">
"use client";

import { useOAuthParams } from "@/hooks/use-oauth-params";
import { useTeamQuery } from "@/hooks/use-team";
import { useTRPC } from "@/trpc/client";
import { getScopeDescription } from "@/utils/scopes";
import { Button } from "@midday/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import { Label } from "@midday/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";
import { useToast } from "@midday/ui/use-toast";
import { useMutation, useSuspenseQuery } from "@tanstack/react-query";
import { AlertTriangle, Check, X } from "lucide-react";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";

export function OAuthConsentScreen() {
  const router = useRouter();
  const { toast } = useToast();

  const {
    client_id: clientId,
    redirect_uri: redirectUri,
    scope,
    state,
    code_challenge: codeChallenge,
  } = useOAuthParams();

  const trpc = useTRPC();
  const { data: currentTeam } = useTeamQuery();
  const [selectedTeamId, setSelectedTeamId] = useState<string>("");

  // Preselect the current team when data is available
  useEffect(() => {
    if (currentTeam?.id && !selectedTeamId) {
      setSelectedTeamId(currentTeam.id);
    }
  }, [currentTeam?.id, selectedTeamId]);

  const { data: applicationInfo } = useSuspenseQuery(
    trpc.oauthApplications.getApplicationInfo.queryOptions({
      clientId: clientId!,
      redirectUri: redirectUri!,
      scope: scope!,
      state: state || undefined,
    }),
  );

  const { data: teams } = useSuspenseQuery(trpc.team.list.queryOptions());

  const authorizeMutation = useMutation(
    trpc.oauthApplications.authorize.mutationOptions({
      onSuccess: (data) => {
        window.location.href = data.redirect_url;
      },
      onError: (error) => {
        toast({
          title: "Error",
          description: error.message || "Authorization failed",
          variant: "error",
        });
      },
    }),
  );

  const handleAuthorize = async () => {
    if (!selectedTeamId) {
      toast({
        title: "Error",
        description: "Please select a workspace",
        variant: "error",
      });
      return;
    }

    if (!applicationInfo || !clientId || !redirectUri) {
      toast({
        title: "Error",
        description: "Application information not available",
        variant: "error",
      });
      return;
    }

    authorizeMutation.mutate({
      clientId,
      decision: "allow",
      scopes: applicationInfo.scopes,
      redirectUri,
      state: state || undefined,
      codeChallenge: codeChallenge || undefined,
      teamId: selectedTeamId,
    });
  };

  const handleDecline = async () => {
    if (!clientId || !redirectUri || !selectedTeamId) return;

    authorizeMutation.mutate({
      clientId,
      decision: "deny",
      scopes: [],
      redirectUri,
      state: state || undefined,
      codeChallenge: codeChallenge || undefined,
      teamId: selectedTeamId,
    });
  };

  if (!applicationInfo) {
    return (
      <div className="flex items-center justify-center min-h-screen p-4 bg-background">
        <Card className="w-full max-w-[448px]">
          <CardHeader className="text-center pb-8">
            <div className="flex items-center justify-center gap-4 mb-8">
              <div className="w-16 h-16 rounded-full bg-background border border-border flex items-center justify-center">
                <X className="h-8 w-8 text-muted-foreground" />
              </div>
            </div>
            <CardTitle className="text-lg mb-2 font-serif">
              Authorization Error
            </CardTitle>
            <CardDescription className="text-sm text-muted-foreground text-center">
              Invalid authorization request. Please check the parameters and try
              again.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="flex gap-3 pt-4">
              <Button onClick={() => router.push("/")} className="w-full">
                Go to Dashboard
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="flex items-center justify-center min-h-screen p-4 bg-background">
      <Card className="w-full max-w-[448px]">
        <CardHeader className="text-center pb-8">
          <div className="flex items-center justify-center gap-4 mb-8">
            <div className="w-16 h-16 rounded-full bg-background border border-border flex items-center justify-center overflow-hidden">
              {applicationInfo.logoUrl ? (
                <Image
                  src={applicationInfo.logoUrl}
                  alt={applicationInfo.name}
                  width={40}
                  height={40}
                  className="object-contain"
                />
              ) : (
                <div className="w-8 h-8 bg-muted rounded-full" />
              )}
            </div>
            <Icons.SyncAlt className="size-4 text-[#666666]" />
            <div className="w-16 h-16 rounded-full bg-background border border-border flex items-center justify-center overflow-hidden">
              <Icons.LogoSmall className="h-8 w-8" />
            </div>
          </div>

          <CardTitle className="text-lg mb-2 font-serif">
            {applicationInfo.name} is requesting API access <br /> to a team in
            Midday.
          </CardTitle>

          <CardDescription className="text-sm text-muted-foreground text-center">
            <span className="flex items-center justify-center gap-1 text-[#878787] text-sm mb-8">
              Built by{" "}
              {applicationInfo.website ? (
                <a
                  href={applicationInfo.website}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="inline-flex items-center gap-1 underline"
                >
                  {applicationInfo.developerName ||
                    new URL(applicationInfo.website).hostname}
                </a>
              ) : (
                <span className="underline">
                  {applicationInfo.developerName || "Unknown"}
                </span>
              )}
            </span>
          </CardDescription>
        </CardHeader>

        {applicationInfo.status !== "approved" && (
          <div className="mx-4 mb-4 px-3 py-2 bg-amber-50 border border-amber-200 dark:bg-amber-900/10 dark:border-amber-800/30">
            <div className="flex items-center gap-2">
              <AlertTriangle className="size-4 text-amber-600 dark:text-amber-400 flex-shrink-0" />
              <span className="text-sm text-amber-700 dark:text-amber-300">
                This app hasn't been verified by Midday yet
              </span>
            </div>
          </div>
        )}

        <CardContent className="space-y-6">
          <div className="space-y-4 border-t border-b border-border border-dashed py-6">
            <span className="text-sm">Grant permissions</span>
            <div
              className={`${applicationInfo.scopes.length > 3 ? "relative" : ""}`}
            >
              <div
                className={cn(
                  "space-y-4",
                  applicationInfo.scopes.length > 3 &&
                    "max-h-[92px] overflow-y-auto pr-2 pb-2",
                )}
              >
                {applicationInfo.scopes.map((scope) => {
                  const description = getScopeDescription(scope);
                  return (
                    <div key={scope} className="flex items-center gap-3">
                      <div className="flex-shrink-0">
                        <Check className="size-3.5 text-[#878787]" />
                      </div>
                      <span className="text-sm text-[#878787]">
                        {description.label}
                      </span>
                    </div>
                  );
                })}
              </div>
              {applicationInfo.scopes.length > 3 && (
                <div className="absolute bottom-0 left-0 right-0 h-5 bg-gradient-to-t from-card to-transparent pointer-events-none" />
              )}
            </div>
          </div>

          <div className="space-y-3">
            <Label htmlFor="workspace" className="text-sm font-normal">
              Select a team to grant API access to
            </Label>
            <Select value={selectedTeamId} onValueChange={setSelectedTeamId}>
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Search workspaces" />
              </SelectTrigger>
              <SelectContent>
                {teams?.map((team) => (
                  <SelectItem key={team.id} value={team.id!}>
                    {team.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="flex gap-3 pt-4">
            <Button
              variant="outline"
              onClick={handleDecline}
              disabled={authorizeMutation.isPending}
              className="flex-1"
            >
              Decline
            </Button>
            <Button
              onClick={handleAuthorize}
              disabled={authorizeMutation.isPending || !selectedTeamId}
              className="flex-1"
            >
              {authorizeMutation.isPending ? "Authorizing..." : "Authorize"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/oauth/oauth-error-message.tsx">
"use client";

import { Button } from "@midday/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { Icons } from "@midday/ui/icons";
import { useRouter } from "next/navigation";

export type OAuthErrorType =
  | "missing_params"
  | "invalid_response_type"
  | "invalid_client_id"
  | "invalid_redirect_uri"
  | "invalid_scopes"
  | "expired"
  | "application_inactive"
  | "user_not_authenticated"
  | "invalid_client_credentials"
  | "authorization_code_expired"
  | "authorization_code_used"
  | "invalid_code_verifier"
  | "invalid_code_challenge_method"
  | "refresh_token_expired"
  | "refresh_token_revoked"
  | "invalid_refresh_token"
  | "grant_type_not_supported"
  | "failed_to_create_authorization_code"
  | "invalid_authorization_code"
  | "invalid_url_format"
  | "empty_scopes"
  | "unauthorized_team_access"
  | "server_error";

interface OAuthErrorMessageProps {
  errorType: OAuthErrorType;
  customMessage?: string;
  details?: string;
}

export function OAuthErrorMessage({
  errorType,
  customMessage,
  details,
}: OAuthErrorMessageProps) {
  const router = useRouter();

  const getErrorContent = () => {
    switch (errorType) {
      case "missing_params":
        return {
          title: "Invalid OAuth Request",
          message:
            "Could not find OAuth application. Make sure you have the correct client_id.",
        };
      case "invalid_response_type":
        return {
          title: "Invalid OAuth Request",
          message: "response_type must be 'code'",
        };
      case "invalid_client_id":
        return {
          title: "Invalid OAuth Request",
          message:
            "Could not find OAuth application. Make sure you have the correct client_id.",
        };
      case "invalid_redirect_uri":
        return {
          title: "Invalid OAuth Request",
          message:
            "Invalid redirect_uri parameter detected. Make sure you have allowlisted the redirect_uri in your OAuth app settings.",
        };
      case "invalid_scopes":
        return {
          title: "Invalid OAuth Request",
          message: customMessage || "Invalid scopes",
        };
      case "expired":
        return {
          title: "Invalid OAuth Request",
          message: "The OAuth request has expired. Please try again.",
        };
      case "application_inactive":
        return {
          title: "OAuth Application Inactive",
          message:
            "This OAuth application is currently inactive. Please contact the application owner.",
        };
      case "user_not_authenticated":
        return {
          title: "Authentication Required",
          message:
            "You must be logged in to authorize this application. Please sign in and try again.",
        };
      case "invalid_client_credentials":
        return {
          title: "Invalid OAuth Request",
          message:
            "Invalid client credentials provided. Please check your client_id and client_secret.",
        };
      case "authorization_code_expired":
        return {
          title: "Authorization Code Expired",
          message:
            "The authorization code has expired. Please restart the OAuth flow.",
        };
      case "authorization_code_used":
        return {
          title: "Authorization Code Already Used",
          message:
            "This authorization code has already been used. Please restart the OAuth flow.",
        };
      case "invalid_code_verifier":
        return {
          title: "Invalid OAuth Request",
          message: "Invalid code verifier provided for PKCE validation.",
        };
      case "invalid_code_challenge_method":
        return {
          title: "Invalid OAuth Request",
          message:
            "Invalid code challenge method. Supported methods are 'S256' and 'plain'.",
        };
      case "refresh_token_expired":
        return {
          title: "Refresh Token Expired",
          message:
            "The refresh token has expired. Please restart the OAuth flow.",
        };
      case "refresh_token_revoked":
        return {
          title: "Refresh Token Revoked",
          message:
            "The refresh token has been revoked. Please restart the OAuth flow.",
        };
      case "invalid_refresh_token":
        return {
          title: "Invalid Refresh Token",
          message:
            "The provided refresh token is invalid. Please restart the OAuth flow.",
        };
      case "grant_type_not_supported":
        return {
          title: "Grant Type Not Supported",
          message:
            "The requested grant type is not supported. Please use 'authorization_code' or 'refresh_token'.",
        };
      case "failed_to_create_authorization_code":
        return {
          title: "Server Error",
          message:
            "Failed to create authorization code. Please try again later.",
        };
      case "invalid_authorization_code":
        return {
          title: "Invalid Authorization Code",
          message:
            "The provided authorization code is invalid or does not exist.",
        };

      case "invalid_url_format":
        return {
          title: "Invalid URL Format",
          message: "The provided redirect_uri is not a valid URL format.",
        };
      case "empty_scopes":
        return {
          title: "Invalid OAuth Request",
          message:
            "No scopes provided. Please specify the required scopes for your application.",
        };
      case "unauthorized_team_access":
        return {
          title: "Unauthorized Access",
          message: "You don't have permission to access this team's resources.",
        };
      case "server_error":
        return {
          title: "Server Error",
          message:
            "An unexpected server error occurred. Please try again later.",
        };
      default:
        return {
          title: "Invalid OAuth Request",
          message:
            customMessage ||
            "An error occurred while processing your OAuth request.",
        };
    }
  };

  const { title, message } = getErrorContent();

  return (
    <div className="flex items-center justify-center min-h-screen p-4 bg-background">
      <Card className="w-full max-w-[448px]">
        <CardHeader className="text-center pb-8">
          <div className="flex items-center justify-center gap-4 mb-8">
            <div className="w-16 h-16 rounded-full bg-background border border-border flex items-center justify-center">
              <Icons.Close className="size-5 text-[#666666]" />
            </div>
          </div>
          <CardTitle className="text-lg mb-2 font-serif">{title}</CardTitle>
          <CardDescription className="text-sm text-muted-foreground text-center leading-relaxed break-words whitespace-pre-wrap">
            {message}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="flex gap-3 pt-4">
            <Button onClick={() => router.push("/")} className="w-full">
              Go to Dashboard
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/search/open-search-button.tsx">
"use client";

import { useSearchStore } from "@/store/search";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";

export function OpenSearchButton() {
  const { setOpen } = useSearchStore();

  return (
    <Button
      variant="outline"
      className="relative min-w-[250px] w-full justify-start text-sm text-muted-foreground sm:pr-12 md:w-40 lg:w-64 border-0 p-0 hover:bg-transparent font-normal no-drag hidden md:flex"
      onClick={() => setOpen()}
    >
      <Icons.Search size={18} className="mr-2" />
      <span>Find anything...</span>
      <kbd className="pointer-events-none absolute right-1.5 top-1.5 hidden h-5 select-none items-center gap-1 border bg-accent px-1.5 font-mono text-[10px] font-medium opacity-100 sm:flex">
        <span className="text-xs">⌘</span>K
      </kbd>
    </Button>
  );
}
</file>

<file path="apps/dashboard/src/components/search/search-footer.tsx">
import { Icons } from "@midday/ui/icons";

export function SearchFooter() {
  return (
    <div className="search-footer flex px-3 h-[40px] w-full border border-border border-t-[0px] items-center bg-background backdrop-filter dark:border-[#2C2C2C] backdrop-blur-lg dark:bg-[#151515]/[99]">
      <div className="scale-50 dark:opacity-50 -ml-1">
        <Icons.LogoSmall />
      </div>

      <div className="ml-auto flex space-x-2">
        <div className="size-6 select-none items-center border bg-accent flex justify-center">
          <Icons.ArrowUpward className="size-3 dark:text-[#666666] text-black" />
        </div>

        <div className="size-6 select-none items-center border bg-accent flex justify-center">
          <Icons.ArrowDownward className="size-3 dark:text-[#666666] text-black" />
        </div>

        <div className="size-6 select-none items-center border bg-accent flex justify-center">
          <Icons.SubdirectoryArrowLeft className="size-3 dark:text-[#666666] text-black" />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/search/search-modal.tsx">
"use client";

import { useSearchStore } from "@/store/search";
import { Dialog, DialogContent } from "@midday/ui/dialog";
import { useHotkeys } from "react-hotkeys-hook";
import { Search } from "./search";
import { SearchFooter } from "./search-footer";

export function SearchModal() {
  const { isOpen, setOpen } = useSearchStore();

  useHotkeys("meta+k", () => setOpen(), {
    enableOnFormTags: true,
  });

  return (
    <Dialog open={isOpen} onOpenChange={setOpen}>
      <DialogContent
        className="overflow-hidden p-0 max-w-full w-full md:max-w-[740px] h-[535px] m-0 select-text bg-transparent border-none"
        hideClose
      >
        <Search />
        <SearchFooter />
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/search/search.tsx">
"use client";

import { FormatAmount } from "@/components/format-amount";
import { InvoiceStatus } from "@/components/invoice-status";
import { useCustomerParams } from "@/hooks/use-customer-params";
import { useDocumentParams } from "@/hooks/use-document-params";
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { useTransactionParams } from "@/hooks/use-transaction-params";
import { useUserQuery } from "@/hooks/use-user";
import { downloadFile } from "@/lib/download";
import { useSearchStore } from "@/store/search";
import { useTRPC } from "@/trpc/client";
import { formatDate } from "@/utils/format";
import { Window, emit, invoke, listen } from "@midday/desktop-client/core";
import { isDesktopApp } from "@midday/desktop-client/platform";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@midday/ui/command";
import { Icons } from "@midday/ui/icons";
import { Spinner } from "@midday/ui/spinner";
import { useQuery } from "@tanstack/react-query";
import { formatISO } from "date-fns";
import { useRouter } from "next/navigation";
import { useEffect, useMemo, useRef, useState } from "react";
import type { ReactNode } from "react";
import { useHotkeys } from "react-hotkeys-hook";
import { useDebounceValue } from "usehooks-ts";
import { useCopyToClipboard } from "usehooks-ts";
import { FilePreviewIcon } from "../file-preview-icon";
import { TrackerTimer } from "../tracker-timer";

interface SearchItem {
  id: string;
  type: string;
  title: string;
  data?: {
    name?: string;
    email?: string;
    invoice_number?: string;
    status?: string;
    amount?: number;
    currency?: string;
    date?: string;
    display_name?: string;
    file_name?: string;
    file_path?: string[];
    path_tokens?: string[];
    title?: string;
    metadata?: {
      mimetype?: string;
    };
    template?: {
      size?: string;
    };
    url?: string;
  };
  action?: () => void;
}

function CopyButton({ path }: { path: string }) {
  const [isCopied, setIsCopied] = useState(false);
  const [_, copy] = useCopyToClipboard();

  const handleCopy = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.stopPropagation();

    copy(`${window.location.origin}${path}`);
    setIsCopied(true);
    setTimeout(() => {
      setIsCopied(false);
    }, 1000);
  };

  return (
    <button type="button" onClick={handleCopy}>
      {isCopied ? (
        <Icons.Check className="size-4 dark:text-[#666] text-primary hover:!text-primary cursor-pointer" />
      ) : (
        <Icons.Copy className="size-4 dark:text-[#666] text-primary hover:!text-primary cursor-pointer" />
      )}
    </button>
  );
}

function DownloadButton({
  href,
  filename,
}: { href: string; filename?: string }) {
  const [isDownloading, setIsDownloading] = useState(false);

  const handleDownload = async (e: React.MouseEvent) => {
    e.stopPropagation();

    try {
      setIsDownloading(true);
      await downloadFile(href, filename || "download");

      // Keep spinner for 1 second
      setTimeout(() => {
        setIsDownloading(false);
      }, 1000);
    } catch (error) {
      console.error("Download failed:", error);
      setIsDownloading(false);
    }
  };

  return (
    <button type="button" onClick={handleDownload}>
      {isDownloading ? (
        <Spinner size={16} />
      ) : (
        <Icons.ArrowCoolDown className="size-4 dark:text-[#666] text-primary hover:!text-primary cursor-pointer" />
      )}
    </button>
  );
}

// Helper function to format group names
const formatGroupName = (name: string): string | null => {
  switch (name) {
    case "shortcut":
      return "Shortcuts";
    case "customer":
      return "Customers";
    case "vault":
      return "Vault";
    case "invoice":
      return "Invoices";
    case "tracker_project":
      return "Tracker";
    case "transaction":
      return "Transactions";
    case "inbox":
      return "Inbox";

    default:
      return null;
  }
};

// Add desktop navigation function
const handleDesktopNavigation = async (
  path: string,
  params?: Record<string, any>,
) => {
  if (!isDesktopApp()) return false;

  try {
    // Step 1: Get the main window first to check its current path
    const mainWindow = await Window.getByLabel("main");

    if (!mainWindow) {
      console.error("❌ Main window not found for navigation");
      return false;
    }

    // Step 2: Close search window
    await emit("search-window-close-requested");

    // Step 3: Show and focus main window
    await invoke("show_window");

    // Step 4: Navigate in main window context
    // If we have params, we need to use the main window's current path
    // If it's a full path (like /inbox?inboxId=...), use it directly
    if (params && Object.keys(params).length > 0) {
      // For param navigation, we want to stay on the current main window page
      // but we can't easily get the main window's current path from here
      // So let's send a special signal to navigate with params on current page
      await mainWindow.emit("desktop-navigate-with-params", { params });
    } else {
      // For full path navigation, use the path directly
      await mainWindow.emit("desktop-navigate", { path, params });
    }

    return true;
  } catch (error) {
    console.error("❌ Failed to handle desktop navigation:", error);
    return false;
  }
};

const useSearchNavigation = () => {
  const router = useRouter();
  const { setOpen } = useSearchStore();
  const { setParams: setInvoiceParams } = useInvoiceParams();
  const { setParams: setCustomerParams } = useCustomerParams();
  const { setParams: setTrackerParams } = useTrackerParams();
  const { setParams: setTransactionParams } = useTransactionParams();
  const { setParams: setDocumentParams } = useDocumentParams();

  const shouldUseWebNavigation = async () => {
    if (!isDesktopApp()) {
      return true;
    }

    try {
      const currentWindow = await Window.getCurrent();
      const currentLabel = currentWindow.label;
      return currentLabel === "main";
    } catch (error) {
      console.error("Failed to get current window label:", error);
      return false;
    }
  };

  const navigateWithParams = async (
    params: Record<string, any>,
    paramSetter: (params: any) => void,
  ) => {
    const useWebNav = await shouldUseWebNavigation();

    if (useWebNav) {
      // Web mode - use traditional navigation
      setOpen();
      paramSetter(params);
      return;
    }

    // Desktop mode - use params-only navigation to stay on current main window page
    await handleDesktopNavigation("", params);
  };

  const navigateToPath = async (path: string) => {
    const useWebNav = await shouldUseWebNavigation();

    if (useWebNav) {
      // Web mode - use traditional navigation
      setOpen();
      router.push(path);
      return;
    }

    // Desktop mode - use full path navigation
    await handleDesktopNavigation(path);
  };

  return {
    navigateToDocument: (params: { documentId: string }) => {
      return navigateWithParams(params, setDocumentParams);
    },
    navigateToCustomer: (params: { customerId: string }) => {
      return navigateWithParams(params, setCustomerParams);
    },
    navigateToInvoice: (params: {
      invoiceId: string;
      type: "details" | "create" | "edit" | "success";
    }) => {
      return navigateWithParams(params, setInvoiceParams);
    },
    navigateToTracker: (params: {
      projectId?: string;
      update?: boolean;
      create?: boolean;
      selectedDate?: string;
    }) => {
      return navigateWithParams(params, setTrackerParams);
    },
    navigateToTransaction: (params: {
      transactionId?: string;
      createTransaction?: boolean;
    }) => {
      return navigateWithParams(params, setTransactionParams);
    },
    navigateToPath: (path: string) => {
      return navigateToPath(path);
    },
    // Action helpers
    createInvoice: () => {
      return navigateWithParams({ type: "create" as const }, setInvoiceParams);
    },
    createCustomer: (params = { createCustomer: true }) => {
      return navigateWithParams(params, setCustomerParams);
    },
    createTransaction: () => {
      return navigateWithParams(
        { createTransaction: true },
        setTransactionParams,
      );
    },
    createProject: () => {
      return navigateWithParams({ create: true }, setTrackerParams);
    },
    trackTime: () => {
      return navigateWithParams(
        { selectedDate: formatISO(new Date(), { representation: "date" }) },
        setTrackerParams,
      );
    },
  };
};

// Sub-component to render each search item
const SearchResultItemDisplay = ({
  item,
  dateFormat,
}: { item: SearchItem; dateFormat?: string }) => {
  const nav = useSearchNavigation();

  let icon: ReactNode | undefined;
  let resultDisplay: ReactNode;
  let onSelect: () => void;

  if (!item.data) {
    // This is an action item (e.g., "Create Invoice", "View Documents")
    icon = <Icons.Shortcut className="size-4 dark:text-[#666] text-primary" />;
    resultDisplay = item.title;
  } else {
    icon = null;
    resultDisplay = item.title;

    switch (item.type) {
      case "vault": {
        onSelect = () => nav.navigateToDocument({ documentId: item.id });

        icon = (
          <FilePreviewIcon
            mimetype={item.data?.metadata?.mimetype}
            className="size-4 dark:text-[#666] text-primary"
          />
        );
        resultDisplay = (
          <div className="flex items-center justify-between w-full">
            <span className="flex-grow truncate">
              {
                (item.data?.title ||
                  (item.data?.name as string)?.split("/").at(-1) ||
                  "") as string
              }
            </span>
            <div className="flex items-center gap-2 invisible group-hover/item:visible group-focus/item:visible group-aria-selected/item:visible">
              <CopyButton path={`?documentId=${item.id}`} />
              <DownloadButton
                href={`/api/download/file?path=${item.data?.path_tokens?.join("/")}&filename=${
                  (item.data?.title ||
                    (item.data?.name as string)?.split("/").at(-1) ||
                    "") as string
                }`}
                filename={
                  (item.data?.title ||
                    (item.data?.name as string)?.split("/").at(-1) ||
                    "") as string
                }
              />
              <Icons.ArrowOutward className="size-4 dark:text-[#666] text-primary hover:!text-primary cursor-pointer" />
            </div>
          </div>
        );
        break;
      }
      case "customer": {
        onSelect = () => nav.navigateToCustomer({ customerId: item.id });

        icon = (
          <Icons.Customers className="size-4 dark:text-[#666] text-primary" />
        );
        resultDisplay = (
          <div className="flex items-center w-full">
            <div className="flex-grow truncate flex gap-2 items-center">
              <span>{item.data.name as string}</span>
              <span className="text-xs text-muted-foreground">
                {item.data.email as string}
              </span>
            </div>
            <div className="flex items-center gap-2 invisible group-hover/item:visible group-focus/item:visible group-aria-selected/item:visible">
              <CopyButton path={`?customerId=${item.id}`} />
              <Icons.ArrowOutward className="size-4 dark:text-[#666] text-primary hover:!text-primary cursor-pointer" />
            </div>
          </div>
        );

        break;
      }
      case "invoice": {
        onSelect = () =>
          nav.navigateToInvoice({ invoiceId: item.id, type: "details" });

        icon = (
          <Icons.Invoice className="size-4 dark:text-[#666] text-primary" />
        );
        resultDisplay = (
          <div className="flex items-center w-full">
            <div className="flex-grow truncate flex gap-2 items-center">
              <span>{item.data.invoice_number as string}</span>
              {/* @ts-expect-error - Unstructured data */}
              <InvoiceStatus status={item.data?.status} />
            </div>
            <div className="flex items-center gap-2 invisible group-hover/item:visible group-focus/item:visible group-aria-selected/item:visible">
              <CopyButton path={`?invoiceId=${item.id}&type=details`} />
              <DownloadButton
                href={`/api/download/invoice?id=${item.id}&size=${item?.data?.template?.size}`}
                filename={`${item.data.invoice_number || "invoice"}.pdf`}
              />
              <Icons.ArrowOutward className="size-4 dark:text-[#666] text-primary hover:!text-primary cursor-pointer" />
            </div>
          </div>
        );
        break;
      }
      case "inbox": {
        onSelect = () => nav.navigateToPath(`/inbox?inboxId=${item.id}`);

        icon = (
          <Icons.Inbox2 size={14} className="dark:text-[#666] text-primary" />
        );
        resultDisplay = (
          <div className="flex items-center justify-between w-full">
            <div className="flex-grow truncate flex gap-2 items-center">
              <span>
                {
                  (item.data?.display_name ||
                    (item.data?.file_name as string)?.split("/").at(-1) ||
                    "") as string
                }
              </span>
              {item.data?.amount && item.data?.currency && (
                <span className="text-xs text-muted-foreground">
                  <FormatAmount
                    currency={item.data.currency}
                    amount={item.data.amount}
                  />
                </span>
              )}
              <span className="text-xs text-muted-foreground">
                {item.data?.date && formatDate(item.data.date, dateFormat)}
              </span>
            </div>
            <div className="flex items-center gap-2 invisible group-hover/item:visible group-focus/item:visible group-aria-selected/item:visible">
              <CopyButton path={`/inbox?inboxId=${item.id}`} />
              <DownloadButton
                href={`/api/download/file?path=${item.data?.file_path?.join("/")}&filename=${item.data?.file_name || ""}`}
                filename={item.data?.file_name || "download"}
              />
              <Icons.ArrowOutward className="size-4 dark:text-[#666] text-primary hover:!text-primary cursor-pointer" />
            </div>
          </div>
        );
        break;
      }
      case "tracker_project": {
        onSelect = () =>
          nav.navigateToTracker({ projectId: item.id, update: true });

        icon = null; // TrackerTimer will handle its own icon
        resultDisplay = (
          <div className="flex items-center w-full">
            <div className="flex-grow min-w-0 -ml-[6px]">
              <TrackerTimer
                projectId={item.id}
                projectName={item.data.name as string}
                onClick={() =>
                  nav.navigateToTracker({ projectId: item.id, update: true })
                }
                alwaysShowButton={true}
              />
            </div>
          </div>
        );
        break;
      }
      case "transaction": {
        onSelect = () => nav.navigateToTransaction({ transactionId: item.id });

        icon = (
          <Icons.Transactions className="size-4 dark:text-[#666] text-primary" />
        );
        resultDisplay = (
          <div className="flex items-center justify-between w-full">
            <div className="flex-grow truncate flex gap-2 items-center">
              <span>{(item.data?.name || "") as string}</span>
              <span className="text-xs text-muted-foreground">
                <FormatAmount
                  currency={item.data?.currency as string}
                  amount={item.data?.amount as number}
                />
              </span>
              <span className="text-xs text-muted-foreground">
                {item.data?.date
                  ? formatDate(item.data.date, dateFormat)
                  : null}
              </span>
            </div>
            <div className="flex items-center gap-2 invisible group-hover/item:visible group-focus/item:visible group-aria-selected/item:visible">
              <CopyButton path={item.data?.url as string} />
              <Icons.ArrowOutward className="size-4 dark:text-[#666] text-primary hover:!text-primary cursor-pointer" />
            </div>
          </div>
        );
        break;
      }
      default:
        // For types not explicitly handled but have data,
        // icon remains the default data icon, and resultDisplay remains item.title.
        // This is fine.
        break;
    }
  }

  const handleSelect = () => {
    item.action?.();
    onSelect?.();
  };

  return (
    <CommandItem
      key={item.id}
      value={item.id}
      onSelect={handleSelect}
      className="text-sm flex flex-col items-start gap-1 py-2 group/item"
    >
      <div className="flex items-center gap-2 w-full">
        {icon}
        {resultDisplay}
      </div>
    </CommandItem>
  );
};

export function Search() {
  const { data: user } = useUserQuery();
  const [debounceDelay, setDebounceDelay] = useState(200);
  const ref = useRef<HTMLDivElement>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);
  const height = useRef<HTMLDivElement>(null);
  const nav = useSearchNavigation();
  const trpc = useTRPC();

  // Get current timer status to prioritize tracker section
  const { data: timerStatus, refetch: refetchTimerStatus } = useQuery({
    ...trpc.trackerEntries.getTimerStatus.queryOptions(),
    refetchInterval: false,
    staleTime: 5 * 60 * 1000,
  });

  useHotkeys(
    "esc",
    () => {
      setDebouncedSearch("");
      emit("search-window-close-requested");
    },
    {
      enableOnFormTags: true,
    },
  );

  useEffect(() => {
    if (!isDesktopApp()) {
      return;
    }

    const unlistenPromise = listen("search-window-open", (event) => {
      const isOpen = event.payload as boolean;
      if (isOpen) {
        // Refetch timer status to get the most up-to-date information
        refetchTimerStatus();

        // Focus the search input field when window opens
        setTimeout(() => {
          searchInputRef.current?.focus();
        }, 100); // Small delay to ensure window is fully rendered
      }
    });

    // Cleanup function
    return () => {
      unlistenPromise.then((unlisten) => unlisten());
    };
  }, [refetchTimerStatus]);

  // Refetch timer status when search component mounts (for both desktop and web)
  useEffect(() => {
    refetchTimerStatus();
  }, [refetchTimerStatus]);

  const [debouncedSearch, setDebouncedSearch] = useDebounceValue(
    "",
    debounceDelay,
  );

  const sectionActions: SearchItem[] = [
    {
      id: "sc-create-invoice",
      type: "invoice",
      title: "Create invoice",
      action: nav.createInvoice,
    },
    {
      id: "sc-create-customer",
      type: "customer",
      title: "Create customer",
      action: nav.createCustomer,
    },
    {
      id: "sc-create-transaction",
      type: "transaction",
      title: "Create transaction",
      action: nav.createTransaction,
    },
    {
      id: "sc-create-project",
      type: "tracker_project",
      title: "Create project",
      action: nav.createProject,
    },
    {
      id: "sc-track-time",
      type: "tracker_project",
      title: "Track time",
      action: nav.trackTime,
    },
    {
      id: "sc-view-documents",
      type: "vault",
      title: "View vault",
      action: () => nav.navigateToPath("/vault"),
    },
    {
      id: "sc-view-customers",
      type: "customer",
      title: "View customers",
      action: () => nav.navigateToPath("/customers"),
    },
    {
      id: "sc-view-transactions",
      type: "transaction",
      title: "View transactions",
      action: () => nav.navigateToPath("/transactions"),
    },
    {
      id: "sc-view-inbox",
      type: "inbox",
      title: "View inbox",
      action: () => nav.navigateToPath("/inbox"),
    },
    {
      id: "sc-view-invoices",
      type: "invoice",
      title: "View invoices",
      action: () => nav.navigateToPath("/invoices"),
    },
    {
      id: "sc-view-tracker",
      type: "tracker_project",
      title: "View tracker",
      action: () => nav.navigateToPath("/tracker"),
    },
  ];

  // Fetch data using useQuery
  const {
    data: queryResult,
    isLoading,
    isFetching,
  } = useQuery({
    ...trpc.search.global.queryOptions({
      searchTerm: debouncedSearch,
    }),
    placeholderData: (previousData) => previousData,
  });

  // Extract search results array from queryResult
  const searchResults: SearchItem[] = queryResult || [];

  const combinedData = useMemo(() => {
    // Type assertion for searchResults from DB to ensure they have actions if needed,
    // or map them to include default actions. For now, assuming they come with 'type' and 'title'.
    const mappedSearchResults = searchResults.map((res) => ({
      ...res,
      action: () => {},
    }));
    return [...mappedSearchResults];
  }, [debouncedSearch, searchResults]);

  const groupedData = useMemo(() => {
    const groups: Record<string, SearchItem[]> = {};
    // Group search results first
    for (const item of combinedData) {
      const groupKey = item.type || "other";
      if (!groups[groupKey]) {
        groups[groupKey] = [];
      }
      groups[groupKey].push(item);
    }

    // Filter sectionActions based on debouncedSearch
    const filteredSectionActions = debouncedSearch
      ? sectionActions.filter((action) =>
          action.title.toLowerCase().includes(debouncedSearch.toLowerCase()),
        )
      : sectionActions;

    // Add filtered sectionActions to their respective groups
    for (const actionItem of filteredSectionActions) {
      const groupKey = actionItem.type;
      if (!groups[groupKey]) {
        groups[groupKey] = [];
      }
      groups[groupKey].push(actionItem);
    }

    // Sort tracker projects to put the running project first
    const trackerProjectKey = "tracker_project";
    if (groups[trackerProjectKey] && timerStatus?.currentEntry?.projectId) {
      const runningProjectId = timerStatus.currentEntry.projectId;
      groups[trackerProjectKey] = groups[trackerProjectKey].sort((a, b) => {
        // Put the running project first
        if (a.id === runningProjectId && b.id !== runningProjectId) return -1;
        if (b.id === runningProjectId && a.id !== runningProjectId) return 1;
        return 0; // Keep original order for non-running projects
      });
    }

    // Prioritize tracker projects when timer is running
    const definedGroupOrder = timerStatus?.isRunning
      ? [
          "tracker_project",
          "vault",
          "customer",
          "invoice",
          "transaction",
          "inbox",
        ]
      : [
          "vault",
          "customer",
          "invoice",
          "transaction",
          "tracker_project",
          "inbox",
        ];

    const allGroupKeysInOrder: string[] = [];
    const addedKeys = new Set<string>();

    // Add groups based on defined order if they exist
    for (const key of definedGroupOrder) {
      if (groups[key]) {
        allGroupKeysInOrder.push(key);
        addedKeys.add(key);
      }
    }
    // Add any remaining groups that weren't in the defined order
    for (const key in groups) {
      if (groups[key] && groups[key].length > 0 && !addedKeys.has(key)) {
        allGroupKeysInOrder.push(key);
        addedKeys.add(key);
      }
    }

    const orderedGroups: Record<string, SearchItem[]> = {};
    for (const key of allGroupKeysInOrder) {
      if (groups[key] && groups[key].length > 0) {
        // Ensure group is not empty before adding
        orderedGroups[key] = groups[key];
      }
    }
    return orderedGroups;
  }, [
    combinedData,
    debouncedSearch,
    timerStatus?.isRunning,
    timerStatus?.currentEntry?.projectId,
  ]);

  useEffect(() => {
    if (height.current && ref.current && !isDesktopApp()) {
      const el = height.current;
      const wrapper = ref.current;
      let animationFrame: number;
      const observer = new ResizeObserver(() => {
        animationFrame = requestAnimationFrame(() => {
          const newHeight = el.offsetHeight;
          wrapper.style.setProperty("--search-list-height", `${newHeight}px`);
        });
      });
      observer.observe(el);
      return () => {
        cancelAnimationFrame(animationFrame);
        observer.unobserve(el);
      };
    }
  }, []);

  return (
    <Command
      shouldFilter={false}
      className="search-container overflow-hidden p-0 relative w-full bg-background backdrop-filter dark:border-[#2C2C2C] backdrop-blur-lg dark:bg-[#151515]/[99] h-auto border border-border"
    >
      <div className="border-b border-border relative">
        <CommandInput
          ref={searchInputRef}
          placeholder="Type a command or search..."
          onValueChange={(value: string) => {
            setDebouncedSearch(value);

            // If the search term is longer than 1 word, increase the debounce delay
            if (value.trim().split(/\s+/).length > 1) {
              setDebounceDelay(700);
            } else {
              setDebounceDelay(200);
            }
          }}
          className="px-4 h-[55px] py-0"
        />
        {isFetching && (
          <div className="absolute bottom-0 h-[2px] w-full overflow-hidden">
            <div className="absolute top-[1px] h-full w-40 animate-slide-effect bg-gradient-to-r dark:from-gray-800 dark:via-white dark:via-80% dark:to-gray-800 from-gray-200 via-black via-80% to-gray-200" />
          </div>
        )}
      </div>

      <div className="px-2 global-search-list" ref={ref}>
        <CommandList ref={height} className="scrollbar-hide">
          {!isLoading && combinedData.length === 0 && debouncedSearch && (
            <CommandEmpty>
              No results found for "{debouncedSearch}".
            </CommandEmpty>
          )}
          {!isLoading &&
            Object.entries(groupedData).map(([groupName, items]) => (
              <CommandGroup
                key={groupName}
                heading={formatGroupName(groupName)}
              >
                {items.map((item: SearchItem) => (
                  <SearchResultItemDisplay
                    key={item.id}
                    item={item}
                    dateFormat={user?.dateFormat ?? undefined}
                  />
                ))}
              </CommandGroup>
            ))}
        </CommandList>
      </div>
    </Command>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/customer-create-sheet.tsx">
"use client";

import { useCustomerParams } from "@/hooks/use-customer-params";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { Sheet, SheetContent, SheetHeader } from "@midday/ui/sheet";
import React from "react";
import { CustomerForm } from "../forms/customer-form";

export function CustomerCreateSheet() {
  const { setParams, createCustomer } = useCustomerParams();

  const isOpen = Boolean(createCustomer);

  return (
    <Sheet open={isOpen} onOpenChange={() => setParams(null)}>
      <SheetContent stack>
        <SheetHeader className="mb-6 flex justify-between items-center flex-row">
          <h2 className="text-xl">Create Customer</h2>
          <Button
            size="icon"
            variant="ghost"
            onClick={() => setParams(null)}
            className="p-0 m-0 size-auto hover:bg-transparent"
          >
            <Icons.Close className="size-5" />
          </Button>
        </SheetHeader>

        <CustomerForm />
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/customer-edit-sheet.tsx">
"use client";

import { useCustomerParams } from "@/hooks/use-customer-params";
import { useTRPC } from "@/trpc/client";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@midday/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { Sheet, SheetContent, SheetHeader } from "@midday/ui/sheet";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { CustomerForm } from "../forms/customer-form";

export function CustomerEditSheet() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { setParams, customerId } = useCustomerParams();

  const isOpen = Boolean(customerId);

  const { data: customer } = useQuery(
    trpc.customers.getById.queryOptions(
      { id: customerId! },
      {
        enabled: isOpen,
        staleTime: 0, // Always consider data stale so it always refetches
        initialData: () => {
          const pages = queryClient
            .getQueriesData({ queryKey: trpc.customers.get.infiniteQueryKey() })
            // @ts-expect-error
            .flatMap(([, data]) => data?.pages ?? [])
            .flatMap((page) => page.data ?? []);

          return pages.find((d) => d.id === customerId);
        },
      },
    ),
  );

  const deleteCustomerMutation = useMutation(
    trpc.customers.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.customers.get.infiniteQueryKey(),
        });
        setParams(null);
      },
    }),
  );

  return (
    <Sheet open={isOpen} onOpenChange={() => setParams(null)}>
      <SheetContent stack>
        <SheetHeader className="mb-6 flex justify-between items-center flex-row">
          <h2 className="text-xl">Edit Customer</h2>

          {customerId && (
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <button type="button">
                  <Icons.MoreVertical className="size-5" />
                </button>
              </DropdownMenuTrigger>
              <DropdownMenuContent sideOffset={10} align="end">
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <DropdownMenuItem
                      className="text-destructive"
                      onSelect={(e) => e.preventDefault()}
                    >
                      Delete
                    </DropdownMenuItem>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>
                        Are you absolutely sure?
                      </AlertDialogTitle>
                      <AlertDialogDescription>
                        This action cannot be undone. This will permanently
                        delete the customer and remove their data from our
                        servers.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel>Cancel</AlertDialogCancel>
                      <AlertDialogAction
                        onClick={() =>
                          deleteCustomerMutation.mutate({ id: customerId })
                        }
                      >
                        Delete
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </DropdownMenuContent>
            </DropdownMenu>
          )}
        </SheetHeader>

        <CustomerForm data={customer} key={customer?.id} />
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/document-sheet.tsx">
"use client";

import { DocumentDetails } from "@/components/document-details";
import { useDocumentParams } from "@/hooks/use-document-params";
import { Sheet, SheetContent } from "@midday/ui/sheet";
import React from "react";

export function DocumentSheet() {
  const { params, setParams } = useDocumentParams();

  const isOpen = Boolean(params.filePath || params.documentId);

  return (
    <Sheet
      open={isOpen}
      onOpenChange={() => setParams({ documentId: null, filePath: null })}
    >
      <SheetContent style={{ maxWidth: 647 }}>
        <DocumentDetails />
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/global-sheets.tsx">
"use client";

import { AssistantModal } from "@/components/assistant/assistant-modal";
import { ConnectTransactionsModal } from "@/components/modals/connect-transactions-modal";
import { ImportModal } from "@/components/modals/import-modal";
import { SelectBankAccountsModal } from "@/components/modals/select-bank-accounts";
import { TrialEndedModal } from "@/components/modals/trial-ended-modal";
import { SearchModal } from "@/components/search/search-modal";
import { CustomerCreateSheet } from "@/components/sheets/customer-create-sheet";
import { CustomerEditSheet } from "@/components/sheets/customer-edit-sheet";
import { DocumentSheet } from "@/components/sheets/document-sheet";
import { InboxDetailsSheet } from "@/components/sheets/inbox-details-sheet";
import { InvoiceDetailsSheet } from "@/components/sheets/invoice-details-sheet";
import { InvoiceSheet } from "@/components/sheets/invoice-sheet";
import { TrackerCreateSheet } from "@/components/sheets/tracker-create-sheet";
import { TrackerScheduleSheet } from "@/components/sheets/tracker-schedule-sheet";
import { TrackerUpdateSheet } from "@/components/sheets/tracker-update-sheet";
import { TransactionCreateSheet } from "@/components/sheets/transaction-create-sheet";
import { TransactionSheet } from "@/components/sheets/transaction-sheet";
import { uniqueCurrencies } from "@midday/location/currencies";
import { use } from "react";

type Props = {
  currencyPromise: Promise<string>;
  countryCodePromise: Promise<string>;
};

export function GlobalSheets({ currencyPromise, countryCodePromise }: Props) {
  const currency = use(currencyPromise);
  const countryCode = use(countryCodePromise);

  return (
    <>
      <TrackerUpdateSheet defaultCurrency={currency} />
      <TrackerCreateSheet defaultCurrency={currency} />
      <TrackerScheduleSheet />

      <CustomerCreateSheet />
      <CustomerEditSheet />

      <TransactionSheet />
      <TransactionCreateSheet />

      <AssistantModal />
      <SelectBankAccountsModal />
      <TrialEndedModal />
      <SearchModal />

      <DocumentSheet />
      <InboxDetailsSheet />

      <ImportModal currencies={uniqueCurrencies} defaultCurrency={currency} />
      <ConnectTransactionsModal countryCode={countryCode} />

      <InvoiceDetailsSheet />
      <InvoiceSheet />
    </>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/inbox-details-sheet.tsx">
"use client";

import { InboxSheetDetails } from "@/components/inbox-sheet-details";
import { useInboxParams } from "@/hooks/use-inbox-params";
import { Sheet, SheetContent } from "@midday/ui/sheet";
import React from "react";

export function InboxDetailsSheet() {
  const { params, setParams } = useInboxParams();

  const isOpen = Boolean(params.inboxId && params.type === "details");

  return (
    <Sheet
      open={isOpen}
      onOpenChange={() => setParams({ type: null, inboxId: null })}
    >
      <SheetContent style={{ maxWidth: 647 }}>
        <InboxSheetDetails />
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/invoice-details-sheet.tsx">
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { Sheet, SheetContent } from "@midday/ui/sheet";
import React from "react";
import { InvoiceDetails } from "../invoice-details";

export function InvoiceDetailsSheet() {
  const { invoiceId, type, setParams } = useInvoiceParams();

  const isOpen = Boolean(invoiceId && type === "details");

  return (
    <Sheet
      open={isOpen}
      onOpenChange={() => setParams({ invoiceId: null, type: null })}
    >
      <SheetContent>
        <InvoiceDetails />
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/invoice-sheet.tsx">
"use client";

import { InvoiceContent } from "@/components/invoice-content";
import { FormContext } from "@/components/invoice/form-context";
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { useTRPC } from "@/trpc/client";
import { Sheet } from "@midday/ui/sheet";
import { useQuery, useSuspenseQuery } from "@tanstack/react-query";
import React from "react";

export function InvoiceSheet() {
  const trpc = useTRPC();
  const { setParams, type, invoiceId } = useInvoiceParams();
  const isOpen = type === "create" || type === "edit" || type === "success";

  // Get default settings for new invoices
  const { data: defaultSettings, refetch } = useSuspenseQuery(
    trpc.invoice.defaultSettings.queryOptions(),
  );

  // Get draft invoice for edit
  const { data } = useQuery(
    trpc.invoice.getById.queryOptions(
      {
        id: invoiceId!,
      },
      {
        enabled: !!invoiceId,
      },
    ),
  );

  const handleOnOpenChange = (open: boolean) => {
    // Refetch default settings when the sheet is closed
    if (!open) {
      refetch();
    }

    setParams(null);
  };

  return (
    <Sheet open={isOpen} onOpenChange={handleOnOpenChange}>
      <FormContext defaultSettings={defaultSettings} data={data}>
        <InvoiceContent />
      </FormContext>
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/oauth-application-create-sheet.tsx">
"use client";

import { OAuthApplicationForm } from "@/components/forms/oauth-application-form";
import { useOAuthApplicationParams } from "@/hooks/use-oauth-application-params";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { ScrollArea } from "@midday/ui/scroll-area";
import { Sheet, SheetContent, SheetHeader } from "@midday/ui/sheet";
import React from "react";

export function OAuthApplicationCreateSheet() {
  const { setParams, createApplication } = useOAuthApplicationParams();

  const isOpen = Boolean(createApplication);

  return (
    <Sheet open={isOpen} onOpenChange={() => setParams(null)}>
      <SheetContent stack>
        <SheetHeader className="mb-6 flex justify-between items-center flex-row">
          <h2 className="text-xl">Create OAuth Application</h2>
          <Button
            size="icon"
            variant="ghost"
            onClick={() => setParams(null)}
            className="p-0 m-0 size-auto hover:bg-transparent"
          >
            <Icons.Close className="size-5" />
          </Button>
        </SheetHeader>

        <ScrollArea className="h-full p-0 pb-10" hideScrollbar>
          <OAuthApplicationForm />
        </ScrollArea>
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/oauth-application-edit-sheet.tsx">
"use client";

import { OAuthApplicationForm } from "@/components/forms/oauth-application-form";
import { DeleteOAuthApplicationModal } from "@/components/modals/delete-oauth-application-modal";
import { OAuthApplicationStatusBadge } from "@/components/oauth-application-status-badge";
import { useOAuthApplicationParams } from "@/hooks/use-oauth-application-params";
import { useTRPC } from "@/trpc/client";
import { Badge } from "@midday/ui/badge";
import { Button } from "@midday/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { ScrollArea } from "@midday/ui/scroll-area";
import { Sheet, SheetContent, SheetHeader } from "@midday/ui/sheet";
import { useToast } from "@midday/ui/use-toast";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useState } from "react";
import { useCopyToClipboard } from "usehooks-ts";

export function OAuthApplicationEditSheet() {
  const trpc = useTRPC();
  const { toast } = useToast();
  const [, copy] = useCopyToClipboard();
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const queryClient = useQueryClient();
  const { setParams, applicationId, editApplication } =
    useOAuthApplicationParams();

  const isOpen = Boolean(applicationId && editApplication);

  const { data: application } = useQuery(
    trpc.oauthApplications.get.queryOptions(
      { id: applicationId! },
      {
        enabled: isOpen,
      },
    ),
  );

  const submitForReviewMutation = useMutation(
    trpc.oauthApplications.updateApprovalStatus.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.oauthApplications.list.queryKey(),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.oauthApplications.get.queryKey(),
        });
        toast({
          title: "Submitted for review",
          description:
            "Your application has been submitted for review and will be visible once approved.",
          variant: "success",
        });
      },
      onError: (error) => {
        toast({
          title: "Error",
          description: error.message || "Failed to submit for review",
        });
      },
    }),
  );

  const makeDraftMutation = useMutation(
    trpc.oauthApplications.updateApprovalStatus.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.oauthApplications.list.queryKey(),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.oauthApplications.get.queryKey(),
        });
        toast({
          title: "Application moved to draft",
          description:
            "Your application has been moved back to draft status and removed from review.",
          variant: "success",
        });
      },
      onError: (error) => {
        toast({
          title: "Error",
          description: error.message || "Failed to move to draft",
        });
      },
    }),
  );

  const handleCopyClientId = () => {
    if (application?.clientId) {
      copy(application.clientId);
      toast({
        title: "Client ID copied to clipboard",
        variant: "success",
      });
    }
  };

  const handleSubmitForReview = () => {
    if (applicationId) {
      submitForReviewMutation.mutate({
        id: applicationId,
        status: "pending",
      });
    }
  };

  const handleMakeDraft = () => {
    if (applicationId) {
      makeDraftMutation.mutate({
        id: applicationId,
        status: "draft",
      });
    }
  };

  return (
    <Sheet open={isOpen} onOpenChange={() => setParams(null)}>
      <SheetContent stack>
        <SheetHeader className="mb-6 flex justify-between items-center flex-row">
          <h2 className="text-xl">Edit OAuth Application</h2>

          <div className="flex items-center gap-2">
            {application?.status && (
              <OAuthApplicationStatusBadge status={application.status} />
            )}

            {applicationId && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <button type="button">
                    <Icons.MoreVertical className="size-5" />
                  </button>
                </DropdownMenuTrigger>
                <DropdownMenuContent sideOffset={10} align="end">
                  <DropdownMenuItem onClick={handleCopyClientId}>
                    Copy Client ID
                  </DropdownMenuItem>
                  {application?.status === "draft" && (
                    <DropdownMenuItem
                      onClick={handleSubmitForReview}
                      disabled={submitForReviewMutation.isPending}
                    >
                      {submitForReviewMutation.isPending
                        ? "Submitting..."
                        : "Submit for review"}
                    </DropdownMenuItem>
                  )}
                  {application?.status === "pending" && (
                    <DropdownMenuItem
                      onClick={handleMakeDraft}
                      disabled={makeDraftMutation.isPending}
                    >
                      {makeDraftMutation.isPending
                        ? "Cancelling review..."
                        : "Cancel review"}
                    </DropdownMenuItem>
                  )}
                  <DropdownMenuItem
                    className="text-destructive"
                    onClick={() => setShowDeleteModal(true)}
                  >
                    Delete
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </div>
        </SheetHeader>

        <ScrollArea className="h-full p-0 pb-10" hideScrollbar>
          <OAuthApplicationForm data={application} key={application?.id} />
        </ScrollArea>
      </SheetContent>

      <DeleteOAuthApplicationModal
        applicationId={applicationId!}
        applicationName={application?.name || ""}
        isOpen={showDeleteModal}
        onOpenChange={setShowDeleteModal}
      />
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/tracker-create-sheet.tsx">
"use client";

import { TrackerProjectForm } from "@/components/forms/tracker-project-form";
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { ScrollArea } from "@midday/ui/scroll-area";
import { Sheet, SheetContent, SheetHeader } from "@midday/ui/sheet";
import React from "react";

type Props = {
  defaultCurrency: string;
};

export function TrackerCreateSheet({ defaultCurrency }: Props) {
  const { setParams, create } = useTrackerParams();

  const isOpen = Boolean(create);

  return (
    <Sheet open={isOpen} onOpenChange={() => setParams({ create: null })}>
      <SheetContent>
        <SheetHeader className="mb-8 flex justify-between items-center flex-row">
          <h2 className="text-xl">Create Project</h2>
        </SheetHeader>

        <ScrollArea className="h-full p-0 pb-28" hideScrollbar>
          <TrackerProjectForm defaultCurrency={defaultCurrency} />
        </ScrollArea>
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/tracker-schedule-sheet.tsx">
"use client";

import { useTrackerParams } from "@/hooks/use-tracker-params";
import { Sheet, SheetContent } from "@midday/ui/sheet";
import React from "react";
import { TrackerSchedule } from "../tracker-schedule";

export function TrackerScheduleSheet() {
  const { setParams, projectId, range, selectedDate, eventId, update, create } =
    useTrackerParams();

  const isOpen =
    !update &&
    !create &&
    (Boolean(projectId) ||
      range?.length === 2 ||
      Boolean(selectedDate) ||
      Boolean(eventId));

  return (
    <Sheet
      open={isOpen}
      onOpenChange={() =>
        setParams({
          projectId: null,
          range: null,
          selectedDate: null,
          eventId: null,
        })
      }
    >
      <SheetContent>
        <TrackerSchedule />
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/tracker-update-sheet.tsx">
"use client";

import { TrackerProjectForm } from "@/components/forms/tracker-project-form";
import { useLatestProjectId } from "@/hooks/use-latest-project-id";
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { useTRPC } from "@/trpc/client";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@midday/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { ScrollArea } from "@midday/ui/scroll-area";
import { Sheet, SheetContent, SheetHeader } from "@midday/ui/sheet";
import { useMutation } from "@tanstack/react-query";
import { useQueryClient } from "@tanstack/react-query";
import { useQuery } from "@tanstack/react-query";

type Props = {
  defaultCurrency: string;
};

export function TrackerUpdateSheet({ defaultCurrency }: Props) {
  const { setParams, update, projectId } = useTrackerParams();
  const { latestProjectId, setLatestProjectId } = useLatestProjectId();
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const isOpen = update !== null && Boolean(projectId);

  const { data } = useQuery(
    trpc.trackerProjects.getById.queryOptions(
      { id: projectId! },
      {
        enabled: isOpen,
        staleTime: 0, // Always consider data stale so it always refetches
        initialData: () => {
          const pages = queryClient
            .getQueriesData({
              queryKey: trpc.trackerProjects.get.infiniteQueryKey(),
            })
            // @ts-expect-error
            .flatMap(([, data]) => data?.pages ?? [])
            .flatMap((page) => page.data ?? []);

          return pages.find((d) => d.id === projectId);
        },
      },
    ),
  );

  const deleteTrackerProjectMutation = useMutation(
    trpc.trackerProjects.delete.mutationOptions({
      onSuccess: (result) => {
        if (result && result.id === latestProjectId) {
          setLatestProjectId(null);
        }

        setParams({ projectId: null, update: null });

        queryClient.invalidateQueries({
          queryKey: trpc.trackerProjects.get.infiniteQueryKey(),
        });
      },
    }),
  );

  return (
    <AlertDialog>
      <Sheet
        open={isOpen}
        onOpenChange={() => setParams({ update: null, projectId: null })}
      >
        <SheetContent>
          <SheetHeader className="mb-8 flex justify-between items-center flex-row">
            <h2 className="text-xl">Edit Project</h2>

            <DropdownMenu>
              <DropdownMenuTrigger>
                <Icons.MoreVertical className="w-5 h-5" />
              </DropdownMenuTrigger>

              <DropdownMenuContent className="w-42" sideOffset={10} align="end">
                <AlertDialogTrigger asChild>
                  <DropdownMenuItem className="text-destructive">
                    Delete
                  </DropdownMenuItem>
                </AlertDialogTrigger>
              </DropdownMenuContent>
            </DropdownMenu>
          </SheetHeader>

          <ScrollArea className="h-full p-0 pb-28" hideScrollbar>
            <TrackerProjectForm data={data} defaultCurrency={defaultCurrency} />
          </ScrollArea>
        </SheetContent>
      </Sheet>

      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
          <AlertDialogDescription>
            This action cannot be undone. This will permanently delete this
            project.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={() =>
              deleteTrackerProjectMutation.mutate({ id: projectId! })
            }
          >
            Continue
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/transaction-create-sheet.tsx">
"use client";

import { useTransactionParams } from "@/hooks/use-transaction-params";
import { ScrollArea } from "@midday/ui/scroll-area";
import { Sheet, SheetContent, SheetHeader, SheetTitle } from "@midday/ui/sheet";
import { TransactionCreateForm } from "../forms/transaction-create-form";

export function TransactionCreateSheet() {
  const { createTransaction, setParams } = useTransactionParams();

  const isOpen = Boolean(createTransaction);

  const handleOpenChange = (open: boolean) => {
    if (!open) {
      setParams(null);
    }
  };

  return (
    <Sheet open={isOpen} onOpenChange={handleOpenChange}>
      <SheetContent>
        <SheetHeader className="mb-8">
          <SheetTitle>Create Transaction</SheetTitle>
        </SheetHeader>

        <ScrollArea className="h-full p-0 pb-[100px]" hideScrollbar>
          <TransactionCreateForm />
        </ScrollArea>
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/sheets/transaction-sheet.tsx">
"use client";

import { useTransactionParams } from "@/hooks/use-transaction-params";
import { Sheet, SheetContent } from "@midday/ui/sheet";
import React from "react";
import { TransactionDetails } from "../transaction-details";

export function TransactionSheet() {
  const { transactionId, setParams } = useTransactionParams();
  const isOpen = Boolean(transactionId);

  const handleOpenChange = (open: boolean) => {
    if (!open) {
      setParams(null);
    }
  };

  return (
    <Sheet open={isOpen} onOpenChange={handleOpenChange}>
      <SheetContent>
        <TransactionDetails />
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/api-keys/columns.tsx">
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Button } from "@midday/ui/button";
import type { ColumnDef } from "@tanstack/react-table";
import * as React from "react";
import "@tanstack/react-table";
import { useTokenModalStore } from "@/store/token-modal";
import { scopesToName } from "@api/utils/scopes";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { Badge } from "@midday/ui/badge";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { formatDistanceToNow } from "date-fns";

type ApiKey = RouterOutputs["apiKeys"]["get"][number];

export const columns: ColumnDef<ApiKey>[] = [
  {
    id: "name",
    accessorKey: "name",
    header: "Name",
    cell: ({ row }) => {
      return row.original.name;
    },
  },
  {
    id: "user",
    accessorKey: "user",
    header: "User",
    cell: ({ row }) => {
      const user = row.original.user;
      if (!user) return <span className="text-muted-foreground">-</span>;

      return (
        <div className="flex space-x-2 items-center">
          <Avatar className="h-6 w-6">
            {user.avatarUrl && (
              <AvatarImageNext
                src={user.avatarUrl}
                alt={user.fullName ?? ""}
                width={24}
                height={24}
              />
            )}
            <AvatarFallback className="text-xs">
              {user.fullName?.charAt(0)?.toUpperCase() ?? "?"}
            </AvatarFallback>
          </Avatar>
          <span className="truncate">
            {user.fullName?.split(" ").at(0) ?? "Unknown"}
          </span>
        </div>
      );
    },
  },
  {
    id: "scopes",
    accessorKey: "scopes",
    header: "Permissions",
    cell: ({ row }) => {
      return (
        <Badge variant="tag">{scopesToName(row.original.scopes).name}</Badge>
      );
    },
  },
  {
    id: "created",
    accessorKey: "createdAt",
    header: "Created",
    cell: ({ row }) => {
      const createdAt = row.original.createdAt;

      if (!createdAt) {
        return <span className="text-muted-foreground">-</span>;
      }

      return (
        <span>
          {formatDistanceToNow(new Date(createdAt), { addSuffix: true })}
        </span>
      );
    },
  },
  {
    id: "lastUsed",
    accessorKey: "lastUsedAt",
    header: "Last used",
    meta: {
      className: "border-r-[0px]",
    },
    cell: ({ row }) => {
      const lastUsedAt = row.original.lastUsedAt;

      if (!lastUsedAt) {
        return <span className="text-muted-foreground">Never</span>;
      }

      return (
        <span>
          {formatDistanceToNow(new Date(lastUsedAt), { addSuffix: true })}
        </span>
      );
    },
  },
  {
    id: "actions",
    cell: ({ row }) => {
      const { setData } = useTokenModalStore();

      return (
        <div className="flex justify-end">
          <div className="flex space-x-2 items-center">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button size="icon" variant="ghost">
                  <Icons.MoreHoriz className="size-4" />
                </Button>
              </DropdownMenuTrigger>

              <DropdownMenuContent sideOffset={10} align="end">
                <DropdownMenuItem onClick={() => setData(row.original, "edit")}>
                  Edit
                </DropdownMenuItem>
                <DropdownMenuItem
                  className="text-destructive"
                  onClick={() => setData(row.original, "delete")}
                >
                  Delete
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      );
    },
    meta: {
      className: "text-right",
    },
  },
];
</file>

<file path="apps/dashboard/src/components/tables/api-keys/empty-state.tsx">
export function EmptyState() {
  return (
    <div className="flex flex-col items-center justify-center h-[300px] border border-border">
      <h3>No API keys found</h3>
      <p className="text-sm text-muted-foreground">
        No API keys have been created for this team yet.
      </p>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/api-keys/index.tsx">
"use client";

import { useTokenModalStore } from "@/store/token-modal";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@midday/ui/table";
import { useSuspenseQuery } from "@tanstack/react-query";
import {
  flexRender,
  getCoreRowModel,
  useReactTable,
} from "@tanstack/react-table";
import * as React from "react";
import { columns } from "./columns";
import { EmptyState } from "./empty-state";

export function DataTable() {
  const trpc = useTRPC();
  const { setData } = useTokenModalStore();
  const { data } = useSuspenseQuery({
    ...trpc.apiKeys.get.queryOptions(),
  });

  const table = useReactTable({
    getRowId: (row) => row.id,
    data: data ?? [],
    columns,
    getCoreRowModel: getCoreRowModel(),
  });

  return (
    <div className="w-full">
      <div className="flex flex-col md:flex-row md:items-center pb-4 gap-4 md:gap-8">
        <div className="flex-1">
          <h3 className="text-lg font-medium leading-none tracking-tight mb-2">
            API Keys
          </h3>
          <p className="text-sm text-[#606060]">
            These API keys allow other apps to access your team. Use it with
            caution – do not share your API key with others, or expose it in the
            browser or other client-side code.
          </p>
        </div>
        <div className="flex-shrink-0">
          <Button onClick={() => setData(undefined, "create")}>
            Create API Key
          </Button>
        </div>
      </div>
      {data.length > 0 ? (
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => {
                  return (
                    <TableHead
                      key={header.id}
                      className={header.column.columnDef.meta?.className}
                    >
                      {header.isPlaceholder
                        ? null
                        : flexRender(
                            header.column.columnDef.header,
                            header.getContext(),
                          )}
                    </TableHead>
                  );
                })}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows.map((row) => (
              <TableRow key={row.id} className="hover:bg-transparent">
                {row.getAllCells().map((cell) => (
                  <TableCell
                    key={cell.id}
                    onClick={() => {
                      if (cell.column.id !== "actions") {
                        setData(row.original, "edit");
                      }
                    }}
                    className={cn(
                      "border-r-[0px] py-4 cursor-pointer",
                      cell.column.columnDef.meta?.className,
                    )}
                  >
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </TableCell>
                ))}
              </TableRow>
            ))}
          </TableBody>
        </Table>
      ) : (
        <EmptyState />
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/categories/columns.tsx">
"use client";

import { CreateSubCategoryModal } from "@/components/modals/create-sub-category-modal";
import { EditCategoryModal } from "@/components/modals/edit-category-modal";
import { useI18n } from "@/locales/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { getTaxTypeLabel } from "@midday/utils/tax";
import { DotsHorizontalIcon } from "@radix-ui/react-icons";
import type { ColumnDef } from "@tanstack/react-table";
import { ChevronDown, ChevronRight } from "lucide-react";
import * as React from "react";

export type Category = RouterOutputs["transactionCategories"]["get"][number];

// Component to display category description from localization
function CategoryTooltip({ category }: { category: any }) {
  const t = useI18n();

  // Priority 1: User-defined description
  if (category.description) {
    return <span>{category.description}</span>;
  }

  // Priority 2: System description from localization
  try {
    return (
      // @ts-expect-error - slug is not nullable
      <span>{t(`transaction_categories.${category.slug}`)}</span>
    );
  } catch {
    // Fallback if translation not found
    return <span>Category description not available</span>;
  }
}

// Flatten categories to include both parents and children with hierarchy info
export function flattenCategories(categories: any[]): any[] {
  const flattened: any[] = [];

  for (const category of categories) {
    // Add parent category
    flattened.push({
      ...category,
      isChild: false,
      hasChildren: category.children && category.children.length > 0,
    });

    // Add children if they exist
    if (category.children && category.children.length > 0) {
      for (const child of category.children) {
        flattened.push({
          ...child,
          isChild: true,
          parentId: category.id,
          hasChildren: false,
        });
      }
    }
  }

  return flattened;
}

export const columns: ColumnDef<any>[] = [
  {
    header: "Name",
    accessorKey: "name",
    cell: ({ row, table }) => {
      const [expandedCategories, setExpandedCategories] = React.useState<
        Set<string>
      >(new Set());

      // Get expanded state from table meta or use local state as fallback
      const tableExpandedCategories =
        (table.options.meta as any)?.expandedCategories || expandedCategories;
      const setTableExpandedCategories =
        (table.options.meta as any)?.setExpandedCategories ||
        setExpandedCategories;

      const isExpanded = tableExpandedCategories.has(row.original.id);
      const hasChildren = row.original.hasChildren;
      const isChild = row.original.isChild;

      const toggleExpanded = () => {
        const newExpanded = new Set(tableExpandedCategories);
        if (isExpanded) {
          newExpanded.delete(row.original.id);
        } else {
          newExpanded.add(row.original.id);
        }
        setTableExpandedCategories(newExpanded);
      };

      return (
        <div className={cn("flex space-x-2 items-center", isChild && "ml-10")}>
          {hasChildren && !isChild && (
            <Button
              variant="ghost"
              size="sm"
              className="h-4 w-4 p-0 hover:bg-transparent"
              onClick={toggleExpanded}
            >
              {isExpanded ? (
                <ChevronDown className="h-3 w-3" />
              ) : (
                <ChevronRight className="h-3 w-3" />
              )}
            </Button>
          )}
          {!hasChildren && !isChild && <div className="w-4" />}
          <div
            className="size-3"
            style={{ backgroundColor: row.original.color ?? undefined }}
          />
          <TooltipProvider delayDuration={0}>
            <Tooltip>
              <TooltipTrigger asChild>
                <span
                  className={cn(
                    hasChildren && !isChild
                      ? "cursor-pointer"
                      : "cursor-default",
                  )}
                  onClick={hasChildren && !isChild ? toggleExpanded : undefined}
                >
                  {row.getValue("name")}
                </span>
              </TooltipTrigger>
              <TooltipContent
                className="px-3 py-1.5 text-xs"
                side="right"
                sideOffset={10}
              >
                <CategoryTooltip category={row.original} />
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          {row.original.system && (
            <div className="pl-2">
              <span className="border border-border rounded-full py-1 px-2 text-[10px] text-[#878787] font-mono">
                System
              </span>
            </div>
          )}
        </div>
      );
    },
  },
  {
    header: "Tax Type",
    accessorKey: "taxType",
    cell: ({ row }) =>
      row.getValue("taxType") ? getTaxTypeLabel(row.getValue("taxType")) : "-",
  },
  {
    header: "Tax Rate",
    accessorKey: "taxRate",
    cell: ({ row }) =>
      row.getValue("taxRate") ? `${row.getValue("taxRate")}%` : "-",
  },
  {
    header: () => <span className="whitespace-nowrap">Report Code</span>,
    accessorKey: "taxReportingCode",
    cell: ({ row }) => row.getValue("taxReportingCode") || "-",
  },
  {
    id: "actions",
    cell: ({ row, table }) => {
      const [isEditOpen, setIsEditOpen] = React.useState(false);
      const [isCreateSubcategoryOpen, setIsCreateSubcategoryOpen] =
        React.useState(false);

      return (
        <div className="text-right">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" className="h-8 w-8 p-0">
                <DotsHorizontalIcon className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem onClick={() => setIsEditOpen(true)}>
                Edit
              </DropdownMenuItem>

              {!row.original.isChild && (
                <DropdownMenuItem
                  onClick={() => setIsCreateSubcategoryOpen(true)}
                >
                  Add Subcategory
                </DropdownMenuItem>
              )}

              {!row.original.system && (
                <DropdownMenuItem
                  onClick={() =>
                    table.options.meta?.deleteCategory?.(row.original.id)
                  }
                >
                  Remove
                </DropdownMenuItem>
              )}
            </DropdownMenuContent>
          </DropdownMenu>

          <EditCategoryModal
            id={row.original.id}
            defaultValue={row.original}
            isOpen={isEditOpen}
            onOpenChange={setIsEditOpen}
          />

          <CreateSubCategoryModal
            isOpen={isCreateSubcategoryOpen}
            onOpenChange={setIsCreateSubcategoryOpen}
            parentId={row.original.id}
            defaultTaxRate={row.original.taxRate}
            defaultTaxType={row.original.taxType}
            defaultColor={row.original.color}
            defaultTaxReportingCode={row.original.taxReportingCode}
            defaultExcluded={row.original.excluded}
          />
        </div>
      );
    },
  },
];
</file>

<file path="apps/dashboard/src/components/tables/categories/header.tsx">
"use client";

import { Button } from "@midday/ui/button";
import { Input } from "@midday/ui/input";
import type { Table } from "@tanstack/react-table";
import type { Category } from "./columns";

type Props = {
  table?: Table<Category>;
  onOpenChange?: (isOpen: boolean) => void;
};

export function Header({ table, onOpenChange }: Props) {
  return (
    <div className="flex items-center py-4 justify-between">
      <Input
        placeholder="Search..."
        value={(table?.getColumn("name")?.getFilterValue() as string) ?? ""}
        onChange={(event) =>
          table?.getColumn("name")?.setFilterValue(event.target.value)
        }
        className="max-w-sm"
      />

      <Button onClick={() => onOpenChange?.(true)}>Create</Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/categories/skeleton.tsx">
import { Skeleton } from "@midday/ui/skeleton";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@midday/ui/table";
import { Header } from "./header";

export function CategoriesSkeleton() {
  return (
    <div className="w-full">
      <Header />

      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Name</TableHead>
            <TableHead>VAT</TableHead>
          </TableRow>
        </TableHeader>

        <TableBody>
          {[...Array(15)].map((_, index) => (
            <TableRow
              key={index.toString()}
              className="hover:bg-transparent h-[49px]"
            >
              <TableCell className="w-[50px]">
                <Skeleton className="size-4 rounded-md" />
              </TableCell>
              <TableCell>
                <Skeleton className="w-[20%] h-2" />
              </TableCell>
              <TableCell className="w-[65px]">
                <Skeleton className="w-5 h-1" />
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/categories/table.tsx">
"use client";

import { CreateCategoriesModal } from "@/components/modals/create-categories-modal";
import { useTRPC } from "@/trpc/client";
import { cn } from "@midday/ui/cn";
import { Dialog } from "@midday/ui/dialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@midday/ui/table";
import {
  useMutation,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";
import {
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  useReactTable,
} from "@tanstack/react-table";
import React from "react";
import { columns, flattenCategories } from "./columns";
import { Header } from "./header";

export function DataTable() {
  const [isOpen, onOpenChange] = React.useState(false);
  const [expandedCategories, setExpandedCategories] = React.useState<
    Set<string>
  >(new Set());

  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const { data } = useSuspenseQuery(
    trpc.transactionCategories.get.queryOptions(),
  );

  const deleteCategoryMutation = useMutation(
    trpc.transactionCategories.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.transactionCategories.get.queryKey(),
        });
      },
    }),
  );

  // Flatten categories and filter based on expanded state
  const flattenedData = React.useMemo(() => {
    const flattened = flattenCategories(data ?? []);

    // Filter to only show parent categories and children of expanded parents
    return flattened.filter((category) => {
      // Always show parent categories
      if (!category.isChild) {
        return true;
      }
      // Only show children if their parent is expanded
      return category.parentId && expandedCategories.has(category.parentId);
    });
  }, [data, expandedCategories]);

  const table = useReactTable({
    data: flattenedData,
    getRowId: ({ id }) => id,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    meta: {
      deleteCategory: (id: string) => {
        deleteCategoryMutation.mutate({ id });
      },
      expandedCategories,
      setExpandedCategories,
    },
  });

  return (
    <div className="w-full">
      <Header table={table} onOpenChange={onOpenChange} />

      <Table>
        <TableHeader>
          {table.getHeaderGroups().map((headerGroup) => (
            <TableRow key={headerGroup.id}>
              {headerGroup.headers.map((header) => {
                return (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext(),
                        )}
                  </TableHead>
                );
              })}
            </TableRow>
          ))}
        </TableHeader>

        <TableBody>
          {table.getRowModel().rows.map((row) => (
            <TableRow className="hover:bg-transparent" key={row.id}>
              {row.getVisibleCells().map((cell, index) => (
                <TableCell
                  key={cell.id}
                  className={cn(index === 3 && "w-[50px]")}
                >
                  {flexRender(cell.column.columnDef.cell, cell.getContext())}
                </TableCell>
              ))}
            </TableRow>
          ))}
        </TableBody>
      </Table>

      <Dialog open={isOpen} onOpenChange={onOpenChange}>
        <CreateCategoriesModal onOpenChange={onOpenChange} isOpen={isOpen} />
      </Dialog>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/customers/columns.tsx">
"use client";

import { useCustomerParams } from "@/hooks/use-customer-params";
import { getWebsiteLogo } from "@/utils/logos";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { Badge } from "@midday/ui/badge";
import { Button } from "@midday/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { ScrollArea, ScrollBar } from "@midday/ui/scroll-area";
import { DotsHorizontalIcon } from "@radix-ui/react-icons";
import type { ColumnDef } from "@tanstack/react-table";
import Link from "next/link";
import * as React from "react";

export type Customer = RouterOutputs["customers"]["get"]["data"][number];

export const columns: ColumnDef<Customer>[] = [
  {
    header: "Name",
    accessorKey: "name",
    meta: {
      className:
        "w-[240px] min-w-[240px] md:sticky md:left-0 bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-20 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]",
    },
    cell: ({ row }) => {
      const name = row.original.name;

      if (!name) return "-";

      return (
        <div className="flex items-center space-x-2">
          <Avatar className="size-5">
            {row.original.website && (
              <AvatarImageNext
                src={getWebsiteLogo(row.original.website)}
                alt={`${name} logo`}
                width={20}
                height={20}
                quality={100}
              />
            )}
            <AvatarFallback className="text-[9px] font-medium">
              {name?.[0]}
            </AvatarFallback>
          </Avatar>
          <span className="truncate">{name}</span>
        </div>
      );
    },
  },
  {
    header: "Contact person",
    accessorKey: "contact",
    cell: ({ row }) => row.getValue("contact") ?? "-",
  },
  {
    header: "Email",
    accessorKey: "email",
    cell: ({ row }) => row.getValue("email") ?? "-",
  },
  {
    header: "Invoices",
    accessorKey: "invoices",
    cell: ({ row }) => {
      if (row.original.invoiceCount > 0) {
        return (
          <Link href={`/invoices?customers=${row.original.id}`}>
            {row.original.invoiceCount}
          </Link>
        );
      }

      return "-";
    },
  },
  {
    header: "Projects",
    accessorKey: "projects",
    cell: ({ row }) => {
      if (row.original.projectCount > 0) {
        return (
          <Link href={`/tracker?customers=${row.original.id}`}>
            {row.original.projectCount}
          </Link>
        );
      }

      return "-";
    },
  },
  {
    header: "Tags",
    accessorKey: "tags",
    meta: {
      className: "w-[280px] max-w-[280px]",
    },
    cell: ({ row }) => {
      return (
        <div className="relative w-full">
          <div className="flex items-center space-x-2 overflow-x-auto scrollbar-hide">
            {row.original.tags?.map((tag) => (
              <Link href={`/transactions?tags=${tag.id}`} key={tag.id}>
                <Badge
                  variant="tag-rounded"
                  className="whitespace-nowrap flex-shrink-0"
                >
                  {tag.name}
                </Badge>
              </Link>
            ))}
          </div>
          <div className="absolute group-hover:hidden right-0 top-0 bottom-0 w-8 bg-gradient-to-l from-background to-transparent pointer-events-none z-10" />
        </div>
      );
    },
  },
  {
    id: "actions",
    header: "Actions",
    meta: {
      className:
        "text-right sticky right-0 bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-30 before:absolute before:left-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:left-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-r after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]",
    },
    cell: ({ row, table }) => {
      const { setParams } = useCustomerParams();

      return (
        <div>
          <DropdownMenu>
            <DropdownMenuTrigger asChild className="relative">
              <Button variant="ghost" className="h-8 w-8 p-0">
                <DotsHorizontalIcon className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>

            <DropdownMenuContent align="end">
              <DropdownMenuItem
                onClick={() =>
                  setParams({
                    customerId: row.original.id,
                  })
                }
              >
                Edit customer
              </DropdownMenuItem>

              <DropdownMenuItem
                onClick={() =>
                  table.options.meta?.deleteCustomer?.(row.original.id)
                }
                className="text-[#FF3638]"
              >
                Delete
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      );
    },
  },
];
</file>

<file path="apps/dashboard/src/components/tables/customers/data-table.tsx">
"use client";

import { LoadMore } from "@/components/load-more";
import { useCustomerFilterParams } from "@/hooks/use-customer-filter-params";
import { useCustomerParams } from "@/hooks/use-customer-params";
import { useSortParams } from "@/hooks/use-sort-params";
import { useTableScroll } from "@/hooks/use-table-scroll";
import { useTRPC } from "@/trpc/client";
import { Table, TableBody } from "@midday/ui/table";
import { useMutation, useSuspenseInfiniteQuery } from "@tanstack/react-query";
import {
  getCoreRowModel,
  getFilteredRowModel,
  useReactTable,
} from "@tanstack/react-table";
import React, { useDeferredValue, useEffect, useMemo } from "react";
import { useInView } from "react-intersection-observer";
import { columns } from "./columns";
import { EmptyState, NoResults } from "./empty-states";
import { CustomerRow } from "./row";
import { TableHeader } from "./table-header";

export function DataTable() {
  const { ref, inView } = useInView();
  const { setParams } = useCustomerParams();
  const trpc = useTRPC();
  const { filter, hasFilters } = useCustomerFilterParams();
  const { params } = useSortParams();

  const deferredSearch = useDeferredValue(filter.q);

  const tableScroll = useTableScroll({
    useColumnWidths: true,
    startFromColumn: 1,
  });

  const infiniteQueryOptions = trpc.customers.get.infiniteQueryOptions(
    {
      ...filter,
      sort: params.sort,
      q: deferredSearch,
    },
    {
      getNextPageParam: ({ meta }) => meta?.cursor,
    },
  );

  const { data, fetchNextPage, hasNextPage, refetch } =
    useSuspenseInfiniteQuery(infiniteQueryOptions);

  const deleteCustomerMutation = useMutation(
    trpc.customers.delete.mutationOptions({
      onSuccess: () => {
        refetch();
      },
    }),
  );

  const handleDeleteCustomer = (id: string) => {
    deleteCustomerMutation.mutate({ id });
  };

  useEffect(() => {
    if (inView) {
      fetchNextPage();
    }
  }, [inView]);

  const tableData = useMemo(() => {
    return data?.pages.flatMap((page) => page.data) ?? [];
  }, [data]);

  const setOpen = (id?: string) => {
    if (id) {
      setParams({ customerId: id });
    } else {
      setParams(null);
    }
  };

  const table = useReactTable({
    data: tableData,
    getRowId: (row) => row.id,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    meta: {
      deleteCustomer: handleDeleteCustomer,
    },
  });

  if (!tableData.length && hasFilters) {
    return <NoResults />;
  }

  if (!tableData.length) {
    return <EmptyState />;
  }

  return (
    <div className="w-full">
      <div
        ref={tableScroll.containerRef}
        className="overflow-x-auto overscroll-x-none md:border-l md:border-r border-border scrollbar-hide"
      >
        <Table>
          <TableHeader tableScroll={tableScroll} />

          <TableBody className="border-l-0 border-r-0">
            {table.getRowModel().rows.map((row) => (
              <CustomerRow key={row.id} row={row} setOpen={setOpen} />
            ))}
          </TableBody>
        </Table>
      </div>

      <LoadMore ref={ref} hasNextPage={hasNextPage} />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/customers/empty-states.tsx">
"use client";

import { useCustomerParams } from "@/hooks/use-customer-params";
import { Button } from "@midday/ui/button";

export function EmptyState() {
  const { setParams } = useCustomerParams();

  return (
    <div className="flex items-center justify-center ">
      <div className="flex flex-col items-center mt-40">
        <div className="text-center mb-6 space-y-2">
          <h2 className="font-medium text-lg">No customers</h2>
          <p className="text-[#606060] text-sm">
            You haven't created any customers yet. <br />
            Go ahead and create your first one.
          </p>
        </div>

        <Button
          variant="outline"
          onClick={() =>
            setParams({
              createCustomer: true,
            })
          }
        >
          Create customer
        </Button>
      </div>
    </div>
  );
}

export function NoResults() {
  const { setParams } = useCustomerParams();

  return (
    <div className="flex items-center justify-center ">
      <div className="flex flex-col items-center mt-40">
        <div className="text-center mb-6 space-y-2">
          <h2 className="font-medium text-lg">No results</h2>
          <p className="text-[#606060] text-sm">
            Try another search, or adjusting the filters
          </p>
        </div>

        <Button variant="outline" onClick={() => setParams(null)}>
          Clear filters
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/customers/row.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { TableCell, TableRow } from "@midday/ui/table";
import { type Row, flexRender } from "@tanstack/react-table";
import type { Customer } from "./columns";

type Props = {
  row: Row<Customer>;
  setOpen: (id?: string) => void;
};

export function CustomerRow({ row, setOpen }: Props) {
  return (
    <>
      <TableRow
        className="group h-[45px] cursor-pointer hover:bg-[#F2F1EF] hover:dark:bg-secondary"
        key={row.id}
      >
        {row.getVisibleCells().map((cell, index) => (
          <TableCell
            key={cell.id}
            onClick={() => ![3, 4, 5, 6].includes(index) && setOpen(row.id)}
            className={cn(cell.column.columnDef.meta?.className)}
          >
            {flexRender(cell.column.columnDef.cell, cell.getContext())}
          </TableCell>
        ))}
      </TableRow>
    </>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/customers/skeleton.tsx">
import { Skeleton } from "@midday/ui/skeleton";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { TableHeader } from "./table-header";

export function CustomersSkeleton() {
  return (
    <div className="w-full">
      <div className="overflow-x-auto md:border-l md:border-r border-border">
        <Table>
          <TableHeader />
          <TableBody className="border-l-0 border-r-0 border-t-0 border-b-0">
            {Array.from({ length: 25 }).map((_, index) => (
              <TableRow key={index.toString()} className="h-[45px]">
                <TableCell className="w-[240px] min-w-[240px]">
                  <Skeleton className="h-4 w-24" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-32" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-20" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-24" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-16" />
                </TableCell>
                <TableCell className="w-[280px] max-w-[280px]">
                  <Skeleton className="h-4 w-20" />
                </TableCell>
                <TableCell className="w-[100px] sticky right-0 bg-background z-30">
                  <Skeleton className="h-4 w-8" />
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/customers/table-header.tsx">
"use client";

import { HorizontalPagination } from "@/components/horizontal-pagination";
import { useSortParams } from "@/hooks/use-sort-params";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import {
  TableHeader as BaseTableHeader,
  TableHead,
  TableRow,
} from "@midday/ui/table";
import { ArrowDown, ArrowUp } from "lucide-react";

interface Props {
  tableScroll?: {
    canScrollLeft: boolean;
    canScrollRight: boolean;
    isScrollable: boolean;
    scrollLeft: () => void;
    scrollRight: () => void;
  };
}

export function TableHeader({ tableScroll }: Props) {
  const { params, setParams } = useSortParams();

  const [column, value] = params.sort || [];

  const createSortQuery = (name: string) => {
    const [currentColumn, currentValue] = params.sort || [];

    if (name === currentColumn) {
      if (currentValue === "asc") {
        setParams({ sort: [name, "desc"] });
      } else if (currentValue === "desc") {
        setParams({ sort: null });
      } else {
        setParams({ sort: [name, "asc"] });
      }
    } else {
      setParams({ sort: [name, "asc"] });
    }
  };

  return (
    <BaseTableHeader className="border-l-0 border-r-0">
      <TableRow>
        <TableHead className="w-[240px] min-w-[240px] md:sticky md:left-0 bg-background z-20 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background after:z-[-1]">
          <div className="flex items-center justify-between">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("name")}
            >
              <span>Name</span>
              {"name" === column && value === "asc" && <ArrowDown size={16} />}
              {"name" === column && value === "desc" && <ArrowUp size={16} />}
            </Button>
            {tableScroll?.isScrollable && (
              <HorizontalPagination
                canScrollLeft={tableScroll.canScrollLeft}
                canScrollRight={tableScroll.canScrollRight}
                onScrollLeft={tableScroll.scrollLeft}
                onScrollRight={tableScroll.scrollRight}
                className="ml-auto hidden md:flex"
              />
            )}
          </div>
        </TableHead>
        <TableHead className="w-[180px] min-w-[180px] ">
          <Button
            className="p-0 hover:bg-transparent space-x-2"
            variant="ghost"
            onClick={() => createSortQuery("contact")}
          >
            <span>Contact person</span>
            {"contact" === column && value === "asc" && <ArrowDown size={16} />}
            {"contact" === column && value === "desc" && <ArrowUp size={16} />}
          </Button>
        </TableHead>
        <TableHead>
          <Button
            className="p-0 hover:bg-transparent space-x-2"
            variant="ghost"
            onClick={() => createSortQuery("email")}
          >
            <span>Email</span>
            {"email" === column && value === "asc" && <ArrowDown size={16} />}
            {"email" === column && value === "desc" && <ArrowUp size={16} />}
          </Button>
        </TableHead>
        <TableHead className="w-[200px]">
          <Button
            className="p-0 hover:bg-transparent space-x-2"
            variant="ghost"
            onClick={() => createSortQuery("invoices")}
          >
            <span>Invoices</span>
            {"invoices" === column && value === "asc" && (
              <ArrowDown size={16} />
            )}
            {"invoices" === column && value === "desc" && <ArrowUp size={16} />}
          </Button>
        </TableHead>
        <TableHead>
          <Button
            className="p-0 hover:bg-transparent space-x-2"
            variant="ghost"
            onClick={() => createSortQuery("projects")}
          >
            <span>Projects</span>
            {"projects" === column && value === "asc" && (
              <ArrowDown size={16} />
            )}
            {"projects" === column && value === "desc" && <ArrowUp size={16} />}
          </Button>
        </TableHead>

        <TableHead className="w-[280px] max-w-[280px]">
          <Button
            className="p-0 hover:bg-transparent space-x-2"
            variant="ghost"
            onClick={() => createSortQuery("tags")}
          >
            <span>Tags</span>
            {"tags" === column && value === "asc" && <ArrowDown size={16} />}
            {"tags" === column && value === "desc" && <ArrowUp size={16} />}
          </Button>
        </TableHead>

        <TableHead
          className={cn(
            "w-[100px] md:sticky md:right-0 bg-background z-30",
            "before:absolute before:left-0 before:top-0 before:bottom-0 before:w-px before:bg-border",
            "after:absolute after:left-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-r after:from-transparent after:to-background after:z-[-1]",
          )}
        >
          Actions
        </TableHead>
      </TableRow>
    </BaseTableHeader>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/invoices/actions-menu.tsx">
"use client";

import { OpenURL } from "@/components/open-url";
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { downloadFile } from "@/lib/download";
import { useTRPC } from "@/trpc/client";
import { getUrl } from "@/utils/environment";
import { Button } from "@midday/ui/button";
import { Calendar } from "@midday/ui/calendar";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { useToast } from "@midday/ui/use-toast";
import { DotsHorizontalIcon } from "@radix-ui/react-icons";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useCopyToClipboard } from "usehooks-ts";
import type { Invoice } from "./columns";

type Props = {
  row: Invoice;
};

export function ActionsMenu({ row }: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { setParams } = useInvoiceParams();
  const { toast } = useToast();
  const [, copy] = useCopyToClipboard();

  const deleteInvoiceMutation = useMutation(
    trpc.invoice.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.infiniteQueryKey(),
        });

        // Widget uses regular query
        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.getById.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.invoiceSummary.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.defaultSettings.queryKey(),
        });
      },
    }),
  );

  const updateInvoiceMutation = useMutation(
    trpc.invoice.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.infiniteQueryKey(),
        });

        // Widget uses regular query
        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.queryKey(),
        });
      },
    }),
  );

  const duplicateInvoiceMutation = useMutation(
    trpc.invoice.duplicate.mutationOptions({
      onSuccess: (data) => {
        if (data) {
          setParams({
            invoiceId: data.id,
            type: "edit",
          });
        }

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.queryKey(),
        });
      },
    }),
  );

  const cancelScheduleMutation = useMutation(
    trpc.invoice.cancelSchedule.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.infiniteQueryKey(),
        });

        // Widget uses regular query
        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.getById.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.invoiceSummary.queryKey(),
        });
      },
    }),
  );

  const handleCopyLink = async () => {
    copy(`${getUrl()}/i/${row.token}`);

    toast({
      duration: 4000,
      title: "Copied link to clipboard.",
      variant: "success",
    });
  };

  return (
    <div>
      <DropdownMenu>
        <DropdownMenuTrigger asChild className="relative">
          <Button variant="ghost" className="h-8 w-8 p-0">
            <DotsHorizontalIcon className="h-4 w-4" />
          </Button>
        </DropdownMenuTrigger>

        <DropdownMenuContent align="end">
          {row.status !== "paid" && row.status !== "canceled" && (
            <DropdownMenuItem
              onClick={() =>
                setParams({
                  invoiceId: row.id,
                  type: "edit",
                })
              }
            >
              Edit invoice
            </DropdownMenuItem>
          )}

          <DropdownMenuItem>
            <OpenURL href={`${getUrl()}/i/${row.token}`}>Open invoice</OpenURL>
          </DropdownMenuItem>

          <DropdownMenuItem onClick={handleCopyLink}>
            Copy link
          </DropdownMenuItem>

          {row.status !== "draft" && (
            <DropdownMenuItem
              onClick={() => {
                downloadFile(
                  `/api/download/invoice?id=${row.id}`,
                  `${row.invoiceNumber || "invoice"}.pdf`,
                );
              }}
            >
              Download
            </DropdownMenuItem>
          )}

          <DropdownMenuItem
            onClick={() => duplicateInvoiceMutation.mutate({ id: row.id })}
          >
            Duplicate
          </DropdownMenuItem>

          {row.status === "scheduled" && (
            <DropdownMenuItem
              onClick={() => cancelScheduleMutation.mutate({ id: row.id })}
              className="text-[#FF3638]"
            >
              Cancel schedule
            </DropdownMenuItem>
          )}

          {row.status === "paid" && (
            <DropdownMenuItem
              onClick={() =>
                updateInvoiceMutation.mutate({
                  id: row.id,
                  status: "unpaid",
                  paidAt: null,
                })
              }
            >
              Mark as unpaid
            </DropdownMenuItem>
          )}

          {(row.status === "overdue" || row.status === "unpaid") && (
            <>
              <DropdownMenuSub>
                <DropdownMenuSubTrigger>Mark as paid</DropdownMenuSubTrigger>
                <DropdownMenuSubContent>
                  <Calendar
                    mode="single"
                    toDate={new Date()}
                    selected={new Date()}
                    onSelect={(date) => {
                      if (date) {
                        updateInvoiceMutation.mutate({
                          id: row.id,
                          status: "paid",
                          paidAt: date.toISOString(),
                        });
                      } else {
                        // NOTE: Today is undefined
                        updateInvoiceMutation.mutate({
                          id: row.id,
                          status: "paid",
                          paidAt: new Date().toISOString(),
                        });
                      }
                    }}
                    initialFocus
                  />
                </DropdownMenuSubContent>
              </DropdownMenuSub>

              <DropdownMenuItem
                onClick={() =>
                  updateInvoiceMutation.mutate({
                    id: row.id,
                    status: "canceled",
                  })
                }
                className="text-[#FF3638]"
              >
                Cancel
              </DropdownMenuItem>
            </>
          )}

          {row.status === "canceled" && (
            <DropdownMenuItem
              onClick={() => deleteInvoiceMutation.mutate({ id: row.id })}
              className="text-[#FF3638]"
            >
              Delete
            </DropdownMenuItem>
          )}

          {row.status === "draft" && (
            <DropdownMenuItem
              onClick={() => deleteInvoiceMutation.mutate({ id: row.id })}
              className="text-[#FF3638]"
            >
              Delete
            </DropdownMenuItem>
          )}
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/invoices/columns.tsx">
"use client";

import { FormatAmount } from "@/components/format-amount";
import { InvoiceStatus } from "@/components/invoice-status";
import { formatDate, getDueDateStatus } from "@/utils/format";
import { getWebsiteLogo } from "@/utils/logos";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import { Tooltip, TooltipContent, TooltipTrigger } from "@midday/ui/tooltip";
import { TooltipProvider } from "@midday/ui/tooltip";
import type { ColumnDef } from "@tanstack/react-table";
import { format, formatDistanceToNow } from "date-fns";
import * as React from "react";
import { ActionsMenu } from "./actions-menu";

export type Invoice = NonNullable<
  RouterOutputs["invoice"]["get"]["data"]
>[number];

export const columns: ColumnDef<Invoice>[] = [
  {
    header: "Invoice no.",
    accessorKey: "invoiceNumber",
    meta: {
      className:
        "w-[220px] min-w-[220px] md:sticky md:left-0 bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-20 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]",
    },
    cell: ({ row }) => (
      <span
        className={cn({
          "line-through": row.original.status === "canceled",
        })}
      >
        {row.getValue("invoiceNumber")}
      </span>
    ),
  },
  {
    header: "Status",
    accessorKey: "status",
    cell: ({ row, table }) => {
      const status = row.getValue("status") as string;
      const scheduledAt = row.original.scheduledAt;

      if (status === "scheduled" && scheduledAt) {
        return (
          <TooltipProvider delayDuration={0}>
            <Tooltip>
              <TooltipTrigger>
                <InvoiceStatus status={status as any} />
              </TooltipTrigger>
              <TooltipContent
                className="text-xs py-1 px-2"
                side="right"
                sideOffset={5}
              >
                Scheduled to send:{" "}
                {format(
                  scheduledAt,
                  `MMM d, ${table.options.meta?.timeFormat === 24 ? "HH:mm" : "h:mm a"}`,
                )}
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        );
      }

      return <InvoiceStatus status={status as any} />;
    },
  },
  {
    header: "Due date",
    accessorKey: "dueDate",
    cell: ({ row, table }) => {
      const date = row.original.dueDate;

      const showDate =
        row.original.status === "unpaid" || row.original.status === "overdue";

      return (
        <div className="flex flex-col space-y-1 w-[80px]">
          <span>
            {date ? formatDate(date, table.options.meta?.dateFormat) : "-"}
          </span>
          {showDate && (
            <span className="text-xs text-muted-foreground">
              {date ? getDueDateStatus(date as string) : "-"}
            </span>
          )}
        </div>
      );
    },
  },
  {
    header: "Customer",
    accessorKey: "customer",
    cell: ({ row }) => {
      const customer = row.original.customer;
      const name = customer?.name || row.original.customerName;
      const viewAt = row.original.viewedAt;

      if (!name) return "-";

      return (
        <div className="flex items-center space-x-2">
          <Avatar className="size-5">
            {customer?.website && (
              <AvatarImageNext
                src={getWebsiteLogo(customer?.website)}
                alt={`${name} logo`}
                width={20}
                height={20}
                quality={100}
              />
            )}
            <AvatarFallback className="text-[9px] font-medium">
              {name?.[0]}
            </AvatarFallback>
          </Avatar>
          <span className="truncate">{name}</span>

          {viewAt && row.original.status !== "paid" && (
            <TooltipProvider delayDuration={0}>
              <Tooltip>
                <TooltipTrigger className="flex items-center space-x-2">
                  <Icons.Visibility className="size-4 text-[#878787]" />
                </TooltipTrigger>
                <TooltipContent
                  className="text-xs py-1 px-2"
                  side="right"
                  sideOffset={5}
                >
                  {viewAt
                    ? `Viewed ${formatDistanceToNow(new Date(viewAt))} ago`
                    : ""}
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          )}
        </div>
      );
    },
  },
  {
    header: "Amount",
    accessorKey: "amount",
    cell: ({ row }) => {
      if (!row.original.amount) return "-";
      return (
        <span
          className={cn("flex items-center gap-2", {
            "line-through": row.original.status === "canceled",
          })}
        >
          <FormatAmount
            amount={row.original.amount}
            currency={row.original.currency ?? "USD"}
          />
        </span>
      );
    },
  },
  {
    header: "VAT Rate",
    accessorKey: "vatRate",
    cell: ({ row }) => {
      // @ts-expect-error template is a jsonb field
      const vatRate = row.original.template.vatRate as number | undefined;
      const value =
        vatRate !== undefined && vatRate !== null ? `${vatRate}%` : "-";
      return (
        <span
          className={cn({
            "line-through": row.original.status === "canceled",
          })}
        >
          {value}
        </span>
      );
    },
  },
  {
    header: "VAT Amount",
    accessorKey: "vatAmount",
    cell: ({ row }) => (
      <span
        className={cn({
          "line-through": row.original.status === "canceled",
        })}
      >
        <FormatAmount
          amount={(row.original?.vat as number) ?? null}
          currency={row.original.currency ?? "USD"}
        />
      </span>
    ),
  },
  {
    header: "Tax Rate",
    accessorKey: "taxRate",
    cell: ({ row }) => {
      // @ts-expect-error template is a jsonb field
      const taxRate = row.original.template.taxRate as number | undefined;
      const value =
        taxRate !== undefined && taxRate !== null ? `${taxRate}%` : "-";
      return (
        <span
          className={cn({
            "line-through": row.original.status === "canceled",
          })}
        >
          {value}
        </span>
      );
    },
  },
  {
    header: "Tax Amount",
    accessorKey: "taxAmount",
    cell: ({ row }) => (
      <span
        className={cn({
          "line-through": row.original.status === "canceled",
        })}
      >
        <FormatAmount
          amount={(row.original.tax as number) ?? null}
          currency={row.original.currency ?? "USD"}
        />
      </span>
    ),
  },
  {
    header: "Excl. VAT",
    accessorKey: "exclVat",
    cell: ({ row }) => (
      <span
        className={cn({
          "line-through": row.original.status === "canceled",
        })}
      >
        <FormatAmount
          amount={
            (row.original.amount as number) - (row.original.vat as number)
          }
          currency={row.original.currency ?? "USD"}
        />
      </span>
    ),
  },
  {
    header: "Excl. Tax",
    accessorKey: "exclTax",
    cell: ({ row }) => (
      <span
        className={cn({
          "line-through": row.original.status === "canceled",
        })}
      >
        <FormatAmount
          amount={
            (row.original.amount as number) - (row.original.tax as number)
          }
          currency={row.original.currency ?? "USD"}
        />
      </span>
    ),
  },
  {
    header: "Internal Note",
    accessorKey: "internalNote",
    cell: ({ row }) => {
      return <span className="truncate">{row.original.internalNote}</span>;
    },
  },
  {
    header: "Issue date",
    accessorKey: "issueDate",
    cell: ({ row, table }) => {
      const date = row.original.issueDate;
      return (
        <span>
          {date ? formatDate(date, table.options.meta?.dateFormat) : "-"}
        </span>
      );
    },
  },
  {
    header: "Sent at",
    accessorKey: "sentAt",
    cell: ({ row, table }) => {
      const sentAt = row.original.sentAt;
      const sentTo = row.original.sentTo;

      if (!sentAt) {
        return "-";
      }

      if (!sentTo) {
        return formatDate(sentAt, table.options.meta?.dateFormat);
      }

      return (
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger className="flex items-center space-x-2">
              {formatDate(sentAt, table.options.meta?.dateFormat)}
            </TooltipTrigger>
            <TooltipContent
              className="text-xs py-1 px-2"
              side="right"
              sideOffset={5}
            >
              {sentTo}
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      );
    },
  },
  {
    id: "actions",
    header: "Actions",
    meta: {
      className:
        "text-right md:sticky md:right-0 bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-30 before:absolute before:left-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:left-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-r after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]",
    },
    cell: ({ row }) => {
      return <ActionsMenu row={row.original} />;
    },
  },
];
</file>

<file path="apps/dashboard/src/components/tables/invoices/data-table.tsx">
"use client";

import { updateColumnVisibilityAction } from "@/actions/update-column-visibility-action";
import { LoadMore } from "@/components/load-more";
import { useInvoiceFilterParams } from "@/hooks/use-invoice-filter-params";
import { useSortParams } from "@/hooks/use-sort-params";
import { useTableScroll } from "@/hooks/use-table-scroll";
import { useUserQuery } from "@/hooks/use-user";
import { useInvoiceStore } from "@/store/invoice";
import { useTRPC } from "@/trpc/client";
import { Cookies } from "@/utils/constants";
import { Table, TableBody } from "@midday/ui/table";
import { useSuspenseInfiniteQuery } from "@tanstack/react-query";
import {
  type VisibilityState,
  getCoreRowModel,
  getFilteredRowModel,
  useReactTable,
} from "@tanstack/react-table";
import React, { use, useEffect, useMemo, useState } from "react";
import { useInView } from "react-intersection-observer";
import { columns } from "./columns";
import { NoResults } from "./empty-states";
import { EmptyState } from "./empty-states";
import { InvoiceRow } from "./row";
import { TableHeader } from "./table-header";

type Props = {
  columnVisibility: Promise<VisibilityState>;
};

export function DataTable({
  columnVisibility: columnVisibilityPromise,
}: Props) {
  const trpc = useTRPC();
  const { params } = useSortParams();
  const { filter, hasFilters } = useInvoiceFilterParams();
  const { ref, inView } = useInView();
  const { data: user } = useUserQuery();

  const { setColumns } = useInvoiceStore();
  const initialColumnVisibility = use(columnVisibilityPromise);
  const [columnVisibility, setColumnVisibility] = useState<VisibilityState>(
    initialColumnVisibility ?? {},
  );

  const tableScroll = useTableScroll({
    useColumnWidths: true,
    startFromColumn: 1,
  });

  const infiniteQueryOptions = trpc.invoice.get.infiniteQueryOptions(
    {
      sort: params.sort,
      ...filter,
    },
    {
      getNextPageParam: ({ meta }) => meta?.cursor,
    },
  );

  const { data, fetchNextPage, hasNextPage, isFetching } =
    useSuspenseInfiniteQuery(infiniteQueryOptions);

  const tableData = useMemo(() => {
    return data?.pages.flatMap((page) => page?.data ?? []) ?? [];
  }, [data]);

  useEffect(() => {
    if (inView) {
      fetchNextPage();
    }
  }, [inView]);

  useEffect(() => {
    updateColumnVisibilityAction({
      key: Cookies.InvoicesColumns,
      data: columnVisibility,
    });
  }, [columnVisibility]);

  const table = useReactTable({
    data: tableData,
    getRowId: ({ id }) => id,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    onColumnVisibilityChange: setColumnVisibility,
    state: {
      columnVisibility,
    },
    meta: {
      dateFormat: user?.dateFormat,
      timeFormat: user?.timeFormat,
    },
  });

  useEffect(() => {
    setColumns(table.getAllLeafColumns());
  }, [columnVisibility]);

  if (hasFilters && !tableData?.length) {
    return <NoResults />;
  }

  if (!tableData?.length && !isFetching) {
    return <EmptyState />;
  }

  return (
    <div className="w-full">
      <div
        ref={tableScroll.containerRef}
        className="overflow-x-auto overscroll-x-none md:border-l md:border-r border-border scrollbar-hide"
      >
        <Table>
          <TableHeader table={table} tableScroll={tableScroll} />

          <TableBody className="border-l-0 border-r-0">
            {table.getRowModel().rows.map((row) => (
              <InvoiceRow key={row.id} row={row} />
            ))}
          </TableBody>
        </Table>
      </div>

      <LoadMore ref={ref} hasNextPage={hasNextPage} />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/invoices/empty-states.tsx">
"use client";

import { useInvoiceFilterParams } from "@/hooks/use-invoice-filter-params";
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { Button } from "@midday/ui/button";

export function EmptyState() {
  const { setParams } = useInvoiceParams();

  return (
    <div className="flex items-center justify-center ">
      <div className="flex flex-col items-center mt-40">
        <div className="text-center mb-6 space-y-2">
          <h2 className="font-medium text-lg">No invoices</h2>
          <p className="text-[#606060] text-sm">
            You haven't created any invoices yet. <br />
            Go ahead and create your first one.
          </p>
        </div>

        <Button
          variant="outline"
          onClick={() =>
            setParams({
              type: "create",
            })
          }
        >
          Create invoice
        </Button>
      </div>
    </div>
  );
}

export function NoResults() {
  const { setFilter } = useInvoiceFilterParams();

  return (
    <div className="flex items-center justify-center ">
      <div className="flex flex-col items-center mt-40">
        <div className="text-center mb-6 space-y-2">
          <h2 className="font-medium text-lg">No results</h2>
          <p className="text-[#606060] text-sm">
            Try another search, or adjusting the filters
          </p>
        </div>

        <Button variant="outline" onClick={() => setFilter(null)}>
          Clear filters
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/invoices/row.tsx">
"use client";

import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { cn } from "@midday/ui/cn";
import { TableCell, TableRow } from "@midday/ui/table";
import { type Row, flexRender } from "@tanstack/react-table";
import type { Invoice } from "./columns";

type Props = {
  row: Row<Invoice>;
};

export function InvoiceRow({ row }: Props) {
  const { setParams } = useInvoiceParams();

  return (
    <>
      <TableRow
        className="group h-[57px] cursor-pointer hover:bg-[#F2F1EF] hover:dark:bg-secondary"
        key={row.id}
      >
        {row.getVisibleCells().map((cell, index) => (
          <TableCell
            key={cell.id}
            className={cn(
              index === 2 && "w-[50px] min-w-[50px]",
              cell.column.columnDef.meta?.className,
            )}
            onClick={() => {
              if (index !== row.getVisibleCells().length - 1) {
                setParams({
                  invoiceId: row.id,
                  type: "details",
                });
              }
            }}
          >
            {flexRender(cell.column.columnDef.cell, cell.getContext())}
          </TableCell>
        ))}
      </TableRow>
    </>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/invoices/skeleton.tsx">
import { Skeleton } from "@midday/ui/skeleton";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { TableHeader } from "./table-header";

export function InvoiceSkeleton() {
  return (
    <div className="w-full">
      <div className="overflow-x-auto md:border-l md:border-r border-border">
        <Table>
          <TableHeader />
          <TableBody className="border-l-0 border-r-0 border-t-0 border-b-0">
            {Array.from({ length: 25 }).map((_, index) => (
              <TableRow key={index.toString()} className="h-[57px]">
                <TableCell>
                  <Skeleton className="h-4 w-[200px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[150px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[150px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[180px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[250px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[200px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[100px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[150px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[100px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[150px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[150px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[150px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[120px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[100px]" />
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/invoices/table-header.tsx">
"use client";

import { HorizontalPagination } from "@/components/horizontal-pagination";
import { useSortParams } from "@/hooks/use-sort-params";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import {
  TableHeader as BaseTableHeader,
  TableHead,
  TableRow,
} from "@midday/ui/table";
import { ArrowDown, ArrowUp } from "lucide-react";

interface TableColumn {
  id: string;
  getIsVisible: () => boolean;
}

interface TableInterface {
  getAllLeafColumns: () => TableColumn[];
}

interface Props {
  table?: TableInterface;
  tableScroll?: {
    canScrollLeft: boolean;
    canScrollRight: boolean;
    isScrollable: boolean;
    scrollLeft: () => void;
    scrollRight: () => void;
  };
}

export function TableHeader({ table, tableScroll }: Props) {
  const { params, setParams } = useSortParams();

  const [column, value] = params.sort || [];

  const createSortQuery = (name: string) => {
    const [currentColumn, currentValue] = params.sort || [];

    if (name === currentColumn) {
      if (currentValue === "asc") {
        setParams({ sort: [name, "desc"] });
      } else if (currentValue === "desc") {
        setParams({ sort: null });
      } else {
        setParams({ sort: [name, "asc"] });
      }
    } else {
      setParams({ sort: [name, "asc"] });
    }
  };

  const isVisible = (id: string) =>
    table
      ?.getAllLeafColumns()
      .find((col) => col.id === id)
      ?.getIsVisible();

  return (
    <BaseTableHeader className="border-l-0 border-r-0">
      <TableRow>
        {isVisible("invoiceNumber") && (
          <TableHead className="w-[220px] min-w-[220px] md:sticky md:left-0 bg-background z-20 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background after:z-[-1]">
            <div className="flex items-center justify-between">
              <Button
                className="p-0 hover:bg-transparent space-x-2"
                variant="ghost"
                onClick={() => createSortQuery("invoice_number")}
              >
                <span>Invoice no.</span>
                {"invoiceNumber" === column && value === "asc" && (
                  <ArrowDown size={16} />
                )}
                {"invoiceNumber" === column && value === "desc" && (
                  <ArrowUp size={16} />
                )}
              </Button>
              {tableScroll?.isScrollable && (
                <HorizontalPagination
                  canScrollLeft={tableScroll.canScrollLeft}
                  canScrollRight={tableScroll.canScrollRight}
                  onScrollLeft={tableScroll.scrollLeft}
                  onScrollRight={tableScroll.scrollRight}
                  className="ml-auto hidden md:flex"
                />
              )}
            </div>
          </TableHead>
        )}
        {isVisible("status") && (
          <TableHead className="w-[150px]">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("status")}
            >
              <span>Status</span>
              {"status" === column && value === "asc" && (
                <ArrowDown size={16} />
              )}
              {"status" === column && value === "desc" && <ArrowUp size={16} />}
            </Button>
          </TableHead>
        )}

        {isVisible("dueDate") && (
          <TableHead className="w-[180px]">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("due_date")}
            >
              <span>Due Date</span>
              {"dueDate" === column && value === "asc" && (
                <ArrowDown size={16} />
              )}
              {"dueDate" === column && value === "desc" && (
                <ArrowUp size={16} />
              )}
            </Button>
          </TableHead>
        )}

        {isVisible("customer") && (
          <TableHead className="min-w-[250px]">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("customer")}
            >
              <span>Customer</span>
              {"customer" === column && value === "asc" && (
                <ArrowDown size={16} />
              )}
              {"customer" === column && value === "desc" && (
                <ArrowUp size={16} />
              )}
            </Button>
          </TableHead>
        )}
        {isVisible("amount") && (
          <TableHead className="w-[200px]">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("amount")}
            >
              <span>Amount</span>
              {"amount" === column && value === "asc" && (
                <ArrowDown size={16} />
              )}
              {"amount" === column && value === "desc" && <ArrowUp size={16} />}
            </Button>
          </TableHead>
        )}

        {isVisible("vatRate") && (
          <TableHead className="w-[100px] min-w-[100px]">
            <span>VAT Rate</span>
          </TableHead>
        )}

        {isVisible("vatAmount") && (
          <TableHead className="w-[150px] min-w-[150px]">
            <span>VAT Amount</span>
          </TableHead>
        )}

        {isVisible("taxRate") && (
          <TableHead className="w-[100px] min-w-[100px]">
            <span>Tax Rate</span>
          </TableHead>
        )}

        {isVisible("taxAmount") && (
          <TableHead className="w-[150px] min-w-[150px]">
            <span>Tax Amount</span>
          </TableHead>
        )}

        {isVisible("exclVat") && (
          <TableHead className="w-[150px] min-w-[150px]">
            <span>Excl. VAT</span>
          </TableHead>
        )}

        {isVisible("exclTax") && (
          <TableHead className="w-[150px] min-w-[150px]">
            <span>Excl. Tax</span>
          </TableHead>
        )}

        {isVisible("internalNote") && (
          <TableHead className="w-[150px] min-w-[150px]">
            <span>Internal Note</span>
          </TableHead>
        )}

        {isVisible("issueDate") && (
          <TableHead className="w-[120px] min-w-[120px]">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("issue_date")}
            >
              <span>Issue Date</span>
              {"issueDate" === column && value === "asc" && (
                <ArrowDown size={16} />
              )}
              {"issueDate" === column && value === "desc" && (
                <ArrowUp size={16} />
              )}
            </Button>
          </TableHead>
        )}

        {isVisible("sentAt") && (
          <TableHead className="w-[150px] min-w-[150px]">
            <span>Sent at</span>
          </TableHead>
        )}

        {isVisible("actions") && (
          <TableHead
            className={cn(
              "w-[100px] md:sticky md:right-0 bg-background z-30",
              "before:absolute before:left-0 before:top-0 before:bottom-0 before:w-px before:bg-border",
              "after:absolute after:left-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-r after:from-transparent after:to-background after:z-[-1]",
            )}
          >
            Actions
          </TableHead>
        )}
      </TableRow>
    </BaseTableHeader>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/members/columns.tsx">
import { useI18n } from "@/locales/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@midday/ui/alert-dialog";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { Button } from "@midday/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";
import { useToast } from "@midday/ui/use-toast";
import type { ColumnDef, FilterFn, Row } from "@tanstack/react-table";
import { MoreHorizontal } from "lucide-react";
import { Loader2 } from "lucide-react";
import * as React from "react";
import "@tanstack/react-table";
import { useTRPC } from "@/trpc/client";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useRouter } from "next/navigation";

type TeamMember = RouterOutputs["team"]["members"][number];

const userFilterFn: FilterFn<TeamMember> = (
  row: Row<TeamMember>,
  _: string,
  filterValue: string,
) => {
  const memberName = row.original.user?.fullName?.toLowerCase();

  return memberName?.includes(filterValue.toLowerCase()) ?? false;
};

export const columns: ColumnDef<TeamMember>[] = [
  {
    id: "user",
    accessorKey: "user.full_name",
    filterFn: userFilterFn,
    cell: ({ row }) => {
      return (
        <div>
          <div className="flex items-center space-x-4">
            <Avatar className="rounded-full w-8 h-8">
              <AvatarImageNext
                src={row.original.user?.avatarUrl ?? ""}
                alt={row.original.user?.fullName ?? ""}
                width={32}
                height={32}
              />
              <AvatarFallback>
                <span className="text-xs">
                  {row.original.user?.fullName?.charAt(0)?.toUpperCase()}
                </span>
              </AvatarFallback>
            </Avatar>
            <div className="flex flex-col">
              <span className="font-medium text-sm">
                {row.original.user?.fullName}
              </span>
              <span className="text-sm text-[#606060]">
                {row.original.user?.email}
              </span>
            </div>
          </div>
        </div>
      );
    },
  },
  {
    id: "actions",
    cell: ({ row, table }) => {
      const t = useI18n();
      const { toast } = useToast();
      const meta = table.options.meta;
      const trpc = useTRPC();
      const queryClient = useQueryClient();
      const router = useRouter();

      const deleteMemberMutation = useMutation(
        trpc.team.deleteMember.mutationOptions({
          onSuccess: () => {
            queryClient.invalidateQueries({
              queryKey: trpc.team.members.queryKey(),
            });
          },
          onError: () => {
            toast({
              title: "Error deleting member",
            });
          },
        }),
      );

      const leaveTeamMutation = useMutation(
        trpc.team.leave.mutationOptions({
          onSuccess: async () => {
            router.push("/teams");
          },
        }),
      );

      const updateMemberMutation = useMutation(
        trpc.team.updateMember.mutationOptions({
          onSuccess: () => {
            queryClient.invalidateQueries({
              queryKey: trpc.team.members.queryKey(),
            });
          },
        }),
      );

      return (
        <div className="flex justify-end">
          <div className="flex space-x-2 items-center">
            {(meta?.currentUser?.role === "owner" &&
              meta?.currentUser?.user?.id !== row.original.user?.id) ||
            (meta?.currentUser?.role === "owner" &&
              (meta?.totalOwners ?? 0) > 1) ? (
              <Select
                value={row.original.role ?? undefined}
                onValueChange={(role) => {
                  updateMemberMutation.mutate({
                    userId: row.original.user?.id!,
                    teamId: row.original.teamId!,
                    role: role as "owner" | "member",
                  });
                }}
              >
                <SelectTrigger>
                  <SelectValue
                    placeholder={t(`roles.${row.original.role || "member"}`)}
                  />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="owner">Owner</SelectItem>
                  <SelectItem value="member">Member</SelectItem>
                </SelectContent>
              </Select>
            ) : (
              <span className="text-sm text-[#606060]">
                {t(`roles.${row.original.role || "member"}`)}
              </span>
            )}
            {meta?.currentUser?.role === "owner" && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" className="h-8 w-8 p-0">
                    <MoreHorizontal className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  {meta?.currentUser?.user?.id !== row.original.user?.id && (
                    <AlertDialog>
                      <DropdownMenuItem
                        className="text-destructive"
                        asDialogTrigger
                      >
                        <AlertDialogTrigger>Remove Member</AlertDialogTrigger>
                      </DropdownMenuItem>

                      <AlertDialogContent>
                        <AlertDialogHeader>
                          <AlertDialogTitle>
                            Remove Team Member
                          </AlertDialogTitle>
                          <AlertDialogDescription>
                            You are about to remove the following Team Member,
                            are you sure you want to continue?
                          </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                          <AlertDialogCancel>Cancel</AlertDialogCancel>
                          <AlertDialogAction
                            disabled={deleteMemberMutation.isPending}
                            onClick={() => {
                              deleteMemberMutation.mutate({
                                userId: row.original.user?.id!,
                                teamId: row.original.teamId!,
                              });
                            }}
                          >
                            {deleteMemberMutation.isPending ? (
                              <Loader2 className="h-4 w-4 animate-spin" />
                            ) : (
                              "Confirm"
                            )}
                          </AlertDialogAction>
                        </AlertDialogFooter>
                      </AlertDialogContent>
                    </AlertDialog>
                  )}

                  {meta?.currentUser?.user?.id === row.original.user?.id && (
                    <AlertDialog>
                      <DropdownMenuItem
                        className="text-destructive"
                        asDialogTrigger
                      >
                        <AlertDialogTrigger>Leave Team</AlertDialogTrigger>
                      </DropdownMenuItem>

                      <AlertDialogContent>
                        <AlertDialogHeader>
                          <AlertDialogTitle>Leave Team</AlertDialogTitle>
                          <AlertDialogDescription>
                            You are about to leave this team. In order to regain
                            access at a later time, a Team Owner must invite
                            you.
                            <p className="mt-4">
                              Are you sure you want to continue?
                            </p>
                          </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                          <AlertDialogCancel>Cancel</AlertDialogCancel>
                          <AlertDialogAction
                            disabled={leaveTeamMutation.isPending}
                            onClick={() =>
                              leaveTeamMutation.mutate({
                                teamId: row.original.teamId!,
                              })
                            }
                          >
                            {leaveTeamMutation.isPending ? (
                              <Loader2 className="h-4 w-4 animate-spin" />
                            ) : (
                              "Confirm"
                            )}
                          </AlertDialogAction>
                        </AlertDialogFooter>
                      </AlertDialogContent>
                    </AlertDialog>
                  )}
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </div>
        </div>
      );
    },
    meta: {
      className: "text-right",
    },
  },
];
</file>

<file path="apps/dashboard/src/components/tables/members/index.tsx">
"use client";

import { InviteTeamMembersModal } from "@/components/modals/invite-team-members-modal";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { Dialog } from "@midday/ui/dialog";
import { Input } from "@midday/ui/input";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { useSuspenseQuery } from "@tanstack/react-query";
import {
  type ColumnFiltersState,
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  useReactTable,
} from "@tanstack/react-table";
import * as React from "react";
import { useState } from "react";
import { columns } from "./columns";

export function DataTable() {
  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);
  const trpc = useTRPC();
  const [isOpen, onOpenChange] = useState(false);
  const { data: user } = useUserQuery();
  const { data } = useSuspenseQuery({
    ...trpc.team.members.queryOptions(),
  });

  const table = useReactTable({
    getRowId: (row) => row.id,
    data: data ?? [],
    columns,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    onColumnFiltersChange: setColumnFilters,
    state: {
      columnFilters,
    },
    meta: {
      currentUser: data?.find((member) => member?.user?.id === user?.id),
      totalOwners: data?.filter((member) => member?.role === "owner").length,
    },
  });

  return (
    <div className="w-full">
      <div className="flex items-center pb-4 space-x-4">
        <Input
          className="flex-1"
          placeholder="Search..."
          value={(table.getColumn("user")?.getFilterValue() as string) ?? ""}
          onChange={(event) =>
            table.getColumn("user")?.setFilterValue(event.target.value)
          }
          autoComplete="off"
          autoCapitalize="none"
          autoCorrect="off"
          spellCheck="false"
        />
        <Dialog open={isOpen} onOpenChange={onOpenChange}>
          <Button onClick={() => onOpenChange(true)}>Invite member</Button>
          <InviteTeamMembersModal onOpenChange={onOpenChange} />
        </Dialog>
      </div>
      <Table>
        <TableBody>
          {table.getRowModel().rows?.length ? (
            table.getRowModel().rows.map((row) => (
              <TableRow
                key={row.id}
                data-state={row.getIsSelected() && "selected"}
                className="hover:bg-transparent"
              >
                {row.getAllCells().map((cell) => (
                  <TableCell
                    key={cell.id}
                    className={cn(
                      "border-r-[0px] py-4",
                      cell.column.columnDef.meta?.className,
                    )}
                  >
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </TableCell>
                ))}
              </TableRow>
            ))
          ) : (
            <TableRow className="hover:bg-transparent">
              <TableCell colSpan={columns.length} className="h-24 text-center">
                No results.
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/oauth-applications/columns.tsx">
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Button } from "@midday/ui/button";
import type { ColumnDef } from "@tanstack/react-table";
import * as React from "react";
import "@tanstack/react-table";
import { useOAuthApplicationParams } from "@/hooks/use-oauth-application-params";
import { scopesToName } from "@api/utils/scopes";
import { Badge } from "@midday/ui/badge";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { format } from "date-fns";
import { useCopyToClipboard } from "usehooks-ts";
import { DeleteOAuthApplicationModal } from "../../modals/delete-oauth-application-modal";
import { OAuthApplicationStatusBadge } from "../../oauth-application-status-badge";

type OAuthApplication =
  RouterOutputs["oauthApplications"]["list"]["data"][number];

export const columns: ColumnDef<OAuthApplication>[] = [
  {
    id: "name",
    accessorKey: "name",
    header: "Name",
    cell: ({ row }) => {
      return (
        <div className="flex items-center space-x-2">
          {row.original.logoUrl && (
            <img
              src={row.original.logoUrl}
              alt={row.original.name}
              className="h-6 w-6"
            />
          )}
          <span className="font-medium">{row.original.name}</span>
        </div>
      );
    },
  },
  {
    id: "updatedAt",
    accessorKey: "updatedAt",
    header: "Updated",
    cell: ({ row }) => {
      const updatedAt = row.original.updatedAt;
      if (!updatedAt) return <span className="text-muted-foreground">-</span>;

      return (
        <span className="text-sm text-muted-foreground truncate max-w-[200px]">
          {format(new Date(updatedAt), "MMM d, yyyy")}
        </span>
      );
    },
  },
  {
    id: "clientId",
    accessorKey: "clientId",
    header: "Client ID",
    cell: ({ row }) => {
      const clientId = row.original.clientId;
      const shortId = `${clientId.slice(0, 12)}...`;
      const [, copy] = useCopyToClipboard();
      const [isCopied, setIsCopied] = React.useState(false);

      const handleCopyClientId = (e: React.MouseEvent) => {
        e.stopPropagation();
        copy(clientId);
        setIsCopied(true);
        setTimeout(() => setIsCopied(false), 2000);
      };

      return (
        <TooltipProvider>
          <Tooltip open={isCopied}>
            <TooltipTrigger asChild>
              <button
                type="button"
                onClick={handleCopyClientId}
                className="font-mono text-sm text-muted-foreground hover:text-foreground transition-colors cursor-pointer"
              >
                {shortId}
              </button>
            </TooltipTrigger>
            <TooltipContent className="px-3 py-1.5 text-xs" sideOffset={10}>
              <p>Copied!</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      );
    },
  },
  {
    id: "scopes",
    accessorKey: "scopes",
    header: "Permissions",
    cell: ({ row }) => {
      const scopes = row.original.scopes || [];

      return <Badge variant="tag">{scopesToName(scopes).name}</Badge>;
    },
  },
  {
    id: "status",
    accessorKey: "status",
    header: "Status",
    cell: ({ row }) => {
      return (
        <div className="flex items-center space-x-2">
          <OAuthApplicationStatusBadge status={row.original.status} />
        </div>
      );
    },
  },
  {
    id: "actions",
    cell: ({ row }) => {
      const { setParams } = useOAuthApplicationParams();
      const [showDeleteModal, setShowDeleteModal] = React.useState(false);

      return (
        <div className="flex justify-end">
          <div className="flex space-x-2 items-center">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button size="icon" variant="ghost">
                  <Icons.MoreHoriz className="size-4" />
                </Button>
              </DropdownMenuTrigger>

              <DropdownMenuContent sideOffset={10} align="end">
                <DropdownMenuItem
                  onClick={() =>
                    setParams({
                      applicationId: row.original.id,
                      editApplication: true,
                    })
                  }
                >
                  Edit
                </DropdownMenuItem>
                <DropdownMenuSeparator />

                <DropdownMenuItem
                  className="text-destructive"
                  onClick={() => setShowDeleteModal(true)}
                >
                  Delete
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>

            <DeleteOAuthApplicationModal
              applicationId={row.original.id}
              applicationName={row.original.name}
              isOpen={showDeleteModal}
              onOpenChange={setShowDeleteModal}
            />
          </div>
        </div>
      );
    },
    meta: {
      className: "text-right",
    },
  },
];
</file>

<file path="apps/dashboard/src/components/tables/oauth-applications/empty-state.tsx">
export function EmptyState() {
  return (
    <div className="flex flex-col items-center justify-center h-[300px] border border-border">
      <h3>No OAuth applications found</h3>
      <p className="text-sm text-muted-foreground">
        No OAuth applications have been created for this team yet.
      </p>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/oauth-applications/index.tsx">
"use client";

import { useOAuthApplicationParams } from "@/hooks/use-oauth-application-params";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@midday/ui/table";
import { useSuspenseQuery } from "@tanstack/react-query";
import {
  flexRender,
  getCoreRowModel,
  useReactTable,
} from "@tanstack/react-table";
import * as React from "react";
import { columns } from "./columns";
import { EmptyState } from "./empty-state";

export function OAuthDataTable() {
  const trpc = useTRPC();
  const { setParams } = useOAuthApplicationParams();
  const { data } = useSuspenseQuery({
    ...trpc.oauthApplications.list.queryOptions(),
  });

  const applications = data?.data ?? [];

  const table = useReactTable({
    getRowId: (row) => row.id,
    data: applications,
    columns,
    getCoreRowModel: getCoreRowModel(),
  });

  return (
    <div className="w-full">
      <div className="flex flex-col md:flex-row md:items-center pb-4 gap-4 md:gap-8">
        <div className="flex-1">
          <h3 className="text-lg font-medium leading-none tracking-tight mb-2">
            OAuth Applications
          </h3>
          <p className="text-sm text-[#606060]">
            These OAuth applications allow other apps to access your team data
            on behalf of users. Manage client credentials and permissions
            carefully.
          </p>
        </div>
        <div className="flex-shrink-0">
          <Button onClick={() => setParams({ createApplication: true })}>
            Create OAuth App
          </Button>
        </div>
      </div>
      {applications.length > 0 ? (
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => {
                  return (
                    <TableHead
                      key={header.id}
                      className={header.column.columnDef.meta?.className}
                    >
                      {header.isPlaceholder
                        ? null
                        : flexRender(
                            header.column.columnDef.header,
                            header.getContext(),
                          )}
                    </TableHead>
                  );
                })}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows.map((row) => (
              <TableRow key={row.id} className="hover:bg-transparent">
                {row.getAllCells().map((cell) => (
                  <TableCell
                    key={cell.id}
                    onClick={() => {
                      if (cell.column.id !== "actions") {
                        setParams({
                          applicationId: row.original.id,
                          editApplication: true,
                        });
                      }
                    }}
                    className={cn(
                      "border-r-[0px] py-4 cursor-pointer",
                      cell.column.columnDef.meta?.className,
                    )}
                  >
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </TableCell>
                ))}
              </TableRow>
            ))}
          </TableBody>
        </Table>
      ) : (
        <EmptyState />
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/orders/actions-menu.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Button } from "@midday/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { useToast } from "@midday/ui/use-toast";
import { DotsHorizontalIcon } from "@radix-ui/react-icons";
import { useMutation, useQuery } from "@tanstack/react-query";
import { useCallback, useEffect, useState } from "react";

type Props = {
  order: RouterOutputs["billing"]["orders"]["data"][number];
};

export function ActionsMenu({ order }: Props) {
  const { toast } = useToast();
  const trpc = useTRPC();
  const [isDownloading, setIsDownloading] = useState(false);
  const [currentToast, setCurrentToast] = useState<{
    id: string;
    dismiss: () => void;
    update: (props: any) => void;
  } | null>(null);
  const [shouldPoll, setShouldPoll] = useState(false);
  const [progress, setProgress] = useState(0);
  const [pollCount, setPollCount] = useState(0);

  // Use React Query for polling invoice status
  const { data: invoiceStatus, error: invoiceError } = useQuery({
    ...trpc.billing.checkInvoiceStatus.queryOptions(order.id),
    enabled: shouldPoll,
    refetchInterval: shouldPoll ? 2000 : false, // Poll every 2 seconds when enabled
    refetchIntervalInBackground: false,
  });

  // Handle invoice status changes
  useEffect(() => {
    if (!shouldPoll || !invoiceStatus) return;

    if (invoiceStatus.status === "ready" && invoiceStatus.downloadUrl) {
      // Stop polling
      setShouldPoll(false);

      // Dismiss the generating toast
      if (currentToast) {
        currentToast.dismiss();
      }

      // Download the file
      const link = document.createElement("a");
      link.href = invoiceStatus.downloadUrl;
      link.download = `invoice-${order.id}.pdf`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      setIsDownloading(false);
      setCurrentToast(null);
      setProgress(0);
      setPollCount(0);
    } else if (invoiceStatus.status === "generating" && currentToast) {
      // Increment poll count for progress simulation
      setPollCount((prev) => prev + 1);

      // Simulate progress - gradually increase from 10% to 90% over time
      const newProgress = Math.min(90, 10 + pollCount * 8);
      setProgress(newProgress);

      // Update existing toast with current status and progress
      currentToast.update({
        title: "Generating invoice...",
        description: `Processing your invoice (${Math.round(newProgress)}% complete)`,
        duration: Number.POSITIVE_INFINITY,
        variant: "progress",
        progress: newProgress,
      });
    }
  }, [invoiceStatus, shouldPoll, order.id, toast, pollCount]);

  // Handle invoice status errors
  useEffect(() => {
    if (invoiceError && shouldPoll) {
      setShouldPoll(false);

      // Update existing toast with error
      if (currentToast) {
        currentToast.update({
          title: "Generation failed",
          description: "Unable to generate invoice. Please try again later.",
          variant: "error",
          duration: 5000,
        });
      }

      setIsDownloading(false);
      setCurrentToast(null);
      setProgress(0);
      setPollCount(0);
    }
  }, [invoiceError, shouldPoll, currentToast]);

  // Stop polling after 2 minutes
  useEffect(() => {
    if (shouldPoll) {
      const timeout = setTimeout(() => {
        setShouldPoll(false);
        if (currentToast) {
          currentToast.update({
            title: "Generation timeout",
            description:
              "Invoice generation is taking longer than expected. Please try again later.",
            variant: "error",
            duration: 5000,
          });
          setIsDownloading(false);
          setCurrentToast(null);
          setProgress(0);
          setPollCount(0);
        }
      }, 120000); // 2 minutes

      return () => clearTimeout(timeout);
    }
  }, [shouldPoll, currentToast]);

  const downloadInvoiceMutation = useMutation(
    trpc.billing.getInvoice.mutationOptions({
      onSuccess: (result) => {
        if (result.status === "ready" && result.downloadUrl) {
          // Download immediately if ready
          const link = document.createElement("a");
          link.href = result.downloadUrl;
          link.download = `invoice-${order.id}.pdf`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          setIsDownloading(false);
        } else if (result.status === "generating") {
          // Start polling for status
          setProgress(10); // Start with 10% progress
          setPollCount(0);

          const toastInstance = toast({
            title: "Generating invoice...",
            description: "This may take a few moments",
            duration: Number.POSITIVE_INFINITY,
            variant: "progress",
            progress: 10,
          });

          setCurrentToast(toastInstance);
          setShouldPoll(true);
        }
      },
      onError: (error) => {
        toast({
          title: "Download failed",
          description: "Unable to download invoice. Please try again later.",
          variant: "error",
        });
        setIsDownloading(false);
        setCurrentToast(null);
        setProgress(0);
        setPollCount(0);
      },
    }),
  );

  const handleDownload = useCallback(() => {
    setIsDownloading(true);
    downloadInvoiceMutation.mutate(order.id);
  }, [downloadInvoiceMutation, order.id]);

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" className="h-8 w-8 p-0">
          <DotsHorizontalIcon className="h-4 w-4" />
        </Button>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={handleDownload} disabled={isDownloading}>
          {isDownloading ? "Preparing..." : "Download Invoice"}
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/orders/data-table.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { formatDate } from "@/utils/format";
import { Button } from "@midday/ui/button";
import { Spinner } from "@midday/ui/spinner";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { useSuspenseInfiniteQuery } from "@tanstack/react-query";
import { useMemo } from "react";
import { FormatAmount } from "../../format-amount";
import { OrderStatus } from "../../order-status";
import { ActionsMenu } from "./actions-menu";
import { OrdersTableHeader } from "./table-header";

export function OrdersDataTable() {
  const trpc = useTRPC();

  const infiniteQueryOptions = trpc.billing.orders.infiniteQueryOptions(
    {
      pageSize: 15,
    },
    {
      getNextPageParam: ({ meta }) => meta?.cursor,
    },
  );

  const { data, fetchNextPage, hasNextPage, isFetching } =
    useSuspenseInfiniteQuery(infiniteQueryOptions);

  const tableData = useMemo(() => {
    return data?.pages.flatMap((page) => page?.data ?? []) ?? [];
  }, [data]);

  return (
    <div className="w-full">
      <Table>
        <OrdersTableHeader />
        <TableBody>
          {tableData.length === 0 ? (
            <TableRow>
              <TableCell colSpan={5} className="h-32 text-center">
                <p className="text-muted-foreground">No orders found</p>
              </TableCell>
            </TableRow>
          ) : (
            tableData.map((order) => (
              <TableRow key={order.id} className="h-[45px]">
                <TableCell className="w-[120px] text-sm text-muted-foreground">
                  {formatDate(
                    order.createdAt.toISOString(),
                    "MMM, yyyy",
                    false,
                  )}
                </TableCell>
                <TableCell className="w-[100px] font-medium">
                  <FormatAmount
                    amount={order.amount.amount / 100}
                    currency={order.amount.currency}
                  />
                </TableCell>
                <TableCell className="w-[120px]">
                  <OrderStatus status={order.status} />
                </TableCell>
                <TableCell className="w-[140px] text-sm">
                  {order.product?.name || "N/A"}
                </TableCell>
                <TableCell className="w-[100px] text-right">
                  <ActionsMenu order={order} />
                </TableCell>
              </TableRow>
            ))
          )}
        </TableBody>
      </Table>

      {hasNextPage && (
        <div className="flex items-center justify-center mt-6">
          <Button
            onClick={() => fetchNextPage()}
            variant="outline"
            className="w-full"
          >
            {isFetching ? <Spinner /> : "Load more"}
          </Button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/orders/index.tsx">
export { OrdersDataTable } from "./data-table";
export { OrdersSkeleton } from "./skeleton";
export { OrdersTableHeader } from "./table-header";
</file>

<file path="apps/dashboard/src/components/tables/orders/skeleton.tsx">
import { Skeleton } from "@midday/ui/skeleton";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { DotsHorizontalIcon } from "@radix-ui/react-icons";
import { OrdersTableHeader } from "./table-header";

export function OrdersSkeleton() {
  return (
    <div className="w-full">
      <Table>
        <OrdersTableHeader />
        <TableBody>
          {Array.from({ length: 10 }).map((_, index) => (
            <TableRow key={index.toString()} className="h-[45px]">
              <TableCell className="w-[120px] text-sm text-muted-foreground">
                <Skeleton className="h-4 w-16" />
              </TableCell>
              <TableCell className="w-[100px] font-medium">
                <Skeleton className="h-4 w-14" />
              </TableCell>
              <TableCell className="w-[120px]">
                <Skeleton className="h-4 w-16" />
              </TableCell>
              <TableCell className="w-[140px] text-sm">
                <Skeleton className="h-4 w-20" />
              </TableCell>
              <TableCell className="w-[100px] text-right" />
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/orders/table-header.tsx">
import { TableHead, TableHeader, TableRow } from "@midday/ui/table";

export function OrdersTableHeader() {
  return (
    <TableHeader>
      <TableRow>
        <TableHead className="w-[120px]">Date</TableHead>
        <TableHead className="w-[100px]">Amount</TableHead>
        <TableHead className="w-[120px]">Status</TableHead>
        <TableHead className="w-[140px]">Product</TableHead>
        <TableHead className="w-[100px] text-right">Actions</TableHead>
      </TableRow>
    </TableHeader>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/pending-invites/columns.tsx">
import { useI18n } from "@/locales/client";
import { useTRPC } from "@/trpc/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Avatar, AvatarFallback } from "@midday/ui/avatar";
import { Button } from "@midday/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { ColumnDef, FilterFn, Row } from "@tanstack/react-table";
import { MoreHorizontal } from "lucide-react";

type TeamInvite = RouterOutputs["team"]["teamInvites"][number];

const emailFilterFn: FilterFn<TeamInvite> = (
  row: Row<TeamInvite>,
  _: string,
  filterValue: string,
) => {
  const email = row.original.email?.toLowerCase();
  return email?.includes(filterValue.toLowerCase()) ?? false;
};

export const columns: ColumnDef<TeamInvite>[] = [
  {
    id: "email",
    accessorKey: "email",
    filterFn: emailFilterFn,
    cell: ({ row }) => {
      return (
        <div className="flex items-center space-x-4">
          <Avatar className="rounded-full w-8 h-8">
            <AvatarFallback>
              <span className="text-xs">
                {row.original.email?.slice(0, 1)?.toUpperCase() ?? "P"}
              </span>
            </AvatarFallback>
          </Avatar>
          <div className="flex flex-col">
            <span className="font-medium text-sm">Pending Invitation</span>
            <span className="text-sm text-[#606060]">{row.original.email}</span>
          </div>
        </div>
      );
    },
  },
  {
    id: "actions",
    cell: ({ row }) => {
      const t = useI18n();
      const trpc = useTRPC();
      const queryClient = useQueryClient();

      const deleteInvite = useMutation(
        trpc.team.deleteInvite.mutationOptions({
          onSuccess: () => {
            queryClient.invalidateQueries({
              queryKey: trpc.team.teamInvites.queryKey(),
            });
          },
        }),
      );

      return (
        <div className="flex justify-end">
          <div className="flex space-x-2 items-center">
            <span className="text-[#606060]">
              {t(`roles.${row.original.role || "member"}`)}
            </span>

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" className="h-8 w-8 p-0">
                  <span className="sr-only">Open menu</span>
                  <MoreHorizontal className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem
                  className="text-destructive"
                  onClick={() =>
                    deleteInvite.mutate({
                      id: row.original.id,
                    })
                  }
                >
                  Remove
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      );
    },
    meta: {
      className: "text-right",
    },
  },
];
</file>

<file path="apps/dashboard/src/components/tables/pending-invites/index.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { cn } from "@midday/ui/cn";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { useSuspenseQuery } from "@tanstack/react-query";
import {
  type ColumnFiltersState,
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  useReactTable,
} from "@tanstack/react-table";
import { useState } from "react";
import { columns } from "./columns";
import { DataTableHeader } from "./table-header";

export function DataTable() {
  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);

  const trpc = useTRPC();
  const { data } = useSuspenseQuery({
    ...trpc.team.teamInvites.queryOptions(),
  });

  const table = useReactTable({
    getRowId: (row) => row.id,
    data,
    columns,
    state: {
      columnFilters,
    },
    onColumnFiltersChange: setColumnFilters,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
  });

  return (
    <div className="w-full">
      <DataTableHeader table={table} />

      <Table>
        <TableBody>
          {table.getRowModel().rows?.length ? (
            table.getRowModel().rows.map((row) => (
              <TableRow
                key={row.id}
                data-state={row.getIsSelected() && "selected"}
                className="hover:bg-transparent"
              >
                {row.getAllCells().map((cell) => (
                  <TableCell
                    key={cell.id}
                    className={cn(
                      "border-r-[0px] py-4",
                      cell.column.columnDef.meta?.className,
                    )}
                  >
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </TableCell>
                ))}
              </TableRow>
            ))
          ) : (
            <TableRow className="hover:bg-transparent">
              <TableCell
                colSpan={columns.length}
                className="h-[360px] text-center"
              >
                <h2 className="font-medium mb-1">
                  No Pending Invitations Found
                </h2>
                <span className="text-[#606060]">
                  Use the button above to invite a Team Member.
                </span>
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/pending-invites/skeleton.tsx">
import { Skeleton } from "@midday/ui/skeleton";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { DataTableHeader } from "./table-header";

export function PendingInvitesSkeleton() {
  return (
    <div className="w-full">
      <DataTableHeader />

      <Table>
        <TableBody>
          {[...Array(6)].map((_, index) => (
            <TableRow key={index.toString()} className="hover:bg-transparent">
              <TableCell className="border-r-[0px] py-4">
                <div className="flex items-center space-x-4">
                  <Skeleton className="rounded-full w-8 h-8" />

                  <div className="flex flex-col space-y-2">
                    <Skeleton className="w-[200px] h-3" />
                    <Skeleton className="w-[150px] h-2" />
                  </div>
                </div>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/pending-invites/table-header.tsx">
"use client";

import { InviteTeamMembersModal } from "@/components/modals/invite-team-members-modal";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Button } from "@midday/ui/button";
import { Dialog } from "@midday/ui/dialog";
import { Input } from "@midday/ui/input";
import type { Table } from "@tanstack/react-table";
import { useState } from "react";

type Props = {
  table?: Table<RouterOutputs["team"]["teamInvites"][number]>;
};

export function DataTableHeader({ table }: Props) {
  const [isOpen, onOpenChange] = useState(false);

  return (
    <div className="flex items-center pb-4 space-x-4">
      <Input
        className="flex-1"
        placeholder="Search..."
        value={(table?.getColumn("email")?.getFilterValue() as string) ?? ""}
        onChange={(event) =>
          table?.getColumn("email")?.setFilterValue(event.target.value)
        }
        autoComplete="off"
        autoCapitalize="none"
        autoCorrect="off"
        spellCheck="false"
      />
      <Dialog open={isOpen} onOpenChange={onOpenChange}>
        <Button onClick={() => onOpenChange(true)}>Invite member</Button>
        <InviteTeamMembersModal onOpenChange={onOpenChange} />
      </Dialog>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/select-team/table-row.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { SubmitButton } from "@midday/ui/submit-button";
import { TableRow as BaseTableRow, TableCell } from "@midday/ui/table";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useRouter } from "next/navigation";
import { useState } from "react";

type Props = {
  row: RouterOutputs["team"]["list"][number];
};

export function TableRow({ row }: Props) {
  const queryClient = useQueryClient();
  const [isLoading, setIsLoading] = useState(false);
  const trpc = useTRPC();
  const router = useRouter();

  const changeTeamMutation = useMutation(
    trpc.user.update.mutationOptions({
      onMutate: () => {
        setIsLoading(true);
      },
      onSuccess: async () => {
        await queryClient.invalidateQueries();
        router.push("/teams");
      },
      onError: () => {
        setIsLoading(false);
      },
    }),
  );

  return (
    <BaseTableRow key={row.id} className="hover:bg-transparent">
      <TableCell className="border-r-[0px] py-4 px-0">
        <div className="flex items-center space-x-4">
          <Avatar className="size-8 rounded-none">
            {row.logoUrl && (
              <AvatarImageNext
                src={row.logoUrl}
                alt={row.name ?? ""}
                width={32}
                height={32}
              />
            )}
            <AvatarFallback className="rounded-none">
              <span className="text-xs">
                {row?.name?.charAt(0)?.toUpperCase()}
              </span>
            </AvatarFallback>
          </Avatar>
          <div className="flex flex-col">
            <span className="font-medium text-sm">{row?.name}</span>
          </div>
        </div>
      </TableCell>
      <TableCell className="px-0">
        <div className="flex justify-end">
          <div className="flex space-x-3 items-center">
            <SubmitButton
              isSubmitting={isLoading}
              variant="outline"
              onClick={() => {
                changeTeamMutation.mutate({
                  teamId: row.id!,
                });
              }}
            >
              Launch
            </SubmitButton>
          </div>
        </div>
      </TableCell>
    </BaseTableRow>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/select-team/table.tsx">
"use client";

import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Table, TableBody } from "@midday/ui/table";
import { TableRow } from "./table-row";

type Props = {
  data: RouterOutputs["team"]["list"];
};

export function SelectTeamTable({ data }: Props) {
  return (
    <Table>
      <TableBody className="border-none">
        {data.map((row) => (
          <TableRow key={row.id} row={row} />
        ))}
      </TableBody>
    </Table>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/teams/columns.tsx">
import { useI18n } from "@/locales/client";
import { useTRPC } from "@/trpc/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@midday/ui/alert-dialog";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { Button } from "@midday/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { SubmitButton } from "@midday/ui/submit-button";
import { toast } from "@midday/ui/use-toast";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { ColumnDef, FilterFn, Row } from "@tanstack/react-table";
import { MoreHorizontal } from "lucide-react";
import { Loader2 } from "lucide-react";
import { useRouter } from "next/navigation";

const teamNameFilterFn: FilterFn<RouterOutputs["team"]["list"][number]> = (
  row: Row<RouterOutputs["team"]["list"][number]>,
  _: string,
  filterValue: string,
) => {
  const teamName = row.original.name?.toLowerCase();

  return teamName?.includes(filterValue.toLowerCase()) ?? false;
};

export const columns: ColumnDef<RouterOutputs["team"]["list"][number]>[] = [
  {
    id: "team",
    accessorKey: "team.name",
    filterFn: teamNameFilterFn,
    cell: ({ row }) => {
      const t = useI18n();

      return (
        <div className="flex items-center space-x-4">
          <Avatar className="rounded-full w-8 h-8">
            <AvatarImageNext
              src={row.original.logoUrl ?? ""}
              alt={row.original.name ?? ""}
              width={32}
              height={32}
            />
            <AvatarFallback>
              <span className="text-xs">
                {row.original.name?.charAt(0)?.toUpperCase()}
              </span>
            </AvatarFallback>
          </Avatar>
          <div className="flex flex-col">
            <span className="font-medium text-sm">{row.original.name}</span>
            <span className="text-sm text-[#606060]">
              {/* @ts-expect-error */}
              {t(`roles.${row.original.role}`)}
            </span>
          </div>
        </div>
      );
    },
  },
  {
    id: "actions",
    cell: ({ row }) => {
      const trpc = useTRPC();
      const queryClient = useQueryClient();
      const router = useRouter();

      const viewTeamMutation = useMutation(
        trpc.user.update.mutationOptions({
          onSuccess: () => {
            queryClient.invalidateQueries();
          },
        }),
      );

      const manageTeamMutation = useMutation(
        trpc.user.update.mutationOptions({
          onSuccess: () => {
            queryClient.invalidateQueries();
          },
        }),
      );

      const leaveTeamMutation = useMutation(
        trpc.team.leave.mutationOptions({
          onSuccess: async () => {
            router.push("/teams");
          },
          onError: () => {
            toast({
              duration: 6000,
              variant: "error",
              title:
                "You cannot leave since you are the only remaining owner of the team. Delete this team instead.",
            });
          },
        }),
      );

      return (
        <div className="flex justify-end">
          <div className="flex space-x-3 items-center">
            <SubmitButton
              variant="outline"
              isSubmitting={viewTeamMutation.isPending}
              onClick={() =>
                viewTeamMutation.mutate(
                  {
                    teamId: row.original.id!,
                  },
                  {
                    onSuccess: () => {
                      router.push("/");
                    },
                  },
                )
              }
            >
              View
            </SubmitButton>
            {row.original.role === "owner" && (
              <SubmitButton
                variant="outline"
                isSubmitting={manageTeamMutation.isPending}
                onClick={() =>
                  manageTeamMutation.mutate(
                    {
                      teamId: row.original.id!,
                    },
                    {
                      onSuccess: () => {
                        router.push("/settings");
                      },
                    },
                  )
                }
              >
                Manage
              </SubmitButton>
            )}

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" className="h-8 w-8 p-0">
                  <MoreHorizontal className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <AlertDialog>
                  <DropdownMenuItem
                    className="text-destructive"
                    asDialogTrigger
                  >
                    <AlertDialogTrigger>Leave Team</AlertDialogTrigger>
                  </DropdownMenuItem>

                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Leave Team</AlertDialogTitle>
                      <AlertDialogDescription>
                        You are about to leave this team. In order to regain
                        access at a later time, a Team Owner must invite you.
                        <p className="mt-4">
                          Are you sure you want to continue?
                        </p>
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel>Cancel</AlertDialogCancel>
                      <AlertDialogAction
                        disabled={leaveTeamMutation.isPending}
                        onClick={() =>
                          leaveTeamMutation.mutate({
                            teamId: row.original.id!,
                          })
                        }
                      >
                        {leaveTeamMutation.isPending ? (
                          <Loader2 className="h-4 w-4 animate-spin" />
                        ) : (
                          "Confirm"
                        )}
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      );
    },
    meta: {
      className: "text-right",
    },
  },
];
</file>

<file path="apps/dashboard/src/components/tables/teams/index.tsx">
import { Invites } from "./invites";
import { DataTable } from "./table";

export function TeamsTable() {
  return (
    <div className="flex flex-col gap-4">
      <DataTable />
      <Invites />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/teams/invites.tsx">
"use client";

import { useI18n } from "@/locales/client";
import { useTRPC } from "@/trpc/client";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { SubmitButton } from "@midday/ui/submit-button";
import {
  useMutation,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";

export function Invites() {
  const t = useI18n();
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { data: invites } = useSuspenseQuery(trpc.user.invites.queryOptions());

  const declineInviteMutation = useMutation(
    trpc.team.declineInvite.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.user.invites.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.team.list.queryKey(),
        });
      },
    }),
  );

  const acceptInviteMutation = useMutation(
    trpc.team.acceptInvite.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.user.invites.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.team.list.queryKey(),
        });
      },
    }),
  );

  if (!invites?.length) {
    return null;
  }

  return (
    <div className="border divide-y">
      {invites?.map((invite) => (
        <div key={invite.id} className="px-4 align-middle py-4">
          <div className="flex items-center space-x-4 justify-between">
            <div className="flex items-center space-x-4">
              <div className="flex items-center space-x-4">
                <Avatar className="rounded-full w-8 h-8">
                  <AvatarImageNext
                    src={invite.team?.logoUrl ?? ""}
                    alt={invite.team?.name ?? ""}
                    width={32}
                    height={32}
                  />
                  <AvatarFallback>
                    <span className="text-xs">
                      {invite.team?.name?.charAt(0)?.toUpperCase()}
                    </span>
                  </AvatarFallback>
                </Avatar>
                <div className="flex flex-col">
                  <span className="font-medium text-sm">
                    {invite.team?.name}
                  </span>
                  <span className="text-sm text-[#606060]">
                    {/* @ts-expect-error */}
                    {t(`roles.${invite.role}`)}
                  </span>
                </div>
              </div>
            </div>
            <div className="flex justify-end">
              <div className="flex space-x-3 items-center">
                <SubmitButton
                  variant="outline"
                  onClick={() => {
                    declineInviteMutation.mutate({
                      id: invite.id,
                    });
                  }}
                  isSubmitting={declineInviteMutation.isPending}
                >
                  Decline
                </SubmitButton>
                <SubmitButton
                  variant="outline"
                  onClick={() => {
                    acceptInviteMutation.mutate({
                      id: invite.id,
                    });
                  }}
                  isSubmitting={acceptInviteMutation.isPending}
                >
                  Accept
                </SubmitButton>
              </div>
            </div>
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/teams/skeleton.tsx">
import { cn } from "@midday/ui/cn";
import { Skeleton } from "@midday/ui/skeleton";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { DataTableHeader } from "./table-header";

export function TeamsSkeleton() {
  return (
    <div className="w-full">
      <DataTableHeader />

      <Table>
        <TableBody>
          {[...Array(6)].map((_, index) => (
            <TableRow key={index.toString()} className="hover:bg-transparent">
              <TableCell className={cn("border-r-[0px] py-4")}>
                <div className="flex items-center space-x-4">
                  <Skeleton className="rounded-full w-8 h-8" />

                  <div className="flex flex-col space-y-2">
                    <Skeleton className="w-[200px] h-3" />
                    <Skeleton className="w-[150px] h-2" />
                  </div>
                </div>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/teams/table-header.tsx">
"use client";

import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Button } from "@midday/ui/button";
import { Input } from "@midday/ui/input";
import type { Table } from "@tanstack/react-table";
import Link from "next/link";

type Props = {
  table?: Table<RouterOutputs["team"]["list"][number]>;
};

export function DataTableHeader({ table }: Props) {
  return (
    <div className="flex items-center pb-4 space-x-4">
      <Input
        className="flex-1"
        placeholder="Search..."
        value={(table?.getColumn("team")?.getFilterValue() as string) ?? ""}
        onChange={(event) =>
          table?.getColumn("team")?.setFilterValue(event.target.value)
        }
        autoComplete="off"
        autoCapitalize="none"
        autoCorrect="off"
        spellCheck="false"
      />
      <Link href="/teams/create">
        <Button>Create team</Button>
      </Link>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/teams/table.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { cn } from "@midday/ui/cn";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { useSuspenseQuery } from "@tanstack/react-query";
import type { ColumnFiltersState } from "@tanstack/react-table";
import {
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  useReactTable,
} from "@tanstack/react-table";
import * as React from "react";
import { useState } from "react";
import { columns } from "./columns";
import { DataTableHeader } from "./table-header";

export function DataTable() {
  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);
  const trpc = useTRPC();
  const { data } = useSuspenseQuery(trpc.team.list.queryOptions());

  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    onColumnFiltersChange: setColumnFilters,
    state: {
      columnFilters,
    },
  });

  return (
    <div className="w-full">
      <DataTableHeader table={table} />
      <Table>
        <TableBody>
          {table.getRowModel().rows?.length ? (
            table.getRowModel().rows.map((row) => (
              <TableRow
                key={row.id}
                data-state={row.getIsSelected() && "selected"}
                className="hover:bg-transparent"
              >
                {row.getAllCells().map((cell) => (
                  <TableCell
                    key={cell.id}
                    className={cn(
                      "border-r-[0px] py-4",
                      cell.column.columnDef.meta?.className,
                    )}
                  >
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </TableCell>
                ))}
              </TableRow>
            ))
          ) : (
            <TableRow className="hover:bg-transparent">
              <TableCell colSpan={columns.length} className="h-24 text-center">
                No results.
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/tracker/data-table-header.tsx">
"use client";

import { HorizontalPagination } from "@/components/horizontal-pagination";
import { useSortParams } from "@/hooks/use-sort-params";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { TableHead, TableHeader, TableRow } from "@midday/ui/table";
import { ArrowDown, ArrowUp } from "lucide-react";

interface Props {
  tableScroll?: {
    canScrollLeft: boolean;
    canScrollRight: boolean;
    isScrollable: boolean;
    scrollLeft: () => void;
    scrollRight: () => void;
  };
}

export function DataTableHeader({ tableScroll }: Props) {
  const { params, setParams } = useSortParams();

  const [column, value] = params.sort || [];

  const createSortQuery = (name: string) => {
    const [currentColumn, currentValue] = params.sort || [];

    if (name === currentColumn) {
      if (currentValue === "asc") {
        setParams({ sort: [name, "desc"] });
      } else if (currentValue === "desc") {
        setParams({ sort: null });
      } else {
        setParams({ sort: [name, "asc"] });
      }
    } else {
      setParams({ sort: [name, "asc"] });
    }
  };

  return (
    <TableHeader className="border-l-0 border-r-0">
      <TableRow className="h-[45px]">
        <TableHead className="w-[420px] min-w-[420px] md:sticky md:left-0 bg-background z-20 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background after:z-[-1]">
          <div className="flex items-center justify-between">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("name")}
            >
              <span>Project</span>
              {"name" === column && value === "asc" && <ArrowDown size={16} />}
              {"name" === column && value === "desc" && <ArrowUp size={16} />}
            </Button>
            {tableScroll?.isScrollable && (
              <HorizontalPagination
                canScrollLeft={tableScroll.canScrollLeft}
                canScrollRight={tableScroll.canScrollRight}
                onScrollLeft={tableScroll.scrollLeft}
                onScrollRight={tableScroll.scrollRight}
                className="ml-auto hidden md:flex"
              />
            )}
          </div>
        </TableHead>
        <TableHead className="w-[180px]">
          <Button
            className="p-0 hover:bg-transparent space-x-2"
            variant="ghost"
            onClick={() => createSortQuery("customer")}
          >
            <span>Customer</span>
            {"customer" === column && value === "asc" && (
              <ArrowDown size={16} />
            )}
            {"customer" === column && value === "desc" && <ArrowUp size={16} />}
          </Button>
        </TableHead>

        <TableHead className="w-[180px] min-w-[180px]">
          <Button
            className="p-0 hover:bg-transparent space-x-2"
            variant="ghost"
            onClick={() => createSortQuery("time")}
          >
            <span>Total Time</span>
            {"time" === column && value === "asc" && <ArrowDown size={16} />}
            {"time" === column && value === "desc" && <ArrowUp size={16} />}
          </Button>
        </TableHead>
        <TableHead className="w-[190px] min-w-[190px]">
          <Button
            className="p-0 hover:bg-transparent space-x-2"
            variant="ghost"
            onClick={() => createSortQuery("amount")}
          >
            <span>Total Amount</span>
            {"amount" === column && value === "asc" && <ArrowDown size={16} />}
            {"amount" === column && value === "desc" && <ArrowUp size={16} />}
          </Button>
        </TableHead>
        <TableHead className="w-[200px] min-w-[200px]">
          <Button
            className="p-0 hover:bg-transparent space-x-2"
            variant="ghost"
            onClick={() => createSortQuery("description")}
          >
            <span className="line-clamp-1 text-ellipsis">Description</span>
            {"description" === column && value === "asc" && (
              <ArrowDown size={16} />
            )}
            {"description" === column && value === "desc" && (
              <ArrowUp size={16} />
            )}
          </Button>
        </TableHead>

        <TableHead className="min-w-[170px]">
          <Button
            className="p-0 hover:bg-transparent space-x-2"
            variant="ghost"
            onClick={() => createSortQuery("tags")}
          >
            <span>Tags</span>
            {"tags" === column && value === "asc" && <ArrowDown size={16} />}
            {"tags" === column && value === "desc" && <ArrowUp size={16} />}
          </Button>
        </TableHead>

        <TableHead className="w-[140px]">
          <Button
            className="p-0 hover:bg-transparent space-x-2"
            variant="ghost"
            onClick={() => createSortQuery("assigned")}
          >
            <span>Assigned</span>
            {"assigned" === column && value === "asc" && (
              <ArrowDown size={16} />
            )}
            {"assigned" === column && value === "desc" && <ArrowUp size={16} />}
          </Button>
        </TableHead>
        <TableHead className="w-[150px] min-w-[150px]">
          <Button
            className="p-0 hover:bg-transparent space-x-2"
            variant="ghost"
            onClick={() => createSortQuery("status")}
          >
            <span>Status</span>
            {"status" === column && value === "asc" && <ArrowDown size={16} />}
            {"status" === column && value === "desc" && <ArrowUp size={16} />}
          </Button>
        </TableHead>
        <TableHead
          className={cn(
            "w-[100px] md:sticky md:right-0 bg-background z-30",
            "before:absolute before:left-0 before:top-0 before:bottom-0 before:w-px before:bg-border",
            "after:absolute after:left-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-r after:from-transparent after:to-background after:z-[-1]",
          )}
        >
          Actions
        </TableHead>
      </TableRow>
    </TableHeader>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/tracker/data-table-row.tsx">
"use client";

import { TrackerCreateInvoice } from "@/components/tracker-create-invoice";
import { TrackerExportCSV } from "@/components/tracker-export-csv";
import { TrackerStatus } from "@/components/tracker-status";
import { TrackerTimer } from "@/components/tracker-timer";
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { useUserQuery } from "@/hooks/use-user";
import { formatAmount, secondsToHoursAndMinutes } from "@/utils/format";
import { getWebsiteLogo } from "@/utils/logos";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@midday/ui/alert-dialog";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { Badge } from "@midday/ui/badge";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { ScrollArea, ScrollBar } from "@midday/ui/scroll-area";
import { TableCell, TableRow } from "@midday/ui/table";
import Link from "next/link";

type DataTableCellProps = {
  children: React.ReactNode;
  className?: string;
  onClick?: () => void;
};

export function DataTableCell({
  children,
  className,
  onClick,
}: DataTableCellProps) {
  return (
    <TableCell className={className} onClick={onClick}>
      {children}
    </TableCell>
  );
}

type RowProps = {
  children: React.ReactNode;
};

export function Row({ children }: RowProps) {
  return (
    <TableRow className="group h-[45px] hover:bg-[#F2F1EF] hover:dark:bg-secondary">
      {children}
    </TableRow>
  );
}

type DataTableRowProps = {
  row: RouterOutputs["trackerProjects"]["get"]["data"][number];
  onDelete: ({ id }: { id: string }) => void;
};

export function DataTableRow({ row, onDelete }: DataTableRowProps) {
  const { setParams } = useTrackerParams();
  const { data: user } = useUserQuery();

  const onClick = () => {
    setParams({
      projectId: row.id,
      update: true,
    });
  };

  return (
    <AlertDialog>
      <DropdownMenu>
        <Row>
          <DataTableCell className="w-[420px] min-w-[420px] md:sticky md:left-0 bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-20 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]">
            <TrackerTimer
              projectId={row.id}
              projectName={row.name}
              onClick={onClick}
            />
          </DataTableCell>
          <DataTableCell onClick={onClick} className="cursor-pointer">
            {row.customer ? (
              <div className="flex items-center space-x-2">
                <Avatar className="size-5">
                  {row.customer?.website && (
                    <AvatarImageNext
                      src={getWebsiteLogo(row.customer?.website)}
                      alt={`${row.customer?.name} logo`}
                      width={20}
                      height={20}
                      quality={100}
                    />
                  )}
                  <AvatarFallback className="text-[9px] font-medium">
                    {row.customer?.name?.[0]}
                  </AvatarFallback>
                </Avatar>
                <span className="truncate">{row.customer?.name}</span>
              </div>
            ) : (
              "-"
            )}
          </DataTableCell>

          <DataTableCell onClick={onClick} className="cursor-pointer">
            <span className="text-sm">
              {row.estimate
                ? `${secondsToHoursAndMinutes(row.totalDuration ?? 0)} / ${secondsToHoursAndMinutes(row.estimate * 3600)}`
                : secondsToHoursAndMinutes(row.totalDuration ?? 0)}
            </span>
          </DataTableCell>
          <DataTableCell onClick={onClick} className="cursor-pointer">
            {row.currency ? (
              <span className="text-sm">
                {formatAmount({
                  currency: row.currency,
                  amount: row.totalAmount ?? 0,
                  minimumFractionDigits: 0,
                  maximumFractionDigits: 0,
                  locale: user?.locale,
                })}
              </span>
            ) : (
              "-"
            )}
          </DataTableCell>
          <DataTableCell onClick={onClick} className="cursor-pointer">
            {row.description}
          </DataTableCell>
          <DataTableCell>
            <div className="relative">
              <ScrollArea className="w-[170px] whitespace-nowrap">
                <div className="flex items-center space-x-2">
                  {row.tags?.map((tag) => (
                    <Link href={`/transactions?tags=${tag.id}`} key={tag.id}>
                      <Badge
                        variant="tag-rounded"
                        className="whitespace-nowrap"
                      >
                        {tag.name}
                      </Badge>
                    </Link>
                  ))}
                </div>

                <ScrollBar orientation="horizontal" />
              </ScrollArea>

              <div className="absolute group-hover:hidden right-0 top-0 bottom-0 w-8 bg-gradient-to-l from-background to-transparent pointer-events-none z-10" />
            </div>
          </DataTableCell>
          <DataTableCell onClick={onClick} className="cursor-pointer">
            <div className="flex items-center space-x-2">
              {row.users?.map((user) => (
                <Avatar key={user.id} className="size-4">
                  <AvatarImageNext
                    src={user.avatarUrl}
                    alt={user.fullName ?? ""}
                    width={20}
                    height={20}
                  />
                  <AvatarFallback className="text-[10px]">
                    {user.fullName?.slice(0, 1)?.toUpperCase()}
                  </AvatarFallback>
                </Avatar>
              ))}
            </div>
          </DataTableCell>
          <DataTableCell onClick={onClick} className="cursor-pointer">
            <TrackerStatus status={row.status} />
          </DataTableCell>
          <DataTableCell className="md:sticky md:right-0 bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-30 before:absolute before:left-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:left-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-r after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]">
            <div className="flex justify-center">
              <DropdownMenuTrigger>
                <Icons.MoreHoriz />
              </DropdownMenuTrigger>
            </div>
          </DataTableCell>
        </Row>

        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete this
              project.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={() => onDelete({ id: row.id })}>
              Continue
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>

        <DropdownMenuContent className="w-42" sideOffset={10} align="end">
          <DropdownMenuItem
            onClick={() => setParams({ update: true, projectId: row.id })}
          >
            Edit
          </DropdownMenuItem>

          <TrackerCreateInvoice projectId={row.id} projectName={row.name} />

          <TrackerExportCSV name={row.name} projectId={row.id} />

          <DropdownMenuSeparator />

          <AlertDialogTrigger asChild>
            <DropdownMenuItem className="text-destructive">
              Delete
            </DropdownMenuItem>
          </AlertDialogTrigger>
        </DropdownMenuContent>
      </DropdownMenu>
    </AlertDialog>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/tracker/empty-states.tsx">
"use client";

import { useTrackerFilterParams } from "@/hooks/use-tracker-filter-params";
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { Button } from "@midday/ui/button";

export function EmptyState() {
  const { setParams } = useTrackerParams();

  return (
    <div className="flex items-center justify-center h-[350px]">
      <div className="flex flex-col items-center -mt-20">
        <div className="text-center mb-6 space-y-2">
          <h2 className="font-medium text-lg">No projects</h2>
          <p className="text-[#606060] text-sm">
            You haven't created any projects yet. <br />
            Go ahead and create your first one.
          </p>
        </div>

        <Button
          variant="outline"
          onClick={() =>
            setParams({
              create: true,
            })
          }
        >
          Create project
        </Button>
      </div>
    </div>
  );
}

export function NoResults() {
  const { setFilter } = useTrackerFilterParams();

  return (
    <div className="flex items-center justify-center h-[350px]">
      <div className="flex flex-col items-center -mt-20">
        <div className="text-center mb-6 space-y-2">
          <h2 className="font-medium text-lg">No results</h2>
          <p className="text-[#606060] text-sm">
            Try another search, or adjusting the filters
          </p>
        </div>

        <Button variant="outline" onClick={() => setFilter(null)}>
          Clear filters
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/tracker/index.tsx">
"use client";

import { LoadMore } from "@/components/load-more";
import { useLatestProjectId } from "@/hooks/use-latest-project-id";
import { useSortParams } from "@/hooks/use-sort-params";
import { useTableScroll } from "@/hooks/use-table-scroll";
import { useTrackerFilterParams } from "@/hooks/use-tracker-filter-params";
import { useTRPC } from "@/trpc/client";
import { Table, TableBody } from "@midday/ui/table";
import { useMutation, useSuspenseInfiniteQuery } from "@tanstack/react-query";
import { useDeferredValue, useEffect } from "react";
import { useInView } from "react-intersection-observer";
import { DataTableHeader } from "./data-table-header";
import { DataTableRow } from "./data-table-row";
import { EmptyState, NoResults } from "./empty-states";

export function DataTable() {
  const trpc = useTRPC();
  const { ref, inView } = useInView();
  const { latestProjectId, setLatestProjectId } = useLatestProjectId();
  const { params } = useSortParams();
  const { hasFilters, filter } = useTrackerFilterParams();
  const deferredSearch = useDeferredValue(filter.q);

  const tableScroll = useTableScroll({
    useColumnWidths: true,
    startFromColumn: 1,
  });

  const infiniteQueryOptions = trpc.trackerProjects.get.infiniteQueryOptions(
    {
      ...filter,
      q: deferredSearch ?? null,
      sort: params.sort,
    },
    {
      getNextPageParam: ({ meta }) => meta?.cursor,
    },
  );

  const { data, fetchNextPage, hasNextPage, refetch, isFetching } =
    useSuspenseInfiniteQuery(infiniteQueryOptions);

  const deleteTrackerProjectMutation = useMutation(
    trpc.trackerProjects.delete.mutationOptions({
      onSuccess: (result) => {
        if (result && result.id === latestProjectId) {
          setLatestProjectId(null);
        }

        refetch();
      },
    }),
  );

  const pageData = data?.pages.flatMap((page) => page.data);

  useEffect(() => {
    if (inView) {
      fetchNextPage();
    }
  }, [inView]);

  if (!isFetching && !pageData?.length && !hasFilters) {
    return <EmptyState />;
  }

  if (!pageData?.length && hasFilters) {
    return <NoResults />;
  }

  return (
    <div className="w-full">
      <div
        ref={tableScroll.containerRef}
        className="overflow-x-auto overscroll-x-none md:border-l md:border-r border-border scrollbar-hide"
      >
        <Table>
          <DataTableHeader tableScroll={tableScroll} />

          <TableBody className="border-l-0 border-r-0">
            {pageData?.map((row) => (
              <DataTableRow
                row={row}
                key={row.id}
                onDelete={deleteTrackerProjectMutation.mutate}
              />
            ))}
          </TableBody>
        </Table>
      </div>

      <LoadMore ref={ref} hasNextPage={hasNextPage} />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/tracker/loading.tsx">
"use client";

import { Skeleton } from "@midday/ui/skeleton";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { DataTableHeader } from "./data-table-header";

const data = [...Array(10)].map((_, i) => ({ id: i.toString() }));

export function Loading() {
  return (
    <div className="w-full">
      <div className="overflow-x-auto md:border-l md:border-r border-border">
        <Table>
          <DataTableHeader />

          <TableBody className="border-l-0 border-r-0 border-t-0 border-b-0">
            {data?.map((row) => (
              <TableRow key={row.id} className="h-[45px]">
                <TableCell className="w-[240px] min-w-[240px] sticky left-0 bg-background z-20">
                  <Skeleton className="h-3.5 w-[60%]" />
                </TableCell>
                <TableCell className="w-[180px]">
                  <Skeleton className="h-3.5 w-[50%]" />
                </TableCell>
                <TableCell className="w-[180px]">
                  <Skeleton className="h-3.5 w-[40%]" />
                </TableCell>
                <TableCell className="w-[190px]">
                  <Skeleton className="h-3.5 w-[50%]" />
                </TableCell>
                <TableCell className="w-[330px]">
                  <Skeleton className="h-3.5 w-[70%]" />
                </TableCell>
                <TableCell className="min-w-[170px]">
                  <Skeleton className="h-3.5 w-[60%]" />
                </TableCell>
                <TableCell className="w-[140px]">
                  <Skeleton className="h-3.5 w-[50%]" />
                </TableCell>
                <TableCell className="w-[150px] min-w-[150px]">
                  <Skeleton className="h-3.5 w-[40%]" />
                </TableCell>
                <TableCell className="w-[100px] sticky right-0 bg-background z-30">
                  <Skeleton className="h-3.5 w-[30%]" />
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/transactions/bottom-bar.tsx">
"use client";

import { useTransactionFilterParams } from "@/hooks/use-transaction-filter-params";
import { useUserQuery } from "@/hooks/use-user";
import { useI18n } from "@/locales/client";
import { useTRPC } from "@/trpc/client";
import { formatAmount } from "@/utils/format";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useQuery } from "@tanstack/react-query";
import { motion } from "framer-motion";
import { useMemo } from "react";

type Transaction = {
  amount: number;
  currency: string;
};

export function BottomBar() {
  const { data: user } = useUserQuery();
  const t = useI18n();
  const trpc = useTRPC();
  const { filter } = useTransactionFilterParams();
  const { data: transactions, isLoading } = useQuery({
    ...trpc.transactions.get.queryOptions({
      ...filter,
      pageSize: 10000,
    }),
  });

  const totalAmount = useMemo(() => {
    const totals: Transaction[] = [];

    for (const transaction of transactions?.data ?? []) {
      if (!transaction.amount || !transaction.currency) continue;

      const existingTotal = totals.find(
        (total) => total.currency === transaction.currency,
      );

      if (existingTotal) {
        existingTotal.amount += transaction.amount;
      } else {
        totals.push({
          currency: transaction.currency,
          amount: transaction.amount,
        });
      }
    }

    return totals;
  }, [transactions]);

  const multiCurrency = totalAmount && totalAmount.length > 1;

  const amountPerCurrency = totalAmount
    .map((total) =>
      formatAmount({
        amount: total?.amount,
        currency: total.currency,
        locale: user?.locale ?? undefined,
      }),
    )
    .join(", ");

  if (isLoading) return null;

  return (
    <motion.div
      className="h-12 fixed bottom-4 left-0 right-0 pointer-events-none flex justify-center"
      initial={{ y: 100, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      exit={{ y: 100, opacity: 0 }}
      transition={{ type: "spring", stiffness: 400, damping: 25 }}
    >
      <div className="pointer-events-auto backdrop-filter  dark:bg-[#1A1A1A]/80 bg-[#F6F6F3]/80 h-12 justify-between items-center flex px-4 border dark:border-[#2C2C2C] border-[#DCDAD2] space-x-2">
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger className="flex items-center space-x-2">
              <Icons.Info className="text-[#606060]" />
              <span className="text-sm">
                {multiCurrency
                  ? t("bottom_bar.multi_currency")
                  : totalAmount.length > 0 &&
                    totalAmount[0] &&
                    formatAmount({
                      amount: totalAmount[0].amount,
                      currency: totalAmount[0].currency,
                      locale: user?.locale ?? undefined,
                      maximumFractionDigits: 0,
                      minimumFractionDigits: 0,
                    })}
              </span>
            </TooltipTrigger>
            <TooltipContent sideOffset={30} className="px-3 py-1.5 text-xs">
              {multiCurrency ? amountPerCurrency : t("bottom_bar.description")}
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>

        <span className="text-sm text-[#878787]">
          (
          {t("bottom_bar.transactions", {
            count: transactions?.data?.length ?? 0,
          })}
          )
        </span>
      </div>
    </motion.div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/transactions/columns.tsx">
"use client";

import { AssignedUser } from "@/components/assigned-user";
import { Category } from "@/components/category";
import { FormatAmount } from "@/components/format-amount";
import { TransactionBankAccount } from "@/components/transaction-bank-account";
import { TransactionMethod } from "@/components/transaction-method";
import { TransactionStatus } from "@/components/transaction-status";
import { formatDate } from "@/utils/format";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Badge } from "@midday/ui/badge";
import { Button } from "@midday/ui/button";
import { Checkbox } from "@midday/ui/checkbox";
import { cn } from "@midday/ui/cn";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { Spinner } from "@midday/ui/spinner";
import { Tooltip, TooltipContent, TooltipTrigger } from "@midday/ui/tooltip";
import type { ColumnDef } from "@tanstack/react-table";
import { memo, useCallback } from "react";

type Transaction = RouterOutputs["transactions"]["get"]["data"][number];

const SelectCell = memo(
  ({
    checked,
    onChange,
  }: { checked: boolean; onChange: (value: boolean) => void }) => (
    <Checkbox checked={checked} onCheckedChange={onChange} />
  ),
);

SelectCell.displayName = "SelectCell";

const DateCell = memo(
  ({
    date,
    format,
    noSort,
  }: { date: string; format?: string | null; noSort?: boolean }) =>
    formatDate(date, format, noSort),
);

DateCell.displayName = "DateCell";

const DescriptionCell = memo(
  ({
    name,
    description,
    status,
    categorySlug,
  }: {
    name: string;
    description?: string;
    status?: string;
    categorySlug?: string | null;
  }) => (
    <div className="flex items-center space-x-2">
      <Tooltip>
        <TooltipTrigger asChild>
          <span className={cn(categorySlug === "income" && "text-[#00C969]")}>
            <div className="flex space-x-2 items-center">
              <span className="line-clamp-1 text-ellipsis max-w-[100px] md:max-w-none">
                {name}
              </span>

              {status === "pending" && (
                <div className="flex space-x-1 items-center border rounded-md text-[10px] py-1 px-2 h-[22px] text-[#878787]">
                  <span>Pending</span>
                </div>
              )}
            </div>
          </span>
        </TooltipTrigger>

        {description && (
          <TooltipContent
            className="px-3 py-1.5 text-xs max-w-[380px]"
            side="right"
            sideOffset={10}
          >
            {description}
          </TooltipContent>
        )}
      </Tooltip>
    </div>
  ),
);

DescriptionCell.displayName = "DescriptionCell";

const AmountCell = memo(
  ({
    amount,
    currency,
    categorySlug,
  }: {
    amount: number;
    currency: string;
    categorySlug?: string | null;
  }) => (
    <span
      className={cn("text-sm", categorySlug === "income" && "text-[#00C969]")}
    >
      <FormatAmount amount={amount} currency={currency} />
    </span>
  ),
);

AmountCell.displayName = "AmountCell";

const TagsCell = memo(
  ({ tags }: { tags?: { id: string; name: string | null }[] }) => (
    <div className="relative w-full">
      <div className="flex items-center space-x-2 overflow-x-auto scrollbar-hide">
        {tags?.map(({ id, name }) => (
          <Badge
            key={id}
            variant="tag-rounded"
            className="whitespace-nowrap flex-shrink-0"
          >
            {name}
          </Badge>
        ))}
      </div>
      <div className="group-hover:hidden right-0 top-0 bottom-0 w-8 bg-gradient-to-l from-background to-transparent pointer-events-none z-10" />
    </div>
  ),
);

TagsCell.displayName = "TagsCell";

const ActionsCell = memo(
  ({
    transaction,
    onViewDetails,
    onCopyUrl,
    onUpdateTransaction,
    onDeleteTransaction,
  }: {
    transaction: Transaction;
    onViewDetails?: (id: string) => void;
    onCopyUrl?: (id: string) => void;
    onUpdateTransaction?: (data: { id: string; status: string }) => void;
    onDeleteTransaction?: (id: string) => void;
  }) => {
    const handleViewDetails = useCallback(() => {
      onViewDetails?.(transaction.id);
    }, [transaction.id, onViewDetails]);

    const handleCopyUrl = useCallback(() => {
      onCopyUrl?.(transaction.id);
    }, [transaction.id, onCopyUrl]);

    const handleUpdateToPosted = useCallback(() => {
      onUpdateTransaction?.({ id: transaction.id, status: "posted" });
    }, [transaction.id, onUpdateTransaction]);

    const handleUpdateToCompleted = useCallback(() => {
      onUpdateTransaction?.({ id: transaction.id, status: "completed" });
    }, [transaction.id, onUpdateTransaction]);

    const handleUpdateToExcluded = useCallback(() => {
      onUpdateTransaction?.({ id: transaction.id, status: "excluded" });
    }, [transaction.id, onUpdateTransaction]);

    const handleDeleteTransaction = useCallback(() => {
      onDeleteTransaction?.(transaction.id);
    }, [transaction.id, onDeleteTransaction]);

    return (
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" className="h-8 w-8 p-0">
            <span className="sr-only">Open menu</span>
            <Icons.MoreHoriz />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem onClick={handleViewDetails}>
            View details
          </DropdownMenuItem>
          <DropdownMenuItem onClick={handleCopyUrl}>Share URL</DropdownMenuItem>
          <DropdownMenuSeparator />
          {!transaction.manual && transaction.status === "excluded" && (
            <DropdownMenuItem onClick={handleUpdateToPosted}>
              Include
            </DropdownMenuItem>
          )}

          {!transaction.isFulfilled && (
            <DropdownMenuItem onClick={handleUpdateToCompleted}>
              Mark as completed
            </DropdownMenuItem>
          )}

          {transaction.isFulfilled && transaction.status === "completed" && (
            <DropdownMenuItem onClick={handleUpdateToPosted}>
              Mark as uncompleted
            </DropdownMenuItem>
          )}

          {!transaction.manual && transaction.status !== "excluded" && (
            <DropdownMenuItem onClick={handleUpdateToExcluded}>
              Exclude
            </DropdownMenuItem>
          )}

          {transaction.manual && (
            <DropdownMenuItem
              className="text-destructive"
              onClick={handleDeleteTransaction}
            >
              Delete
            </DropdownMenuItem>
          )}
        </DropdownMenuContent>
      </DropdownMenu>
    );
  },
);

ActionsCell.displayName = "ActionsCell";

export const columns: ColumnDef<Transaction>[] = [
  {
    id: "select",
    meta: {
      className:
        "md:sticky bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-10 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]",
    },
    cell: ({ row }) => (
      <SelectCell
        checked={row.getIsSelected()}
        onChange={(value) => row.toggleSelected(!!value)}
      />
    ),
    enableSorting: false,
    enableHiding: false,
  },
  {
    accessorKey: "date",
    header: "Date",
    meta: {
      className:
        "md:sticky bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-10 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]",
    },
    cell: ({ row, table }) => (
      <DateCell
        date={row.original.date}
        format={table.options.meta?.dateFormat}
        noSort={!table.options.meta?.hasSorting}
      />
    ),
  },
  {
    accessorKey: "description",
    header: "Description",
    meta: {
      className:
        "md:sticky bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-10 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]",
    },
    cell: ({ row }) => (
      <DescriptionCell
        name={row.original.name}
        description={row.original.description ?? undefined}
        status={row.original.status ?? undefined}
        categorySlug={row.original?.category?.slug}
      />
    ),
  },
  {
    accessorKey: "amount",
    header: "Amount",
    meta: {
      className: "border-l border-border",
    },
    cell: ({ row }) => (
      <AmountCell
        amount={row.original.amount}
        currency={row.original.currency}
        categorySlug={row.original?.category?.slug}
      />
    ),
  },
  {
    accessorKey: "taxAmount",
    header: "Tax Amount",
    cell: ({ row }) => (
      <FormatAmount
        amount={row.original.taxAmount}
        currency={row.original.currency}
      />
    ),
  },
  {
    accessorKey: "category",
    header: "Category",
    cell: ({ row }) => {
      // Show analyzing state when enrichment is not completed
      if (!row.original.enrichmentCompleted) {
        return (
          <Tooltip>
            <TooltipTrigger asChild>
              <div className="flex items-center space-x-2 cursor-help">
                <Spinner size={14} className="stroke-primary" />
                <span className="text-[#878787] text-sm">Analyzing</span>
              </div>
            </TooltipTrigger>
            <TooltipContent
              className="px-3 py-1.5 text-xs max-w-[280px]"
              side="top"
              sideOffset={5}
            >
              Analyzing transaction details to determine the best category.
            </TooltipContent>
          </Tooltip>
        );
      }

      return (
        <Category
          name={row.original?.category?.name ?? ""}
          color={row.original?.category?.color ?? ""}
        />
      );
    },
  },
  {
    accessorKey: "counterparty",
    header: "From / To",
    cell: ({ row }) => row.original.counterpartyName ?? "-",
  },
  {
    accessorKey: "tags",
    header: "Tags",
    meta: {
      className: "w-[280px] max-w-[280px]",
    },
    cell: ({ row }) => <TagsCell tags={row.original.tags} />,
  },
  {
    accessorKey: "bank_account",
    header: "Account",
    cell: ({ row }) => (
      <TransactionBankAccount
        name={row.original?.account?.name ?? undefined}
        logoUrl={row.original?.account?.connection?.logoUrl ?? undefined}
      />
    ),
  },
  {
    accessorKey: "method",
    header: "Method",
    cell: ({ row }) => <TransactionMethod method={row.original.method} />,
  },
  {
    accessorKey: "assigned",
    header: "Assigned",
    cell: ({ row }) => {
      if (!row.original.assigned) {
        return null;
      }

      return (
        <AssignedUser
          fullName={row.original.assigned?.fullName}
          avatarUrl={row.original.assigned?.avatarUrl}
        />
      );
    },
  },
  {
    accessorKey: "status",
    cell: ({ row }) => {
      const fullfilled =
        row.original.status === "completed" || row.original.isFulfilled;
      const hasPendingSuggestion = row.original.hasPendingSuggestion;

      return (
        <TransactionStatus
          fullfilled={fullfilled}
          hasPendingSuggestion={hasPendingSuggestion}
        />
      );
    },
  },
  {
    id: "actions",
    enableSorting: false,
    enableHiding: false,
    meta: {
      className:
        "text-right md:sticky md:right-0 bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-10 before:absolute before:left-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:left-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-r after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]",
    },
    cell: ({ row, table }) => {
      const meta = table.options.meta;

      return (
        <ActionsCell
          transaction={row.original}
          onViewDetails={meta?.setOpen}
          onCopyUrl={meta?.copyUrl}
          onUpdateTransaction={meta?.updateTransaction}
          onDeleteTransaction={meta?.onDeleteTransaction}
        />
      );
    },
  },
];
</file>

<file path="apps/dashboard/src/components/tables/transactions/data-table-header.tsx">
"use client";

import { HorizontalPagination } from "@/components/horizontal-pagination";
import { useSortParams } from "@/hooks/use-sort-params";
import { useStickyColumns } from "@/hooks/use-sticky-columns";
import { Button } from "@midday/ui/button";
import { Checkbox } from "@midday/ui/checkbox";
import { cn } from "@midday/ui/cn";
import { TableHead, TableHeader, TableRow } from "@midday/ui/table";
import { ArrowDown, ArrowUp } from "lucide-react";
import { useCallback } from "react";

interface TableColumn {
  id: string;
  getIsVisible: () => boolean;
}

interface TableInterface {
  getAllLeafColumns: () => TableColumn[];
  getIsAllPageRowsSelected: () => boolean;
  getIsSomePageRowsSelected: () => boolean;
  toggleAllPageRowsSelected: (value: boolean) => void;
}

interface TableScrollState {
  containerRef: React.RefObject<HTMLDivElement | null>;
  canScrollLeft: boolean;
  canScrollRight: boolean;
  isScrollable: boolean;
  scrollLeft: () => void;
  scrollRight: () => void;
}

interface Props {
  table?: TableInterface;
  loading?: boolean;
  tableScroll?: TableScrollState;
}

export function DataTableHeader({ table, loading, tableScroll }: Props) {
  const { params, setParams } = useSortParams();
  const [column, value] = params.sort || [];

  const createSortQuery = useCallback(
    (name: string) => {
      if (value === "asc") {
        // If currently ascending, switch to descending
        setParams({ sort: [name, "desc"] });
      } else if (value === "desc") {
        // If currently descending, clear sort
        setParams({ sort: null });
      } else {
        // If not sorted on this column, set to ascending
        setParams({ sort: [name, "asc"] });
      }
    },
    [value, setParams],
  );

  // Use the reusable sticky columns hook
  const { getStickyStyle, isVisible } = useStickyColumns({
    table,
    loading,
  });

  return (
    <TableHeader className="border-l-0 border-r-0">
      <TableRow className="h-[45px] hover:bg-transparent">
        <TableHead
          className={cn(
            "min-w-[50px] w-[50px] px-3 md:px-4 py-2 md:sticky md:left-[var(--stick-left)] bg-background z-10 border-r border-border",
            "before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border",
            "after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background after:z-[-1]",
          )}
          style={getStickyStyle("select")}
        >
          <Checkbox
            checked={
              table?.getIsAllPageRowsSelected() ||
              (table?.getIsSomePageRowsSelected() && "indeterminate")
            }
            onCheckedChange={(value) =>
              table?.toggleAllPageRowsSelected(!!value)
            }
          />
        </TableHead>

        {isVisible("date") && (
          <TableHead
            className={cn(
              "w-[110px] min-w-[110px] px-3 md:px-4 py-2 md:sticky md:left-[var(--stick-left)] bg-background z-10 border-r border-border",
              "before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border",
              "after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background after:z-[-1]",
            )}
            style={getStickyStyle("date")}
          >
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("date")}
            >
              <span>Date</span>
              {"date" === column && value === "asc" && <ArrowDown size={16} />}
              {"date" === column && value === "desc" && <ArrowUp size={16} />}
            </Button>
          </TableHead>
        )}

        {isVisible("description") && (
          <TableHead
            className={cn(
              "w-[320px] min-w-[320px] px-3 md:px-4 py-2 md:sticky md:left-[var(--stick-left)] bg-background z-10 border-r border-border",
              "before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border",
              "after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background after:z-[-1]",
            )}
            style={getStickyStyle("description")}
          >
            <div className="flex items-center justify-between">
              <Button
                className="p-0 hover:bg-transparent space-x-2"
                variant="ghost"
                onClick={() => createSortQuery("name")}
              >
                <span>Description</span>
                {"name" === column && value === "asc" && (
                  <ArrowDown size={16} />
                )}
                {"name" === column && value === "desc" && <ArrowUp size={16} />}
              </Button>
              {tableScroll?.isScrollable && (
                <HorizontalPagination
                  canScrollLeft={tableScroll.canScrollLeft}
                  canScrollRight={tableScroll.canScrollRight}
                  onScrollLeft={tableScroll.scrollLeft}
                  onScrollRight={tableScroll.scrollRight}
                  className="hidden md:flex"
                />
              )}
            </div>
          </TableHead>
        )}

        {isVisible("amount") && (
          <TableHead className="w-[170px] min-w-[170px] px-3 md:px-4 py-2 border-l border-border">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("amount")}
            >
              <span>Amount</span>
              {"amount" === column && value === "asc" && (
                <ArrowDown size={16} />
              )}
              {"amount" === column && value === "desc" && <ArrowUp size={16} />}
            </Button>
          </TableHead>
        )}

        {isVisible("taxAmount") && (
          <TableHead className="w-[170px] min-w-[170px] px-3 md:px-4 py-2">
            <span>Tax Amount</span>
          </TableHead>
        )}

        {isVisible("category") && (
          <TableHead className="w-[250px] min-w-[250px] px-3 md:px-4 py-2">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("category")}
            >
              <span>Category</span>
              {"category" === column && value === "asc" && (
                <ArrowDown size={16} />
              )}
              {"category" === column && value === "desc" && (
                <ArrowUp size={16} />
              )}
            </Button>
          </TableHead>
        )}

        {isVisible("counterparty") && (
          <TableHead className="w-[200px] min-w-[200px] px-3 md:px-4 py-2">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("counterparty")}
            >
              <span>From / To</span>
              {"counterparty" === column && value === "asc" && (
                <ArrowDown size={16} />
              )}
              {"counterparty" === column && value === "desc" && (
                <ArrowUp size={16} />
              )}
            </Button>
          </TableHead>
        )}

        {isVisible("tags") && (
          <TableHead className="w-[280px] max-w-[280px] px-3 md:px-4 py-2">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("tags")}
            >
              <span>Tags</span>
              {"tags" === column && value === "asc" && <ArrowDown size={16} />}
              {"tags" === column && value === "desc" && <ArrowUp size={16} />}
            </Button>
          </TableHead>
        )}

        {isVisible("bank_account") && (
          <TableHead className="w-[250px] px-3 md:px-4 py-2">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("bank_account")}
            >
              <span>Account</span>
              {"bank_account" === column && value === "asc" && (
                <ArrowDown size={16} />
              )}
              {"bank_account" === column && value === "desc" && (
                <ArrowUp size={16} />
              )}
            </Button>
          </TableHead>
        )}

        {isVisible("method") && (
          <TableHead className="w-[140px] min-w-[140px] px-3 md:px-4 py-2">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("method")}
            >
              <span>Method</span>
              {"method" === column && value === "asc" && (
                <ArrowDown size={16} />
              )}
              {"method" === column && value === "desc" && <ArrowUp size={16} />}
            </Button>
          </TableHead>
        )}

        {isVisible("assigned") && (
          <TableHead className="w-[220px] min-w-[220px] px-3 md:px-4 py-2">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("assigned")}
            >
              <span>Assigned</span>
              {"assigned" === column && value === "asc" && (
                <ArrowDown size={16} />
              )}
              {"assigned" === column && value === "desc" && (
                <ArrowUp size={16} />
              )}
            </Button>
          </TableHead>
        )}

        {isVisible("status") && (
          <TableHead className="w-[160px] min-w-[160px] px-3 md:px-4 py-2">
            <Button
              className="p-0 hover:bg-transparent space-x-2"
              variant="ghost"
              onClick={() => createSortQuery("attachment")}
            >
              <span>Status</span>
              {"attachment" === column && value === "asc" && (
                <ArrowDown size={16} />
              )}
              {"attachment" === column && value === "desc" && (
                <ArrowUp size={16} />
              )}
            </Button>
          </TableHead>
        )}

        {isVisible("actions") && (
          <TableHead
            className={cn(
              "w-[100px] md:sticky md:right-0 bg-background z-10",
              "before:absolute before:left-0 before:top-0 before:bottom-0 before:w-px before:bg-border",
              "after:absolute after:left-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-r after:from-transparent after:to-background after:z-[-1]",
            )}
          >
            Actions
          </TableHead>
        )}
      </TableRow>
    </TableHeader>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/transactions/data-table.tsx">
"use client";

import { updateColumnVisibilityAction } from "@/actions/update-column-visibility-action";
import { LoadMore } from "@/components/load-more";
import { useSortParams } from "@/hooks/use-sort-params";
import { useStickyColumns } from "@/hooks/use-sticky-columns";
import { useTableScroll } from "@/hooks/use-table-scroll";
import { useTransactionFilterParamsWithPersistence } from "@/hooks/use-transaction-filter-params-with-persistence";
import { useTransactionParams } from "@/hooks/use-transaction-params";
import { useTransactionsStore } from "@/store/transactions";
import { useTRPC } from "@/trpc/client";
import { Cookies } from "@/utils/constants";
import { cn } from "@midday/ui/cn";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { Tooltip, TooltipProvider } from "@midday/ui/tooltip";
import { toast } from "@midday/ui/use-toast";
import { useMutation, useSuspenseInfiniteQuery } from "@tanstack/react-query";
import {
  type VisibilityState,
  flexRender,
  getCoreRowModel,
  useReactTable,
} from "@tanstack/react-table";
import { AnimatePresence } from "framer-motion";
import { use, useDeferredValue, useEffect, useMemo, useState } from "react";
import { useHotkeys } from "react-hotkeys-hook";
import { useInView } from "react-intersection-observer";
import { BottomBar } from "./bottom-bar";
import { columns } from "./columns";
import { DataTableHeader } from "./data-table-header";
import { NoResults, NoTransactions } from "./empty-states";
import { ExportBar } from "./export-bar";
import { Loading } from "./loading";

type Props = {
  columnVisibility: Promise<VisibilityState>;
};

export function DataTable({
  columnVisibility: columnVisibilityPromise,
}: Props) {
  const trpc = useTRPC();
  const { filter, hasFilters } = useTransactionFilterParamsWithPersistence();
  const { setRowSelection, rowSelection, setColumns, setCanDelete } =
    useTransactionsStore();
  const deferredSearch = useDeferredValue(filter.q);
  const { params } = useSortParams();
  const { ref, inView } = useInView();
  const { transactionId, setParams } = useTransactionParams();

  const showBottomBar = hasFilters && !Object.keys(rowSelection).length;
  const initialColumnVisibility = use(columnVisibilityPromise);
  const [columnVisibility, setColumnVisibility] = useState<VisibilityState>(
    initialColumnVisibility ?? {},
  );

  const infiniteQueryOptions = trpc.transactions.get.infiniteQueryOptions(
    {
      ...filter,
      q: deferredSearch,
      sort: params.sort,
    },
    {
      getNextPageParam: ({ meta }) => meta?.cursor,
    },
  );

  const { data, fetchNextPage, hasNextPage, refetch } =
    useSuspenseInfiniteQuery(infiniteQueryOptions);

  const updateTransactionMutation = useMutation(
    trpc.transactions.update.mutationOptions({
      onSuccess: () => {
        refetch();

        toast({
          title: "Transaction updated",
          variant: "success",
        });
      },
    }),
  );

  const deleteTransactionMutation = useMutation(
    trpc.transactions.deleteMany.mutationOptions({
      onSuccess: () => {
        refetch();
      },
    }),
  );

  useEffect(() => {
    if (inView) {
      fetchNextPage();
    }
  }, [inView]);

  const tableData = useMemo(() => {
    return data?.pages.flatMap((page) => page.data) ?? [];
  }, [data]);

  const ids = useMemo(() => {
    return tableData.map((row) => row?.id);
  }, [tableData]);

  // Only poll if the first transaction needs enrichment
  const shouldPollForEnrichment = useMemo(() => {
    if (tableData.length === 0) return false;
    // Focus on the first transaction (most recent) since table is sorted by date desc
    return !tableData.at(0)?.enrichmentCompleted;
  }, [tableData]);

  // Poll for enrichment completion when needed
  useEffect(() => {
    if (!shouldPollForEnrichment) return;

    const pollInterval = setInterval(() => {
      refetch();
    }, 3000); // Poll every 3 seconds

    // Cleanup after 1 minute to avoid infinite polling
    const timeoutId = setTimeout(
      () => {
        clearInterval(pollInterval);
      },
      1 * 60 * 1000,
    );

    return () => {
      clearInterval(pollInterval);
      clearTimeout(timeoutId);
    };
  }, [shouldPollForEnrichment, refetch]);

  const table = useReactTable({
    getRowId: (row) => row?.id,
    data: tableData,
    columns,
    getCoreRowModel: getCoreRowModel(),
    onRowSelectionChange: setRowSelection,
    onColumnVisibilityChange: setColumnVisibility,
    state: {
      rowSelection,
      columnVisibility,
    },
    meta: {
      setOpen: (id: string) => {
        setParams({ transactionId: id });
      },
      copyUrl: (id: string) => {
        try {
          window.navigator.clipboard.writeText(
            `${process.env.NEXT_PUBLIC_URL}/transactions/?transactionId=${id}`,
          );

          toast({
            title: "Transaction URL copied to clipboard",
            variant: "success",
          });
        } catch {
          toast({
            title: "Failed to copy transaction URL to clipboard",
            variant: "error",
          });
        }
      },
      updateTransaction: (data: { id: string; status: string }) => {
        updateTransactionMutation.mutate({
          id: data.id,
          status: data.status as
            | "pending"
            | "archived"
            | "completed"
            | "posted"
            | "excluded",
        });
      },
      onDeleteTransaction: (id: string) => {
        deleteTransactionMutation.mutate([id]);
      },
    },
  });

  // Use the reusable sticky columns hook
  const { getStickyStyle, getStickyClassName } = useStickyColumns({
    columnVisibility,
    table,
  });

  // Use the reusable table scroll hook with column-width scrolling starting after sticky columns
  const tableScroll = useTableScroll({
    useColumnWidths: true,
    startFromColumn: 3, // Skip sticky columns: select, date, description
  });

  useEffect(() => {
    setColumns(table.getAllLeafColumns());
  }, [columnVisibility]);

  useEffect(() => {
    updateColumnVisibilityAction({
      key: Cookies.TransactionsColumns,
      data: columnVisibility,
    });
  }, [columnVisibility]);

  useEffect(() => {
    const transactions = tableData.filter((transaction) => {
      if (!transaction?.id) return false;
      const found = rowSelection[transaction.id];

      if (found) {
        return !transaction?.manual;
      }
      return false;
    });

    if (Object.keys(rowSelection)?.length > 0) {
      if (transactions.length === 0) {
        setCanDelete(true);
      } else {
        setCanDelete(false);
      }
    }
  }, [rowSelection]);

  useHotkeys(
    "ArrowUp, ArrowDown",
    ({ key }) => {
      if (key === "ArrowUp" && transactionId) {
        const currentIndex = ids?.indexOf(transactionId) ?? 0;
        const prevId = ids[currentIndex - 1];

        if (prevId) {
          setParams({ transactionId: prevId });
        }
      }

      if (key === "ArrowDown" && transactionId) {
        const currentIndex = ids?.indexOf(transactionId) ?? 0;
        const nextId = ids[currentIndex + 1];

        if (nextId) {
          setParams({ transactionId: nextId });
        }
      }
    },
    { enabled: !!transactionId },
  );

  if (!tableData.length && !hasFilters) {
    return (
      <div className="relative h-[calc(100vh-200px)] overflow-hidden">
        <NoTransactions />
        <Loading isEmpty />
      </div>
    );
  }

  if (!tableData.length && hasFilters) {
    return (
      <div className="relative h-[calc(100vh-200px)] overflow-hidden">
        <NoResults />
        <Loading isEmpty />
      </div>
    );
  }

  return (
    <div className="relative">
      <TooltipProvider delayDuration={20}>
        <Tooltip>
          <div className="w-full">
            <div
              ref={tableScroll.containerRef}
              className="overflow-x-auto overscroll-x-none md:border-l md:border-r border-border scrollbar-hide"
            >
              <Table>
                <DataTableHeader table={table} tableScroll={tableScroll} />

                <TableBody className="border-l-0 border-r-0">
                  {table.getRowModel().rows?.length ? (
                    table.getRowModel().rows.map((row) => (
                      <TableRow
                        key={row.id}
                        className="group h-[40px] md:h-[45px] cursor-pointer select-text hover:bg-[#F2F1EF] hover:dark:bg-secondary"
                      >
                        {row.getVisibleCells().map((cell) => (
                          <TableCell
                            key={cell.id}
                            className={getStickyClassName(
                              cell.column.id,
                              cell.column.columnDef.meta?.className,
                            )}
                            style={getStickyStyle(cell.column.id)}
                            onClick={() => {
                              if (
                                cell.column.id !== "select" &&
                                cell.column.id !== "actions"
                              ) {
                                setParams({ transactionId: row.original.id });
                              }
                            }}
                          >
                            {flexRender(
                              cell.column.columnDef.cell,
                              cell.getContext(),
                            )}
                          </TableCell>
                        ))}
                      </TableRow>
                    ))
                  ) : (
                    <TableRow>
                      <TableCell
                        colSpan={columns.length}
                        className="h-24 text-center"
                      >
                        No results.
                      </TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
            </div>

            <LoadMore ref={ref} hasNextPage={hasNextPage} />
          </div>
        </Tooltip>
      </TooltipProvider>

      <ExportBar />

      <AnimatePresence>{showBottomBar && <BottomBar />}</AnimatePresence>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/transactions/empty-states.tsx">
"use client";

import { AddAccountButton } from "@/components/add-account-button";
import { useTransactionFilterParamsWithPersistence } from "@/hooks/use-transaction-filter-params-with-persistence";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";

export function NoResults() {
  const { clearAllFilters } = useTransactionFilterParamsWithPersistence();

  return (
    <div className="h-[calc(100vh-300px)] flex items-center justify-center">
      <div className="flex flex-col items-center">
        <Icons.Transactions2 className="mb-4" />
        <div className="text-center mb-6 space-y-2">
          <h2 className="font-medium text-lg">No results</h2>
          <p className="text-[#606060] text-sm">
            Try another search, or adjusting the filters
          </p>
        </div>

        <Button variant="outline" onClick={clearAllFilters}>
          Clear filters
        </Button>
      </div>
    </div>
  );
}

export function NoTransactions() {
  return (
    <div className="absolute w-full h-[calc(100vh-300px)] top-0 left-0 flex items-center justify-center z-20">
      <div className="text-center max-w-sm mx-auto flex flex-col items-center justify-center">
        <h2 className="text-xl font-medium mb-2">No transactions</h2>
        <p className="text-sm text-[#878787] mb-6">
          Connect your bank account to automatically import transactions and
          unlock powerful financial insights to help you make smarter money
          decisions.
        </p>

        <AddAccountButton />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/transactions/export-bar.tsx">
import { exportTransactionsAction } from "@/actions/export-transactions-action";
import { useUserQuery } from "@/hooks/use-user";
import { useExportStore } from "@/store/export";
import { useTransactionsStore } from "@/store/transactions";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { SubmitButton } from "@midday/ui/submit-button";
import { useToast } from "@midday/ui/use-toast";
import NumberFlow from "@number-flow/react";
import { AnimatePresence, motion } from "framer-motion";
import { useAction } from "next-safe-action/hooks";
import { useEffect, useState } from "react";

export function ExportBar() {
  const { toast } = useToast();
  const { setExportData } = useExportStore();
  const { rowSelection, setRowSelection } = useTransactionsStore();
  const [isOpen, setOpen] = useState(false);
  const { data: user } = useUserQuery();

  const ids = Object.keys(rowSelection);
  const totalSelected = ids.length;

  const { execute, status } = useAction(exportTransactionsAction, {
    onSuccess: ({ data }) => {
      if (data?.id && data?.publicAccessToken) {
        setExportData({
          runId: data.id,
          accessToken: data.publicAccessToken,
        });

        setRowSelection(() => ({}));
      }

      setOpen(false);
    },
    onError: () => {
      toast({
        duration: 3500,
        variant: "error",
        title: "Something went wrong please try again.",
      });
    },
  });

  useEffect(() => {
    if (totalSelected) {
      setOpen(true);
    } else {
      setOpen(false);
    }
  }, [totalSelected]);

  return (
    <AnimatePresence>
      <motion.div
        className="h-12 fixed left-[50%] bottom-2 w-[400px] -ml-[200px] z-50"
        animate={{ y: isOpen ? 0 : 100 }}
        initial={{ y: 100 }}
      >
        <div className="mx-2 md:mx-0 backdrop-filter backdrop-blur-lg dark:bg-[#1A1A1A]/80 bg-[#F6F6F3]/80 h-12 justify-between items-center flex px-4 border dark:border-[#2C2C2C]">
          <span className="text-sm text-[#878787]">
            <NumberFlow value={Object.keys(rowSelection).length} /> selected
          </span>

          <div className="flex items-center space-x-2">
            <Button variant="ghost" onClick={() => setRowSelection({})}>
              <span>Deselect all</span>
            </Button>
            <SubmitButton
              isSubmitting={status === "executing"}
              onClick={() =>
                execute({
                  transactionIds: ids,
                  dateFormat: user?.dateFormat ?? undefined,
                  locale: user?.locale ?? undefined,
                })
              }
            >
              <div className="flex items-center space-x-2">
                <span>Export</span>
                <Icons.ArrowCoolDown className="size-4" />
              </div>
            </SubmitButton>
          </div>
        </div>
      </motion.div>
    </AnimatePresence>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/transactions/loading.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { Skeleton } from "@midday/ui/skeleton";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { DataTableHeader } from "./data-table-header";

const data = [...Array(40)].map((_, i) => ({ id: i.toString() }));

export function Loading({ isEmpty }: { isEmpty?: boolean }) {
  return (
    <div className="w-full">
      <div
        className={cn(
          "overflow-x-auto",
          !isEmpty && "md:border-l md:border-r border-border",
        )}
      >
        <Table
          className={cn(
            "min-w-[1600px]",
            isEmpty && "opacity-20 pointer-events-none blur-[7px]",
          )}
        >
          <DataTableHeader loading />

          <TableBody className="border-l-0 border-r-0 border-t-0 border-b-0">
            {data?.map((row) => (
              <TableRow key={row.id} className="h-[45px]">
                {/* Select column - always visible */}
                <TableCell className="w-[50px] min-w-[50px]">
                  <Skeleton className="h-3.5 w-[15px]" />
                </TableCell>

                {/* Date column - always visible */}
                <TableCell className="w-[110px] min-w-[110px]">
                  <Skeleton className="h-3.5 w-[60%]" />
                </TableCell>

                {/* Description column - always visible */}
                <TableCell className="w-[320px] min-w-[320px]">
                  <Skeleton className="h-3.5 w-[50%]" />
                </TableCell>

                {/* Amount column */}
                <TableCell className="w-[170px] min-w-[170px]">
                  <Skeleton className="h-3.5 w-[50%]" />
                </TableCell>

                {/* Tax Amount column */}
                <TableCell className="w-[170px] min-w-[170px]">
                  <Skeleton className="h-3.5 w-[60%]" />
                </TableCell>

                {/* Category column */}
                <TableCell className="w-[250px] min-w-[250px]">
                  <div className="flex items-center space-x-2 w-[80%]">
                    <Skeleton className="h-5 w-5" />
                    <Skeleton className="h-3.5 w-[70%]" />
                  </div>
                </TableCell>

                {/* Counterparty column */}
                <TableCell className="w-[200px] min-w-[200px]">
                  <Skeleton className="h-3.5 w-[60%]" />
                </TableCell>

                {/* Tags column */}
                <TableCell className="w-[280px] max-w-[280px]">
                  <div className="flex items-center space-x-1">
                    <Skeleton className="h-5 w-12" />
                    <Skeleton className="h-5 w-16" />
                  </div>
                </TableCell>

                {/* Bank Account column */}
                <TableCell className="w-[250px]">
                  <div className="flex items-center space-x-2">
                    <Skeleton className="h-6 w-6" />
                    <Skeleton className="h-3.5 w-[60%]" />
                  </div>
                </TableCell>

                {/* Method column */}
                <TableCell className="w-[140px] min-w-[140px]">
                  <Skeleton className="h-3.5 w-[50%]" />
                </TableCell>

                {/* Assigned column */}
                <TableCell className="w-[220px] min-w-[220px]">
                  <div className="flex items-center space-x-2">
                    <Skeleton className="h-6 w-6" />
                    <Skeleton className="h-3.5 w-[50%]" />
                  </div>
                </TableCell>

                {/* Status column */}
                <TableCell className="w-[140px]">
                  <Skeleton className="h-5 w-[80px]" />
                </TableCell>

                {/* Actions column - always visible */}
                <TableCell className="w-[100px]">
                  <Skeleton className="h-[20px] w-[20px]" />
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/vault/bottom-bar.tsx">
"use client";

import { useDownloadZip } from "@/hooks/use-download-zip";
import { useDocumentsStore } from "@/store/vault";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { SubmitButton } from "@midday/ui/submit-button";
import NumberFlow from "@number-flow/react";
import { motion } from "framer-motion";

type Props = {
  data: string[];
};

export function BottomBar({ data }: Props) {
  const { rowSelection, setRowSelection } = useDocumentsStore();
  const { handleDownloadZip, isPending } = useDownloadZip();

  // Filter the data array based on the selected row indices (keys in rowSelection)
  const selectedFiles = data.filter((_, index) => rowSelection[index]);

  return (
    <motion.div
      className="h-12 fixed bottom-4 left-0 right-0 pointer-events-none flex justify-center"
      initial={{ y: 100, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      exit={{ y: 100, opacity: 0 }}
      transition={{ type: "spring", stiffness: 400, damping: 25 }}
    >
      <div className="pointer-events-auto backdrop-filter min-w-[400px] backdrop-blur-lg dark:bg-[#1A1A1A]/80 bg-[#F6F6F3]/80 h-12 justify-between items-center flex px-4 border dark:border-[#2C2C2C] border-[#DCDAD2]">
        <span className="text-sm text-[#878787]">
          <NumberFlow value={Object.keys(rowSelection).length} /> selected
        </span>

        <div className="flex items-center space-x-2">
          <Button variant="ghost" onClick={() => setRowSelection({})}>
            <span>Deselect all</span>
          </Button>

          <SubmitButton
            isSubmitting={isPending}
            onClick={() => handleDownloadZip(selectedFiles)}
          >
            <div className="flex items-center space-x-2">
              <span>Download</span>
              <Icons.ArrowCoolDown className="size-4" />
            </div>
          </SubmitButton>
        </div>
      </div>
    </motion.div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/vault/columns.tsx">
import { useDocumentFilterParams } from "@/hooks/use-document-filter-params";
import { useDocumentParams } from "@/hooks/use-document-params";
import { downloadFile } from "@/lib/download";
import { formatSize } from "@/utils/format";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Badge } from "@midday/ui/badge";
import { Button } from "@midday/ui/button";
import { Checkbox } from "@midday/ui/checkbox";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Skeleton } from "@midday/ui/skeleton";
import type { ColumnDef } from "@tanstack/react-table";
import { MoreHorizontal } from "lucide-react";

type Document = RouterOutputs["documents"]["get"]["data"][number];

export const columns: ColumnDef<Document>[] = [
  {
    id: "select",
    meta: {
      className:
        "md:sticky md:left-0 bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-20 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]",
    },
    cell: ({ row }) => (
      <Checkbox
        checked={row.getIsSelected()}
        onCheckedChange={(checked) => {
          if (checked === "indeterminate") {
            row.toggleSelected();
          } else {
            row.toggleSelected(checked);
          }
        }}
      />
    ),
    enableSorting: false,
    enableHiding: false,
  },
  {
    id: "title",
    accessorKey: "title",
    meta: {
      className:
        "w-[250px] min-w-[250px] md:sticky md:left-[50px] bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-20 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]",
    },
    cell: ({ row }) => {
      const isLoading = row.original.processingStatus === "pending";

      if (isLoading) {
        return <Skeleton className="w-52 h-4" />;
      }

      return (
        <div className="truncate">
          {row.original.title ?? row.original.name?.split("/").at(-1)}
        </div>
      );
    },
  },
  {
    id: "tags",
    accessorKey: "tags",
    meta: {
      className: "w-[280px] max-w-[280px]",
    },
    cell: ({ row }) => {
      const { setFilter } = useDocumentFilterParams();

      const isLoading = row.original.processingStatus === "pending";

      if (isLoading) {
        return (
          <div className="flex gap-2 flex-wrap">
            <Skeleton className="h-6 w-20 rounded-full" />
            <Skeleton className="h-6 w-16 rounded-full" />
            <Skeleton className="h-6 w-24 rounded-full" />
          </div>
        );
      }

      return (
        <div className="relative w-full">
          <div className="flex items-center space-x-2 overflow-x-auto scrollbar-hide">
            {row.original.documentTagAssignments?.map(({ documentTag }) => (
              <Badge
                key={documentTag.id}
                variant="tag-rounded"
                className="whitespace-nowrap flex-shrink-0"
                onClick={() => {
                  setFilter({ tags: [documentTag.id] });
                }}
              >
                {documentTag.name}
              </Badge>
            ))}
          </div>
          <div className="absolute group-hover:hidden right-0 top-0 bottom-0 w-8 bg-gradient-to-l from-background to-transparent pointer-events-none z-10" />
        </div>
      );
    },
  },
  {
    id: "size",
    accessorKey: "size",
    cell: ({ row }) => {
      // @ts-expect-error - size is not typed (JSONB)
      return <span>{formatSize(row.original.metadata?.size)}</span>;
    },
  },
  {
    id: "actions",
    cell: ({ row, table }) => {
      const { setParams } = useDocumentParams();

      if (!table.options.meta) {
        return null;
      }

      const { handleDelete, handleShare } = table.options.meta;

      return (
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" size="icon">
              <MoreHorizontal size={16} />
            </Button>
          </DropdownMenuTrigger>

          <DropdownMenuContent>
            <DropdownMenuItem
              onClick={() => {
                setParams({ documentId: row.original.id });
              }}
            >
              View details
            </DropdownMenuItem>
            <DropdownMenuItem
              onClick={async () => {
                try {
                  await downloadFile(
                    `/api/download/file?path=${row.original.pathTokens?.join("/")}&filename=${row.original.name?.split("/").at(-1)}`,
                    row.original.name?.split("/").at(-1) || "download",
                  );
                } catch (error) {
                  console.error("Download failed:", error);
                }
              }}
            >
              Download
            </DropdownMenuItem>
            <DropdownMenuItem
              onClick={() => {
                if (row.original.pathTokens) {
                  handleShare?.(row.original.pathTokens);
                }
              }}
              disabled={!row.original.pathTokens}
            >
              Copy link
            </DropdownMenuItem>

            <DropdownMenuItem
              onClick={() => {
                handleDelete?.(row.original.id);
              }}
            >
              Delete
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      );
    },
    meta: {
      className:
        "text-right sticky right-0 bg-background group-hover:bg-[#F2F1EF] group-hover:dark:bg-secondary z-30 before:absolute before:left-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:left-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-r after:from-transparent after:to-background group-hover:after:to-muted after:z-[-1]",
    },
  },
];
</file>

<file path="apps/dashboard/src/components/tables/vault/data-table-header.tsx">
"use client";

import { HorizontalPagination } from "@/components/horizontal-pagination";
import { Checkbox } from "@midday/ui/checkbox";
import { cn } from "@midday/ui/cn";
import { TableHead, TableHeader, TableRow } from "@midday/ui/table";

interface TableColumn {
  id: string;
  getIsVisible: () => boolean;
}

interface TableInterface {
  getAllLeafColumns: () => TableColumn[];
  getIsAllPageRowsSelected: () => boolean;
  getIsSomePageRowsSelected: () => boolean;
  toggleAllPageRowsSelected: (value: boolean) => void;
}

interface Props {
  table?: TableInterface;
  tableScroll?: {
    canScrollLeft: boolean;
    canScrollRight: boolean;
    isScrollable: boolean;
    scrollLeft: () => void;
    scrollRight: () => void;
  };
}

export function DataTableHeader({ table, tableScroll }: Props) {
  return (
    <TableHeader className="border-l-0 border-r-0">
      <TableRow className="h-[45px] hover:bg-transparent">
        <TableHead className="w-[50px] min-w-[50px] px-3 md:px-4 py-2 md:sticky md:left-0 bg-background z-20 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background after:z-[-1]">
          <Checkbox
            checked={
              table?.getIsAllPageRowsSelected() ||
              (table?.getIsSomePageRowsSelected() && "indeterminate")
            }
            onCheckedChange={(value) =>
              table?.toggleAllPageRowsSelected(!!value)
            }
          />
        </TableHead>

        <TableHead className="w-[250px] min-w-[250px] px-3 py-2 md:sticky md:left-[50px] bg-background z-20 border-r border-border before:absolute before:right-0 before:top-0 before:bottom-0 before:w-px before:bg-border after:absolute after:right-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-l after:from-transparent after:to-background after:z-[-1]">
          <div className="flex items-center justify-between">
            <span>Name</span>
            {tableScroll?.isScrollable && (
              <HorizontalPagination
                canScrollLeft={tableScroll.canScrollLeft}
                canScrollRight={tableScroll.canScrollRight}
                onScrollLeft={tableScroll.scrollLeft}
                onScrollRight={tableScroll.scrollRight}
                className="ml-auto hidden md:flex"
              />
            )}
          </div>
        </TableHead>

        <TableHead className="w-[280px] max-w-[280px] px-3 py-2">
          <span>Tags</span>
        </TableHead>

        <TableHead className="px-3 md:px-4 py-2 w-[100px] min-w-[100px]">
          <span>Size</span>
        </TableHead>

        <TableHead
          className={cn(
            "px-3 md:px-4 py-2 text-right w-[100px] md:sticky md:right-0 bg-background z-30",
            "before:absolute before:left-0 before:top-0 before:bottom-0 before:w-px before:bg-border",
            "after:absolute after:left-[-24px] after:top-0 after:bottom-0 after:w-6 after:bg-gradient-to-r after:from-transparent after:to-background after:z-[-1]",
          )}
        >
          <span>Actions</span>
        </TableHead>
      </TableRow>
    </TableHeader>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/vault/data-table-skeleton.tsx">
"use client";

import { Skeleton } from "@midday/ui/skeleton";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import { DataTableHeader } from "./data-table-header";

const data = [...Array(10)].map((_, i) => ({ id: i.toString() }));

export function DataTableSkeleton() {
  return (
    <div className="w-full">
      <div className="overflow-x-auto md:border-l md:border-r border-border">
        <Table>
          <DataTableHeader />

          <TableBody className="border-l-0 border-r-0 border-t-0 border-b-0">
            {data?.map((row) => (
              <TableRow key={row.id} className="h-[45px]">
                {/* Checkbox column */}
                <TableCell className="w-[50px] min-w-[50px] px-3 md:px-4 py-2">
                  <Skeleton className="h-4 w-4" />
                </TableCell>
                {/* Name column */}
                <TableCell className="w-[250px] min-w-[250px] px-3 py-2">
                  <Skeleton className="h-3.5 w-[60%]" />
                </TableCell>
                {/* Tags column */}
                <TableCell className="w-[280px] max-w-[280px] px-3 py-2">
                  <Skeleton className="h-3.5 w-[70%]" />
                </TableCell>
                {/* Size column */}
                <TableCell className="w-[100px] min-w-[100px] px-3 md:px-4 py-2">
                  <Skeleton className="h-3.5 w-[50%]" />
                </TableCell>
                {/* Actions column */}
                <TableCell className="w-[100px] px-3 md:px-4 py-2 text-right sticky right-0 bg-background z-30">
                  <Skeleton className="h-3.5 w-[50%]" />
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tables/vault/data-table.tsx">
"use client";

import { LoadMore } from "@/components/load-more";
import { NoResults } from "@/components/vault/empty-states";
import { VaultGetStarted } from "@/components/vault/vault-get-started";
import { useDocumentFilterParams } from "@/hooks/use-document-filter-params";
import { useDocumentParams } from "@/hooks/use-document-params";
import { useRealtime } from "@/hooks/use-realtime";
import { useTableScroll } from "@/hooks/use-table-scroll";
import { useUserQuery } from "@/hooks/use-user";
import { useDocumentsStore } from "@/store/vault";
import { useTRPC } from "@/trpc/client";
import { cn } from "@midday/ui/cn";
import { Table, TableBody, TableCell, TableRow } from "@midday/ui/table";
import {
  useMutation,
  useQueryClient,
  useSuspenseInfiniteQuery,
} from "@tanstack/react-query";
import {
  flexRender,
  getCoreRowModel,
  useReactTable,
} from "@tanstack/react-table";
import { AnimatePresence } from "framer-motion";
import * as React from "react";
import { useEffect, useMemo } from "react";
import { useInView } from "react-intersection-observer";
import { useCopyToClipboard } from "usehooks-ts";
import { useDebounceCallback } from "usehooks-ts";
import { BottomBar } from "./bottom-bar";
import { columns } from "./columns";
import { DataTableHeader } from "./data-table-header";

export function DataTable() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { ref, inView } = useInView();
  const { data: user } = useUserQuery();
  const { filter, hasFilters } = useDocumentFilterParams();
  const { setRowSelection, rowSelection } = useDocumentsStore();
  const { setParams, params } = useDocumentParams();
  const [, copy] = useCopyToClipboard();

  const tableScroll = useTableScroll({
    useColumnWidths: true,
    startFromColumn: 2,
  });

  const { data, fetchNextPage, hasNextPage, refetch, isFetching } =
    useSuspenseInfiniteQuery(
      trpc.documents.get.infiniteQueryOptions(
        {
          pageSize: 20,
          ...filter,
        },
        {
          getNextPageParam: ({ meta }) => meta?.cursor,
        },
      ),
    );

  const documents = useMemo(() => {
    return data?.pages.flatMap((page) => page.data) ?? [];
  }, [data]);

  useEffect(() => {
    if (inView) {
      fetchNextPage();
    }
  }, [inView]);

  const debouncedEventHandler = useDebounceCallback(() => {
    refetch();

    queryClient.invalidateQueries({
      queryKey: trpc.documents.get.queryKey(),
    });
  }, 50);

  useRealtime({
    channelName: "realtime_documents",
    table: "documents",
    filter: `team_id=eq.${user?.teamId}`,
    onEvent: (payload) => {
      if (
        payload.eventType === "INSERT" ||
        (payload.eventType === "UPDATE" && params.view === "list")
      ) {
        debouncedEventHandler();
      }
    },
  });

  const deleteDocumentMutation = useMutation(
    trpc.documents.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.documents.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.documents.get.queryKey(),
        });

        // Invalidate global search
        queryClient.invalidateQueries({
          queryKey: trpc.search.global.queryKey(),
        });
      },
    }),
  );

  const shortLinkMutation = useMutation(
    trpc.shortLinks.createForDocument.mutationOptions({
      onSuccess: (data) => {
        if (data?.shortUrl) {
          copy(data.shortUrl);
        }
      },
    }),
  );

  const handleDelete = (id: string) => {
    deleteDocumentMutation.mutate({
      id,
    });
  };

  const handleShare = (filePath: string[]) => {
    shortLinkMutation.mutate({
      filePath: filePath?.join("/") ?? "",
      expireIn: 60 * 60 * 24 * 30, // 30 days
    });
  };

  const files = useMemo(() => {
    return documents.map((document) => document.pathTokens?.join("/") ?? "");
  }, [documents]);

  const showBottomBar = Object.keys(rowSelection).length > 0;

  const table = useReactTable({
    data: documents,
    columns,
    onRowSelectionChange: setRowSelection,
    getCoreRowModel: getCoreRowModel(),
    meta: {
      handleDelete,
      handleShare,
    },
    state: {
      rowSelection,
    },
  });

  if (hasFilters && !documents?.length) {
    return <NoResults />;
  }

  if (!documents?.length && !isFetching) {
    return <VaultGetStarted />;
  }

  return (
    <div className="w-full">
      <div
        ref={tableScroll.containerRef}
        className="overflow-x-auto overscroll-x-none md:border-l md:border-r border-border scrollbar-hide"
      >
        <Table>
          <DataTableHeader table={table} tableScroll={tableScroll} />

          <TableBody className="border-l-0 border-r-0">
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                  className="group h-[40px] md:h-[45px] cursor-pointer select-text hover:bg-[#F2F1EF] hover:dark:bg-secondary"
                >
                  {row.getAllCells().map((cell) => (
                    <TableCell
                      key={cell.id}
                      className={cn(cell.column.columnDef.meta?.className)}
                      onClick={() => {
                        if (
                          cell.column.id !== "select" &&
                          cell.column.id !== "tags" &&
                          cell.column.id !== "actions"
                        ) {
                          setParams({ documentId: row.original.id });
                        }
                      }}
                    >
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext(),
                      )}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow className="hover:bg-transparent">
                <TableCell
                  colSpan={columns.length}
                  className="h-24 text-center"
                >
                  No results.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>

      <AnimatePresence>
        {showBottomBar && <BottomBar data={files} />}
      </AnimatePresence>

      <LoadMore ref={ref} hasNextPage={hasNextPage} />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker/calendar-day.tsx">
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { TZDate } from "@date-fns/tz";
import { cn } from "@midday/ui/cn";
import { format, formatISO, isToday } from "date-fns";
import type React from "react";
import { useCallback } from "react";
import { TrackerEvents } from "./events";
import {
  checkIsFirstSelectedDate,
  checkIsInRange,
  checkIsLastSelectedDate,
} from "./utils";

type CalendarDayProps = {
  date: TZDate;
  currentDate: TZDate;
  selectedDate: string | null;
  dayData:
    | RouterOutputs["trackerEntries"]["byRange"]["result"][string]
    | undefined;
  allData?: RouterOutputs["trackerEntries"]["byRange"]["result"];
  range: [string, string] | null;
  localRange: [string | null, string | null];
  isDragging: boolean;
  handleMouseDown: (date: TZDate) => void;
  handleMouseEnter: (date: TZDate) => void;
  handleMouseUp: () => void;
  onEventClick?: (eventId: string, date: TZDate) => void;
};

export function CalendarDay({
  date,
  currentDate,
  selectedDate,
  dayData,
  allData,
  range,
  localRange,
  isDragging,
  handleMouseDown,
  handleMouseEnter,
  handleMouseUp,
  onEventClick,
}: CalendarDayProps) {
  const isCurrentMonth = date.getMonth() === currentDate.getMonth();
  const formattedDate = formatISO(date, { representation: "date" });

  const isInRange = useCallback(
    (date: TZDate) => checkIsInRange(date, isDragging, localRange, range),
    [isDragging, localRange, range],
  );

  const isFirstSelectedDate = useCallback(
    (date: TZDate) =>
      checkIsFirstSelectedDate(date, isDragging, localRange, range),
    [isDragging, localRange, range],
  );

  const isLastSelectedDate = useCallback(
    (date: TZDate) =>
      checkIsLastSelectedDate(date, isDragging, localRange, range),
    [isDragging, localRange, range],
  );

  const handleDayClick = (event: React.MouseEvent) => {
    // Check if the click target is a continuation event
    const target = event.target as HTMLElement;
    const isContinuation = target.closest('[data-is-continuation="true"]');
    const eventTarget = target.closest("[data-event-id]");

    if (isContinuation) {
      // If this is a continuation event, select the previous day
      event.preventDefault();
      event.stopPropagation();
      const previousDay = new Date(date);
      previousDay.setDate(previousDay.getDate() - 1);
      const previousDayTZ = new TZDate(previousDay, "UTC");
      handleMouseDown(previousDayTZ);
    } else if (eventTarget && onEventClick) {
      // Handle event click on current day
      const eventId = eventTarget.getAttribute("data-event-id");
      if (eventId) {
        event.preventDefault();
        event.stopPropagation();
        onEventClick(eventId, date);
        return;
      }
    } else {
      // Normal behavior - select current day (including for "show all events" clicks)
      handleMouseDown(date);
    }
  };

  return (
    <div
      onMouseDown={handleDayClick}
      onMouseEnter={() => handleMouseEnter(date)}
      onMouseUp={handleMouseUp}
      className={cn(
        "aspect-square md:aspect-[4/2] pt-2 pb-10 px-3 font-mono text-lg relative transition-all duration-100 text-left flex space-x-2 select-none",
        isCurrentMonth && isToday(date)
          ? "bg-[#f0f0f0] dark:bg-[#202020]"
          : "bg-background",
        !isCurrentMonth &&
          "bg-[repeating-linear-gradient(-60deg,#DBDBDB,#DBDBDB_1px,transparent_1px,transparent_5px)] dark:bg-[repeating-linear-gradient(-60deg,#2C2C2C,#2C2C2C_1px,transparent_1px,transparent_5px)] text-[#878787]",
        selectedDate === formattedDate && "ring-1 ring-primary",
        isInRange(date) && "ring-1 ring-primary bg-opacity-50",
        isFirstSelectedDate(date) && "ring-1 ring-primary bg-opacity-50",
        isLastSelectedDate(date) && "ring-1 ring-primary bg-opacity-50",
      )}
    >
      <div>{format(date, "d")}</div>
      <TrackerEvents
        data={dayData ?? []}
        isToday={isToday(date)}
        allData={allData}
        currentDate={date}
        onEventClick={onEventClick}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker/calendar-header.tsx">
import NumberFlow from "@number-flow/react";
import { TotalEarnings } from "../total-earnings";
import { TrackerCalendarType } from "../tracker-calendar-type";
import { TrackerPeriodSelect } from "../tracker-period-select";
import { TrackerSettings } from "../tracker-settings";

type CalendarHeaderProps = {
  totalDuration?: number;
  selectedView: "week" | "month";
};

export function CalendarHeader({
  totalDuration,
  selectedView,
}: CalendarHeaderProps) {
  const hours = Math.floor((totalDuration || 0) / 3600);
  const minutes = Math.floor(((totalDuration || 0) % 3600) / 60);

  return (
    <div className="flex items-center justify-between mb-6">
      <div className="space-y-1 select-text">
        <h1 className="text-4xl font-mono flex items-baseline gap-1 space-x-2">
          <div>
            <NumberFlow value={hours || 0} />
            <span className="relative">h</span>
          </div>
          <div>
            <NumberFlow value={minutes || 0} />
            <span className="relative">m</span>
          </div>
        </h1>
        <TotalEarnings selectedView={selectedView} />
      </div>
      <div className="flex space-x-2">
        <TrackerPeriodSelect dateFormat="MMMM" />
        <TrackerSettings />
        <TrackerCalendarType selectedView={selectedView} />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker/calendar-month-view.tsx">
import type { RouterOutputs } from "@api/trpc/routers/_app";
import type { TZDate } from "@date-fns/tz";
import { format } from "date-fns";
import { CalendarDay } from "./calendar-day";

type CalendarGridProps = {
  firstWeek: TZDate[];
  calendarDays: TZDate[];
  currentDate: TZDate;
  selectedDate: string | null;
  data: RouterOutputs["trackerEntries"]["byRange"]["result"] | undefined;
  range: [string, string] | null;
  localRange: [string | null, string | null];
  isDragging: boolean;
  weekStartsOnMonday: boolean;
  handleMouseDown: (date: TZDate) => void;
  handleMouseEnter: (date: TZDate) => void;
  handleMouseUp: () => void;
  onEventClick?: (eventId: string, date: TZDate) => void;
};

export function CalendarMonthView({
  firstWeek,
  calendarDays,
  currentDate,
  selectedDate,
  data,
  range,
  localRange,
  isDragging,
  handleMouseDown,
  handleMouseEnter,
  handleMouseUp,
  onEventClick,
}: CalendarGridProps) {
  return (
    <div className="grid grid-cols-7 gap-px border border-border bg-border">
      {firstWeek.map((day) => (
        <div
          key={day.toString()}
          className="py-4 px-3 bg-background text-xs font-medium text-[#878787] font-mono"
        >
          {format(day, "EEE").toUpperCase()}
        </div>
      ))}
      {calendarDays.map((date, index) => (
        <CalendarDay
          key={index.toString()}
          date={date}
          currentDate={currentDate}
          selectedDate={selectedDate}
          dayData={data?.[format(date, "yyyy-MM-dd")]}
          allData={data}
          range={range}
          localRange={localRange}
          isDragging={isDragging}
          handleMouseDown={handleMouseDown}
          handleMouseEnter={handleMouseEnter}
          handleMouseUp={handleMouseUp}
          onEventClick={onEventClick}
        />
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker/calendar-week-view.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { secondsToHoursAndMinutes } from "@/utils/format";
import { createSafeDate, formatHour, getSlotFromDate } from "@/utils/tracker";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { TZDate } from "@date-fns/tz";
import { cn } from "@midday/ui/cn";
import { format } from "date-fns";
import { memo, useEffect, useMemo, useState } from "react";

type CalendarWeekViewProps = {
  weekDays: TZDate[];
  currentDate: TZDate;
  selectedDate: string | null;
  data: RouterOutputs["trackerEntries"]["byRange"]["result"] | undefined;
  range: [string, string] | null;
  localRange: [string | null, string | null];
  isDragging: boolean;
  weekStartsOnMonday: boolean;
  handleMouseDown: (date: TZDate) => void;
  handleMouseEnter: (date: TZDate) => void;
  handleMouseUp: () => void;
  onEventClick?: (eventId: string, date: TZDate) => void;
};

const SLOT_HEIGHT = 6.5;
const HOUR_HEIGHT = 26; // Fill the available height (600px - header) / 24 hours ≈ 26px

// Optimized: Memoize hours array to prevent recreation
const hours = Array.from({ length: 25 }, (_, i) => i); // 0-24 for cleaner display

type ProcessedEntry = {
  event: NonNullable<
    RouterOutputs["trackerEntries"]["byRange"]["result"]
  >[string][number];
  eventIndex: string | number;
  displayStartSlot: number;
  displayEndSlot: number;
  isContinuation: boolean;
  spansMidnight: boolean;
  isFromCurrentDay: boolean;
};

type PositionedEntry = ProcessedEntry & {
  column: number;
  totalColumns: number;
  width: number;
  left: number;
  leftPx?: number; // For pixel-based left positioning in cascading layout
};

/**
 * Detect if two events overlap in time
 */
const eventsOverlap = (
  event1: ProcessedEntry,
  event2: ProcessedEntry,
): boolean => {
  return (
    event1.displayStartSlot < event2.displayEndSlot &&
    event2.displayStartSlot < event1.displayEndSlot
  );
};

/**
 * Group overlapping events and calculate positioning
 * Optimized: Memoized and optimized for performance
 */
const calculateEventPositions = (
  entries: ProcessedEntry[],
): PositionedEntry[] => {
  if (entries.length === 0) return [];

  // Sort events by start time, then by duration (longer events first)
  const sortedEntries = [...entries].sort((a, b) => {
    if (a.displayStartSlot !== b.displayStartSlot) {
      return a.displayStartSlot - b.displayStartSlot;
    }
    // If start times are the same, put longer events first
    return (
      b.displayEndSlot -
      b.displayStartSlot -
      (a.displayEndSlot - a.displayStartSlot)
    );
  });

  // Build overlap groups using a more robust algorithm
  const overlapGroups: ProcessedEntry[][] = [];
  const processed = new Set<ProcessedEntry>();

  for (const entry of sortedEntries) {
    if (processed.has(entry)) continue;

    // Start a new group with this entry
    const currentGroup: ProcessedEntry[] = [entry];
    processed.add(entry);

    // Keep expanding the group until no more overlaps are found
    let foundNewOverlap = true;
    while (foundNewOverlap) {
      foundNewOverlap = false;

      for (const candidate of sortedEntries) {
        if (processed.has(candidate)) continue;

        // Check if this candidate overlaps with ANY event in the current group
        const overlapsWithGroup = currentGroup.some((groupEntry) =>
          eventsOverlap(candidate, groupEntry),
        );

        if (overlapsWithGroup) {
          currentGroup.push(candidate);
          processed.add(candidate);
          foundNewOverlap = true;
          // Don't break here - keep checking other candidates in this iteration
        }
      }
    }

    overlapGroups.push(currentGroup);
  }

  const positionedEntries: PositionedEntry[] = [];

  // Process each overlap group separately
  for (const group of overlapGroups) {
    if (group.length === 1) {
      // Single event - no overlap, use full width
      const entry = group[0];
      if (entry) {
        positionedEntries.push({
          ...entry,
          column: 0,
          totalColumns: 1,
          width: 100,
          left: 0,
        });
      }
    } else {
      // Multiple overlapping events - use cascading/staggered layout

      // Sort group by start time for proper stacking order
      const sortedGroup = [...group].sort((a, b) => {
        if (a.displayStartSlot !== b.displayStartSlot) {
          return a.displayStartSlot - b.displayStartSlot;
        }
        return (
          b.displayEndSlot -
          b.displayStartSlot -
          (a.displayEndSlot - a.displayStartSlot)
        );
      });

      sortedGroup.forEach((entry, index) => {
        // Cascading layout parameters
        const offsetStep = 8; // Pixels to offset each event
        const baseWidth = 80; // Width for overlapping events (not the base)
        const widthReduction = 3; // How much to reduce width for each subsequent event

        // Calculate cascading properties
        const totalEvents = sortedGroup.length;

        // First event (index 0) gets full width, others get progressively smaller
        const width =
          index === 0
            ? 100
            : Math.max(60, baseWidth - (index - 1) * widthReduction);

        // Each event is offset to the right (except the first one)
        const leftOffset = index * offsetStep;
        const left = leftOffset;

        positionedEntries.push({
          ...entry,
          column: index,
          totalColumns: totalEvents,
          width,
          left,
          // Add a custom property for pixel-based left positioning
          leftPx: leftOffset,
        });
      });
    }
  }

  return positionedEntries;
};

// Optimized: Create memoized component for day entries to prevent unnecessary re-renders
const DayEntries = memo(
  ({
    day,
    data,
    user,
    handleMouseDown,
    handleMouseEnter,
    handleMouseUp,
    onEventClick,
    currentTime,
  }: {
    day: TZDate;
    data: RouterOutputs["trackerEntries"]["byRange"]["result"] | undefined;
    user: any;
    handleMouseDown: (date: TZDate) => void;
    handleMouseEnter: (date: TZDate) => void;
    handleMouseUp: () => void;
    onEventClick?: (eventId: string, date: TZDate) => void;
    currentTime: Date;
  }) => {
    // Memoize the processed entries to prevent recalculation on every render
    const positionedEntries = useMemo(() => {
      const currentDayStr = format(day, "yyyy-MM-dd");
      const dayData = data?.[currentDayStr] || [];
      const allEntries: ProcessedEntry[] = [];

      // Add entries for current day
      dayData.forEach((event, eventIndex) => {
        const startDate = createSafeDate(event.start);
        const endDate = createSafeDate(event.stop);

        // Convert UTC times to user timezone for display slot calculation
        const displayTimezone = user?.timezone || "UTC";
        let startSlot: number;
        let originalEndSlot: number;

        if (displayTimezone !== "UTC") {
          try {
            const startInUserTz = new TZDate(startDate, displayTimezone);
            const endInUserTz = new TZDate(endDate, displayTimezone);
            startSlot = getSlotFromDate(startInUserTz);
            originalEndSlot = getSlotFromDate(endInUserTz);
          } catch {
            // Fallback with timezone parameter if timezone conversion fails
            startSlot = getSlotFromDate(startDate, displayTimezone);
            originalEndSlot = getSlotFromDate(endDate, displayTimezone);
          }
        } else {
          startSlot = getSlotFromDate(startDate, displayTimezone);
          originalEndSlot = getSlotFromDate(endDate, displayTimezone);
        }

        // Check if this entry spans midnight by comparing actual dates in user timezone
        let startDateStr: string;
        let endDateStr: string;

        if (displayTimezone !== "UTC") {
          try {
            // Convert UTC times to user timezone for proper midnight detection
            const startInUserTz = new TZDate(startDate, displayTimezone);
            const endInUserTz = new TZDate(endDate, displayTimezone);

            startDateStr = format(startInUserTz, "yyyy-MM-dd");
            endDateStr = format(endInUserTz, "yyyy-MM-dd");
          } catch {
            // Fallback to UTC if timezone conversion fails
            startDateStr = format(startDate, "yyyy-MM-dd");
            endDateStr = format(endDate, "yyyy-MM-dd");
          }
        } else {
          startDateStr = format(startDate, "yyyy-MM-dd");
          endDateStr = format(endDate, "yyyy-MM-dd");
        }

        const spansMidnight = startDateStr !== endDateStr;

        let displayStartSlot = startSlot;
        let displayEndSlot = originalEndSlot;
        let isContinuation = false;

        // Check if this is a running timer (no stop time)
        const isRunningTimer = !event.stop || event.stop === null;

        if (isRunningTimer) {
          // Calculate current time slot for running timer
          const currentSlot = getSlotFromDate(currentTime, displayTimezone);
          displayEndSlot = Math.max(startSlot + 1, currentSlot); // At least 1 slot minimum
        } else {
          // Always show entries stored under the current date
          if (event.date === currentDayStr) {
            // This entry was created on this date - show it as the primary display
            if (spansMidnight || originalEndSlot < startSlot) {
              // For midnight-spanning entries or entries that wrap around, extend to end of day
              displayEndSlot = 96; // End of day (extends to midnight)
            }
            // Keep the original start slot even if it appears to be from "yesterday" due to timezone
            // This ensures the entry is visible on the day it was created
          } else if (spansMidnight && endDateStr === currentDayStr) {
            // This is a continuation from a previous day
            // Show the continuation part (from midnight to end time)
            displayStartSlot = 0; // Start of day (midnight)
            displayEndSlot = originalEndSlot; // Original end time converted to user timezone
            isContinuation = true;
          } else {
            // This entry doesn't belong to this day - skip it
            return;
          }
        }

        allEntries.push({
          event,
          eventIndex,
          displayStartSlot,
          displayEndSlot,
          isContinuation,
          spansMidnight,
          isFromCurrentDay: true,
        });
      });

      // Check previous day for entries that continue into current day
      const userTimezone = user?.timezone || "UTC";

      // Simple previous day calculation using the date string directly
      const parts = currentDayStr.split("-").map(Number);
      const year = parts[0]!;
      const month = parts[1]!;
      const dayNum = parts[2]!;
      const previousDateObj = new Date(year, month - 1, dayNum - 1); // month is 0-indexed in JS Date
      const previousDayStr = format(previousDateObj, "yyyy-MM-dd");

      const previousDayData =
        (data && previousDayStr && data[previousDayStr]) || [];

      previousDayData.forEach((event: any, eventIndex: number) => {
        const startDate = createSafeDate(event.start);
        const endDate = createSafeDate(event.stop);

        // Convert to user timezone to check if it spans midnight in their local time
        // userTimezone already declared above
        let startDateStr: string;
        let endDateStr: string;

        if (userTimezone !== "UTC") {
          try {
            const startInUserTz = new TZDate(startDate, userTimezone);
            const endInUserTz = new TZDate(endDate, userTimezone);

            startDateStr = format(startInUserTz, "yyyy-MM-dd");
            endDateStr = format(endInUserTz, "yyyy-MM-dd");
          } catch {
            // Fallback to UTC if timezone conversion fails
            startDateStr = format(startDate, "yyyy-MM-dd");
            endDateStr = format(endDate, "yyyy-MM-dd");
          }
        } else {
          startDateStr = format(startDate, "yyyy-MM-dd");
          endDateStr = format(endDate, "yyyy-MM-dd");
        }

        const spansMidnight = startDateStr !== endDateStr;

        // If this entry from previous day ends on current day
        if (spansMidnight && endDateStr === currentDayStr) {
          // Convert UTC to user timezone for continuation slot calculation
          let originalEndSlot: number;
          if (userTimezone !== "UTC") {
            try {
              const endInUserTz = new TZDate(endDate, userTimezone);
              originalEndSlot = getSlotFromDate(endInUserTz);
            } catch {
              originalEndSlot = getSlotFromDate(endDate, userTimezone);
            }
          } else {
            originalEndSlot = getSlotFromDate(endDate, userTimezone);
          }

          allEntries.push({
            event,
            eventIndex: `prev-${eventIndex}`,
            displayStartSlot: 0, // Start of day
            displayEndSlot: originalEndSlot,
            isContinuation: true,
            spansMidnight,
            isFromCurrentDay: false,
          });
        }
      });

      // Calculate positions for overlapping events
      return calculateEventPositions(allEntries);
    }, [day, data, user?.timezone, currentTime]);

    return (
      <>
        {positionedEntries.map((entry) => {
          const top = entry.displayStartSlot * SLOT_HEIGHT;
          const height = Math.max(
            (entry.displayEndSlot - entry.displayStartSlot) * SLOT_HEIGHT,
            20,
          );

          // Check if this is a running timer
          const isRunningTimer = !entry.event.stop || entry.event.stop === null;

          const handleEventClick = () => {
            if (entry.isContinuation) {
              // If this is a continuation entry, select the previous day (original day)
              // Don't select the event for split events, just navigate to the day
              const previousDay = new Date(day);
              previousDay.setDate(previousDay.getDate() - 1);
              const previousDayTZ = new TZDate(previousDay, "UTC");
              handleMouseDown(previousDayTZ);
            } else {
              // Normal event click behavior - select the event if we have onEventClick
              if (onEventClick) {
                onEventClick(entry.event.id, day);
              } else {
                // Fallback to just selecting the day
                handleMouseDown(day);
              }
            }
          };

          return (
            <div
              key={`${entry.event.id}-${entry.eventIndex}`}
              className={cn(
                "absolute text-xs p-2 overflow-hidden cursor-pointer transition-colors",
                // Same styling for all events
                "bg-[#F0F0F0] dark:bg-[#1D1D1D] text-[#606060] dark:text-[#878787] hover:bg-[#E8E8E8] dark:hover:bg-[#252525]",
                entry.totalColumns > 1 && entry.column > 0
                  ? "border border-border"
                  : "",
              )}
              style={{
                top: `${top}px`,
                height: `${height}px`,
                left:
                  entry.leftPx !== undefined
                    ? `${entry.leftPx}px`
                    : `${entry.left}%`,
                width:
                  entry.leftPx !== undefined
                    ? `calc(${entry.width}% - ${entry.leftPx}px)`
                    : `${entry.width}%`,
                zIndex: entry.totalColumns > 1 ? 20 + entry.column : 10,
              }}
              onMouseDown={handleEventClick}
              onMouseEnter={() => {
                if (entry.spansMidnight) {
                  const allParts = document.querySelectorAll(
                    `[data-event-id="${entry.event.id}"]`,
                  );
                  for (const part of allParts) {
                    part.classList.add("!bg-[#E8E8E8]", "dark:!bg-[#252525]");
                  }
                }
                handleMouseEnter(day);
              }}
              onMouseLeave={() => {
                if (entry.spansMidnight) {
                  const allParts = document.querySelectorAll(
                    `[data-event-id="${entry.event.id}"]`,
                  );
                  for (const part of allParts) {
                    part.classList.remove(
                      "!bg-[#E8E8E8]",
                      "dark:!bg-[#252525]",
                    );
                  }
                }
              }}
              onMouseUp={handleMouseUp}
              data-event-id={entry.event.id}
            >
              <div className="font-medium truncate leading-tight flex items-center gap-1">
                {/* Subtle green dot indicator for running timers */}
                {isRunningTimer && (
                  <span className="relative flex h-1 w-1 flex-shrink-0">
                    <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-500 opacity-75" />
                    <span className="relative inline-flex rounded-full h-1 w-1 bg-green-500" />
                  </span>
                )}
                <span className="truncate">
                  {entry.event.trackerProject?.name || "No Project"}
                  {entry.spansMidnight && entry.isFromCurrentDay && " →"}
                  {entry.isContinuation && " ←"}
                </span>
                {height <= 40 && height > 16 && (
                  <span className="font-normal text-[#878787] dark:text-[#606060] flex-shrink-0">
                    {" ("}
                    {isRunningTimer
                      ? secondsToHoursAndMinutes(
                          Math.max(
                            0,
                            Math.round(
                              (currentTime.getTime() -
                                createSafeDate(entry.event.start).getTime()) /
                                1000,
                            ),
                          ),
                        )
                      : secondsToHoursAndMinutes(
                          entry.spansMidnight || entry.isContinuation
                            ? (entry.displayEndSlot - entry.displayStartSlot) *
                                15 *
                                60 // Use slot-based calculation for split events
                            : (entry.event.duration ?? 0), // Use original duration for normal events
                        )}
                    {")"}
                  </span>
                )}
              </div>
              {height > 40 && (
                <div className="truncate text-[#878787] dark:text-[#606060]">
                  (
                  {isRunningTimer
                    ? secondsToHoursAndMinutes(
                        Math.max(
                          0,
                          Math.round(
                            (currentTime.getTime() -
                              createSafeDate(entry.event.start).getTime()) /
                              1000,
                          ),
                        ),
                      )
                    : secondsToHoursAndMinutes(
                        entry.spansMidnight || entry.isContinuation
                          ? (entry.displayEndSlot - entry.displayStartSlot) *
                              15 *
                              60 // Use slot-based calculation for split events
                          : (entry.event.duration ?? 0), // Use original duration for normal events
                      )}
                  )
                </div>
              )}
            </div>
          );
        })}
      </>
    );
  },
);

DayEntries.displayName = "DayEntries";

// Optimized: Main component with memoization
export const CalendarWeekView = memo(
  ({
    weekDays,
    currentDate,
    data,
    handleMouseDown,
    handleMouseEnter,
    handleMouseUp,
    onEventClick,
  }: CalendarWeekViewProps) => {
    const { data: user } = useUserQuery();
    const is24Hour = user?.timeFormat === 24;

    // State to force re-render for running timers
    const [currentTime, setCurrentTime] = useState(new Date());

    // Update current time every 5 seconds for running timers
    useEffect(() => {
      // Check if any running timers exist across all days
      const hasRunningTimers =
        data &&
        Object.values(data).some((dayData) =>
          dayData.some((event) => !event.stop || event.stop === null),
        );

      if (hasRunningTimers) {
        const interval = setInterval(() => {
          setCurrentTime(new Date());
        }, 5000); // Update every 5 seconds for better visual feedback

        return () => clearInterval(interval);
      }
    }, [data]);

    return (
      <div className="flex flex-col border border-border border-b-0">
        <div
          className="grid gap-px bg-border border-b border-border"
          style={{
            gridTemplateColumns: is24Hour
              ? "55px repeat(7, 1fr)"
              : "80px repeat(7, 1fr)",
          }}
        >
          {/* Empty space above time column */}
          <div className="py-4 px-2 bg-background" />

          {/* Day headers - name and date on same row */}
          {weekDays.map((day) => (
            <div
              key={`header-${day.toString()}`}
              className="py-4 px-2 bg-background text-xs font-medium text-[#878787] font-mono text-center"
            >
              <div className="flex flex-row items-end justify-center gap-2">
                <span className="uppercase">{format(day, "EEE")}</span>
                <span className="text-foreground font-medium">
                  {format(day, "d")}
                </span>
                {day.getMonth() !== currentDate.getMonth() && (
                  <span className="text-[[10px] text-[#878787] uppercase">
                    {format(day, "MMM")}
                  </span>
                )}
              </div>
            </div>
          ))}
        </div>

        {/* Time grid and events */}
        <div
          className="grid gap-px bg-border flex-1"
          style={{
            gridTemplateColumns: is24Hour
              ? "55px repeat(7, 1fr)"
              : "80px repeat(7, 1fr)",
          }}
        >
          {/* Time labels column */}
          <div className="bg-background">
            {hours.slice(0, -1).map(
              (
                hour, // Remove the last hour (24) to avoid duplication
              ) => (
                <div
                  key={hour}
                  className="flex items-center justify-center text-[12px] text-[#878787] font-mono border-b border-border"
                  style={{ height: `${HOUR_HEIGHT}px` }}
                >
                  {hour < 24 && formatHour(hour, user?.timeFormat)}
                </div>
              ),
            )}
          </div>

          {/* Days columns */}
          {weekDays.map((day) => {
            const dayKey = format(day, "yyyy-MM-dd");

            return (
              <div key={dayKey} className="relative bg-background">
                {/* Hour grid lines */}
                {hours.slice(0, -1).map((hour) => {
                  return (
                    <div
                      key={`${dayKey}-${hour}`}
                      className={cn(
                        "hover:bg-muted/10 transition-colors cursor-pointer border-b border-border relative group",
                      )}
                      style={{ height: `${HOUR_HEIGHT}px` }}
                      onMouseDown={() => handleMouseDown(day)}
                      onMouseEnter={() => handleMouseEnter(day)}
                      onMouseUp={handleMouseUp}
                    >
                      {/* Hour hover indicator */}
                      <div className="absolute inset-0 bg-primary/5 opacity-0 group-hover:opacity-100 pointer-events-none" />

                      {/* Time indicator on hover */}
                      <div className="absolute left-1 top-0.5 text-xs font-mono text-muted-foreground opacity-0 group-hover:opacity-100 pointer-events-none bg-background/80 px-1 rounded">
                        {formatHour(hour, user?.timeFormat)}
                      </div>
                    </div>
                  );
                })}

                {/* Events for this day */}
                <DayEntries
                  day={day}
                  data={data}
                  user={user}
                  handleMouseDown={handleMouseDown}
                  handleMouseEnter={handleMouseEnter}
                  handleMouseUp={handleMouseUp}
                  onEventClick={onEventClick}
                  currentTime={currentTime}
                />
              </div>
            );
          })}
        </div>
      </div>
    );
  },
);

CalendarWeekView.displayName = "CalendarWeekView";
</file>

<file path="apps/dashboard/src/components/tracker/events.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { secondsToHoursAndMinutes } from "@/utils/format";
import { createSafeDate } from "@/utils/tracker";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { TZDate } from "@date-fns/tz";
import { cn } from "@midday/ui/cn";
import { format } from "date-fns";
import { memo, useEffect, useMemo, useState } from "react";

type Props = {
  data: any[];
  isToday: boolean;
  allData: RouterOutputs["trackerEntries"]["byRange"]["result"] | undefined;
  currentDate: TZDate;
  onEventClick?: (eventId: string, date: TZDate) => void;
};

export const TrackerEvents = memo(
  ({ data, isToday, allData, currentDate, onEventClick }: Props) => {
    const { data: user } = useUserQuery();

    // State to force re-render for running timers
    const [currentTime, setCurrentTime] = useState(new Date());

    // Process entries to handle midnight spanning - EXACTLY like weekly calendar
    const processedEntries = useMemo(() => {
      // currentDate is already a TZDate in user timezone (like weekly calendar)
      const currentDayStr = format(currentDate, "yyyy-MM-dd");
      const userTimezone = user?.timezone || "UTC";
      const allEntries = [];

      // FIRST LOOP: Process current day data (exactly like weekly calendar)
      const currentDayData = allData?.[currentDayStr] || [];

      for (const event of currentDayData) {
        const startDate = createSafeDate(event.start);
        const endDate = createSafeDate(event.stop);

        // Check if this entry spans midnight - EXACT same logic as weekly calendar
        let startDateStr: string;
        let endDateStr: string;

        if (userTimezone !== "UTC") {
          try {
            const startInUserTz = new TZDate(startDate, userTimezone);
            const endInUserTz = new TZDate(endDate, userTimezone);
            startDateStr = format(startInUserTz, "yyyy-MM-dd");
            endDateStr = format(endInUserTz, "yyyy-MM-dd");
          } catch {
            // Fallback to UTC if timezone conversion fails
            startDateStr = format(startDate, "yyyy-MM-dd");
            endDateStr = format(endDate, "yyyy-MM-dd");
          }
        } else {
          startDateStr = format(startDate, "yyyy-MM-dd");
          endDateStr = format(endDate, "yyyy-MM-dd");
        }

        const spansMidnight = startDateStr !== endDateStr;

        // Always show entries stored under the current date
        if (event.date === currentDayStr) {
          // This entry was created on this date - show it as the primary display
          allEntries.push({
            ...event,
            isFirstPart: spansMidnight, // Show arrow if spans midnight
            isContinuation: false,
            originalDuration: event.duration,
            sortKey: `${event.date}-${event.start}`,
          });
        } else if (spansMidnight && endDateStr === currentDayStr) {
          // This is a continuation from a previous day
          // Show the continuation part (from midnight to end time)
          allEntries.push({
            ...event,
            isFirstPart: false,
            isContinuation: true,
            originalDuration: event.duration,
            sortKey: `${event.date}-${event.start}`,
          });
        }
        // If entry doesn't belong to this day, skip it (same as weekly calendar)
      }

      // SECOND LOOP: Check previous day for entries that continue into current day (exactly like weekly calendar)
      // Simple previous day calculation using the date string directly (same as weekly)
      const parts = currentDayStr.split("-").map(Number);
      const year = parts[0]!;
      const month = parts[1]!;
      const dayNum = parts[2]!;
      const previousDateObj = new Date(year, month - 1, dayNum - 1); // month is 0-indexed in JS Date
      const previousDayStr = format(previousDateObj, "yyyy-MM-dd");

      const previousDayData =
        (allData && previousDayStr && allData[previousDayStr]) || [];

      for (const event of previousDayData) {
        const startDate = createSafeDate(event.start);
        const endDate = createSafeDate(event.stop);

        // Convert to user timezone to check if it spans midnight in their local time
        let startDateStr: string;
        let endDateStr: string;

        if (userTimezone !== "UTC") {
          try {
            const startInUserTz = new TZDate(startDate, userTimezone);
            const endInUserTz = new TZDate(endDate, userTimezone);

            startDateStr = format(startInUserTz, "yyyy-MM-dd");
            endDateStr = format(endInUserTz, "yyyy-MM-dd");
          } catch {
            // Fallback to UTC if timezone conversion fails
            startDateStr = format(startDate, "yyyy-MM-dd");
            endDateStr = format(endDate, "yyyy-MM-dd");
          }
        } else {
          startDateStr = format(startDate, "yyyy-MM-dd");
          endDateStr = format(endDate, "yyyy-MM-dd");
        }

        const spansMidnight = startDateStr !== endDateStr;

        // If this entry from previous day ends on current day
        if (spansMidnight && endDateStr === currentDayStr) {
          allEntries.push({
            ...event,
            isFirstPart: false,
            isContinuation: true,
            originalDuration: event.duration,
            sortKey: `${event.date}-${event.start}`,
          });
        }
      }

      // Sort entries by start time for consistent display
      allEntries.sort((a, b) => a.sortKey.localeCompare(b.sortKey));

      return allEntries;
    }, [allData, currentDate, currentTime, user?.timezone]);

    // Update current time every 5 seconds for running timers
    useEffect(() => {
      // Check if any running timers exist in processed entries
      const hasRunningTimers = processedEntries.some(
        (entry) => !entry.stop || entry.stop === null,
      );

      if (hasRunningTimers) {
        const interval = setInterval(() => {
          setCurrentTime(new Date());
        }, 5000); // Update every 5 seconds for better visual feedback

        return () => clearInterval(interval);
      }
    }, [processedEntries]);

    return (
      <div className="flex flex-col space-y-2 font-sans w-full overflow-hidden">
        {processedEntries.map((entry, index) => {
          if (index === 0) {
            // Check if this is a running timer
            const isRunningTimer = !entry.stop || entry.stop === null;

            // Calculate elapsed time for running timers
            const displayDuration = isRunningTimer
              ? Math.max(
                  0,
                  Math.round(
                    (currentTime.getTime() -
                      createSafeDate(entry.start).getTime()) /
                      1000,
                  ),
                )
              : (entry.duration ?? 0);

            // Show the first event (chronologically)
            return (
              <div
                key={entry.id}
                className={cn(
                  "text-xs p-1 w-full text-left min-h-[23px] flex items-center overflow-hidden transition-colors",
                  // Same styling for all events
                  "bg-[#F0F0F0] dark:bg-[#1D1D1D] text-[#606060] dark:text-[#878787]",
                  (entry.isContinuation || onEventClick) && "cursor-pointer", // Show cursor for continuation events or when event click is enabled
                  isToday && "!bg-background",
                )}
                data-is-continuation={entry.isContinuation}
                data-event-id={entry.id}
              >
                <div className="truncate w-full flex items-center gap-1">
                  {/* Subtle green dot indicator for running timers */}
                  {isRunningTimer && (
                    <span className="relative flex h-1 w-1 flex-shrink-0">
                      <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-500 opacity-75" />
                      <span className="relative inline-flex rounded-full h-1 w-1 bg-green-500" />
                    </span>
                  )}
                  <span className="truncate">
                    {entry.trackerProject?.name || "No Project"}
                    {entry.isFirstPart && " →"}
                    {entry.isContinuation && " ←"}
                    {" ("}
                    {secondsToHoursAndMinutes(displayDuration)}
                    {")"}
                  </span>
                </div>
              </div>
            );
          }
          return null;
        })}
        {processedEntries.length > 1 && (
          <div
            className="text-xs text-primary p-1 w-full text-left cursor-pointer overflow-hidden"
            data-show-all-events="true"
          >
            <div className="truncate">+{processedEntries.length - 1} more</div>
          </div>
        )}
      </div>
    );
  },
);

TrackerEvents.displayName = "TrackerEvents";
</file>

<file path="apps/dashboard/src/components/tracker/utils.ts">
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { TZDate } from "@date-fns/tz";
import { addMonths, formatISO, subMonths } from "date-fns";

export function handleMonthChange(direction: number, currentDate: TZDate) {
  const { setParams } = useTrackerParams();
  const newDate =
    direction > 0 ? addMonths(currentDate, 1) : subMonths(currentDate, 1);
  setParams({
    date: formatISO(newDate, { representation: "date" }),
  });
}

export function checkIsInRange(
  date: TZDate,
  isDragging: boolean,
  localRange: [string | null, string | null],
  range: [string, string] | null,
): boolean {
  if (isDragging && localRange[0] && localRange[1]) {
    const start = new TZDate(localRange[0], "UTC");
    const end = new TZDate(localRange[1], "UTC");
    const minDate = new TZDate(Math.min(start.getTime(), end.getTime()), "UTC");
    const maxDate = new TZDate(Math.max(start.getTime(), end.getTime()), "UTC");
    return date > minDate && date < maxDate;
  }
  if (!isDragging && range && range.length === 2) {
    const start = new TZDate(range[0], "UTC");
    const end = new TZDate(range[1], "UTC");
    const minDate = new TZDate(Math.min(start.getTime(), end.getTime()), "UTC");
    const maxDate = new TZDate(Math.max(start.getTime(), end.getTime()), "UTC");
    return date > minDate && date < maxDate;
  }
  return false;
}

export function checkIsFirstSelectedDate(
  date: TZDate,
  isDragging: boolean,
  localRange: [string | null, string | null],
  range: [string, string] | null,
): boolean {
  const formattedDate = formatISO(date, { representation: "date" });
  if (isDragging && localRange[0]) {
    const start = new TZDate(localRange[0], "UTC");
    const end = localRange[1] ? new TZDate(localRange[1], "UTC") : start;
    const firstDate = new TZDate(
      Math.min(start.getTime(), end.getTime()),
      "UTC",
    );
    return formattedDate === formatISO(firstDate, { representation: "date" });
  }
  if (!isDragging && range && range.length === 2) {
    const start = new TZDate(range[0], "UTC");
    const end = new TZDate(range[1], "UTC");
    const firstDate = new TZDate(
      Math.min(start.getTime(), end.getTime()),
      "UTC",
    );
    return formattedDate === formatISO(firstDate, { representation: "date" });
  }
  return false;
}

export function checkIsLastSelectedDate(
  date: TZDate,
  isDragging: boolean,
  localRange: [string | null, string | null],
  range: [string, string] | null,
): boolean {
  const formattedDate = formatISO(date, { representation: "date" });
  if (isDragging && localRange[0] && localRange[1]) {
    const start = new TZDate(localRange[0], "UTC");
    const end = new TZDate(localRange[1], "UTC");
    const lastDate = new TZDate(
      Math.max(start.getTime(), end.getTime()),
      "UTC",
    );
    return formattedDate === formatISO(lastDate, { representation: "date" });
  }
  if (!isDragging && range && range.length === 2) {
    const start = new TZDate(range[0], "UTC");
    const end = new TZDate(range[1], "UTC");
    const lastDate = new TZDate(
      Math.max(start.getTime(), end.getTime()),
      "UTC",
    );
    return formattedDate === formatISO(lastDate, { representation: "date" });
  }
  return false;
}
</file>

<file path="apps/dashboard/src/components/vault/empty-states.tsx">
"use client";

import { useDocumentFilterParams } from "@/hooks/use-document-filter-params";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { VaultGridSkeleton } from "./vault-grid-skeleton";

export function NoResults() {
  const { setFilter } = useDocumentFilterParams();

  return (
    <div className="h-screen w-full flex items-center justify-center flex-col">
      <div className="flex flex-col items-center -mt-[160px]">
        <Icons.Transactions2 className="mb-4" />
        <div className="text-center mb-6 space-y-2">
          <h2 className="font-medium text-lg">No results</h2>
          <p className="text-[#606060] text-sm">Try another search term</p>
        </div>

        <Button variant="outline" onClick={() => setFilter(null)}>
          Clear search
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-actions.tsx">
"use client";

import { VaultViewSwitch } from "@/components/vault/vault-view-switch";
import { VaultUploadButton } from "./vault-upload-button";

export function VaultActions() {
  return (
    <div className="space-x-2 hidden md:flex">
      <VaultViewSwitch />
      <VaultUploadButton />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-get-started.tsx">
import { Button } from "@midday/ui/button";

export function VaultGetStarted() {
  return (
    <div className="h-[calc(100vh-250px)] flex items-center justify-center">
      <div className="relative z-20 m-auto flex w-full max-w-[380px] flex-col">
        <div className="flex w-full flex-col relative text-center">
          <div className="pb-4">
            <h2 className="font-medium text-lg">Always find what you need</h2>
          </div>

          <p className="pb-6 text-sm text-[#878787]">
            Drag & drop or upload your documents. We'll automatically organize
            them with tags based on content, making them easy and secure to
            find.
          </p>

          <Button
            variant="outline"
            onClick={() => document.getElementById("upload-files")?.click()}
          >
            Upload
          </Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-grid-skeleton.tsx">
import { VaultItemSkeleton } from "./vault-item-skeleton";

export function VaultGridSkeleton() {
  return (
    <div>
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 3xl:grid-cols-6 gap-8">
        {Array.from({ length: 12 }).map((_, index) => (
          <VaultItemSkeleton key={index.toString()} />
        ))}
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-grid.tsx">
"use client";

import { VaultItem } from "@/components/vault/vault-item";
import { useDocumentFilterParams } from "@/hooks/use-document-filter-params";
import { useDocumentParams } from "@/hooks/use-document-params";
import { useRealtime } from "@/hooks/use-realtime";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import {
  useQueryClient,
  useSuspenseInfiniteQuery,
} from "@tanstack/react-query";
import { useEffect, useMemo } from "react";
import { useInView } from "react-intersection-observer";
import { useDebounceCallback } from "usehooks-ts";
import { LoadMore } from "../load-more";
import { NoResults } from "./empty-states";
import { VaultGetStarted } from "./vault-get-started";

export function VaultGrid() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { data: user } = useUserQuery();
  const { ref, inView } = useInView();

  const { filter, hasFilters } = useDocumentFilterParams();
  const { params } = useDocumentParams();

  const infiniteQueryOptions = trpc.documents.get.infiniteQueryOptions(
    {
      pageSize: 20,
      ...filter,
    },
    {
      getNextPageParam: ({ meta }) => meta?.cursor,
    },
  );

  const { data, fetchNextPage, hasNextPage, refetch, isFetching } =
    useSuspenseInfiniteQuery(infiniteQueryOptions);

  const documents = useMemo(() => {
    return data?.pages.flatMap((page) => page.data) ?? [];
  }, [data]);

  useEffect(() => {
    if (inView) {
      fetchNextPage();
    }
  }, [inView]);

  const debouncedEventHandler = useDebounceCallback(() => {
    refetch();

    queryClient.invalidateQueries({
      queryKey: trpc.documents.get.queryKey(),
    });

    queryClient.invalidateQueries({
      queryKey: trpc.documents.get.infiniteQueryKey(),
    });

    // Invalidate global search
    queryClient.invalidateQueries({
      queryKey: trpc.search.global.queryKey(),
    });
  }, 50);

  useRealtime({
    channelName: "realtime_documents",
    table: "documents",
    filter: `team_id=eq.${user?.teamId}`,
    onEvent: (payload) => {
      if (
        payload.eventType === "INSERT" ||
        (payload.eventType === "UPDATE" && params.view === "grid")
      ) {
        debouncedEventHandler();
      }
    },
  });

  if (hasFilters && !documents?.length) {
    return <NoResults />;
  }

  if (!documents?.length && !isFetching) {
    return <VaultGetStarted />;
  }

  return (
    <div>
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 3xl:grid-cols-6 gap-8">
        {documents.map((document) => (
          // @ts-expect-error
          <VaultItem key={document.id} data={document} />
        ))}
      </div>

      <LoadMore ref={ref} hasNextPage={hasNextPage} />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-header.tsx">
"use client";

import { VaultActions } from "@/components/vault/vault-actions";
import { VaultSearchFilter } from "@/components/vault/vault-search-filter";

export function VaultHeader() {
  return (
    <div className="flex justify-between py-6">
      <VaultSearchFilter />
      <VaultActions />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-item-actions.tsx">
"use client";

import { downloadFile } from "@/lib/download";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useState } from "react";
import { useCopyToClipboard } from "usehooks-ts";

type Props = {
  id: string;
  filePath: string[];
  hideDelete?: boolean;
};

export function VaultItemActions({ id, filePath, hideDelete }: Props) {
  const [, copy] = useCopyToClipboard();
  const [isCopied, setIsCopied] = useState(false);
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const downloadUrl = `/api/download/file?path=${filePath.join("/")}`;
  const fileName = filePath.at(-1);

  const shortLinkMutation = useMutation(
    trpc.shortLinks.createForDocument.mutationOptions({
      onMutate: () => {
        setIsCopied(true);
      },
      onSuccess: (data) => {
        if (data?.shortUrl) {
          copy(data.shortUrl);

          setTimeout(() => {
            setIsCopied(false);
          }, 3000);
        }
      },
    }),
  );

  const deleteDocumentMutation = useMutation(
    trpc.documents.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.documents.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.search.global.queryKey(),
        });
      },
    }),
  );

  return (
    <div className="flex flex-row gap-2">
      <Button
        variant="outline"
        size="icon"
        className="rounded-full size-7 bg-background"
        onClick={() => {
          downloadFile(
            `${downloadUrl}&filename=${fileName}`,
            fileName || "download",
          );
        }}
      >
        <Icons.ArrowCoolDown className="size-3.5" />
      </Button>

      <Button
        variant="outline"
        size="icon"
        type="button"
        onClick={() =>
          shortLinkMutation.mutate({
            filePath: filePath.join("/"),
            expireIn: 60 * 60 * 24 * 30, // 30 days
          })
        }
        className="rounded-full size-7 bg-background"
      >
        {isCopied ? (
          <Icons.Check className="size-3.5 -mt-0.5" />
        ) : (
          <Icons.Copy className="size-3.5" />
        )}
      </Button>

      {!hideDelete && (
        <Button
          variant="outline"
          size="icon"
          className="rounded-full size-7 bg-background"
          onClick={() => deleteDocumentMutation.mutate({ id })}
        >
          <Icons.Delete className="size-3.5" />
        </Button>
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-item-skeleton.tsx">
import { cn } from "@midday/ui/cn";
import { Skeleton } from "@midday/ui/skeleton";

type Props = {
  small?: boolean;
};

export function VaultItemSkeleton({ small }: Props) {
  return (
    <div
      className={cn(
        "h-72 border relative flex p-4 flex-col gap-3",
        small && "h-48",
      )}
    >
      {/* Skeleton for the preview area */}
      <Skeleton
        className={cn("w-[60px] h-[84px]", small && "w-[45px] h-[63px]")}
      />

      {/* Skeleton for title and summary */}
      <div className="flex flex-col mt-3 gap-2">
        <Skeleton className="w-[80%] h-4" />
        <Skeleton className="w-full h-4" />
        <Skeleton className="w-[90%] h-4" />
      </div>

      {/* Skeleton for tags */}
      {!small && (
        <div className="flex gap-2 mt-auto">
          <Skeleton className="w-16 h-6 rounded-full" />
          <Skeleton className="w-20 h-6 rounded-full" />
          <Skeleton className="w-14 h-6 rounded-full" />
        </div>
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-item-tags.tsx">
"use client";

import { useDocumentFilterParams } from "@/hooks/use-document-filter-params";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Badge } from "@midday/ui/badge";
import { Skeleton } from "@midday/ui/skeleton";

type Props = {
  tags: RouterOutputs["documents"]["get"]["data"][number]["documentTagAssignments"];
  isLoading: boolean;
};

export function VaultItemTags({ tags, isLoading }: Props) {
  const { setFilter } = useDocumentFilterParams();

  if (isLoading) {
    return (
      <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide mt-auto">
        {[...Array(3)].map((_, index) => (
          <Skeleton
            key={index.toString()}
            className={`h-6 rounded-full ${
              index % 3 === 0 ? "w-16" : index % 3 === 1 ? "w-20" : "w-24"
            }`}
          />
        ))}
      </div>
    );
  }

  return (
    <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide mt-auto">
      {tags?.map((tag) => (
        <button
          key={tag.documentTag.id}
          type="button"
          onClick={() => {
            setFilter({
              tags: [tag.documentTag.id],
            });
          }}
        >
          <Badge
            variant="tag-rounded"
            className="whitespace-nowrap shrink-0 text-[10px]"
          >
            {tag.documentTag.name}
          </Badge>
        </button>
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-item.tsx">
"use client";

import { FilePreview } from "@/components/file-preview";
import { VaultItemTags } from "@/components/vault/vault-item-tags";
import { useDocumentParams } from "@/hooks/use-document-params";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { cn } from "@midday/ui/cn";
import { Skeleton } from "@midday/ui/skeleton";
import { VaultItemActions } from "./vault-item-actions";

type Props = {
  data: Partial<RouterOutputs["documents"]["get"]["data"][number]> & {
    id: string;
    name?: string | null;
    metadata: Record<string, unknown>;
    pathTokens: string[];
    title: string;
    summary: string;
  };
  small?: boolean;
};

export function VaultItem({ data, small }: Props) {
  const { setParams } = useDocumentParams();

  const isLoading = data.processingStatus === "pending";

  return (
    <div
      className={cn(
        "h-72 border relative flex text-muted-foreground p-4 flex-col gap-3 hover:bg-muted dark:hover:bg-[#141414] transition-colors duration-200 group",
        small && "h-48",
      )}
    >
      <div className="absolute top-4 right-4 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
        <VaultItemActions
          id={data.id}
          filePath={data.pathTokens ?? []}
          hideDelete={small}
        />
      </div>

      <button
        type="button"
        className={cn(
          "w-[60px] h-[84px] flex items-center justify-center",
          small && "w-[45px] h-[63px]",
          (data?.metadata as { mimetype?: string })?.mimetype?.startsWith(
            "image/",
          ) && "bg-border",
        )}
        onClick={() => {
          setParams({ documentId: data.id });
        }}
      >
        {data?.metadata?.mimetype === "image/heic" && isLoading ? (
          // NOTE: We convert the heic images to jpeg in the backend, so we need to wait for the image to be processed
          // Otherwise the image will be a broken image, and the cache will not be updated
          <Skeleton className="absolute inset-0 w-full h-full" />
        ) : (
          <FilePreview
            filePath={data?.pathTokens?.join("/") ?? ""}
            mimeType={(data?.metadata as { mimetype?: string })?.mimetype ?? ""}
          />
        )}
      </button>

      <button
        type="button"
        className="flex flex-col text-left"
        onClick={() => {
          setParams({ documentId: data.id });
        }}
      >
        {
          <h2 className="text-sm text-primary line-clamp-1 mb-2 mt-3">
            {isLoading ? (
              <Skeleton className="w-[80%] h-4" />
            ) : (
              (data?.title ?? data?.name?.split("/").at(-1))
            )}
          </h2>
        }

        {isLoading ? (
          <Skeleton className="w-[50%] h-4" />
        ) : (
          <p className="text-xs text-muted-foreground line-clamp-3">
            {data?.summary}
          </p>
        )}
      </button>

      {!small && (
        <VaultItemTags
          tags={data?.documentTagAssignments ?? []}
          isLoading={isLoading}
        />
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-related-files-skeleton.tsx">
export function VaultRelatedFilesSkeleton() {
  return (
    <div className="relative mt-2">
      <div className="flex flex-col mb-4">
        <h2 className="text-sm font-medium">Related Files</h2>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-related-files.tsx">
"use client";

import { useDocumentParams } from "@/hooks/use-document-params";
import { useTRPC } from "@/trpc/client";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { Carousel, CarouselContent, CarouselItem } from "@midday/ui/carousel";
import { useQuery } from "@tanstack/react-query";
import * as React from "react";
import { VaultItem } from "./vault-item";
import { VaultRelatedFilesSkeleton } from "./vault-related-files-skeleton";

export function VaultRelatedFiles() {
  const trpc = useTRPC();
  const { params } = useDocumentParams();

  const { data, isLoading } = useQuery(
    trpc.documents.getRelatedDocuments.queryOptions(
      {
        pageSize: 12,
        id: params?.documentId!,
      },
      {
        enabled: !!params?.documentId,
      },
    ),
  );

  if (isLoading) {
    return <VaultRelatedFilesSkeleton />;
  }

  if (!data?.length) {
    return null;
  }

  return (
    <Accordion className="relative mt-2" type="single" collapsible>
      <AccordionItem value="related-files">
        <AccordionTrigger className="text-sm font-medium">
          Related Files
        </AccordionTrigger>
        <AccordionContent>
          <Carousel
            opts={{
              align: "start",
            }}
          >
            <CarouselContent>
              {data?.map((document) => (
                <CarouselItem key={document.id} className="basis-1/3">
                  <VaultItem data={document} small />
                </CarouselItem>
              ))}
            </CarouselContent>
          </Carousel>
        </AccordionContent>
      </AccordionItem>
    </Accordion>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-search-filter.tsx">
"use client";

import { generateVaultFilters } from "@/actions/ai/filters/generate-vault-filters";
import { FilterList } from "@/components/filter-list";
import { useDocumentFilterParams } from "@/hooks/use-document-filter-params";
import { useTRPC } from "@/trpc/client";
import { Calendar } from "@midday/ui/calendar";
import { cn } from "@midday/ui/cn";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { Input } from "@midday/ui/input";
import { useQuery } from "@tanstack/react-query";
import { readStreamableValue } from "ai/rsc";
import { formatISO } from "date-fns";
import { useRef, useState } from "react";
import { useHotkeys } from "react-hotkeys-hook";

export function VaultSearchFilter() {
  const inputRef = useRef<HTMLInputElement>(null);
  const [streaming, setStreaming] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const trpc = useTRPC();

  const { filter, setFilter } = useDocumentFilterParams();
  const [prompt, setPrompt] = useState(filter.q ?? "");

  const shouldFetch = isOpen;

  const { data: tagsData } = useQuery({
    ...trpc.documentTags.get.queryOptions(),
    enabled: shouldFetch || Boolean(filter.tags?.length),
  });

  useHotkeys(
    "esc",
    () => {
      setPrompt("");
      setFilter(null);
      setIsOpen(false);
    },
    {
      enableOnFormTags: true,
      enabled: Boolean(prompt) && isFocused,
    },
  );

  useHotkeys("meta+s", (evt) => {
    evt.preventDefault();
    inputRef.current?.focus();
  });

  const handleSearch = (evt: React.ChangeEvent<HTMLInputElement>) => {
    const value = evt.target.value;

    if (value) {
      setPrompt(value);
    } else {
      setFilter(null);
      setPrompt("");
    }
  };

  const handleSubmit = async () => {
    // If the user is typing a query with multiple words, we want to stream the results
    if (prompt.split(" ").length > 1) {
      setStreaming(true);

      const { object } = await generateVaultFilters(prompt);

      let finalObject = {};

      for await (const partialObject of readStreamableValue(object)) {
        if (partialObject) {
          finalObject = {
            ...finalObject,
            ...partialObject,
            start: partialObject?.start ?? null,
            end: partialObject?.end ?? null,
            q: partialObject?.name ?? null,
          };
        }
      }

      setFilter({
        q: null,
        ...finalObject,
      });

      setStreaming(false);
    } else {
      setFilter({ q: prompt.length > 0 ? prompt : null });
    }
  };

  const validFilters = Object.fromEntries(
    Object.entries(filter).filter(([key]) => key !== "q"),
  );

  const hasValidFilters = Object.values(validFilters).some(
    (value) => value !== null,
  );

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <div className="flex space-x-4 items-center">
        <form
          className="relative"
          onSubmit={(e) => {
            e.preventDefault();
            handleSubmit();
          }}
        >
          <Icons.Search className="absolute pointer-events-none left-3 top-[11px]" />
          <Input
            ref={inputRef}
            placeholder="Search or type filter"
            className="pl-9 w-full md:w-[350px] pr-8"
            value={prompt}
            onChange={handleSearch}
            autoComplete="off"
            autoCapitalize="none"
            autoCorrect="off"
            spellCheck="false"
            onFocus={() => setIsFocused(true)}
            onBlur={() => setIsFocused(false)}
          />

          <DropdownMenuTrigger asChild>
            <button
              onClick={() => setIsOpen((prev) => !prev)}
              type="button"
              className={cn(
                "absolute z-10 right-3 top-[10px] opacity-50 transition-opacity duration-300 hover:opacity-100",
                hasValidFilters && "opacity-100",
                isOpen && "opacity-100",
              )}
            >
              <Icons.Filter />
            </button>
          </DropdownMenuTrigger>
        </form>

        <FilterList
          filters={validFilters}
          loading={streaming}
          onRemove={setFilter}
          tags={tagsData}
        />
      </div>

      <DropdownMenuContent
        className="w-[350px]"
        align="end"
        sideOffset={19}
        alignOffset={-11}
        side="bottom"
      >
        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.CalendarMonth className="mr-2 h-4 w-4" />
              <span>Date</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                alignOffset={-4}
                className="p-0"
              >
                <Calendar
                  mode="range"
                  initialFocus
                  toDate={new Date()}
                  selected={
                    filter.start || filter.end
                      ? {
                          from: filter.start
                            ? new Date(filter.start)
                            : undefined,
                          to: filter.end ? new Date(filter.end) : undefined,
                        }
                      : undefined
                  }
                  onSelect={(range) => {
                    if (!range) return;

                    const newRange = {
                      start: range.from
                        ? formatISO(range.from, { representation: "date" })
                        : filter.start,
                      end: range.to
                        ? formatISO(range.to, { representation: "date" })
                        : filter.end,
                    };

                    setFilter(newRange);
                  }}
                />
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>

        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.Status className="mr-2 h-4 w-4" />
              <span>Tags</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                alignOffset={-4}
                className="p-0 max-h-[300px] overflow-y-auto"
              >
                {tagsData?.map((tag) => (
                  <DropdownMenuCheckboxItem
                    key={tag.id}
                    onCheckedChange={() => {
                      setFilter({
                        tags: filter?.tags?.includes(tag.id)
                          ? filter.tags.filter((s) => s !== tag.id)
                          : [...(filter?.tags ?? []), tag.id],
                      });
                    }}
                  >
                    {tag.name}
                  </DropdownMenuCheckboxItem>
                ))}

                {!tagsData?.length && (
                  <DropdownMenuItem disabled>No tags found</DropdownMenuItem>
                )}
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-select-tags.tsx">
import { useTRPC } from "@/trpc/client";
import { Icons } from "@midday/ui/icons";
import MultipleSelector from "@midday/ui/multiple-selector";
import type { Option as MultipleSelectorOption } from "@midday/ui/multiple-selector";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import React, { useState } from "react";

type Option = MultipleSelectorOption & {
  id: string;
};

type Props = {
  tags: Option[];
  onSelect?: (tag: Option) => void;
  onRemove?: (tag: Option) => void;
  onChange?: (tags: Option[]) => void;
};

export function VaultSelectTags({ tags, onSelect, onRemove, onChange }: Props) {
  const [selected, setSelected] = useState<Option[]>(tags ?? []);

  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { data } = useQuery(trpc.documentTags.get.queryOptions());

  const createTagMutation = useMutation(
    trpc.documentTags.create.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.documentTags.get.queryKey(),
        });
      },
    }),
  );

  const deleteTagMutation = useMutation(
    trpc.documentTags.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.documentTags.get.queryKey(),
        });
      },
    }),
  );

  const transformedTags = data
    ?.map((tag) => ({
      value: tag.id,
      label: tag.name,
      id: tag.id,
    }))
    .filter((tag) => !selected.some((s) => s.id === tag.id));

  return (
    <div className="w-full">
      <MultipleSelector
        options={transformedTags ?? []}
        value={selected}
        placeholder="Select tags"
        creatable
        renderOption={(option) => {
          return (
            <div className="flex w-full items-center justify-between">
              <span>{option.label}</span>
              <button
                type="button"
                onClick={(event) => {
                  event.stopPropagation();
                  deleteTagMutation.mutate({
                    id: option.id as string,
                  });
                }}
                className="text-gray-500"
              >
                <Icons.Delete className="h-4 w-4" />
              </button>
            </div>
          );
        }}
        emptyIndicator={<p className="text-sm">No results found.</p>}
        onCreate={(option) => {
          createTagMutation.mutate(
            { name: option.value },
            {
              onSuccess: (data) => {
                if (data) {
                  const newTag = {
                    id: data.id,
                    label: data.name,
                    value: data.name,
                  };

                  setSelected([...selected, newTag]);
                  onSelect?.(newTag);
                }
              },
            },
          );
        }}
        onChange={(options) => {
          const typedOptions = options.map((opt) => ({
            ...opt,
            id: opt.value,
          }));
          setSelected(typedOptions);
          onChange?.(typedOptions);

          const newTag = typedOptions.find(
            (tag) => !selected.find((opt) => opt.value === tag.value),
          );

          if (newTag) {
            onSelect?.(newTag);
            return;
          }

          if (typedOptions.length < selected.length) {
            const removedTag = selected.find(
              (tag) => !typedOptions.find((opt) => opt.value === tag.value),
            );

            if (removedTag) {
              onRemove?.(removedTag);
              setSelected(typedOptions);
            }
          }
        }}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-skeleton.tsx">
"use client";

import { DataTableSkeleton } from "@/components/tables/vault/data-table-skeleton";
import { useDocumentParams } from "@/hooks/use-document-params";
import { VaultGridSkeleton } from "./vault-grid-skeleton";

export function VaultSkeleton() {
  const { params } = useDocumentParams();

  if (params.view === "grid") {
    return <VaultGridSkeleton />;
  }

  return <DataTableSkeleton />;
}
</file>

<file path="apps/dashboard/src/components/vault/vault-upload-button.tsx">
"use client";

import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";

export function VaultUploadButton() {
  return (
    <Button
      variant="outline"
      size="icon"
      onClick={() => document.getElementById("upload-files")?.click()}
    >
      <Icons.Add size={17} />
    </Button>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-upload-zone.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { resumableUpload } from "@/utils/upload";
import { createClient } from "@midday/supabase/client";
import { cn } from "@midday/ui/cn";
import { useToast } from "@midday/ui/use-toast";
import { useMutation } from "@tanstack/react-query";
import { type ReactNode, useEffect, useRef, useState } from "react";
import { type FileRejection, useDropzone } from "react-dropzone";

type UploadResult = {
  filename: string;
  file: File;
};

type Props = {
  children: ReactNode;
  onUpload?: (
    results: {
      file_path: string[];
      mimetype: string;
      size: number;
    }[],
  ) => void;
};

export function VaultUploadZone({ onUpload, children }: Props) {
  const trpc = useTRPC();
  const { data: user } = useUserQuery();
  const supabase = createClient();
  const [progress, setProgress] = useState(0);
  const [showProgress, setShowProgress] = useState(false);
  const [toastId, setToastId] = useState<string | null>(null);
  const uploadProgress = useRef<number[]>([]);
  const { toast, dismiss, update } = useToast();

  const processDocumentMutation = useMutation(
    trpc.documents.processDocument.mutationOptions(),
  );

  useEffect(() => {
    if (!toastId && showProgress) {
      const { id } = toast({
        title: `Uploading ${uploadProgress.current.length} files`,
        progress,
        variant: "progress",
        description: "Please do not close browser until completed",
        duration: Number.POSITIVE_INFINITY,
      });

      setToastId(id);
    } else if (toastId) {
      update(toastId, {
        id: toastId,
        title: `Uploading ${uploadProgress.current.length} files`,
        progress,
        variant: "progress",
      });
    }
  }, [showProgress, progress, toastId]);

  const onDrop = async (files: File[]) => {
    // NOTE: If onDropRejected
    if (!files.length) {
      return;
    }

    // Set default progress
    uploadProgress.current = files.map(() => 0);

    setShowProgress(true);

    // Add uploaded (team_id)
    const path = [user?.teamId] as string[];

    try {
      const results = (await Promise.all(
        files.map(async (file: File, idx: number) =>
          resumableUpload(supabase, {
            bucket: "vault",
            path,
            file,
            onProgress: (bytesUploaded: number, bytesTotal: number) => {
              uploadProgress.current[idx] = (bytesUploaded / bytesTotal) * 100;

              const _progress = uploadProgress.current.reduce(
                (acc, currentValue) => {
                  return acc + currentValue;
                },
                0,
              );

              setProgress(Math.round(_progress / files.length));
            },
          }),
        ),
      )) as UploadResult[];

      // Trigger the upload jobs
      processDocumentMutation.mutate(
        results.map((result) => ({
          filePath: [...path, result.filename],
          mimetype: result.file.type,
          size: result.file.size,
        })),
      );

      // Reset once done
      uploadProgress.current = [];

      setProgress(0);
      toast({
        title: "Upload successful.",
        variant: "success",
        duration: 2000,
      });

      setShowProgress(false);
      setToastId(null);
      if (toastId) {
        dismiss(toastId);
      }

      // Type the results properly for onUpload callback
      const typedResults = results.map((result) => ({
        file_path: [...path, result.filename],
        mimetype: result.file.type,
        size: result.file.size,
      }));

      onUpload?.(typedResults);
    } catch {
      toast({
        duration: 2500,
        variant: "error",
        title: "Something went wrong please try again.",
      });
    }
  };

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    onDropRejected: ([reject]: FileRejection[]) => {
      if (reject?.errors.find(({ code }) => code === "file-too-large")) {
        toast({
          duration: 2500,
          variant: "error",
          title: "File size to large.",
        });
      }

      if (reject?.errors.find(({ code }) => code === "file-invalid-type")) {
        toast({
          duration: 2500,
          variant: "error",
          title: "File type not supported.",
        });
      }
    },
    maxSize: 5000000, // 5MB
    maxFiles: 25,
    accept: {
      "image/*": [".jpg", ".jpeg", ".png", ".webp", ".heic", ".heif", ".avif"],
      "application/pdf": [".pdf"],
      "application/msword": [".doc"],
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
        [".docx"],
      "application/vnd.oasis.opendocument.text": [".odt"],
      "application/vnd.ms-excel": [".xls"],
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [
        ".xlsx",
      ],
      "application/vnd.oasis.opendocument.spreadsheet": [".ods"],
      "application/vnd.ms-powerpoint": [".ppt"],
      "application/vnd.openxmlformats-officedocument.presentationml.presentation":
        [".pptx"],
      "application/vnd.oasis.opendocument.presentation": [".odp"],
      "text/plain": [".txt"],
      "text/csv": [".csv"],
      "text/markdown": [".md"],
      "application/rtf": [".rtf"],
      "application/zip": [".zip"],
    },
  });

  return (
    <div
      className="relative h-full"
      {...getRootProps({ onClick: (evt) => evt.stopPropagation() })}
    >
      <div className="absolute top-0 right-0 left-0 z-[51] w-full pointer-events-none h-[calc(100vh-150px)]">
        <div
          className={cn(
            "bg-background dark:bg-[#1A1A1A] h-full w-full flex items-center justify-center text-center",
            isDragActive ? "visible" : "invisible",
          )}
        >
          <input {...getInputProps()} id="upload-files" />

          <div className="flex flex-col items-center justify-center gap-2">
            <p className="text-xs">
              Drop your documents and files here. <br />
              Maximum of 25 files at a time.
            </p>

            <span className="text-xs text-[#878787]">Max file size 5MB</span>
          </div>
        </div>
      </div>

      {children}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-view-switch.tsx">
"use client";

import { useDocumentParams } from "@/hooks/use-document-params";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";

export function VaultViewSwitch() {
  const { params, setParams } = useDocumentParams();

  return (
    <div className="flex gap-2 text-[#878787]">
      <Button
        variant="outline"
        size="icon"
        className={cn(params.view === "grid" && "border-primary text-primary")}
        onClick={() => setParams({ view: "grid" })}
      >
        <Icons.GridView size={18} />
      </Button>

      <Button
        variant="outline"
        size="icon"
        className={cn(params.view === "list" && "border-primary text-primary")}
        onClick={() => setParams({ view: "list" })}
      >
        <Icons.ListView size={18} />
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/vault/vault-view.tsx">
"use client";

import { DataTable } from "@/components/tables/vault/data-table";
import { useDocumentParams } from "@/hooks/use-document-params";
import { VaultGrid } from "./vault-grid";
import { VaultUploadZone } from "./vault-upload-zone";

export function VaultView() {
  const { params } = useDocumentParams();

  return (
    <VaultUploadZone>
      {params.view === "grid" ? <VaultGrid /> : <DataTable />}
    </VaultUploadZone>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/account-balance/account-balance-widget.tsx">
import { AccountBalance } from "./account-balance";

export function AccountBalanceWidget() {
  return (
    <div className="h-full">
      <div className="flex justify-between">
        <div>
          <h2 className="text-lg">Account balance</h2>
        </div>
      </div>

      <AccountBalance />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/account-balance/account-balance.tsx">
"use client";

import { AddAccountButton } from "@/components/add-account-button";
import { FormatAmount } from "@/components/format-amount";
import { useI18n } from "@/locales/client";
import { useTRPC } from "@/trpc/client";
import { formatAccountName } from "@/utils/format";
import { cn } from "@midday/ui/cn";
import { useSuspenseQuery } from "@tanstack/react-query";
import Image from "next/image";
import { useState } from "react";

export function AccountBalance() {
  const [activeIndex, setActiveIndex] = useState(0);
  const t = useI18n();
  const trpc = useTRPC();

  const { data } = useSuspenseQuery(trpc.bankAccounts.balances.queryOptions());
  const formattedData = data
    ?.map((account) => {
      if (account.name === "total_balance") {
        return {
          ...account,
          id: account.name,
          name: t("account_balance.total_balance"),
        };
      }
      return account;
    })
    .sort((a, b) => b.balance - a.balance);

  const activeAccount = formattedData?.at(activeIndex);

  if (!activeAccount) {
    return (
      <div className="flex justify-center items-center h-full flex-col">
        <h2 className="font-medium mb-1">No accounts connected</h2>
        <p className="text-[#606060] text-sm mb-8 text-center">
          Get your balance in real-time by connecting <br />
          your bank account.
        </p>

        <AddAccountButton />
      </div>
    );
  }

  return (
    <div className="flex justify-between mt-12 items-center flex-col space-y-6">
      <div className="-mt-6 w-[80%] md:w-[75%] lg:w-[85%] 2xl:w-[80%] aspect-square rounded-full bg-[#F2F1EF] dark:bg-secondary flex items-center justify-center p-8 flex-col space-y-2">
        <h2 className="font-mono font-medium text-2xl">
          <FormatAmount
            amount={activeAccount.balance}
            currency={activeAccount.currency}
          />
        </h2>

        <div className="flex space-x-2 items-center">
          {activeAccount?.logo_url && (
            <Image
              src={activeAccount.logo_url}
              alt=""
              width={24}
              height={24}
              quality={100}
              className="rounded-full border border-1 aspect-square"
            />
          )}

          <span className="text-xs font-medium text-[#606060]">
            {formatAccountName({
              name: activeAccount.name,
              currency: activeAccount.currency,
            })}
          </span>
        </div>
      </div>

      {formattedData?.length && formattedData.length > 1 && (
        <div className="flex space-x-2">
          {formattedData.map((account, idx) => (
            <button
              type="button"
              onMouseEnter={() => setActiveIndex(idx)}
              onClick={() => setActiveIndex(idx)}
              key={account.id}
              className={cn(
                "w-[8px] h-[8px] rounded-full bg-[#1D1D1D] dark:bg-[#D9D9D9] opacity-30 transition-all cursor-pointer",
                idx === activeIndex && "opacity-1",
              )}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/account-balance/index.tsx">
import { ErrorFallback } from "@/components/error-fallback";
import { ErrorBoundary } from "next/dist/client/components/error-boundary";
import { Suspense } from "react";
import { AccountBalanceWidget } from "./account-balance-widget";

export function AccountBalance() {
  return (
    <div className="border relative aspect-square overflow-hidden p-4 md:p-8">
      <ErrorBoundary errorComponent={ErrorFallback}>
        <Suspense>
          <AccountBalanceWidget />
        </Suspense>
      </ErrorBoundary>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/assistant/assistant-input.tsx">
"use client";

import { useAssistantStore } from "@/store/assistant";
import { Icons } from "@midday/ui/icons";
import { Input } from "@midday/ui/input";

export function AssistantInput() {
  const { setOpen } = useAssistantStore();

  return (
    <div>
      <div className="absolute bottom-4 left-4 right-4 md:bottom-8 md:left-8 md:right-8">
        <div className="relative z-20">
          <Input
            placeholder="Ask Midday a question..."
            className="w-full h-11 cursor-pointer bg-background"
            onFocus={() => setOpen()}
          />
          <Icons.LogoSmall className="absolute right-3 bottom-3.5 pointer-events-none size-4" />
        </div>
      </div>
      <div className="absolute h-[76px] bg-gradient-to-t from-background to-[#fff]/70 dark:to-[#121212]/90 bottom-0 left-0 right-0 w-full z-10" />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/assistant/assistant-list.tsx">
"use client";

import { chatExamples } from "@/components/chat/examples";
import { useAssistantStore } from "@/store/assistant";

export function AssistantList() {
  const { setOpen } = useAssistantStore();

  return (
    <div className="mb-16">
      <ul className="flex flex-col justify-center items-center space-y-3 flex-shrink">
        {chatExamples.slice(0, 5).map((example) => (
          <li
            key={example}
            className="rounded-full dark:bg-secondary bg-[#F2F1EF] text-xs font-mono text-[#606060] hover:opacity-80 transition-all cursor-default"
          >
            <button
              onClick={() => setOpen(example)}
              type="button"
              className="inline-block p-3 py-2"
            >
              <span>{example}</span>
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/assistant/assistant-widget.tsx">
import { AssistantInput } from "./assistant-input";
import { AssistantList } from "./assistant-list";

export function AssistantWidget() {
  return (
    <div>
      <div className="mt-8 overflow-auto scrollbar-hide pb-32 aspect-square flex flex-col-reverse">
        <AssistantList />
        <AssistantInput />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/assistant/index.tsx">
import { ErrorFallback } from "@/components/error-fallback";
import { ErrorBoundary } from "next/dist/client/components/error-boundary";
import { Suspense } from "react";
import { AssistantWidget } from "./assistant-widget";

export function Assistant() {
  return (
    <div className="border aspect-square overflow-hidden relative flex flex-col p-4 md:p-8">
      <h2 className="text-lg">Assistant</h2>

      <ErrorBoundary errorComponent={ErrorFallback}>
        <Suspense>
          <AssistantWidget />
        </Suspense>
      </ErrorBoundary>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/inbox/data.ts">
export const inboxData = [];

export const options = ["all", "todo", "done"] as const;
export type InboxOption = (typeof options)[number];
</file>

<file path="apps/dashboard/src/components/widgets/inbox/inbox-header.tsx">
"use client";

import { useI18n } from "@/locales/client";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import Link from "next/link";
import { type InboxOption, options } from "./data";

type Props = {
  filter: InboxOption;
  disabled: boolean;
  setFilter: (filter: InboxOption) => void;
};

export function InboxHeader({ filter, disabled, setFilter }: Props) {
  const t = useI18n();

  return (
    <div className="flex justify-between">
      <div>
        <Link href="/inbox" prefetch>
          <h2 className="text-lg">Inbox</h2>
        </Link>
      </div>

      <DropdownMenu>
        <DropdownMenuTrigger disabled={disabled}>
          <div className="flex items-center space-x-2">
            <span>{t(`inbox_filter.${filter}`)}</span>
            <Icons.ChevronDown />
          </div>
        </DropdownMenuTrigger>
        <DropdownMenuContent className="w-[130px]">
          {options.map((option) => (
            <DropdownMenuCheckboxItem
              key={option}
              onCheckedChange={() => setFilter(option)}
              checked={option === filter}
            >
              {t(`inbox_filter.${option}`)}
            </DropdownMenuCheckboxItem>
          ))}
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/inbox/inbox-list.tsx">
"use client";

import { FormatAmount } from "@/components/format-amount";
import { InboxStatus } from "@/components/inbox/inbox-status";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Icons } from "@midday/ui/icons";
import { format } from "date-fns";
import Link from "next/link";

type Props = {
  data: RouterOutputs["inbox"]["get"]["data"];
};

export function InboxList({ data }: Props) {
  return (
    <div className="flex flex-col gap-4 overflow-auto scrollbar-hide aspect-square pb-14 mt-8">
      {data?.map((item) => {
        return (
          <Link
            key={item.id}
            href={`/inbox?inboxId=${item.id}`}
            className="flex flex-col items-start gap-2 border p-4 text-left text-sm transition-all"
          >
            <div className="flex w-full flex-col gap-1">
              <div className="flex items-center mb-1">
                <div className="flex items-center gap-2">
                  <div className="flex items-center space-x-2">
                    <div className="font-semibold">{item?.displayName}</div>
                    {item.transactionId && <Icons.Check />}
                  </div>
                </div>
                <div className="ml-auto text-xs text-muted-foreground">
                  {item.date && format(new Date(item.date), "MMM d")}
                </div>
              </div>
              <div className="flex">
                {item?.currency && item?.amount && (
                  <div className="text-xs font-medium">
                    <FormatAmount
                      amount={item.amount}
                      currency={item.currency}
                    />
                  </div>
                )}
                <div className="ml-auto">
                  <InboxStatus item={item} />
                </div>
              </div>
            </div>
          </Link>
        );
      })}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/inbox/inbox-widget.tsx">
"use client";

import { CopyInput } from "@/components/copy-input";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { getInboxEmail } from "@midday/inbox";
import { useSuspenseQuery } from "@tanstack/react-query";
import { InboxList } from "./inbox-list";

export function InboxWidget() {
  const trpc = useTRPC();
  const { data: user } = useUserQuery();
  const { data } = useSuspenseQuery(trpc.inbox.get.queryOptions());

  if (!data?.data?.length) {
    return (
      <div className="flex flex-col space-y-4 items-center justify-center h-full text-center">
        <div>
          <CopyInput value={getInboxEmail(user?.team?.inboxId ?? "")} />
        </div>

        <p className="text-sm text-[#606060]">
          Use this email for online purchases to seamlessly
          <br />
          match invoices againsts transactions.
        </p>
      </div>
    );
  }

  return <InboxList data={data.data} />;
}
</file>

<file path="apps/dashboard/src/components/widgets/inbox/index.tsx">
"use client";

import { ErrorFallback } from "@/components/error-fallback";
import { InboxListSkeleton } from "@/components/inbox/inbox-list-skeleton";
import { ErrorBoundary } from "next/dist/client/components/error-boundary";
import { Suspense, useState } from "react";
import type { InboxOption } from "./data";
import { InboxHeader } from "./inbox-header";
import { InboxWidget } from "./inbox-widget";

type Props = {
  disabled: boolean;
};

export function Inbox({ disabled }: Props) {
  const [filter, setFilter] = useState<InboxOption>("all");

  return (
    <div className="border relative aspect-square overflow-hidden p-4 md:p-8">
      <InboxHeader filter={filter} disabled={disabled} setFilter={setFilter} />

      <ErrorBoundary errorComponent={ErrorFallback}>
        <Suspense
          fallback={<InboxListSkeleton numberOfItems={5} className="pt-8" />}
        >
          <InboxWidget />
        </Suspense>
      </ErrorBoundary>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/invoice/empty-state.tsx">
"use client";

import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { Button } from "@midday/ui/button";

export function EmptyState() {
  const { setParams } = useInvoiceParams();

  return (
    <div className="flex flex-col space-y-4 items-center justify-center h-full text-center mt-16">
      <p className="text-sm text-[#606060]">
        No invoices created yet.
        <br />
        Create an invoice to get started.
      </p>

      <Button variant="outline" onClick={() => setParams({ type: "create" })}>
        Create invoice
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/invoice/index.tsx">
import { ErrorFallback } from "@/components/error-fallback";
import { ErrorBoundary } from "next/dist/client/components/error-boundary";
import { Suspense } from "react";
import { InvoiceWidgetHeader } from "./invoice-header";
import { InvoiceWidget } from "./invoice-widget";
import { InvoiceWidgetSkeleton } from "./skeleton";

export function Invoice() {
  return (
    <div className="border aspect-square overflow-hidden relative p-4 md:p-8">
      <InvoiceWidgetHeader />

      <ErrorBoundary errorComponent={ErrorFallback}>
        <Suspense fallback={<InvoiceWidgetSkeleton />}>
          <InvoiceWidget />
        </Suspense>
      </ErrorBoundary>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/invoice/invoice-header.tsx">
"use client";

import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import Link from "next/link";

export function InvoiceWidgetHeader() {
  const { setParams } = useInvoiceParams();

  return (
    <div className="flex justify-between items-center">
      <Link href="/invoices" prefetch>
        <h2 className="text-lg">Invoices</h2>
      </Link>

      <Button
        variant="outline"
        size="icon"
        onClick={() => setParams({ type: "create" })}
      >
        <Icons.Add />
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/invoice/invoice-row.tsx">
"use client";

import { FormatAmount } from "@/components/format-amount";
import { InvoiceStatus } from "@/components/invoice-status";
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { getDueDateStatus } from "@/utils/format";
import { formatDate } from "@/utils/format";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { cn } from "@midday/ui/cn";

type Props = {
  invoice: NonNullable<RouterOutputs["invoice"]["get"]["data"]>[number];
};

export function InvoiceRow({ invoice }: Props) {
  const { setParams } = useInvoiceParams();
  const showDate = invoice.status === "unpaid" || invoice.status === "overdue";

  return (
    <>
      <li
        key={invoice.id}
        className="h-[57px] flex items-center w-full"
        onClick={() => setParams({ invoiceId: invoice.id, type: "details" })}
      >
        <div className="flex items-center w-full">
          <div className="flex flex-col space-y-1 w-[90px]">
            <span className="text-sm">
              {invoice.dueDate ? formatDate(invoice.dueDate) : "-"}
            </span>
            {showDate && (
              <span className="text-xs text-muted-foreground">
                {invoice.dueDate ? getDueDateStatus(invoice.dueDate) : "-"}
              </span>
            )}
          </div>

          <div className="w-[85px]">
            <InvoiceStatus status={invoice.status} />
          </div>

          <div className="flex-1 text-sm line-clamp-1 pr-4">
            {invoice.customer?.name}
          </div>

          <div
            className={cn(
              "w-1/4 flex justify-end text-sm",
              invoice.status === "canceled" && "line-through",
            )}
          >
            <FormatAmount
              amount={invoice.amount ?? 0}
              currency={invoice.currency ?? "USD"}
            />
          </div>
        </div>
      </li>
    </>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/invoice/invoice-widget.tsx">
"use client";

import { PaymentScoreVisualizer } from "@/components/payment-score-visualizer";
import { useI18n } from "@/locales/client";
import { useTRPC } from "@/trpc/client";
import { useSuspenseQuery } from "@tanstack/react-query";
import { Invoice } from "./invoice";

export function InvoiceWidget() {
  const trpc = useTRPC();
  const t = useI18n();

  const { data: invoices } = useSuspenseQuery(
    trpc.invoice.get.queryOptions({ pageSize: 10 }),
  );

  const { data: paymentStatus } = useSuspenseQuery(
    trpc.invoice.paymentStatus.queryOptions(),
  );

  return (
    <div className="mt-8">
      <div className="flex justify-between items-center p-3 py-2 border border-border">
        <div>
          <div className="flex flex-col gap-2">
            {/* @ts-expect-error */}
            <div>{t(`payment_status.${paymentStatus?.paymentStatus}`)}</div>
            <div className="text-sm text-muted-foreground">Payment score</div>
          </div>
        </div>

        <PaymentScoreVisualizer
          score={paymentStatus?.score ?? 0}
          paymentStatus={paymentStatus?.paymentStatus ?? "none"}
        />
      </div>

      <Invoice invoices={invoices?.data ?? []} />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/invoice/invoice.tsx">
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { EmptyState } from "./empty-state";
import { InvoiceRow } from "./invoice-row";

type Props = {
  invoices: RouterOutputs["invoice"]["get"]["data"];
};

export function Invoice({ invoices }: Props) {
  if (!invoices?.length) {
    return <EmptyState />;
  }

  return (
    <ul className="bullet-none divide-y cursor-pointer overflow-auto scrollbar-hide aspect-square pb-32 mt-4">
      {invoices?.map((invoice) => {
        return <InvoiceRow key={invoice.id} invoice={invoice} />;
      })}
    </ul>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/invoice/skeleton.tsx">
import { Skeleton } from "@midday/ui/skeleton";

function InvoiceRowSkeleton() {
  return (
    <li className="h-[57px] flex items-center w-full">
      <div className="flex items-center w-full">
        <div className="flex flex-col space-y-1 w-1/4">
          <Skeleton className="h-4 w-20" />
          <Skeleton className="h-3 w-16" />
        </div>

        <div className="w-1/4">
          <Skeleton className="h-5 w-16" />
        </div>

        <div className="w-1/4">
          <Skeleton className="h-4 w-24" />
        </div>

        <div className="w-1/4 flex justify-end">
          <Skeleton className="h-4 w-16" />
        </div>
      </div>
    </li>
  );
}

export function InvoiceWidgetSkeleton() {
  return (
    <div className="mt-8">
      <div className="flex justify-between items-center p-3 py-2 border border-border">
        <div className="w-1/2">
          <div className="flex flex-col gap-2">
            <Skeleton className="h-4 w-3/4" />
            <Skeleton className="h-3 w-1/2" />
          </div>
        </div>
      </div>
      <div className="mt-4 space-y-2">
        {Array.from({ length: 10 }).map((_, index) => (
          <InvoiceRowSkeleton key={index.toString()} />
        ))}
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/spending/data.ts">
import { getColorFromName } from "@/utils/categories";
import {
  formatISO,
  startOfMonth,
  startOfYear,
  subDays,
  subMonths,
  subYears,
} from "date-fns";

export const defaultPeriod = {
  id: "last_30d",
  from: formatISO(subDays(new Date(), 30), { representation: "date" }),
  to: formatISO(new Date(), { representation: "date" }),
};

export const options = [
  defaultPeriod,
  {
    id: "this_month",
    from: formatISO(startOfMonth(new Date()), { representation: "date" }),
    to: formatISO(new Date(), { representation: "date" }),
  },
  {
    id: "last_month",
    from: formatISO(subMonths(startOfMonth(new Date()), 1), {
      representation: "date",
    }),
    to: formatISO(new Date(), { representation: "date" }),
  },
  {
    id: "this_year",
    from: formatISO(startOfYear(new Date()), { representation: "date" }),
    to: formatISO(new Date(), { representation: "date" }),
  },
  {
    id: "last_year",
    from: formatISO(subYears(startOfMonth(new Date()), 1), {
      representation: "date",
    }),
    to: formatISO(new Date(), { representation: "date" }),
  },
];

export const spendingExampleData = [
  {
    slug: "rent",
    color: getColorFromName("Rent") || "#FF6900",
    name: "Rent",
    currency: "USD",
    amount: 0,
    percentage: 0,
  },
  {
    slug: "meals",
    color: getColorFromName("Meals") || "#FCB900",
    name: "Meals",
    currency: "USD",
    amount: 0,
    percentage: 0,
  },
  {
    slug: "other",
    color: getColorFromName("Other") || "#00D084",
    name: "Other",
    currency: "USD",
    amount: 0,
    percentage: 0,
  },
  {
    slug: "internet-and-telephone",
    color: getColorFromName("Internet and Telephone") || "#8ED1FC",
    name: "Internet and Telephone",
    currency: "USD",
    amount: 0,
    percentage: 0,
  },
  {
    slug: "facilities-expenses",
    color: getColorFromName("Facilities Expenses") || "#0693E3",
    name: "Facilities Expenses",
    currency: "USD",
    amount: 0,
    percentage: 0,
  },
  {
    slug: "transfer",
    color: getColorFromName("Transfer") || "#ABB8C3",
    name: "Transfer",
    currency: "USD",
    amount: 0,
    percentage: 0,
  },
  {
    slug: "software",
    color: getColorFromName("Software") || "#EB144C",
    name: "Software",
    currency: "USD",
    amount: 0,
    percentage: 0,
  },
  {
    slug: "equipment",
    color: getColorFromName("Equipment") || "#F78DA7",
    name: "Equipment",
    currency: "USD",
    amount: 0,
    percentage: 0,
  },
  {
    slug: "office-supplies",
    color: getColorFromName("Office Supplies") || "#9900EF",
    name: "Office Supplies",
    currency: "USD",
    amount: 0,
    percentage: 0,
  },
  {
    slug: "uncategorized",
    color: getColorFromName("Uncategorized") || "#0079BF",
    name: "Uncategorized",
    currency: "USD",
    amount: 0,
    percentage: 0,
  },
  {
    slug: "fees",
    color: getColorFromName("Fees") || "#B6BBBF",
    name: "Fees",
    currency: "USD",
    amount: 0,
    percentage: 0,
  },
  {
    slug: "travel",
    color: getColorFromName("Travel") || "#FF5A5F",
    name: "Travel",
    currency: "USD",
    amount: 0,
    percentage: 0,
  },
];
</file>

<file path="apps/dashboard/src/components/widgets/spending/index.tsx">
"use client";

import { ErrorFallback } from "@/components/error-fallback";
import { ErrorBoundary } from "next/dist/client/components/error-boundary";
import { Suspense, useState } from "react";
import { SpendingListSkeleton } from "./skeleton";
import { SpendingList } from "./spending-list";
import { SpendingPeriod } from "./spending-period";

type Props = {
  disabled: boolean;
};

export function Spending({ disabled }: Props) {
  const [period, setPeriod] = useState("last_30d");

  return (
    <div className="border aspect-square relative overflow-hidden">
      <div className="p-4 md:p-8 flex-col">
        <SpendingPeriod period={period} onChange={setPeriod} />

        <ErrorBoundary errorComponent={ErrorFallback}>
          <Suspense fallback={<SpendingListSkeleton />}>
            <SpendingList disabled={disabled} period={period} />
          </Suspense>
        </ErrorBoundary>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/spending/skeleton.tsx">
import { Skeleton } from "@midday/ui/skeleton";

export function SpendingListSkeleton() {
  return (
    <div className="mt-8 space-y-4">
      {[...Array(16)].map((_, index) => (
        <div
          key={index.toString()}
          className="flex justify-between items-center"
        >
          <div className="w-[70%] flex space-x-4 pr-8 items-center">
            <Skeleton className="size-[12px] flex-shrink-0" />
            <Skeleton className="h-[6px] w-full rounded-none" />
          </div>
          <div className="w-full ml-auto">
            <Skeleton className="w-full align-start h-[6px] rounded-none" />
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/spending/spending-category-item.tsx">
"use client";

import { CategoryColor } from "@/components/category";
import { useUserQuery } from "@/hooks/use-user";
import { formatAmount } from "@/utils/format";

type Props = {
  color: string;
  amount: number;
  currency: string;
  percentage: number;
};

export function SpendingCategoryItem({
  color,
  amount,
  currency,
  percentage,
}: Props) {
  const { data: user } = useUserQuery();

  return (
    <div className="px-3 py-1 flex justify-between items-center space-x-12">
      <div className="text-sm font-medium flex items-center space-x-2">
        <CategoryColor color={color} />

        <p>
          {amount &&
            formatAmount({
              amount: amount,
              currency,
              locale: user?.locale,
              maximumFractionDigits: 0,
              minimumFractionDigits: 0,
            })}
        </p>
      </div>

      <p className="text-sm text-[#606060] truncate">{percentage}%</p>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/spending/spending-category-list.tsx">
"use client";

import { Category } from "@/components/category";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import {
  HoverCard,
  HoverCardContent,
  HoverCardTrigger,
} from "@midday/ui/hover-card";
import { Progress } from "@midday/ui/progress";
import { formatISO } from "date-fns";
import Link from "next/link";
import { SpendingCategoryItem } from "./spending-category-item";

type Props = {
  selectedPeriod: {
    from: string;
    to: string;
  };
  data: RouterOutputs["reports"]["spending"];
  disabled: boolean;
};

export function SpendingCategoryList({
  data,
  selectedPeriod,
  disabled,
}: Props) {
  return (
    <ul className="mt-8 space-y-4 overflow-auto scrollbar-hide aspect-square pb-14">
      {data?.map((category) => {
        return (
          <li key={category.slug}>
            <HoverCard openDelay={10} closeDelay={10}>
              <HoverCardTrigger asChild>
                <Link
                  className="flex items-center"
                  href={`/transactions?categories=${category.slug}&start=${formatISO(new Date(selectedPeriod.from), { representation: "date" })}&end=${formatISO(new Date(selectedPeriod.to), { representation: "date" })}`}
                >
                  <Category
                    key={category.slug}
                    name={category.name}
                    color={category.color}
                    className="text-sm text-primary space-x-3 w-[90%]"
                  />

                  <Progress
                    className="w-full rounded-none h-[6px]"
                    value={category.percentage}
                  />
                </Link>
              </HoverCardTrigger>

              {!disabled && (
                <HoverCardContent className="border shadow-sm bg-background py-1 px-0">
                  <SpendingCategoryItem
                    color={category.color}
                    amount={category.amount}
                    currency={category.currency}
                    percentage={category.percentage}
                  />
                </HoverCardContent>
              )}
            </HoverCard>
          </li>
        );
      })}
    </ul>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/spending/spending-list.tsx">
import { useTRPC } from "@/trpc/client";
import { useSuspenseQuery } from "@tanstack/react-query";
import { defaultPeriod, options, spendingExampleData } from "./data";
import { SpendingCategoryList } from "./spending-category-list";

type Props = {
  period: string;
  disabled: boolean;
};

export function SpendingList({ period, disabled }: Props) {
  const trpc = useTRPC();

  const selectedPeriod =
    options.find((option) => option.id === period) || defaultPeriod;

  const { data } = useSuspenseQuery(
    trpc.reports.spending.queryOptions({
      from: selectedPeriod.from,
      to: selectedPeriod.to,
    }),
  );

  const spending = data?.length ? data : spendingExampleData;

  if (!spending?.length) {
    return (
      <div className="flex items-center justify-center aspect-square">
        <p className="text-sm text-[#606060]">
          No transactions have been categorized in this period.
        </p>
      </div>
    );
  }

  return (
    <SpendingCategoryList
      data={spending}
      selectedPeriod={selectedPeriod}
      disabled={disabled}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/spending/spending-period.tsx">
"use client";

import { useI18n } from "@/locales/client";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import Link from "next/link";
import { options } from "./data";

type Props = {
  period: string;
  onChange: (period: string) => void;
};

export function SpendingPeriod({ period, onChange }: Props) {
  const t = useI18n();

  const selectedPeriod = options.find((option) => option.id === period);

  return (
    <div className="flex justify-between">
      <div>
        <Link
          href={`/transactions?start=${selectedPeriod?.from}&end=${selectedPeriod?.to}&amount=lte,0`}
          prefetch
        >
          <h2 className="text-lg">Spending</h2>
        </Link>
      </div>

      <DropdownMenu>
        <DropdownMenuTrigger>
          <div className="flex items-center space-x-2">
            {/* @ts-expect-error */}
            <span>{t(`spending_period.${period}`)}</span>
            <Icons.ChevronDown />
          </div>
        </DropdownMenuTrigger>
        <DropdownMenuContent className="w-[180px]">
          {options.map((option) => (
            <DropdownMenuCheckboxItem
              key={option.id}
              onCheckedChange={() => onChange(option.id)}
              checked={option.id === period}
            >
              {/* @ts-expect-error */}
              {t(`spending_period.${option.id}`)}
            </DropdownMenuCheckboxItem>
          ))}
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/tracker/index.tsx">
import { ErrorFallback } from "@/components/error-fallback";
import { ErrorBoundary } from "next/dist/client/components/error-boundary";
import { TrackerWidget } from "./tracker-widget";

export function Tracker() {
  return (
    <div className="border aspect-square overflow-hidden relative p-4 md:p-8">
      <ErrorBoundary errorComponent={ErrorFallback}>
        <TrackerWidget />
      </ErrorBoundary>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/tracker/tracker-header.tsx">
"use client";

import { TrackerPeriodSelect } from "@/components/tracker-period-select";
import NumberFlow from "@number-flow/react";

type TrackerHeaderProps = {
  totalDuration?: number;
};

export function TrackerHeader({ totalDuration }: TrackerHeaderProps) {
  return (
    <div className="flex items-center justify-between">
      <div className="space-y-2">
        <h2 className="text-xl text-[#878787]">
          <NumberFlow
            value={totalDuration ? Math.round(totalDuration / 3600) : 0}
          />
          <span className="relative">h</span>
        </h2>
      </div>
      <div className="flex items-center space-x-2">
        <TrackerPeriodSelect />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/tracker/tracker-indicator.tsx">
import { cn } from "@midday/ui/cn";

interface Props {
  count: number;
  isToday: boolean;
}

export function TrackerIndicator({ count, isToday }: Props) {
  if (count === 1) {
    return (
      <div className="absolute bottom-2 left-3 right-3">
        <div
          className={cn("h-1 w-1/2 bg-border", isToday && "bg-background")}
        />
      </div>
    );
  }

  if (count === 2) {
    return (
      <div className="absolute bottom-2 left-3 right-3 flex justify-center space-x-1">
        <div
          className={cn("h-1 w-1/2 bg-border", isToday && "bg-background")}
        />
        <div
          className={cn("h-1 w-1/2 bg-border", isToday && "bg-background")}
        />
      </div>
    );
  }

  if (count === 3) {
    return (
      <div className="absolute bottom-2 left-3 right-3 flex justify-center space-x-1">
        <div
          className={cn("h-1 w-1/2 bg-border", isToday && "bg-background")}
        />
        <div
          className={cn("h-1 w-1/2 bg-border", isToday && "bg-background")}
        />
        <div
          className={cn("h-1 w-1/2 bg-border", isToday && "bg-background")}
        />
      </div>
    );
  }

  if (count > 3) {
    return (
      <div className="absolute bottom-2 left-3 right-3">
        <div
          className={cn("h-1 w-full bg-border", isToday && "bg-background")}
        />
      </div>
    );
  }

  return null;
}
</file>

<file path="apps/dashboard/src/components/widgets/tracker/tracker-widget.tsx">
"use client";

import { useTrackerParams } from "@/hooks/use-tracker-params";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { sortDates } from "@/utils/tracker";
import { cn } from "@midday/ui/cn";
import { useQuery } from "@tanstack/react-query";
import {
  eachDayOfInterval,
  endOfMonth,
  endOfWeek,
  format,
  formatISO,
  isToday,
  startOfMonth,
  startOfWeek,
} from "date-fns";
import { useEffect, useRef, useState } from "react";
import { useOnClickOutside } from "usehooks-ts";
import { TrackerHeader } from "./tracker-header";
import { TrackerIndicator } from "./tracker-indicator";

export function TrackerWidget() {
  const ref = useRef<HTMLDivElement>(null);
  const {
    date: currentDate,
    range,
    setParams,
    selectedDate,
  } = useTrackerParams({ initialDate: new Date().toISOString() });

  const trpc = useTRPC();

  const { data } = useQuery(
    trpc.trackerEntries.byRange.queryOptions({
      from: formatISO(startOfMonth(new Date(currentDate)), {
        representation: "date",
      }),
      to: formatISO(endOfMonth(new Date(currentDate)), {
        representation: "date",
      }),
    }),
  );

  const { data: user } = useUserQuery();
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState<string | null>(null);
  const [dragEnd, setDragEnd] = useState<string | null>(null);

  const monthStart = startOfMonth(new Date(currentDate));
  const monthEnd = endOfMonth(new Date(currentDate));
  const calendarStart = startOfWeek(monthStart, {
    weekStartsOn: user?.weekStartsOnMonday ? 1 : 0,
  });

  const calendarEnd = endOfWeek(monthEnd, {
    weekStartsOn: user?.weekStartsOnMonday ? 1 : 0,
  });

  const calendarDays = eachDayOfInterval({
    start: calendarStart,
    end: calendarEnd,
  });

  const sortedDates = sortDates(range ?? []);

  const firstWeek = eachDayOfInterval({
    start: calendarStart,
    end: endOfWeek(calendarStart, {
      weekStartsOn: user?.weekStartsOnMonday ? 1 : 0,
    }),
  });

  // @ts-expect-error
  useOnClickOutside(ref, () => {
    if (range?.length === 1) {
      setParams({ range: null });
    }
  });

  const getEventCount = (date: Date) => {
    const formattedDate = formatISO(date, { representation: "date" });
    const result = data?.result ?? {};
    return result[formattedDate]?.length ?? 0;
  };

  const handleMouseDown = (date: Date) => {
    setIsDragging(true);
    const dateStr = formatISO(date, { representation: "date" });
    setDragStart(dateStr);
    setDragEnd(null);
    setParams({ range: [dateStr] });
  };

  const handleMouseEnter = (date: Date) => {
    if (isDragging) {
      setDragEnd(formatISO(date, { representation: "date" }));
    }
  };

  const handleMouseUp = () => {
    setIsDragging(false);
    if (dragStart && dragEnd) {
      setParams({
        range: [dragStart, dragEnd].sort(),
      });
    } else if (dragStart) {
      setParams({ selectedDate: dragStart, range: null });
    }
    setDragStart(null);
    setDragEnd(null);
  };

  useEffect(() => {
    const handleGlobalMouseUp = () => {
      if (isDragging) {
        handleMouseUp();
      }
    };

    document.addEventListener("mouseup", handleGlobalMouseUp);
    return () => {
      document.removeEventListener("mouseup", handleGlobalMouseUp);
    };
  }, [isDragging, dragStart, dragEnd]);

  return (
    <div ref={ref}>
      <TrackerHeader totalDuration={data?.meta?.totalDuration} />

      <div className="mt-4">
        <div className="grid grid-cols-7 gap-px border border-border bg-border">
          {firstWeek.map((day) => (
            <div
              key={day.toString()}
              className="py-4 px-3 bg-background text-xs font-medium text-[#878787] font-mono"
            >
              {format(day, "EEE").toUpperCase()}
            </div>
          ))}
          {calendarDays.map((date, index) => {
            const isCurrentMonth =
              new Date(date).getMonth() === new Date(currentDate).getMonth();
            const dateStr = formatISO(date, { representation: "date" });
            const isInDragRange =
              dragStart &&
              dragEnd &&
              ((dateStr >= dragStart && dateStr <= dragEnd) ||
                (dateStr <= dragStart && dateStr >= dragEnd));

            return (
              <button
                type="button"
                onMouseDown={() => handleMouseDown(date)}
                onMouseEnter={() => handleMouseEnter(date)}
                key={index.toString()}
                className={cn(
                  "pt-2 pb-5 px-3 font-mono text-sm relative transition-all duration-100 text-left aspect-square",
                  isCurrentMonth && isToday(date)
                    ? "bg-[#f0f0f0] dark:bg-[#202020]"
                    : "bg-background",
                  !isCurrentMonth &&
                    "bg-[repeating-linear-gradient(-60deg,#DBDBDB,#DBDBDB_1px,transparent_1px,transparent_5px)] dark:bg-[repeating-linear-gradient(-60deg,#2C2C2C,#2C2C2C_1px,transparent_1px,transparent_5px)] text-[#878787]",
                  selectedDate === dateStr && "ring-1 ring-primary",
                  (range?.includes(dateStr) ||
                    (sortedDates.length === 2 &&
                      date >= new Date(sortedDates[0] || 0) &&
                      date <= new Date(sortedDates[1] || 0))) &&
                    "ring-1 ring-primary",
                  isInDragRange && "ring-1 ring-primary",
                )}
              >
                <div>{format(date, "d")}</div>
                <TrackerIndicator
                  count={getEventCount(date)}
                  isToday={isToday(date)}
                />
              </button>
            );
          })}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/transactions/data.ts">
export const options = ["all", "income", "expense"] as const;
export type TransactionType = (typeof options)[number];

export const transactionExampleData = {
  data: [
    { id: 1, name: "Spotify", amount: -199, currency: "USD" },
    { id: 2, name: "Netflix", amount: -179, currency: "USD" },
    { id: 3, name: "WeWork", amount: -6700, currency: "USD" },
    {
      id: 4,
      name: "Acme Inc",
      amount: 76300,
      currency: "USD",
    },
    {
      id: 5,
      name: "GitHub",
      amount: -99,
      currency: "USD",
    },
    {
      id: 6,
      name: "Supabase",
      amount: -299,
      currency: "USD",
    },
    {
      id: 7,
      name: "Acme Inc",
      amount: 86300,
      currency: "USD",
    },
  ],
};
</file>

<file path="apps/dashboard/src/components/widgets/transactions/skeleton.tsx">
import { Skeleton } from "@midday/ui/skeleton";

export function TransactionsListSkeleton() {
  return (
    <div className="divide-y">
      {[...Array(12)].map((_, index) => (
        <div
          key={index.toString()}
          className="flex justify-between px-3 items-center h-[49px]"
        >
          <div className="w-[60%]">
            <Skeleton className="h-3 w-[50%]" />
          </div>
          <div className="w-[40%] ml-auto">
            <Skeleton className="w-[60%] h-3 align-start" />
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/transactions/transaction-list-header.tsx">
export function TransactionsListHeader() {
  return (
    <div className="flex py-3 border-b-[1px]">
      <span className="font-medium text-sm w-[50%]">Description</span>
      <span className="font-medium text-sm w-[35%]">Amount</span>
      <span className="font-medium text-sm ml-auto">Status</span>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/transactions/transaction-list-item.tsx">
"use client";

import { FormatAmount } from "@/components/format-amount";
import { TransactionStatus } from "@/components/transaction-status";
import { useTransactionParams } from "@/hooks/use-transaction-params";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { cn } from "@midday/ui/cn";

type Props = {
  transaction: NonNullable<
    RouterOutputs["transactions"]["get"]["data"]
  >[number];
  disabled?: boolean;
};

export function TransactionListItem({ transaction, disabled }: Props) {
  const { setParams } = useTransactionParams();
  const fullfilled = transaction.isFulfilled;

  return (
    <>
      <div
        onClick={() => setParams({ transactionId: transaction.id })}
        className="w-full"
      >
        <div className="flex items-center py-3">
          <div className="w-[50%] flex space-x-2">
            <span
              className={cn(
                "text-sm line-clamp-1",
                disabled && "skeleton-box animate-none",
                transaction?.category?.slug === "income" && "text-[#00C969]",
              )}
            >
              {transaction.name}
            </span>
          </div>
          <div className="w-[35%]">
            <span
              className={cn(
                "text-sm line-clamp-1",
                disabled && "skeleton-box animate-none",
                transaction?.category?.slug === "income" && "text-[#00C969]",
              )}
            >
              <FormatAmount
                amount={transaction.amount}
                currency={transaction.currency}
              />
            </span>
          </div>

          <div className="ml-auto">
            <TransactionStatus fullfilled={fullfilled} />
          </div>
        </div>
      </div>
    </>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/transactions/transactions-item-list.tsx">
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { TransactionListItem } from "./transaction-list-item";

type Props = {
  transactions: NonNullable<RouterOutputs["transactions"]["get"]["data"]>;
  disabled: boolean;
};

export function TransactionsItemList({ transactions, disabled }: Props) {
  return (
    <ul className="bullet-none divide-y cursor-pointer overflow-auto scrollbar-hide aspect-square pb-24">
      {transactions?.map((transaction) => {
        return (
          <li key={transaction.id}>
            <TransactionListItem
              transaction={transaction}
              disabled={disabled}
            />
          </li>
        );
      })}
    </ul>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/transactions/transactions-list.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { useSuspenseQuery } from "@tanstack/react-query";
import type { TransactionType } from "./data";
import { TransactionsItemList } from "./transactions-item-list";

type Props = {
  type: TransactionType;
  disabled: boolean;
};

export function TransactionsList({ type, disabled }: Props) {
  const trpc = useTRPC();

  const { data: transactions } = useSuspenseQuery(
    trpc.transactions.get.queryOptions({
      pageSize: 15,
      type: type === "all" ? undefined : type,
    }),
  );

  if (!transactions?.data?.length) {
    return (
      <div className="flex items-center justify-center aspect-square">
        <p className="text-sm text-[#606060] -mt-12">No transactions found</p>
      </div>
    );
  }

  return (
    <TransactionsItemList
      transactions={transactions?.data}
      disabled={disabled}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/transactions/transactions-period.tsx">
"use client";

import { useI18n } from "@/locales/client";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import Link from "next/link";
import { type TransactionType, options } from "./data";

type Props = {
  type: TransactionType;
  setType: (type: TransactionType) => void;
  disabled: boolean;
};

export function TransactionsPeriod({ type, setType, disabled }: Props) {
  const t = useI18n();

  return (
    <div className="flex justify-between">
      <div>
        <Link href="/transactions" prefetch>
          <h2 className="text-lg">Transactions</h2>
        </Link>
      </div>

      <DropdownMenu>
        <DropdownMenuTrigger disabled={disabled}>
          <div className="flex items-center space-x-2">
            <span>{t(`transactions_period.${type}`)}</span>
            <Icons.ChevronDown />
          </div>
        </DropdownMenuTrigger>
        <DropdownMenuContent className="w-[130px]">
          {options.map((option) => (
            <DropdownMenuCheckboxItem
              key={option}
              onCheckedChange={() => setType(option)}
              checked={option === type}
            >
              {t(`transactions_period.${option}`)}
            </DropdownMenuCheckboxItem>
          ))}
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/transactions/transactions.tsx">
"use client";

import { ErrorFallback } from "@/components/error-fallback";
import { ErrorBoundary } from "next/dist/client/components/error-boundary";
import { Suspense, useState } from "react";
import type { TransactionType } from "./data";
import { TransactionsListSkeleton } from "./skeleton";
import { TransactionsListHeader } from "./transaction-list-header";
import { TransactionsList } from "./transactions-list";
import { TransactionsPeriod } from "./transactions-period";

type Props = {
  disabled: boolean;
};

export function Transactions({ disabled }: Props) {
  const [type, setType] = useState<TransactionType>("all");

  return (
    <div className="border aspect-square overflow-hidden relative p-4 md:p-8">
      <TransactionsPeriod type={type} setType={setType} disabled={disabled} />

      <div className="mt-4">
        <TransactionsListHeader />
        <ErrorBoundary errorComponent={ErrorFallback}>
          <Suspense fallback={<TransactionsListSkeleton />}>
            <TransactionsList type={type} disabled={disabled} />
          </Suspense>
        </ErrorBoundary>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/vault/index.tsx">
import { ErrorFallback } from "@/components/error-fallback";
import { ErrorBoundary } from "next/dist/client/components/error-boundary";
import { Suspense } from "react";
import { VaultHeader } from "./vault-header";
import { VaultWidget } from "./vault-widget";

export function Vault() {
  return (
    <div className="border aspect-square overflow-hidden relative p-4 md:p-8">
      <VaultHeader />

      <ErrorBoundary errorComponent={ErrorFallback}>
        <Suspense>
          <VaultWidget />
        </Suspense>
      </ErrorBoundary>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/vault/vault-header.tsx">
import Link from "next/link";

export function VaultHeader() {
  return (
    <div className="mb-4">
      <Link href="/vault" prefetch>
        <h2 className="text-lg">Recent files</h2>
      </Link>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/vault/vault-widget.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { useSuspenseQuery } from "@tanstack/react-query";
import { Vault } from "./vault";

export function VaultWidget() {
  const trpc = useTRPC();

  const { data: documents } = useSuspenseQuery(
    trpc.documents.get.queryOptions({
      pageSize: 10,
    }),
  );

  if (!documents.data.length) {
    return (
      <div className="flex items-center justify-center aspect-square">
        <p className="text-sm text-[#606060] -mt-12">No files found</p>
      </div>
    );
  }

  return <Vault files={documents.data} />;
}
</file>

<file path="apps/dashboard/src/components/widgets/vault/vault.tsx">
"use client";

import { useDocumentParams } from "@/hooks/use-document-params";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Badge } from "@midday/ui/badge";
import { useRouter } from "next/navigation";

type Props = {
  files: RouterOutputs["documents"]["get"]["data"];
};

export function Vault({ files }: Props) {
  const { setParams } = useDocumentParams();
  const router = useRouter();

  return (
    <ul className="bullet-none divide-y cursor-pointer overflow-auto scrollbar-hide aspect-square pb-24">
      {files?.map((file) => {
        const firstTag = file.documentTagAssignments.at(0)?.documentTag;

        return (
          <li key={file.id}>
            <div className="flex items-center py-3 justify-between">
              <span
                className="text-sm line-clamp-1 pr-8"
                onClick={() => {
                  setParams({
                    filePath: file.name,
                  });
                }}
              >
                {file.name?.split("/").at(-1)}
              </span>

              {file.documentTagAssignments.length > 0 && (
                <button
                  type="button"
                  onClick={() => {
                    router.push(`/vault?tags=${firstTag?.id}`);
                  }}
                >
                  <Badge variant="tag-rounded" className="text-xs">
                    {firstTag?.name}
                  </Badge>
                </button>
              )}
            </div>
          </li>
        );
      })}
    </ul>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/index.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import {
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselNext,
  CarouselPrevious,
} from "@midday/ui/carousel";
import { useQuery } from "@tanstack/react-query";
import * as React from "react";
import { AccountBalance } from "./account-balance";
import { Assistant } from "./assistant";
import { Inbox } from "./inbox";
import { Invoice } from "./invoice";
import { WidgetsNavigation } from "./navigation";
import { Spending } from "./spending";
import { Tracker } from "./tracker";
import { Transactions } from "./transactions/transactions";
import { Vault } from "./vault";

export function Widgets() {
  const trpc = useTRPC();

  const { data: accounts } = useQuery(
    trpc.bankAccounts.get.queryOptions({
      enabled: true,
    }),
  );

  // If the user has not connected any accounts, disable the widgets
  const disabled = !accounts?.length;

  const items = [
    <Assistant key="assistant" />,
    <Spending disabled={disabled} key="spending" />,
    <Invoice key="invoice" />,
    <Transactions disabled={disabled} key="transactions" />,
    <Tracker key="tracker" />,
    <Inbox key="inbox" disabled={disabled} />,
    <AccountBalance key="account-balance" />,
    <Vault key="vault" />,
  ];

  return (
    <Carousel
      className="flex flex-col"
      opts={{
        align: "start",
        watchDrag: false,
      }}
    >
      <WidgetsNavigation />
      <div className="ml-auto hidden md:flex">
        <CarouselPrevious className="static p-0 border-none hover:bg-transparent" />
        <CarouselNext className="static p-0 border-none hover:bg-transparent" />
      </div>

      <CarouselContent className="-ml-[20px] 2xl:-ml-[40px] flex-col md:flex-row space-y-6 md:space-y-0">
        {items.map((item, idx) => {
          return (
            <CarouselItem
              className="lg:basis-1/2 xl:basis-1/3 3xl:basis-1/4 pl-[20px] 2xl:pl-[40px]"
              key={idx.toString()}
            >
              {item}
            </CarouselItem>
          );
        })}
      </CarouselContent>
    </Carousel>
  );
}
</file>

<file path="apps/dashboard/src/components/widgets/navigation.tsx">
"use client";

import { useCarousel } from "@midday/ui/carousel";
import { parseAsString, useQueryStates } from "nuqs";
import { useHotkeys } from "react-hotkeys-hook";

export function WidgetsNavigation() {
  const { scrollPrev, scrollNext } = useCarousel();
  const [params] = useQueryStates({
    selectedDate: parseAsString,
  });

  const disabled = params.selectedDate;

  useHotkeys("left", scrollPrev, {
    enabled: !disabled,
  });

  useHotkeys("right", scrollNext, {
    enabled: !disabled,
  });

  return null;
}
</file>

<file path="apps/dashboard/src/components/account-settings.tsx">
"use client";

import { ChangeEmail } from "@/components/change-email";
import { ChangeTheme } from "@/components/change-theme";
import { DeleteAccount } from "@/components/delete-account";
import { DisplayName } from "@/components/display-name";
import { UserAvatar } from "@/components/user-avatar";

export function AccountSettings() {
  return (
    <div className="space-y-12">
      <UserAvatar />
      <DisplayName />
      <ChangeEmail />
      <ChangeTheme />
      <DeleteAccount />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/add-account-button.tsx">
"use client";

import { Button } from "@midday/ui/button";
import { useQueryState } from "nuqs";

export function AddAccountButton({ onClick }: { onClick?: () => void }) {
  const [_, setStep] = useQueryState("step");

  const handleClick = () => {
    setStep("connect");
    onClick?.();
  };

  return (
    <Button
      data-event="Add account"
      data-icon="🏦"
      data-channel="bank"
      onClick={handleClick}
    >
      Add account
    </Button>
  );
}
</file>

<file path="apps/dashboard/src/components/add-transactions.tsx">
"use client";

import { useTransactionParams } from "@/hooks/use-transaction-params";
import { Button } from "@midday/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { parseAsBoolean, parseAsString, useQueryStates } from "nuqs";

export function AddTransactions() {
  const [_, setParams] = useQueryStates({
    step: parseAsString,
    hide: parseAsBoolean,
  });

  const { setParams: setTransactionParams } = useTransactionParams();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Icons.Add size={17} />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent sideOffset={10} align="end">
        <DropdownMenuItem
          onClick={() => setParams({ step: "connect" })}
          className="space-x-2"
        >
          <Icons.Accounts size={18} />
          <span>Connect account</span>
        </DropdownMenuItem>
        <DropdownMenuItem
          onClick={() => setParams({ step: "import", hide: true })}
          className="space-x-2"
        >
          <Icons.Import size={18} />
          <span>Import/backfill</span>
        </DropdownMenuItem>
        <DropdownMenuItem
          onClick={() => setTransactionParams({ createTransaction: true })}
          className="space-x-2"
        >
          <Icons.CreateTransaction size={18} />
          <span>Create transaction</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/amount-range.tsx">
"use client";

import { useSliderWithInput } from "@/hooks/use-slider-with-input";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import { CurrencyInput } from "@midday/ui/currency-input";
import { Label } from "@midday/ui/label";
import { Slider } from "@midday/ui/slider";
import { useQuery } from "@tanstack/react-query";
import { parseAsArrayOf, parseAsInteger, useQueryState } from "nuqs";
import { useEffect, useRef } from "react";

export function AmountRange() {
  const minInputRef = useRef<HTMLInputElement>(null);
  const maxInputRef = useRef<HTMLInputElement>(null);

  const trpc = useTRPC();

  const { data: items, isLoading } = useQuery(
    trpc.transactions.getAmountRange.queryOptions(),
  );

  const [amountRange, setAmountRange] = useQueryState(
    "amount_range",
    parseAsArrayOf(parseAsInteger),
  );

  const minValue = items?.length
    ? Math.min(...items.map((item) => Number(item.amount) || 0))
    : 0;
  const maxValue = items?.length
    ? Math.max(...items.map((item) => Number(item.amount) || 0))
    : 0;

  const {
    sliderValue,
    inputValues,
    validateAndUpdateValue,
    handleInputChange,
    handleSliderChange,
    setValues,
  } = useSliderWithInput({
    minValue,
    maxValue,
    initialValue: amountRange || [minValue, maxValue],
  });

  useEffect(() => {
    if (minValue !== undefined && maxValue !== undefined) {
      setValues([minValue, maxValue]);
    }
  }, [minValue, maxValue, setValues]);

  if (isLoading) return null;

  const handleSliderValueChange = (values: number[]) => {
    handleSliderChange(values);
  };

  const countItemsInRange = (min: number, max: number) => {
    if (!items) return 0;
    return items.filter((item) => {
      const amount =
        typeof item.amount === "number" ? item.amount : Number(item.amount);
      return !Number.isNaN(amount) && amount >= min && amount <= max;
    }).length;
  };

  const totalCount = countItemsInRange(
    sliderValue[0] ?? minValue,
    sliderValue[1] ?? maxValue,
  );

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between gap-4">
        <form
          className="flex w-full items-center justify-between gap-4"
          onSubmit={(e) => {
            e.preventDefault();
            if (sliderValue[0] !== undefined && sliderValue[1] !== undefined) {
              setAmountRange([sliderValue[0], sliderValue[1]]);
            }
          }}
        >
          <div className="space-y-1 flex-1">
            <Label htmlFor="min-amount" className="text-xs">
              Min amount
            </Label>

            <CurrencyInput
              className="w-full font-mono text-xs"
              type="text"
              inputMode="decimal"
              value={inputValues[0] || ""}
              onChange={(e) => handleInputChange(e, 0)}
              onFocus={(e) => e.target.select()}
              onBlur={() => validateAndUpdateValue(inputValues[0] ?? "", 0)}
              onKeyDown={(e) => {
                if (e.key === "Enter") {
                  e.preventDefault();
                  validateAndUpdateValue(inputValues[0] ?? "", 0);
                  maxInputRef.current?.focus();
                }
              }}
              aria-label="Enter minimum amount"
              getInputRef={minInputRef}
            />
          </div>
          <div className="space-y-1 flex-1">
            <Label htmlFor="max-amount" className="text-xs">
              Max amount
            </Label>

            <CurrencyInput
              className="w-full font-mono text-xs"
              type="text"
              inputMode="decimal"
              value={inputValues[1] || ""}
              onChange={(e) => handleInputChange(e, 1)}
              onFocus={(e) => e.target.select()}
              onBlur={() => validateAndUpdateValue(inputValues[1] ?? "", 1)}
              onKeyDown={(e) => {
                if (e.key === "Enter") {
                  e.preventDefault();
                  validateAndUpdateValue(inputValues[1] ?? "", 1);
                }
              }}
              aria-label="Enter maximum amount"
              getInputRef={maxInputRef}
            />
          </div>
        </form>
      </div>

      <Slider
        value={sliderValue}
        onValueChange={handleSliderValueChange}
        min={minValue}
        max={maxValue}
        aria-label="Amount range"
      />

      <Button
        className="w-full text-xs"
        variant="outline"
        disabled={totalCount === 0}
        onClick={() => {
          if (sliderValue[0] !== undefined && sliderValue[1] !== undefined) {
            setAmountRange([sliderValue[0], sliderValue[1]]);
          }
        }}
      >
        {totalCount === 0
          ? "No transactions"
          : `Show ${totalCount} transactions`}
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/animated-number.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import NumberFlow from "@number-flow/react";

type Props = {
  value: number;
  currency: string;
  minimumFractionDigits?: number;
  maximumFractionDigits?: number;
  locale?: string;
};

export function AnimatedNumber({
  value,
  currency,
  minimumFractionDigits,
  maximumFractionDigits,
  locale,
}: Props) {
  const { data: user } = useUserQuery();
  const localeToUse = locale || user?.locale;

  return (
    <NumberFlow
      value={value}
      format={{
        style: "currency",
        currency: currency ?? "USD",
        minimumFractionDigits,
        maximumFractionDigits,
      }}
      willChange
      locales={localeToUse ?? "en"}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/app-settings.tsx">
import { useTRPC } from "@/trpc/client";
import { Label } from "@midday/ui/label";
import { Switch } from "@midday/ui/switch";
import { useMutation, useQueryClient } from "@tanstack/react-query";

type AppSettingsItem = {
  id: string;
  label: string;
  description: string;
  type: "switch" | "text" | "select";
  required: boolean;
  value: string | boolean;
};

function AppSettingsItem({
  setting,
  appId,
}: {
  setting: AppSettingsItem;
  appId: string;
}) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const updateAppSettingsMutation = useMutation(
    trpc.apps.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.apps.get.queryKey(),
        });
      },
    }),
  );

  switch (setting.type) {
    case "switch":
      return (
        <div className="flex items-center justify-between">
          <div className="pr-4 space-y-1">
            <Label className="text-[#878787]">{setting.label}</Label>
            <p className="text-xs text-[#878787]">{setting.description}</p>
          </div>
          <Switch
            disabled={updateAppSettingsMutation.isPending}
            checked={Boolean(setting.value)}
            onCheckedChange={(checked) => {
              updateAppSettingsMutation.mutate({
                appId,
                option: {
                  id: setting.id,
                  value: Boolean(checked),
                },
              });
            }}
          />
        </div>
      );
    default:
      return null;
  }
}

export function AppSettings({
  settings,
  appId,
}: {
  settings: AppSettingsItem[];
  appId: string;
}) {
  return (
    <div>
      {settings.map((setting) => (
        <div key={setting.id}>
          <AppSettingsItem setting={setting} appId={appId} />
        </div>
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/app.tsx">
import { useTRPC } from "@/trpc/client";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { Button } from "@midday/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@midday/ui/card";
import { ScrollArea } from "@midday/ui/scroll-area";
import { Sheet, SheetContent, SheetHeader } from "@midday/ui/sheet";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import Image from "next/image";
import { parseAsBoolean, parseAsString, useQueryStates } from "nuqs";
import { useState } from "react";
import { AppSettings } from "./app-settings";

export function App({
  id,
  logo: Logo,
  name,
  short_description,
  description,
  settings,
  onInitialize,
  images,
  active,
  installed,
  category,
  userSettings,
}: {
  id: string;
  logo: React.ComponentType;
  name: string;
  short_description: string;
  description: string;
  settings: Record<string, any>;
  onInitialize: () => Promise<void>;
  images: string[];
  active?: boolean;
  installed?: boolean;
  category: string;
  userSettings: Record<string, any>;
}) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const [isLoading, setLoading] = useState(false);
  const [params, setParams] = useQueryStates({
    app: parseAsString,
    settings: parseAsBoolean,
  });

  const disconnectAppMutation = useMutation(
    trpc.apps.disconnect.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.apps.get.queryKey(),
        });
      },
    }),
  );

  const handleDisconnect = () => {
    disconnectAppMutation.mutate({ appId: id });
  };

  const handleOnInitialize = async () => {
    setLoading(true);
    await onInitialize();
    setLoading(false);
  };

  return (
    <Card key={id} className="w-full flex flex-col">
      <Sheet open={params.app === id} onOpenChange={() => setParams(null)}>
        <div className="pt-6 px-6 h-16 flex items-center justify-between">
          <Logo />

          {installed && (
            <div className="text-green-600 bg-green-100 text-[10px] dark:bg-green-900 dark:text-green-300 px-3 py-1 rounded-full font-mono">
              Installed
            </div>
          )}
        </div>

        <CardHeader className="pb-0">
          <div className="flex items-center space-x-2 pb-4">
            <CardTitle className="text-md font-medium leading-none p-0 m-0">
              {name}
            </CardTitle>
            {!active && (
              <span className="text-[#878787] bg-[#F2F1EF] text-[10px] dark:bg-[#1D1D1D] px-3 py-1 rounded-full font-mono">
                Coming soon
              </span>
            )}
          </div>
        </CardHeader>
        <CardContent className="text-xs text-[#878787] pb-4">
          {short_description}
        </CardContent>

        <div className="px-6 pb-6 flex gap-2 mt-auto">
          <Button
            variant="outline"
            className="w-full"
            disabled={!active}
            onClick={() => setParams({ app: id })}
          >
            Details
          </Button>

          {installed ? (
            <Button
              variant="outline"
              className="w-full"
              onClick={handleDisconnect}
            >
              {disconnectAppMutation.isPending
                ? "Disconnecting..."
                : "Disconnect"}
            </Button>
          ) : (
            <Button
              variant="outline"
              className="w-full"
              onClick={handleOnInitialize}
              disabled={!onInitialize || !active || isLoading}
            >
              Install
            </Button>
          )}
        </div>

        <SheetContent>
          <SheetHeader>
            <div className="mb-4">
              <Image
                src={images[0] ?? ""}
                alt={name}
                width={465}
                height={290}
                quality={100}
              />
            </div>

            <div className="flex items-center justify-between border-b border-border pb-2">
              <div className="flex items-center space-x-2">
                <Logo />
                <div>
                  <div className="flex items-center space-x-2">
                    <h3 className="text-lg leading-none">{name}</h3>
                    {installed && (
                      <div className="bg-green-600 text-[9px] dark:bg-green-300 rounded-full size-1" />
                    )}
                  </div>

                  <span className="text-xs text-[#878787]">
                    {category} • Published by Midday
                  </span>
                </div>
              </div>

              <div>
                {installed ? (
                  <Button
                    variant="outline"
                    className="w-full"
                    onClick={handleDisconnect}
                  >
                    {disconnectAppMutation.isPending
                      ? "Disconnecting..."
                      : "Disconnect"}
                  </Button>
                ) : (
                  <Button
                    variant="outline"
                    className="w-full border-primary"
                    onClick={handleOnInitialize}
                    disabled={!onInitialize || !active || isLoading}
                  >
                    Install
                  </Button>
                )}
              </div>
            </div>
          </SheetHeader>

          <ScrollArea className="h-[calc(100vh-530px)] pt-2" hideScrollbar>
            <Accordion
              type="multiple"
              defaultValue={[
                "description",
                ...(params.settings ? ["settings"] : []),
              ]}
              className="mt-4"
            >
              <AccordionItem value="description" className="border-none">
                <AccordionTrigger>How it works</AccordionTrigger>
                <AccordionContent className="text-[#878787] text-sm">
                  {description}
                </AccordionContent>
              </AccordionItem>

              {settings && Object.keys(settings).length > 0 && (
                <AccordionItem value="settings" className="border-none">
                  <AccordionTrigger>Settings</AccordionTrigger>
                  <AccordionContent className="text-[#878787] text-sm">
                    <AppSettings
                      appId={id}
                      // @ts-expect-error
                      settings={[
                        ...Object.values({
                          ...Object.fromEntries(
                            (Array.isArray(settings) ? settings : []).map(
                              (setting) => [setting.id, setting],
                            ),
                          ),
                          ...Object.fromEntries(
                            (Array.isArray(userSettings)
                              ? userSettings
                              : []
                            ).map((setting) => [setting.id, setting]),
                          ),
                        }),
                      ]}
                    />
                  </AccordionContent>
                </AccordionItem>
              )}
            </Accordion>
          </ScrollArea>

          <div className="absolute bottom-4 pt-8 border-t border-border">
            <p className="text-[10px] text-[#878787]">
              All apps on the Midday App Store are open-source and
              peer-reviewed. Midday Labs AB maintains high standards but doesn't
              endorse third-party apps. Apps published by Midday are officially
              certified. Report any concerns about app content or behavior.
            </p>

            <a
              href="mailto:support@midday.dev"
              className="text-[10px] text-red-500"
            >
              Report app
            </a>
          </div>
        </SheetContent>
      </Sheet>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/apple-sign-in.tsx">
"use client";

import { getUrl } from "@/utils/environment";
import { isDesktopApp } from "@midday/desktop-client/platform";
import { createClient } from "@midday/supabase/client";
import { Icons } from "@midday/ui/icons";
import { SubmitButton } from "@midday/ui/submit-button";
import { useState } from "react";

export function AppleSignIn() {
  const [isLoading, setLoading] = useState(false);
  const supabase = createClient();

  const handleSignIn = async () => {
    setLoading(true);

    if (isDesktopApp()) {
      const redirectTo = new URL("/api/auth/callback", getUrl());

      redirectTo.searchParams.append("provider", "apple");
      redirectTo.searchParams.append("client", "desktop");

      await supabase.auth.signInWithOAuth({
        provider: "apple",
        options: {
          redirectTo: redirectTo.toString(),
          queryParams: {
            client: "desktop",
          },
        },
      });
    } else {
      await supabase.auth.signInWithOAuth({
        provider: "apple",
        options: {
          redirectTo: `${getUrl()}/api/auth/callback?provider=apple`,
        },
      });
    }

    setTimeout(() => {
      setLoading(false);
    }, 2000);
  };

  return (
    <SubmitButton
      onClick={handleSignIn}
      className="bg-primary px-6 py-4 text-secondary font-medium h-[40px] w-full"
      isSubmitting={isLoading}
    >
      <div className="flex items-center space-x-2">
        <Icons.Apple />
        <span>Continue with Apple</span>
      </div>
    </SubmitButton>
  );
}
</file>

<file path="apps/dashboard/src/components/apps-header.tsx">
import { AppsTabs } from "./apps-tabs";
import { SearchField } from "./search-field";

export function AppsHeader() {
  return (
    <div className="flex space-x-4">
      <AppsTabs />
      <SearchField placeholder="Search apps" shallow />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/apps-tabs.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { useQueryState } from "nuqs";

const tabs = [
  {
    name: "All",
    value: "all",
  },
  {
    name: "Installed",
    value: "installed",
  },
];

export function AppsTabs() {
  const [currentTab, setTab] = useQueryState("tab", {
    defaultValue: "all",
  });

  return (
    <div className="flex">
      {tabs.map((tab) => (
        <button
          onClick={() => setTab(tab.value)}
          key={tab.value}
          type="button"
          className={cn(
            "text-sm transition-colors px-4",
            "dark:bg-[#1D1D1D] dark:text-[#878787]",
            "bg-white text-gray-600",
            currentTab === tab.value &&
              "text-primary dark:bg-[#2C2C2C] bg-gray-100",
          )}
        >
          {tab.name}
        </button>
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/apps.skeleton.tsx">
import { Card } from "@midday/ui/card";
import { Skeleton } from "@midday/ui/skeleton";

export function AppsSkeleton() {
  return (
    <div className="grid gap-6 grid-cols-1 md:grid-cols-2 lg:grid-cols-3 2xl:grid-cols-4 mx-auto mt-8">
      {Array.from({ length: 8 }).map((_, index) => (
        <Card key={index.toString()} className="w-full flex flex-col">
          <div className="p-6">
            <Skeleton className="h-10 w-10 rounded-full" />

            <div className="mt-6">
              <Skeleton className="h-5 w-[40%]" />
            </div>
            <div className="space-y-2 py-4 pb-0">
              <Skeleton className="h-4 w-[80%]" />
              <Skeleton className="h-4 w-[70%]" />
              <Skeleton className="h-4 w-[160px]" />
            </div>
            <div className="flex items-center justify-between space-x-2 mt-4">
              <Skeleton className="h-10 w-full" />
              <Skeleton className="h-10 w-full" />
            </div>
          </div>
        </Card>
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/apps.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { apps as appStoreApps } from "@midday/app-store";
import type { UnifiedApp } from "@midday/app-store/types";
import { Button } from "@midday/ui/button";
import { useSuspenseQuery } from "@tanstack/react-query";
import { useRouter, useSearchParams } from "next/navigation";
import { UnifiedAppComponent } from "./unified-app";

export function Apps() {
  const trpc = useTRPC();
  const { data: user } = useUserQuery();
  const router = useRouter();

  // Fetch from both endpoints
  const { data: installedOfficialApps } = useSuspenseQuery(
    trpc.apps.get.queryOptions(),
  );

  const { data: externalAppsData } = useSuspenseQuery(
    trpc.oauthApplications.list.queryOptions(),
  );

  const { data: authorizedExternalApps } = useSuspenseQuery(
    trpc.oauthApplications.authorized.queryOptions(),
  );

  const searchParams = useSearchParams();
  const isInstalledPage = searchParams.get("tab") === "installed";
  const search = searchParams.get("q");

  // Transform official apps
  const transformedOfficialApps: UnifiedApp[] = appStoreApps.map((app) => ({
    id: app.id,
    name: app.name,
    category: "category" in app ? app.category : "Integration",
    active: app.active,
    logo: app.logo,
    short_description: app.short_description,
    description: app.description || undefined,
    images: app.images || [],
    installed:
      installedOfficialApps?.some((installed) => installed.app_id === app.id) ??
      false,
    type: "official" as const,
    onInitialize:
      "onInitialize" in app && typeof app.onInitialize === "function"
        ? async () => {
            const result = app.onInitialize();
            return result instanceof Promise ? result : Promise.resolve(result);
          }
        : undefined,
    settings:
      "settings" in app && Array.isArray(app.settings)
        ? app.settings
        : undefined,
    userSettings:
      (installedOfficialApps?.find((installed) => installed.app_id === app.id)
        ?.settings as Record<string, any>) || undefined,
  }));

  // Transform external apps (only approved ones)
  const approvedExternalApps =
    externalAppsData?.data?.filter((app) => app.status === "approved") || [];
  const transformedExternalApps: UnifiedApp[] = approvedExternalApps.map(
    (app) => ({
      id: app.id,
      name: app.name,
      category: "Integration",
      active: app.active ?? false, // Convert null to boolean
      logo: app.logoUrl || undefined, // Convert null to undefined
      short_description: app.description || undefined, // Convert null to undefined
      description: app.overview || app.description || undefined, // Convert null to undefined
      images: app.screenshots || [],
      installed:
        authorizedExternalApps?.data?.some(
          (authorized) => authorized.id === app.id,
        ) ?? false,
      type: "external" as const,
      clientId: app.clientId || undefined, // Convert null to undefined
      scopes: app.scopes || undefined, // Convert null to undefined
      developerName: app.developerName || undefined, // Convert null to undefined
      website: app.website || undefined, // Convert null to undefined
      installUrl: app.installUrl || undefined, // Convert null to undefined
      screenshots: app.screenshots || undefined, // Convert null to undefined
      overview: app.overview || undefined, // Convert null to undefined
      createdAt: app.createdAt || undefined, // Convert null to undefined
      status: app.status || undefined, // Convert null to undefined
      lastUsedAt:
        authorizedExternalApps?.data?.find(
          (authorized) => authorized.id === app.id,
        )?.lastUsedAt || undefined, // Convert null to undefined
    }),
  );

  // Combine all apps
  const allApps = [...transformedOfficialApps, ...transformedExternalApps];

  // Filter apps
  const filteredApps = allApps
    .filter((app) => !isInstalledPage || app.installed)
    .filter(
      (app) => !search || app.name.toLowerCase().includes(search.toLowerCase()),
    );

  return (
    <div className="grid gap-6 grid-cols-1 md:grid-cols-2 lg:grid-cols-3 2xl:grid-cols-4 mx-auto mt-8">
      {filteredApps.map((app) => (
        <UnifiedAppComponent
          key={app.id}
          app={app}
          userEmail={user?.email || undefined}
        />
      ))}

      {!search && !filteredApps.length && (
        <div className="col-span-full flex flex-col items-center justify-center h-[calc(100vh-400px)]">
          <h3 className="text-lg font-semibold text-[#1D1D1D] dark:text-[#F2F1EF]">
            No apps installed
          </h3>
          <p className="mt-2 text-sm text-[#878787] text-center max-w-md">
            You haven't installed any apps yet. Go to the 'All Apps' tab to
            browse available apps.
          </p>
        </div>
      )}

      {search && !filteredApps.length && (
        <div className="col-span-full flex flex-col items-center justify-center h-[calc(100vh-400px)]">
          <h3 className="text-lg font-semibold text-[#1D1D1D] dark:text-[#F2F1EF]">
            No apps found
          </h3>
          <p className="mt-2 text-sm text-[#878787] text-center max-w-md">
            No apps found for your search, let us know if you want to see a
            specific app in the app store.
          </p>

          <Button
            onClick={() => router.push("/apps")}
            className="mt-4"
            variant="outline"
          >
            Clear search
          </Button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/assign-user.tsx">
import { useTRPC } from "@/trpc/client";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";
import { useQuery } from "@tanstack/react-query";
import { useEffect, useState } from "react";
import { AssignedUser } from "./assigned-user";

type User = {
  id: string;
  avatar_url?: string | null;
  full_name: string | null;
};

type Props = {
  selectedId?: string;
  onSelect: (user?: User) => void;
};

export function AssignUser({ selectedId, onSelect }: Props) {
  const [value, setValue] = useState<string>();
  const trpc = useTRPC();

  const { data: users } = useQuery(trpc.team.members.queryOptions());

  useEffect(() => {
    setValue(selectedId);
  }, [selectedId]);

  return (
    <Select
      value={value}
      onValueChange={(id) => {
        const found = users?.find(({ user }) => user?.id === id)?.user;

        if (found) {
          onSelect({
            id: found.id,
            full_name: found.fullName ?? null,
            avatar_url: found.avatarUrl ?? null,
          });
        } else {
          onSelect(undefined);
        }
      }}
    >
      <SelectTrigger
        id="assign"
        className="line-clamp-1 truncate"
        onKeyDown={(evt) => evt.preventDefault()}
      >
        <SelectValue placeholder="Select" />
      </SelectTrigger>

      <SelectContent className="overflow-y-auto max-h-[200px]">
        {users?.map(({ user }) => {
          return (
            <SelectItem key={user?.id} value={user?.id ?? ""}>
              <AssignedUser
                fullName={user?.fullName}
                avatarUrl={user?.avatarUrl}
              />
            </SelectItem>
          );
        })}
      </SelectContent>
    </Select>
  );
}
</file>

<file path="apps/dashboard/src/components/assigned-user.tsx">
import { Avatar } from "@midday/ui/avatar";
import Image from "next/image";

type Props = {
  avatarUrl?: string | null;
  fullName?: string | null;
};

export function AssignedUser({ avatarUrl, fullName }: Props) {
  return (
    <div className="flex space-x-2 items-center">
      {avatarUrl && (
        <Avatar className="h-5 w-5">
          <Image src={avatarUrl} alt={fullName ?? ""} width={20} height={20} />
        </Avatar>
      )}
      <span className="truncate">{fullName?.split(" ").at(0)}</span>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/attachment-item.tsx">
"use client";

import { useDocumentParams } from "@/hooks/use-document-params";
import { formatSize } from "@/utils/format";
import { Button } from "@midday/ui/button";
import { Skeleton } from "@midday/ui/skeleton";
import { X } from "lucide-react";
import { FilePreview } from "./file-preview";

export type Attachment = {
  id?: string;
  type: string;
  name: string;
  size: number;
  isUploading?: boolean;
  path?: string[];
};

type Props = {
  file: Attachment;
  onDelete: () => void;
};

export function AttachmentItem({ file, onDelete }: Props) {
  const { setParams } = useDocumentParams();

  return (
    <div className="flex items-center justify-between">
      <div className="flex space-x-4 items-center">
        <div className="w-[40px] h-[40px] overflow-hidden cursor-pointer">
          {file.isUploading ? (
            <Skeleton className="w-full h-full" />
          ) : (
            <button
              onClick={() => setParams({ filePath: file?.path?.join("/") })}
              className="w-full h-full"
              type="button"
            >
              <FilePreview
                mimeType={file.type}
                filePath={`${file?.path?.join("/")}`}
              />
            </button>
          )}
        </div>

        <div className="flex flex-col space-y-0.5 w-80">
          <span className="truncate">{file.name}</span>
          <span className="text-xs text-[#606060]">
            {file.size && formatSize(file.size)}
          </span>
        </div>
      </div>

      <Button
        variant="ghost"
        size="icon"
        className="w-auto hover:bg-transparent flex"
        onClick={onDelete}
      >
        <X size={14} />
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/avatar-upload.tsx">
"use client";

import { useUpload } from "@/hooks/use-upload";
import { useTRPC } from "@/trpc/client";
import { Avatar, AvatarFallback, AvatarImage } from "@midday/ui/avatar";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import { stripSpecialCharacters } from "@midday/utils";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { Loader2 } from "lucide-react";
import { useRef, useState } from "react";
import { forwardRef } from "react";

type Props = {
  userId: string;
  avatarUrl?: string | null;
  onUpload?: (url: string) => void;
  size?: number;
  className?: string;
};

export const AvatarUpload = forwardRef<HTMLInputElement, Props>(
  (
    { userId, avatarUrl: initialAvatarUrl, size = 65, onUpload, className },
    ref,
  ) => {
    const [avatar, setAvatar] = useState(initialAvatarUrl);
    const inputRef = useRef<HTMLInputElement>(null);
    const trpc = useTRPC();
    const queryClient = useQueryClient();

    const updateUserMutation = useMutation(
      trpc.user.update.mutationOptions({
        onSuccess: () => {
          queryClient.invalidateQueries({
            queryKey: trpc.user.me.queryKey(),
          });
        },
      }),
    );

    const { isLoading, uploadFile } = useUpload();

    const handleUpload = async (evt: React.ChangeEvent<HTMLInputElement>) => {
      const { files } = evt.target;
      const selectedFile = files as FileList;

      const filename = stripSpecialCharacters(selectedFile[0]?.name ?? "");

      const { url } = await uploadFile({
        bucket: "avatars",
        path: [userId, filename],
        file: selectedFile[0] as File,
      });

      if (url) {
        updateUserMutation.mutate({ avatarUrl: url });
        setAvatar(url);
        onUpload?.(url);
      }
    };

    const fileInputRef = ref || inputRef;

    return (
      <Avatar
        className={cn(
          "rounded-full flex items-center justify-center bg-accent cursor-pointer border border-border",
          className,
        )}
        style={{ width: size, height: size }}
        onClick={() => {
          if ("current" in fileInputRef && fileInputRef.current) {
            fileInputRef.current.click();
          }
        }}
      >
        {isLoading ? (
          <Loader2 className="size-4 animate-spin" />
        ) : (
          <>
            <AvatarImage src={avatar ?? undefined} />
            <AvatarFallback>
              <Icons.AccountCircle className="size-5" />
            </AvatarFallback>
          </>
        )}
        <input
          ref={fileInputRef}
          type="file"
          style={{ display: "none" }}
          multiple={false}
          onChange={handleUpload}
        />
      </Avatar>
    );
  },
);

AvatarUpload.displayName = "AvatarUpload";
</file>

<file path="apps/dashboard/src/components/average-days-to-payment.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { Card, CardContent, CardHeader, CardTitle } from "@midday/ui/card";
import NumberFlow from "@number-flow/react";
import { useSuspenseQuery } from "@tanstack/react-query";

export function AverageDaysToPayment() {
  const trpc = useTRPC();
  const { data } = useSuspenseQuery(
    trpc.invoice.averageDaysToPayment.queryOptions(),
  );

  return (
    <Card>
      <CardHeader className="pb-3">
        <CardTitle className="font-mono font-medium text-2xl">
          <NumberFlow value={data} willChange />d
        </CardTitle>
      </CardHeader>

      <CardContent className="pb-[34px]">
        <div className="flex flex-col gap-2">
          <div>Average Days to Payment</div>
          <div className="text-sm text-muted-foreground">
            Cross all paid invoices this month
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/average-invoice-size.tsx">
"use client";

import { useTeamQuery } from "@/hooks/use-team";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { Card, CardContent, CardHeader, CardTitle } from "@midday/ui/card";
import { useSuspenseQuery } from "@tanstack/react-query";
import { FormatAmount } from "./format-amount";

export function AverageInvoiceSize() {
  const trpc = useTRPC();
  const { data: team } = useTeamQuery();
  const { data: user } = useUserQuery();
  const { data } = useSuspenseQuery(
    trpc.invoice.averageInvoiceSize.queryOptions(),
  );

  if (!data || data.length === 0) {
    return (
      <Card>
        <CardHeader className="pb-3">
          <CardTitle className="font-mono font-medium text-2xl">$0</CardTitle>
        </CardHeader>

        <CardContent className="pb-[34px]">
          <div className="flex flex-col gap-2">
            <div>Average Invoice Size</div>
            <div className="text-sm text-muted-foreground">
              No invoices sent this month
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  // If multiple currencies, show the primary one or the first one
  const primaryData = data[0];

  return (
    <Card>
      <CardHeader className="pb-3">
        <CardTitle className="font-mono font-medium text-2xl">
          <FormatAmount
            amount={primaryData?.averageAmount ?? 0}
            currency={primaryData?.currency || team?.baseCurrency || "USD"}
            locale={user?.locale ?? undefined}
          />
        </CardTitle>
      </CardHeader>

      <CardContent className="pb-[34px]">
        <div className="flex flex-col gap-2">
          <div>Average Invoice Size</div>
          <div className="text-sm text-muted-foreground">
            Based on invoices sent this month
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/bank-account-list-skeleton.tsx">
import { Skeleton } from "@midday/ui/skeleton";

export function BankAccountListSkeleton() {
  return (
    <div className="px-6 pb-6 space-y-6 divide-y">
      <div className="flex justify-between items-center">
        <div className="ml-[30px] divide-y">
          <div className="flex justify-between items-center mb-4 pt-4">
            <div className="flex items-center">
              <Skeleton className="flex h-9 w-9 items-center justify-center space-y-0 rounded-full" />
              <div className="ml-4 flex flex-col">
                <p className="text-sm font-medium leading-none mb-1">
                  <Skeleton className="h-3 w-[200px] rounded-none" />
                </p>
                <span className="text-xs font-medium text-[#606060]">
                  <Skeleton className="h-2.5 w-[100px] mt-1 rounded-none" />
                </span>
              </div>
            </div>
          </div>
          <div className="flex justify-between items-center mb-4 pt-4">
            <div className="flex items-center">
              <Skeleton className="flex h-9 w-9 items-center justify-center space-y-0 rounded-full" />
              <div className="ml-4 flex flex-col">
                <p className="text-sm font-medium leading-none mb-1">
                  <Skeleton className="h-3 w-[200px] rounded-none" />
                </p>
                <span className="text-xs font-medium text-[#606060]">
                  <Skeleton className="h-2.5 w-[100px] mt-1 rounded-none" />
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/bank-account-list.tsx">
import { BankConnections } from "./bank-connections";
import { ManualAccounts } from "./manual-accounts";

export function BankAccountList() {
  return (
    <>
      <BankConnections />
      <ManualAccounts />
    </>
  );
}
</file>

<file path="apps/dashboard/src/components/bank-account.tsx">
"use client";

import { useI18n } from "@/locales/client";
import { useTRPC } from "@/trpc/client";
import { getInitials } from "@/utils/format";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@midday/ui/alert-dialog";
import { Avatar, AvatarFallback } from "@midday/ui/avatar";
import { cn } from "@midday/ui/cn";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Input } from "@midday/ui/input";
import { Label } from "@midday/ui/label";
import { Switch } from "@midday/ui/switch";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { MoreHorizontal } from "lucide-react";
import { Loader2 } from "lucide-react";
import { parseAsBoolean, parseAsString, useQueryStates } from "nuqs";
import { useState } from "react";
import { FormatAmount } from "./format-amount";
import { EditBankAccountModal } from "./modals/edit-bank-account-modal";

type Props = {
  data: NonNullable<
    RouterOutputs["bankConnections"]["get"]
  >[number]["bankAccounts"][number];
};

export function BankAccount({ data }: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const [value, setValue] = useState("");
  const [isOpen, setOpen] = useState(false);
  const t = useI18n();

  const [_, setParams] = useQueryStates({
    step: parseAsString,
    accountId: parseAsString,
    hide: parseAsBoolean,
    type: parseAsString,
  });

  const { id, enabled, manual, type, name, balance, currency } = data;

  const deleteAccountMutation = useMutation(
    trpc.bankAccounts.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.bankAccounts.get.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.bankConnections.get.queryKey(),
        });

        setOpen(false);
      },
    }),
  );

  const updateAccountMutation = useMutation(
    trpc.bankAccounts.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.bankAccounts.get.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.bankConnections.get.queryKey(),
        });
      },
    }),
  );

  return (
    <div
      className={cn(
        "flex justify-between items-center mb-4 pt-4",
        !enabled && "opacity-60",
      )}
    >
      <div className="flex items-center space-x-4 w-full mr-8">
        <Avatar className="size-[34px]">
          <AvatarFallback className="text-[11px]">
            {getInitials(name ?? "")}
          </AvatarFallback>
        </Avatar>

        <div className="flex items-center justify-between w-full">
          <div className="flex flex-col">
            <p className="font-medium leading-none mb-1 text-sm">{name}</p>
          </div>

          {balance && currency ? (
            <span className="text-[#878787] text-sm">
              <FormatAmount amount={balance} currency={currency} />
            </span>
          ) : null}
        </div>
      </div>

      <div className="flex items-center space-x-4">
        <AlertDialog>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <MoreHorizontal size={20} />
            </DropdownMenuTrigger>
            <DropdownMenuContent className="w-48">
              <DropdownMenuItem onClick={() => setOpen(true)}>
                Edit
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem
                onClick={() => {
                  setParams({
                    step: "import",
                    accountId: id,
                    type,
                    hide: true,
                  });
                }}
              >
                Import
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <AlertDialogTrigger className="w-full text-left">
                  Remove
                </AlertDialogTrigger>
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>

          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Delete Account</AlertDialogTitle>
              <AlertDialogDescription>
                You are about to delete a bank account. If you proceed, all
                transactions associated with this account will also be deleted.
              </AlertDialogDescription>
            </AlertDialogHeader>

            <div className="flex flex-col gap-2 mt-2">
              <Label htmlFor="confirm-delete">
                Type <span className="font-medium">DELETE</span> to confirm.
              </Label>
              <Input
                id="confirm-delete"
                value={value}
                onChange={(e) => setValue(e.target.value)}
              />
            </div>

            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction
                disabled={value !== "DELETE"}
                onClick={() => deleteAccountMutation.mutate({ id })}
              >
                {deleteAccountMutation.isPending ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  "Confirm"
                )}
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>

        {!manual && (
          <Switch
            checked={enabled}
            disabled={updateAccountMutation.isPending}
            onCheckedChange={(enabled: boolean) => {
              updateAccountMutation.mutate({ id, enabled });
            }}
          />
        )}
      </div>

      <EditBankAccountModal
        id={id}
        onOpenChange={setOpen}
        isOpen={isOpen}
        defaultName={name}
        defaultType={type}
        defaultBalance={balance}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/bank-connect-button.tsx">
import { Button } from "@midday/ui/button";
import { Loader2 } from "lucide-react";
import { useState } from "react";

type Props = {
  onClick: () => void;
};

export function BankConnectButton({ onClick }: Props) {
  const [isLoading, setLoading] = useState(false);

  const handleOnClick = () => {
    setLoading(true);
    onClick();

    setTimeout(() => {
      setLoading(false);
    }, 3000);
  };

  return (
    <Button
      variant="outline"
      data-event="Bank Selected"
      data-icon="🏦"
      data-channel="bank"
      disabled={isLoading}
      onClick={handleOnClick}
    >
      {isLoading ? <Loader2 className="w-4 h-4 animate-spin" /> : "Connect"}
    </Button>
  );
}
</file>

<file path="apps/dashboard/src/components/bank-connections.tsx">
"use client";

import { manualSyncTransactionsAction } from "@/actions/transactions/manual-sync-transactions-action";
import { reconnectConnectionAction } from "@/actions/transactions/reconnect-connection-action";
import { useSyncStatus } from "@/hooks/use-sync-status";
import { useTRPC } from "@/trpc/client";
import { connectionStatus } from "@/utils/connection-status";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useToast } from "@midday/ui/use-toast";
import { useQueryClient, useSuspenseQuery } from "@tanstack/react-query";
import { differenceInDays, formatDistanceToNow } from "date-fns";
import { useAction } from "next-safe-action/hooks";
import { parseAsString, useQueryStates } from "nuqs";
import { useEffect, useState } from "react";
import { BankAccount } from "./bank-account";
import { BankLogo } from "./bank-logo";
import { DeleteConnection } from "./delete-connection";
import { ReconnectProvider } from "./reconnect-provider";
import { SyncTransactions } from "./sync-transactions";

function getProviderName(provider: string | null) {
  switch (provider) {
    case "gocardless":
      return "GoCardLess";
    case "enablebanking":
      return "Enable Banking";
    case "teller":
      return "Teller";
    case "plaid":
      return "Plaid";
    default:
      return null;
  }
}

type BankConnection = NonNullable<
  RouterOutputs["bankConnections"]["get"]
>[number];

function ConnectionState({
  connection,
  isSyncing,
}: { connection: BankConnection; isSyncing: boolean }) {
  const { show, expired } = connectionStatus(connection);

  if (isSyncing) {
    return (
      <div className="text-xs font-normal flex items-center space-x-1">
        <span>Syncing...</span>
      </div>
    );
  }

  if (connection.status === "disconnected") {
    return (
      <>
        <div className="text-xs font-normal flex items-center space-x-1 text-[#c33839]">
          <Icons.AlertCircle />
          <span>Connection issue</span>
        </div>

        <TooltipContent
          className="px-3 py-1.5 text-xs max-w-[430px]"
          sideOffset={20}
          side="left"
        >
          Please reconnect to restore the connection to a good state.
        </TooltipContent>
      </>
    );
  }

  if (show) {
    return (
      <>
        <div className="text-xs font-normal flex items-center space-x-1 text-[#FFD02B]">
          <Icons.AlertCircle />
          <span>Connection expires soon</span>
        </div>

        {connection.expiresAt && (
          <TooltipContent
            className="px-3 py-1.5 text-xs max-w-[430px]"
            sideOffset={20}
            side="left"
          >
            We only have access to your bank for another{" "}
            {differenceInDays(new Date(connection.expiresAt), new Date())} days.
            Please update the connection to keep everything in sync.
          </TooltipContent>
        )}
      </>
    );
  }

  if (expired) {
    return (
      <div className="text-xs font-normal flex items-center space-x-1 text-[#c33839]">
        <Icons.Error />
        <span>Connection expired</span>
      </div>
    );
  }

  if (connection.lastAccessed) {
    return (
      <div className="text-xs font-normal flex items-center space-x-1">
        <span className="text-xs font-normal">{`Updated ${formatDistanceToNow(
          new Date(connection.lastAccessed),
          {
            addSuffix: true,
          },
        )}`}</span>
        <span>via {getProviderName(connection.provider)}</span>
      </div>
    );
  }

  return <div className="text-xs font-normal">Never accessed</div>;
}

export function BankConnection({ connection }: { connection: BankConnection }) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const [runId, setRunId] = useState<string | undefined>();
  const [accessToken, setAccessToken] = useState<string | undefined>();
  const [isSyncing, setSyncing] = useState(false);
  const { toast, dismiss } = useToast();

  const { show } = connectionStatus(connection);
  const { status, setStatus } = useSyncStatus({ runId, accessToken });

  const [params] = useQueryStates({
    step: parseAsString,
    id: parseAsString,
  });

  const manualSyncTransactions = useAction(manualSyncTransactionsAction, {
    onExecute: () => setSyncing(true),
    onSuccess: ({ data }) => {
      if (data) {
        setRunId(data.id);
        setAccessToken(data.publicAccessToken);
      }
    },
    onError: () => {
      setSyncing(false);
      setRunId(undefined);
      setStatus("FAILED");

      toast({
        duration: 3500,
        variant: "error",
        title: "Something went wrong please try again.",
      });
    },
  });

  const reconnectConnection = useAction(reconnectConnectionAction, {
    onExecute: () => setSyncing(true),
    onSuccess: ({ data }) => {
      if (data) {
        setRunId(data.id);
        setAccessToken(data.publicAccessToken);
      }
    },
    onError: () => {
      setSyncing(false);
      setRunId(undefined);
      setStatus("FAILED");

      toast({
        duration: 3500,
        variant: "error",
        title: "Something went wrong please try again.",
      });
    },
  });

  useEffect(() => {
    if (isSyncing) {
      toast({
        title: "Syncing...",
        description: "We're connecting to your bank, please wait.",
        duration: Number.POSITIVE_INFINITY,
        variant: "spinner",
      });
    }
  }, [isSyncing]);

  useEffect(() => {
    if (status === "COMPLETED") {
      dismiss();
      setRunId(undefined);
      setSyncing(false);

      queryClient.invalidateQueries({
        queryKey: trpc.bankConnections.get.queryKey(),
      });

      queryClient.invalidateQueries({
        queryKey: trpc.bankAccounts.get.queryKey(),
      });

      queryClient.invalidateQueries({
        queryKey: trpc.team.current.queryKey(),
      });

      queryClient.invalidateQueries({
        queryKey: trpc.transactions.get.queryKey(),
      });

      queryClient.invalidateQueries({
        queryKey: trpc.transactions.get.infiniteQueryKey(),
      });
    }
  }, [status]);

  useEffect(() => {
    if (status === "FAILED") {
      setSyncing(false);
      setRunId(undefined);

      queryClient.invalidateQueries({
        queryKey: trpc.bankConnections.get.queryKey(),
      });

      queryClient.invalidateQueries({
        queryKey: trpc.bankAccounts.get.queryKey(),
      });

      toast({
        duration: 3500,
        variant: "error",
        title: "Something went wrong please try again.",
      });
    }
  }, [status]);

  // NOTE: GoCardLess reconnect flow (redirect from API route)
  useEffect(() => {
    if (params.step === "reconnect" && params.id) {
      reconnectConnection.execute({
        connectionId: params.id,
        provider: connection.provider as
          | "gocardless"
          | "plaid"
          | "teller"
          | "enablebanking",
      });
    }
  }, [params]);

  const handleManualSync = () => {
    manualSyncTransactions.execute({
      connectionId: connection.id,
    });
  };

  return (
    <div>
      <div className="flex justify-between items-center">
        <AccordionTrigger
          className="justify-start text-start w-full"
          chevronBefore
        >
          <div className="flex space-x-4 items-center ml-4 w-full">
            <BankLogo src={connection.logoUrl} alt={connection.name} />

            <div className="flex flex-col">
              <span className="text-sm">{connection.name}</span>

              <TooltipProvider delayDuration={70}>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <div>
                      <ConnectionState
                        connection={connection}
                        isSyncing={isSyncing}
                      />
                    </div>
                  </TooltipTrigger>
                </Tooltip>
              </TooltipProvider>
            </div>
          </div>
        </AccordionTrigger>

        <div className="ml-auto flex space-x-2 items-center">
          {connection.status === "disconnected" || show ? (
            <>
              <ReconnectProvider
                variant="button"
                id={connection.id}
                provider={connection.provider}
                enrollmentId={connection.enrollmentId}
                institutionId={connection.institutionId}
                accessToken={connection.accessToken}
                onManualSync={handleManualSync}
                referenceId={connection.referenceId}
              />
              <DeleteConnection connectionId={connection.id} />
            </>
          ) : (
            <>
              <ReconnectProvider
                id={connection.id}
                provider={connection.provider}
                enrollmentId={connection.enrollmentId}
                institutionId={connection.institutionId}
                accessToken={connection.accessToken}
                onManualSync={handleManualSync}
                referenceId={connection.referenceId}
              />
              <SyncTransactions
                disabled={isSyncing}
                onClick={handleManualSync}
              />
              <DeleteConnection connectionId={connection.id} />
            </>
          )}
        </div>
      </div>

      <AccordionContent className="bg-background">
        <div className="ml-[30px] divide-y">
          {connection.bankAccounts.map((account) => {
            return <BankAccount key={account.id} data={account} />;
          })}
        </div>
      </AccordionContent>
    </div>
  );
}

export function BankConnections() {
  const trpc = useTRPC();
  const { data } = useSuspenseQuery(trpc.bankConnections.get.queryOptions());
  const defaultValue = data?.length === 1 ? ["connection-0"] : undefined;

  return (
    <div className="px-6 divide-y">
      <Accordion type="multiple" className="w-full" defaultValue={defaultValue}>
        {data?.map((connection, index) => {
          return (
            <AccordionItem
              value={`connection-${index}`}
              key={connection.id}
              className="border-none"
            >
              <BankConnection connection={connection} />
            </AccordionItem>
          );
        })}
      </Accordion>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/bank-logo.tsx">
import { Avatar, AvatarFallback, AvatarImage } from "@midday/ui/avatar";
import { cn } from "@midday/ui/cn";
import { useState } from "react";

type Props = {
  src: string | null;
  alt: string;
  size?: number;
};

export function BankLogo({ src, alt, size = 34 }: Props) {
  const [hasError, setHasError] = useState(false);
  const showingFallback = !src || hasError;

  return (
    <Avatar
      style={{ width: size, height: size }}
      className={cn(!showingFallback && "border border-border")}
    >
      {src && !hasError ? (
        <AvatarImage
          src={src}
          alt={alt}
          className="object-contain bg-white"
          onError={() => setHasError(true)}
        />
      ) : (
        <AvatarImage
          src="https://cdn-engine.midday.ai/default.jpg"
          alt={alt}
          className="object-contain"
        />
      )}
      <AvatarFallback>
        <AvatarImage
          src="https://cdn-engine.midday.ai/default.jpg"
          alt={alt}
          className="object-contain"
        />
      </AvatarFallback>
    </Avatar>
  );
}
</file>

<file path="apps/dashboard/src/components/bulk-actions.tsx">
"use client";

import { useTransactionsStore } from "@/store/transactions";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { useToast } from "@midday/ui/use-toast";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { SelectCategory } from "./select-category";
import { SelectUser } from "./select-user";

type Props = {
  ids: string[];
};

export function BulkActions({ ids }: Props) {
  const trpc = useTRPC();
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const { setRowSelection } = useTransactionsStore();

  const updateTransactionsMutation = useMutation(
    trpc.transactions.updateMany.mutationOptions({
      onSuccess: (_, data) => {
        // Invalidate the transaction list query
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });

        // Reset the row selection
        setRowSelection({});

        toast({
          title: `Updated ${data?.ids.length} transactions.`,
          variant: "success",
          duration: 3500,
        });
      },
      onError: () => {
        toast({
          title: "Something went wrong please try again.",
          duration: 3500,
          variant: "error",
        });
      },
    }),
  );

  const { data: tags } = useQuery({
    ...trpc.tags.get.queryOptions(),
    enabled: ids.length > 0,
  });

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" className="space-x-2">
          <span>Actions</span>
          <Icons.ChevronDown size={16} />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-[180px]" sideOffset={8}>
        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.Category className="mr-2 h-4 w-4" />
              <span>Categories</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                className="p-0 w-[250px] h-[270px]"
              >
                <SelectCategory
                  onChange={(selected) => {
                    updateTransactionsMutation.mutate({
                      ids,
                      categorySlug: selected.slug,
                    });
                  }}
                  headless
                />
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>

        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.Status className="mr-2 h-4 w-4" />
              <span>Tags</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                alignOffset={-4}
                className="py-2 max-h-[200px] overflow-y-auto max-w-[220px]"
              >
                {tags && tags.length > 0 ? (
                  tags.map((tag) => (
                    <DropdownMenuCheckboxItem
                      key={tag.id}
                      checked={ids.includes(tag.id)}
                      onCheckedChange={() => {
                        updateTransactionsMutation.mutate({
                          ids,
                          tagId: tag.id,
                        });
                      }}
                    >
                      {tag.name}
                    </DropdownMenuCheckboxItem>
                  ))
                ) : (
                  <p className="text-sm text-[#878787] px-2">No tags found</p>
                )}
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>

        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.Visibility className="mr-2 h-4 w-4" />
              <span>Exclude</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent sideOffset={14}>
                <DropdownMenuCheckboxItem
                  onCheckedChange={() => {
                    updateTransactionsMutation.mutate({
                      ids,
                      status: "excluded",
                    });
                  }}
                >
                  Yes
                </DropdownMenuCheckboxItem>
                <DropdownMenuCheckboxItem
                  onCheckedChange={() => {
                    updateTransactionsMutation.mutate({
                      ids,
                      status: "posted",
                    });
                  }}
                >
                  No
                </DropdownMenuCheckboxItem>
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>

        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.Files className="mr-2 h-4 w-4" />
              <span>Archive</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent sideOffset={14}>
                <DropdownMenuCheckboxItem
                  onCheckedChange={() => {
                    updateTransactionsMutation.mutate({
                      ids,
                      status: "archived",
                    });
                  }}
                >
                  Yes
                </DropdownMenuCheckboxItem>
                <DropdownMenuCheckboxItem
                  onCheckedChange={() => {
                    updateTransactionsMutation.mutate({
                      ids,
                      status: "posted",
                    });
                  }}
                >
                  No
                </DropdownMenuCheckboxItem>
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>

        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.Face className="mr-2 h-4 w-4" />
              <span>Assign</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                className="w-[230px] h-[170px] p-4 space-y-4"
              >
                <SelectUser
                  onSelect={(selected) => {
                    updateTransactionsMutation.mutate({
                      ids,
                      assignedId: selected?.id,
                    });
                  }}
                />
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>

        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.AlertCircle className="mr-2 h-4 w-4" />
              <span>Status</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent sideOffset={14}>
                <DropdownMenuCheckboxItem
                  onCheckedChange={() => {
                    updateTransactionsMutation.mutate({
                      ids,
                      status: "completed",
                    });
                  }}
                >
                  Completed
                </DropdownMenuCheckboxItem>
                <DropdownMenuCheckboxItem
                  onCheckedChange={() => {
                    updateTransactionsMutation.mutate({
                      ids,
                      status: "posted",
                    });
                  }}
                >
                  Uncompleted
                </DropdownMenuCheckboxItem>
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>

        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.Repeat className="mr-2 h-4 w-4" />
              <span>Recurring</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent sideOffset={14}>
                {[
                  {
                    label: "None",
                    value: null,
                  },
                  {
                    label: "Weekly",
                    value: "weekly",
                  },
                  {
                    label: "Monthly",
                    value: "monthly",
                  },
                  {
                    label: "Annually",
                    value: "annually",
                  },
                ].map((item) => (
                  <DropdownMenuCheckboxItem
                    key={item.value}
                    onCheckedChange={() => {
                      updateTransactionsMutation.mutate({
                        ids,
                        frequency: item.value as
                          | "weekly"
                          | "monthly"
                          | "annually"
                          | "irregular",
                        recurring: item.value !== null,
                      });
                    }}
                  >
                    {item.label}
                  </DropdownMenuCheckboxItem>
                ))}
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/category.tsx">
"use client";

import { cn } from "@midday/ui/cn";

type CategoryIconProps = {
  color?: string;
  size?: number;
  className?: string;
};

export function CategoryColor({
  color,
  className,
  size = 12,
}: CategoryIconProps) {
  return (
    <div
      className={className}
      style={{
        backgroundColor: color,
        width: size,
        height: size,
      }}
    />
  );
}

type Props = {
  name: string;
  className?: string;
  color?: string;
};

export function Category({ name, color, className }: Props) {
  return (
    <div className={cn("flex space-x-2 items-center", className)}>
      <CategoryColor color={color} />
      {name && <span>{name}</span>}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/change-email.tsx">
"use client";

import { useUserMutation, useUserQuery } from "@/hooks/use-user";
import { useZodForm } from "@/hooks/use-zod-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { z } from "zod";

const formSchema = z.object({
  email: z.string().email(),
});

export function ChangeEmail() {
  const { data: user } = useUserQuery();
  const updateUserMutation = useUserMutation();

  const form = useZodForm(formSchema, {
    defaultValues: {
      email: user?.email ?? undefined,
    },
  });

  const onSubmit = form.handleSubmit((data) => {
    updateUserMutation.mutate({
      email: data.email,
    });
  });

  return (
    <Form {...form}>
      <form onSubmit={onSubmit}>
        <Card>
          <CardHeader>
            <CardTitle>Email</CardTitle>
            <CardDescription>Change your email address.</CardDescription>
          </CardHeader>

          <CardContent>
            <FormField
              control={form.control}
              name="email"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Input
                      {...field}
                      className="max-w-[300px]"
                      autoComplete="off"
                      autoCapitalize="none"
                      autoCorrect="off"
                      spellCheck="false"
                      type="email"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </CardContent>

          <CardFooter className="flex justify-between">
            <div>
              This is your primary email address for notifications and more.
            </div>
            <SubmitButton
              type="submit"
              isSubmitting={updateUserMutation.isPending}
            >
              Save
            </SubmitButton>
          </CardFooter>
        </Card>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/change-theme.tsx">
import { ThemeSwitch } from "@/components/theme-switch";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";

export function ChangeTheme() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Appearance</CardTitle>
        <CardDescription>
          Customize how Midday looks on your device.
        </CardDescription>
      </CardHeader>

      <CardContent>
        <div className="w-[240px]">
          <ThemeSwitch />
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/change-timezone.tsx">
"use client";

import { useUserMutation, useUserQuery } from "@/hooks/use-user";
import { useI18n } from "@/locales/client";
import { getTimezones } from "@midday/location/timezones";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { ComboboxDropdown } from "@midday/ui/combobox-dropdown";
import { Label } from "@midday/ui/label";
import { Switch } from "@midday/ui/switch";
import { useEffect, useState } from "react";

export function ChangeTimezone() {
  const t = useI18n();
  const { data: user } = useUserQuery();
  const updateUserMutation = useUserMutation();

  const timezones = getTimezones();
  const [currentBrowserTimezone, setCurrentBrowserTimezone] =
    useState<string>("");

  // Get browser timezone on mount
  useEffect(() => {
    try {
      const browserTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      setCurrentBrowserTimezone(browserTz);
    } catch (error) {
      console.warn("Failed to detect browser timezone:", error);
    }
  }, []);

  const timezoneItems = timezones.map((tz, id) => ({
    id: id.toString(),
    label: tz.name,
    value: tz.tzCode,
  }));

  const isAutoSyncEnabled = user?.timezoneAutoSync !== false;
  const currentTimezone = user?.timezone || currentBrowserTimezone;
  const currentTimezoneName =
    timezoneItems.find((item) => item.value === currentTimezone)?.label ||
    currentTimezone;

  const handleAutoSyncToggle = (enabled: boolean) => {
    updateUserMutation.mutate({
      timezoneAutoSync: enabled,
      // If enabling auto-sync, update to browser timezone
      ...(enabled &&
        currentBrowserTimezone && {
          timezone: currentBrowserTimezone,
        }),
    });
  };

  const handleManualTimezoneChange = (item: { value: string }) => {
    // When manually changing timezone, disable auto-sync
    updateUserMutation.mutate({
      timezone: item.value,
      timezoneAutoSync: false,
    });
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>{t("timezone.title")}</CardTitle>
        <CardDescription>{t("timezone.description")}</CardDescription>
      </CardHeader>

      <CardContent className="space-y-6">
        {/* Auto-sync toggle */}
        <div className="flex items-center justify-between">
          <div className="space-y-0.5">
            <Label htmlFor="auto-sync">Use device timezone</Label>
            <div className="text-[0.8rem] text-muted-foreground">
              Automatically use your device's current timezone
              <div>Current: {currentBrowserTimezone}</div>
            </div>
          </div>
          <Switch
            id="auto-sync"
            checked={isAutoSyncEnabled}
            onCheckedChange={handleAutoSyncToggle}
          />
        </div>

        {/* Manual timezone selection - only show when auto-sync is disabled */}
        {!isAutoSyncEnabled && (
          <div className="space-y-2">
            <Label>Timezone</Label>
            <div className="w-full">
              <ComboboxDropdown
                placeholder={t("timezone.placeholder")}
                selectedItem={timezoneItems.find(
                  (item) => item.value === currentTimezone,
                )}
                searchPlaceholder={t("timezone.searchPlaceholder")}
                items={timezoneItems}
                className="text-xs py-1"
                onSelect={handleManualTimezoneChange}
              />
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/checkout-success-desktop.tsx">
"use client";

import Image from "next/image";
import appIcon from "public/appicon.png";
import { useEffect, useRef } from "react";

interface CheckoutSuccessDesktopProps {
  redirectPath: string;
}

export function CheckoutSuccessDesktop({
  redirectPath,
}: CheckoutSuccessDesktopProps) {
  const hasRunned = useRef(false);

  useEffect(() => {
    if (redirectPath && !hasRunned.current) {
      window.location.replace(`midday://${redirectPath}`);
      hasRunned.current = true;
    }
  }, [redirectPath]);

  return (
    <div>
      <div className="h-screen flex flex-col items-center justify-center text-center text-sm text-[#606060]">
        <Image
          src={appIcon}
          width={80}
          height={80}
          alt="Midday"
          quality={100}
          className="mb-10"
        />
        <p>Checkout successful</p>
        <p className="mb-4">
          If Midday dosen't open in a few seconds,{" "}
          <a className="underline" href={`midday://${redirectPath}`}>
            click here
          </a>
          .
        </p>
        <p>You may close this browser tab when done</p>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/choose-plan-button.tsx">
"use client";

import { Button } from "@midday/ui/button";
import { useState } from "react";
import { ChoosePlanModal } from "./modals/choose-plan-modal";

export function ChoosePlanButton({
  children,
  initialIsOpen,
  daysLeft,
  hasDiscount,
  discountPrice,
}: {
  children: React.ReactNode;
  initialIsOpen?: boolean;
  daysLeft?: number;
  hasDiscount?: boolean;
  discountPrice?: number;
}) {
  const [isOpen, setIsOpen] = useState(initialIsOpen ?? false);

  return (
    <>
      <Button
        onClick={() => setIsOpen(true)}
        variant="outline"
        className="rounded-full font-normal h-[32px] p-0 px-3 text-xs text-[#878787]"
      >
        {children}
      </Button>

      <ChoosePlanModal
        isOpen={isOpen}
        onOpenChange={setIsOpen}
        daysLeft={daysLeft}
        hasDiscount={hasDiscount}
        discountPrice={discountPrice}
      />
    </>
  );
}
</file>

<file path="apps/dashboard/src/components/color-picker.tsx">
import { Popover, PopoverContent, PopoverTrigger } from "@midday/ui/popover";
import { HexColorPicker } from "react-colorful";

type Props = {
  value: string;
  onSelect: (value: string) => void;
};

export function ColorPicker({ value, onSelect }: Props) {
  return (
    <Popover>
      <PopoverTrigger asChild>
        <button
          type="button"
          className="size-3 transition-colors absolute top-3 left-2"
          style={{
            backgroundColor: value,
          }}
        />
      </PopoverTrigger>
      <PopoverContent className="p-0 w-auto" sideOffset={14}>
        <HexColorPicker
          className="color-picker"
          color={value}
          onChange={(c) => {
            onSelect(c);
          }}
        />
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="apps/dashboard/src/components/company-country.tsx">
"use client";

import { useTeamMutation, useTeamQuery } from "@/hooks/use-team";
import { useZodForm } from "@/hooks/use-zod-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
} from "@midday/ui/form";
import { SubmitButton } from "@midday/ui/submit-button";
import { z } from "zod";
import { CountrySelector } from "./country-selector";

const formSchema = z.object({
  countryCode: z.string().min(2).max(32),
});

export function CompanyCountry() {
  const { data } = useTeamQuery();
  const updateTeamMutation = useTeamMutation();

  const form = useZodForm(formSchema, {
    defaultValues: {
      countryCode: data?.countryCode ?? "",
    },
  });

  const onSubmit = form.handleSubmit((data) => {
    updateTeamMutation.mutate(data);
  });

  return (
    <Form {...form}>
      <form onSubmit={onSubmit}>
        <Card>
          <CardHeader>
            <CardTitle>Company country</CardTitle>
            <CardDescription>
              This is your company's country of origin.
            </CardDescription>
          </CardHeader>

          <CardContent>
            <FormField
              control={form.control}
              name="countryCode"
              render={({ field }) => (
                <FormItem className="max-w-[300px]">
                  <FormControl>
                    <CountrySelector
                      defaultValue={field.value ?? ""}
                      onSelect={(code, name) => {
                        field.onChange(name);
                        form.setValue("countryCode", code);
                      }}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </CardContent>

          <CardFooter className="flex justify-end">
            <SubmitButton
              isSubmitting={updateTeamMutation.isPending}
              disabled={updateTeamMutation.isPending}
            >
              Save
            </SubmitButton>
          </CardFooter>
        </Card>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/company-email.tsx">
"use client";

import { useTeamMutation, useTeamQuery } from "@/hooks/use-team";
import { useZodForm } from "@/hooks/use-zod-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { z } from "zod";
import { CountrySelector } from "./country-selector";

const formSchema = z.object({
  email: z.string().email(),
});

export function CompanyEmail() {
  const { data } = useTeamQuery();
  const updateTeamMutation = useTeamMutation();

  const form = useZodForm(formSchema, {
    defaultValues: {
      email: data?.email ?? "",
    },
  });

  const onSubmit = form.handleSubmit((data) => {
    updateTeamMutation.mutate(data);
  });

  return (
    <Form {...form}>
      <form onSubmit={onSubmit}>
        <Card>
          <CardHeader>
            <CardTitle>Company email</CardTitle>
            <CardDescription>
              This is the email address that will be used to receive emails from
              Midday.
            </CardDescription>
          </CardHeader>

          <CardContent>
            <FormField
              control={form.control}
              name="email"
              render={({ field }) => (
                <FormItem className="max-w-[300px]">
                  <FormControl>
                    <Input {...field} placeholder="Email" />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </CardContent>

          <CardFooter className="flex justify-end">
            <SubmitButton
              isSubmitting={updateTeamMutation.isPending}
              disabled={updateTeamMutation.isPending}
            >
              Save
            </SubmitButton>
          </CardFooter>
        </Card>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/company-logo.tsx">
"use client";

import { useTeamMutation, useTeamQuery } from "@/hooks/use-team";
import { useUpload } from "@/hooks/use-upload";
import { Avatar, AvatarFallback, AvatarImage } from "@midday/ui/avatar";
import {
  Card,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { Spinner } from "@midday/ui/spinner";
import { stripSpecialCharacters } from "@midday/utils";
import { useRef } from "react";

export function CompanyLogo() {
  const inputRef = useRef<HTMLInputElement>(null);
  const { isLoading, uploadFile } = useUpload();
  const { data } = useTeamQuery();
  const { mutate: updateTeam } = useTeamMutation();

  const handleUpload = async (evt: React.ChangeEvent<HTMLInputElement>) => {
    const { files } = evt.target;
    const selectedFile = files as FileList;

    const filename = stripSpecialCharacters(selectedFile[0]?.name ?? "");

    const { url } = await uploadFile({
      bucket: "avatars",
      path: [data?.id ?? "", filename],
      file: selectedFile[0] as File,
    });

    if (url) {
      updateTeam({ logoUrl: url });
    }
  };

  return (
    <Card>
      <div className="flex justify-between items-center pr-6">
        <CardHeader>
          <CardTitle>Company logo</CardTitle>
          <CardDescription>
            This is your company's logo. Click on the logo to upload a custom
            one from your files.
          </CardDescription>
        </CardHeader>

        <Avatar
          className="rounded-none w-16 h-16 flex items-center justify-center bg-accent cursor-pointer"
          onClick={() => inputRef?.current?.click()}
        >
          {isLoading ? (
            <Spinner className="h-4 w-4" />
          ) : (
            <>
              <AvatarImage
                src={data?.logoUrl ?? undefined}
                alt={data?.name ?? undefined}
                width={64}
                height={64}
              />
              <AvatarFallback>
                <span className="text-md">{data?.name?.charAt(0)}</span>
              </AvatarFallback>
            </>
          )}

          <input
            ref={inputRef}
            type="file"
            style={{ display: "none" }}
            multiple={false}
            onChange={handleUpload}
          />
        </Avatar>
      </div>
      <CardFooter>An avatar is optional but strongly recommended.</CardFooter>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/company-name.tsx">
"use client";

import { useTeamMutation, useTeamQuery } from "@/hooks/use-team";
import { useZodForm } from "@/hooks/use-zod-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { z } from "zod";

const formSchema = z.object({
  name: z.string().min(2).max(32),
});

export function CompanyName() {
  const { data } = useTeamQuery();
  const updateTeamMutation = useTeamMutation();

  const form = useZodForm(formSchema, {
    defaultValues: {
      name: data?.name ?? "",
    },
  });

  const onSubmit = form.handleSubmit((data) => {
    updateTeamMutation.mutate(data);
  });

  return (
    <Form {...form}>
      <form onSubmit={onSubmit}>
        <Card>
          <CardHeader>
            <CardTitle>Company name</CardTitle>
            <CardDescription>
              This is your company's visible name within Midday. For example,
              the name of your company or department.
            </CardDescription>
          </CardHeader>

          <CardContent>
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Input
                      {...field}
                      className="max-w-[300px]"
                      autoComplete="off"
                      autoCapitalize="none"
                      autoCorrect="off"
                      spellCheck="false"
                      maxLength={32}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </CardContent>

          <CardFooter className="flex justify-between">
            <div>Please use 32 characters at maximum.</div>
            <SubmitButton
              isSubmitting={updateTeamMutation.isPending}
              disabled={updateTeamMutation.isPending}
            >
              Save
            </SubmitButton>
          </CardFooter>
        </Card>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/connect-bank-provider.tsx">
import { useConnectParams } from "@/hooks/use-connect-params";
import { useTRPC } from "@/trpc/client";
import { useMutation } from "@tanstack/react-query";
import { BankConnectButton } from "./bank-connect-button";
import { EnableBankingConnect } from "./enablebanking-connect";
import { GoCardLessConnect } from "./gocardless-connect";
import { TellerConnect } from "./teller-connect";

type Props = {
  id: string;
  name: string;
  provider: string;
  availableHistory: number;
  maximumConsentValidity: number;
  openPlaid: () => void;
  type?: "personal" | "business";
};

export function ConnectBankProvider({
  id,
  name,
  provider,
  openPlaid,
  availableHistory,
  maximumConsentValidity,
  type,
}: Props) {
  const { setParams, countryCode } = useConnectParams();
  const trpc = useTRPC();
  const updateUsageMutation = useMutation(
    trpc.institutions.updateUsage.mutationOptions(),
  );

  const updateUsage = () => {
    updateUsageMutation.mutate({ id });
  };

  switch (provider) {
    case "teller":
      return (
        <TellerConnect
          id={id}
          onSelect={() => {
            // NOTE: Wait for Teller sdk to be configured
            setTimeout(() => {
              setParams({ step: null });
            }, 950);

            updateUsage();
          }}
        />
      );
    case "gocardless": {
      return (
        <GoCardLessConnect
          id={id}
          availableHistory={availableHistory}
          onSelect={() => {
            updateUsage();
          }}
        />
      );
    }
    case "enablebanking": {
      return (
        <EnableBankingConnect
          id={name}
          country={countryCode}
          maximumConsentValidity={maximumConsentValidity}
          type={type}
          onSelect={() => {
            updateUsage();
          }}
        />
      );
    }
    case "plaid":
      return (
        <BankConnectButton
          onClick={() => {
            updateUsage();
            openPlaid();
          }}
        />
      );
    default:
      return null;
  }
}
</file>

<file path="apps/dashboard/src/components/connected-accounts.tsx">
import { AddAccountButton } from "@/components/add-account-button";
import { BankAccountList } from "@/components/bank-account-list";
import {
  Card,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { Suspense } from "react";
import { BankAccountListSkeleton } from "./bank-account-list-skeleton";

export function ConnectedAccounts() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Accounts</CardTitle>
        <CardDescription>
          Manage bank accounts, update or connect new ones.
        </CardDescription>
      </CardHeader>

      <Suspense fallback={<BankAccountListSkeleton />}>
        <BankAccountList />
      </Suspense>

      <CardFooter className="flex justify-between">
        <div />

        <AddAccountButton />
      </CardFooter>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/connection-status.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { getConnectionsStatus } from "@/utils/connection-status";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useQuery } from "@tanstack/react-query";
import Link from "next/link";

export function ConnectionStatus() {
  const trpc = useTRPC();

  const { data, isLoading } = useQuery(
    trpc.bankConnections.get.queryOptions({
      enabled: true,
    }),
  );

  if (isLoading || !data) {
    return null;
  }

  const connectionIssue = data?.some((bank) => bank.status === "disconnected");

  if (connectionIssue) {
    return (
      <TooltipProvider delayDuration={70}>
        <Tooltip>
          <TooltipTrigger asChild>
            <Link href="/settings/accounts" prefetch>
              <Button
                variant="outline"
                size="icon"
                className="rounded-full w-8 h-8 items-center hidden md:flex"
              >
                <Icons.Error size={16} className="text-[#FF3638]" />
              </Button>
            </Link>
          </TooltipTrigger>

          <TooltipContent
            className="px-3 py-1.5 text-xs max-w-[230px]"
            sideOffset={10}
          >
            There is a connection issue with one of your banks.
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    );
  }

  // NOTE: No connections with expire_at (Only GoCardLess and Enable Banking)
  if (data?.find((bank) => bank.expiresAt === null)) {
    return null;
  }

  const { warning, error, show } = getConnectionsStatus(data);

  if (!show) {
    return null;
  }

  return (
    <TooltipProvider delayDuration={70}>
      <Tooltip>
        <TooltipTrigger asChild>
          <Link href="/settings/accounts" prefetch>
            <Button
              variant="outline"
              size="icon"
              className="rounded-full w-8 h-8 items-center hidden md:flex"
            >
              <Icons.Error
                size={16}
                className={cn(
                  error && "text-[#FF3638]",
                  warning && "text-[#FFD02B]",
                )}
              />
            </Button>
          </Link>
        </TooltipTrigger>

        <TooltipContent
          className="px-3 py-1.5 text-xs max-w-[230px]"
          sideOffset={10}
        >
          The connection is expiring soon, update your connection.
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}
</file>

<file path="apps/dashboard/src/components/consent-banner.tsx">
"use client";

import { trackingConsentAction } from "@/actions/tracking-consent-action";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { useAction } from "next-safe-action/hooks";
import { useState } from "react";

export function ConsentBanner() {
  const [isOpen, setOpen] = useState(true);
  const trackingAction = useAction(trackingConsentAction, {
    onExecute: () => setOpen(false),
  });

  if (!isOpen) {
    return null;
  }

  return (
    <div
      className={cn(
        "fixed z-50 bottom-2 md:bottom-4 left-2 md:left-4 flex flex-col space-y-4 w-[calc(100vw-16px)] max-w-[420px] border border-border p-4 transition-all bg-background",
        isOpen &&
          "animate-in sm:slide-in-from-bottom-full slide-in-from-bottom-full",
      )}
    >
      <div className="text-sm">
        This site uses tracking technologies. You may opt in or opt out of the
        use of these technologies.
      </div>
      <div className="flex justify-end space-x-2">
        <Button
          className="rounded-full h-8"
          onClick={() => trackingAction.execute(false)}
        >
          Deny
        </Button>
        <Button
          className="rounded-full h-8"
          onClick={() => trackingAction.execute(true)}
        >
          Accept
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/copy-input.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import { motion } from "framer-motion";
import { useState } from "react";
import { useCopyToClipboard } from "usehooks-ts";

type Props = {
  value: string;
  className?: string;
};

export function CopyInput({ value, className }: Props) {
  const [isCopied, setCopied] = useState(false);
  const [, copy] = useCopyToClipboard();

  const handleClipboard = () => {
    setCopied(true);

    copy(value);

    setTimeout(() => {
      setCopied(false);
    }, 2000);
  };

  return (
    <button
      type="button"
      onClick={handleClipboard}
      className={cn(
        "flex items-center relative w-full border py-2 px-4 cursor-pointer",
        className,
      )}
    >
      <div className="pr-8 text-[#878787] text-sm truncate">{value}</div>

      <motion.div
        className="absolute right-4 top-2.5"
        initial={{ opacity: 1, scale: 1 }}
        animate={{ opacity: isCopied ? 0 : 1, scale: isCopied ? 0 : 1 }}
      >
        <Icons.Copy />
      </motion.div>

      <motion.div
        className="absolute right-4 top-2.5"
        initial={{ opacity: 0, scale: 0 }}
        animate={{ opacity: isCopied ? 1 : 0, scale: isCopied ? 1 : 0 }}
      >
        <Icons.Check />
      </motion.div>
    </button>
  );
}
</file>

<file path="apps/dashboard/src/components/country-selector.tsx">
import countries from "@midday/location/country-flags";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@midday/ui/command";
import { Popover, PopoverContent, PopoverTrigger } from "@midday/ui/popover";
import { CaretSortIcon, CheckIcon } from "@radix-ui/react-icons";
import * as React from "react";
import { useEffect } from "react";

type Props = {
  defaultValue: string;
  onSelect: (countryCode: string, countryName: string) => void;
};

export function CountrySelector({ defaultValue, onSelect }: Props) {
  const [open, setOpen] = React.useState(false);
  const [value, setValue] = React.useState(defaultValue);

  useEffect(() => {
    if (value !== defaultValue) {
      setValue(defaultValue);
    }
  }, [defaultValue, value]);

  const selected = Object.values(countries).find(
    (country) => country.code === value || country.name === value,
  );

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          aria-expanded={open}
          className="w-full justify-between font-normal truncate"
        >
          {value ? selected?.name : "Select country"}
          <CaretSortIcon className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-[225px] p-0" align="start" portal={false}>
        <Command loop>
          <CommandInput
            placeholder="Search country..."
            className="h-9 px-2"
            autoComplete="off"
          />
          <CommandEmpty>No country found.</CommandEmpty>
          <CommandGroup>
            <CommandList className="overflow-y-auto max-h-[230px] pt-2">
              {Object.values(countries).map((country) => (
                <CommandItem
                  key={country.code}
                  value={country.name}
                  onSelect={() => {
                    setValue(country.code);
                    onSelect?.(country.code, country.name);
                    setOpen(false);
                  }}
                >
                  {country.name}
                  <CheckIcon
                    className={cn(
                      "ml-auto h-4 w-4",
                      value === country.code ? "opacity-100" : "opacity-0",
                    )}
                  />
                </CommandItem>
              ))}
            </CommandList>
          </CommandGroup>
        </Command>
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="apps/dashboard/src/components/customer-header.tsx">
import { getWebsiteLogo } from "@/utils/logos";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { InvoiceStatus } from "./invoice-status";

type Props = {
  name: string;
  website?: string | null;
  status?: "overdue" | "paid" | "unpaid" | "draft" | "canceled" | "scheduled";
};

export default function CustomerHeader({ name, website, status }: Props) {
  return (
    <div className="flex justify-between items-center mb-4">
      <div className="flex items-center space-x-2">
        {name && (
          <Avatar className="size-5 object-contain border border-border">
            {website && (
              <AvatarImageNext
                src={getWebsiteLogo(website)}
                alt={`${name} logo`}
                width={20}
                height={20}
                quality={100}
              />
            )}
            <AvatarFallback className="text-[9px] font-medium">
              {name?.[0]}
            </AvatarFallback>
          </Avatar>
        )}
        <span className="truncate text-sm">{name}</span>
      </div>

      <InvoiceStatus status={status} />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/customers-header.tsx">
import { OpenCustomerSheet } from "./open-customer-sheet";
import { SearchField } from "./search-field";

export async function CustomersHeader() {
  return (
    <div className="flex items-center justify-between">
      <SearchField placeholder="Search customers" />

      <div className="hidden sm:block">
        <OpenCustomerSheet />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/date-format-settings.tsx">
"use client";

import { useUserMutation, useUserQuery } from "@/hooks/use-user";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";

export function DateFormatSettings() {
  const { data: user } = useUserQuery();
  const updateUserMutation = useUserMutation();

  return (
    <Card className="flex justify-between items-center">
      <CardHeader>
        <CardTitle>Date Display Format</CardTitle>
        <CardDescription>
          Select the format used to display dates throughout the app.
        </CardDescription>
      </CardHeader>

      <CardContent>
        <Select
          defaultValue={user?.dateFormat ?? undefined}
          onValueChange={(value) => {
            updateUserMutation.mutate({
              dateFormat: value as
                | "dd/MM/yyyy"
                | "MM/dd/yyyy"
                | "yyyy-MM-dd"
                | "dd.MM.yyyy",
            });
          }}
        >
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Date format" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="dd/MM/yyyy">dd/MM/yyyy</SelectItem>
            <SelectItem value="MM/dd/yyyy">MM/dd/yyyy</SelectItem>
            <SelectItem value="yyyy-MM-dd">yyyy-MM-dd</SelectItem>
            <SelectItem value="dd.MM.yyyy">dd.MM.yyyy</SelectItem>
          </SelectContent>
        </Select>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/delete-account.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { createClient } from "@midday/supabase/client";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@midday/ui/alert-dialog";
import { Button } from "@midday/ui/button";
import {
  Card,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { Input } from "@midday/ui/input";
import { Label } from "@midday/ui/label";
import { useMutation } from "@tanstack/react-query";
import { Loader2 } from "lucide-react";
import { useRouter } from "next/navigation";
import { useState } from "react";

export function DeleteAccount() {
  const supabase = createClient();
  const trpc = useTRPC();
  const router = useRouter();

  const deleteUserMutation = useMutation(
    trpc.user.delete.mutationOptions({
      onSuccess: async () => {
        await supabase.auth.signOut();
        router.push("/");
      },
    }),
  );

  const [value, setValue] = useState("");

  return (
    <Card className="border-destructive">
      <CardHeader>
        <CardTitle>Delete account</CardTitle>
        <CardDescription>
          Permanently remove your Personal Account and all of its contents from
          the Midday platform. This action is not reversible, so please continue
          with caution.
        </CardDescription>
      </CardHeader>
      <CardFooter className="flex justify-between">
        <div />

        <AlertDialog>
          <AlertDialogTrigger asChild>
            <Button
              variant="destructive"
              className="hover:bg-destructive text-muted"
            >
              Delete
            </Button>
          </AlertDialogTrigger>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
              <AlertDialogDescription>
                This action cannot be undone. This will permanently delete your
                account and remove your data from our servers.
              </AlertDialogDescription>
            </AlertDialogHeader>

            <div className="flex flex-col gap-2 mt-2">
              <Label htmlFor="confirm-delete">
                Type <span className="font-medium">DELETE</span> to confirm.
              </Label>
              <Input
                id="confirm-delete"
                value={value}
                onChange={(e) => setValue(e.target.value)}
              />
            </div>

            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={() => deleteUserMutation.mutate()}
                disabled={value !== "DELETE"}
              >
                {deleteUserMutation.isPending ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  "Continue"
                )}
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </CardFooter>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/delete-connection.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@midday/ui/alert-dialog";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { Input } from "@midday/ui/input";
import { Label } from "@midday/ui/label";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { Loader2 } from "lucide-react";
import { useState } from "react";

type Props = {
  connectionId: string;
};

export function DeleteConnection({ connectionId }: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const [value, setValue] = useState("");
  const [open, setOpen] = useState(false);

  const deleteConnectionMutation = useMutation(
    trpc.bankConnections.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.bankConnections.get.queryKey(),
        });

        setOpen(false);
        setValue("");
      },
    }),
  );

  return (
    <AlertDialog open={open} onOpenChange={setOpen}>
      <TooltipProvider delayDuration={70}>
        <Tooltip>
          <AlertDialogTrigger asChild>
            <TooltipTrigger asChild>
              <Button
                variant="outline"
                size="icon"
                className="rounded-full w-7 h-7 flex items-center"
                disabled={deleteConnectionMutation.isPending}
              >
                <Icons.Delete size={16} />
              </Button>
            </TooltipTrigger>
          </AlertDialogTrigger>

          <TooltipContent className="px-3 py-1.5 text-xs" sideOffset={10}>
            Delete
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>

      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Delete Connection</AlertDialogTitle>
          <AlertDialogDescription>
            You are about to delete a bank connection. If you proceed, all
            transactions associated with this connection and all bank accounts
            will also be deleted.
          </AlertDialogDescription>
        </AlertDialogHeader>

        <div className="flex flex-col gap-2 mt-2">
          <Label htmlFor="confirm-delete">
            Type <span className="font-medium">DELETE</span> to confirm.
          </Label>
          <Input
            id="confirm-delete"
            value={value}
            onChange={(e) => setValue(e.target.value)}
          />
        </div>

        <AlertDialogFooter>
          <AlertDialogCancel>Cancel</AlertDialogCancel>
          <AlertDialogAction
            disabled={value !== "DELETE" || deleteConnectionMutation.isPending}
            onClick={() =>
              deleteConnectionMutation.mutate({ id: connectionId })
            }
          >
            {deleteConnectionMutation.isPending ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              "Confirm"
            )}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
</file>

<file path="apps/dashboard/src/components/delete-team.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@midday/ui/alert-dialog";
import { Button } from "@midday/ui/button";
import {
  Card,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { Input } from "@midday/ui/input";
import { Label } from "@midday/ui/label";
import { useMutation } from "@tanstack/react-query";
import { Loader2 } from "lucide-react";
import { useRouter } from "next/navigation";
import { useState } from "react";

export function DeleteTeam() {
  const [value, setValue] = useState("");
  const trpc = useTRPC();
  const { data: user } = useUserQuery();
  const router = useRouter();

  const deleteTeamMutation = useMutation(
    trpc.team.delete.mutationOptions({
      onSuccess: async () => {
        // Revalidate server state and redirect
        router.push("/teams");
      },
    }),
  );

  return (
    <Card className="border-destructive">
      <CardHeader>
        <CardTitle>Delete team</CardTitle>
        <CardDescription>
          Permanently remove your Team and all of its contents from the Midday
          platform. This action is not reversible — please continue with
          caution.
        </CardDescription>
      </CardHeader>
      <CardFooter className="flex justify-between">
        <div />

        <AlertDialog>
          <AlertDialogTrigger asChild>
            <Button
              variant="destructive"
              className="hover:bg-destructive text-muted"
            >
              Delete
            </Button>
          </AlertDialogTrigger>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
              <AlertDialogDescription>
                This action cannot be undone. This will permanently delete your
                team and remove your data from our servers.
              </AlertDialogDescription>
            </AlertDialogHeader>

            <div className="flex flex-col gap-2 mt-2">
              <Label htmlFor="confirm-delete">
                Type <span className="font-medium">DELETE</span> to confirm.
              </Label>
              <Input
                id="confirm-delete"
                value={value}
                onChange={(e) => setValue(e.target.value)}
              />
            </div>

            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={() =>
                  deleteTeamMutation.mutate({ teamId: user?.teamId! })
                }
                disabled={value !== "DELETE"}
              >
                {deleteTeamMutation.isPending ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  "Confirm"
                )}
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </CardFooter>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/desktop-header.tsx">
"use client";

import { isDesktopApp } from "@midday/desktop-client/platform";
import { usePathname } from "next/navigation";
import { DesktopTrafficLight } from "./desktop-traffic-light";

export function DesktopHeader() {
  const pathname = usePathname();

  if (!isDesktopApp() || pathname.includes("/search")) {
    return null;
  }

  // This is used to make the header draggable on macOS
  return (
    <div
      data-tauri-drag-region
      className="absolute top-0 left-0 right-0 h-5 z-[51] group border-radius-[10px] overflow-hidden"
    >
      <div className="hidden group-hover:flex">
        <DesktopTrafficLight />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/desktop-provider.tsx">
"use client";

import { getCurrentWindow, invoke } from "@midday/desktop-client/core";
import {
  isDesktopApp,
  listenForDeepLinks,
} from "@midday/desktop-client/platform";
import { usePathname, useRouter } from "next/navigation";
import { useEffect } from "react";

// This is used to show the window when the app is loaded
// And to handle deep links
export function DesktopProvider() {
  const router = useRouter();
  const pathname = usePathname();

  useEffect(() => {
    if (!isDesktopApp()) {
      return;
    }

    const currentWindow = getCurrentWindow();
    const label = currentWindow.label;

    const emitSearchWindowState = async () => {
      try {
        if (pathname === "/") {
          // Enable search window for dashboard and login pages
          await currentWindow.emit("search-window-enabled", true);
          console.log("🔍 Search window enabled via event");
        } else if (pathname === "/login") {
          // Enable search window for login page
          await currentWindow.emit("search-window-enabled", false);
          console.log("🔍 Search window enabled via event");
        }
      } catch (error) {
        console.error("Failed to emit search window state:", error);
      }
    };

    if (label === "main") {
      emitSearchWindowState();
    }
  }, [pathname]);

  useEffect(() => {
    if (!isDesktopApp()) {
      return;
    }

    const showWindow = async () => {
      try {
        // Only run show_window logic if we're in the main window
        const currentWindow = getCurrentWindow();
        const label = currentWindow.label;

        if (label !== "main") {
          console.log(
            `📄 Skipping show_window - not in main window (current: ${label})`,
          );
          return;
        }

        console.log("📄 Calling show_window command");
        await invoke("show_window");
        console.log("✅ Window shown successfully");
      } catch (error) {
        console.error("Failed to show window:", error);
      }
    };

    // Simple timeout approach - let content load naturally then show window
    const timer = setTimeout(showWindow, 300);

    // Cleanup timer if component unmounts
    return () => clearTimeout(timer);
  }, []);

  useEffect(() => {
    if (!isDesktopApp()) {
      return;
    }

    let cleanup: (() => void) | undefined;

    const setupDeepLinkListener = async () => {
      try {
        // Only set up deep link listeners if we're in the main window
        const currentWindow = getCurrentWindow();
        const label = currentWindow.label;

        if (label !== "main") {
          console.log(
            `🔗 Skipping deep link setup - not in main window (current: ${label})`,
          );
          return;
        }

        console.log("🔗 Setting up deep link listener...");

        cleanup = await listenForDeepLinks((path) => {
          console.log("🎯 Deep link navigation received:", path);

          // Handle different paths
          if (path === "" || path === "dashboard") {
            console.log("📍 Navigating to dashboard");
            router.push("/");
          } else if (path.startsWith("api/auth/callback")) {
            // Handle authentication callback
            console.log("🔐 Handling auth callback");
            router.push(`/${path}`);
          } else {
            // Handle other paths
            console.log(`📍 Navigating to: /${path}`);
            router.push(`/${path}`);
          }
        });
      } catch (error) {
        console.error("Failed to set up deep link listener:", error);
      }
    };

    setupDeepLinkListener();

    // Cleanup function
    return () => {
      if (cleanup) {
        cleanup();
        console.log("🧹 Deep link listener cleaned up");
      }
    };
  }, [router]);

  // Add desktop navigation listener
  useEffect(() => {
    if (!isDesktopApp()) {
      return;
    }

    let unlistenNavigation: (() => void) | undefined;
    let unlistenParamsNavigation: (() => void) | undefined;

    const setupDesktopNavigationListener = async () => {
      try {
        const currentWindow = getCurrentWindow();
        const label = currentWindow.label;

        // Only set up navigation listener in the main window
        if (label !== "main") {
          console.log(
            `🚀 Skipping desktop navigation setup - not in main window (current: ${label})`,
          );
          return;
        }

        console.log("🚀 Setting up desktop navigation listener...");

        // Handle full path navigation
        unlistenNavigation = await currentWindow.listen(
          "desktop-navigate",
          (event) => {
            const { path, params } = event.payload as {
              path: string;
              params?: Record<string, any>;
            };
            console.log("🚀 Desktop navigation received in main window:", {
              path,
              params,
            });

            if (params && Object.keys(params).length > 0) {
              // Build URL with parameters
              const searchParams = new URLSearchParams();
              for (const [key, value] of Object.entries(params)) {
                if (value !== undefined && value !== null) {
                  searchParams.set(key, String(value));
                }
              }
              const fullPath = `${path}?${searchParams.toString()}`;
              console.log(`📍 Main window navigating to: ${fullPath}`);
              router.push(fullPath);
            } else {
              console.log(`📍 Main window navigating to: ${path}`);
              router.push(path);
            }
          },
        );

        // Handle parameter-only navigation (stay on current page)
        unlistenParamsNavigation = await currentWindow.listen(
          "desktop-navigate-with-params",
          (event) => {
            const { params } = event.payload as { params: Record<string, any> };
            console.log(
              "🚀 Desktop params navigation received in main window:",
              { params },
            );

            // Get current pathname and apply parameters
            const currentPath = window.location.pathname;
            const searchParams = new URLSearchParams();

            for (const [key, value] of Object.entries(params)) {
              if (value !== undefined && value !== null) {
                searchParams.set(key, String(value));
              }
            }

            const fullPath = `${currentPath}?${searchParams.toString()}`;
            console.log(
              `📍 Main window adding params to current page: ${fullPath}`,
            );
            router.push(fullPath);
          },
        );

        console.log("✅ Desktop navigation listeners registered");
      } catch (error) {
        console.error("Failed to set up desktop navigation listener:", error);
      }
    };

    setupDesktopNavigationListener();

    // Cleanup function
    return () => {
      if (unlistenNavigation) {
        unlistenNavigation();
        console.log("🧹 Desktop navigation listener cleaned up");
      }
      if (unlistenParamsNavigation) {
        unlistenParamsNavigation();
        console.log("🧹 Desktop params navigation listener cleaned up");
      }
    };
  }, [router]);

  return null;
}
</file>

<file path="apps/dashboard/src/components/desktop-sign-in-verify-code.tsx">
"use client";

import Image from "next/image";
import appIcon from "public/appicon.png";
import { useEffect, useRef } from "react";

interface DesktopSignInVerifyCodeProps {
  code: string;
}

export function DesktopSignInVerifyCode({
  code,
}: DesktopSignInVerifyCodeProps) {
  const hasRunned = useRef(false);

  useEffect(() => {
    if (code && !hasRunned.current) {
      window.location.replace(`midday://api/auth/callback?code=${code}`);
      hasRunned.current = true;
    }
  }, [code]);

  return (
    <div>
      <div className="h-screen flex flex-col items-center justify-center text-center text-sm text-[#606060]">
        <Image
          src={appIcon}
          width={80}
          height={80}
          alt="Midday"
          quality={100}
          className="mb-10"
        />
        <p>Signing in...</p>
        <p className="mb-4">
          If Midday dosen't open in a few seconds,{" "}
          <a
            className="underline"
            href={`midday://api/auth/callback?code=${code}`}
          >
            click here
          </a>
          .
        </p>
        <p>You may close this browser tab when done</p>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/desktop-traffic-light.tsx">
"use client";

import { Window } from "@midday/desktop-client/core";

export function DesktopTrafficLight() {
  const getMainWindow = async () => {
    const mainWindow = await Window.getByLabel("main");
    if (!mainWindow) {
      throw new Error("Main window not found");
    }
    return mainWindow;
  };

  const handleClose = async () => {
    try {
      const window = await getMainWindow();
      // Hide the main window instead of closing it
      await window.hide();
    } catch (error) {
      console.error("Failed to hide main window:", error);
    }
  };

  const handleMinimize = async () => {
    try {
      const window = await getMainWindow();
      await window.minimize();
    } catch (error) {
      console.error("Failed to minimize main window:", error);
    }
  };

  const handleMaximize = async () => {
    try {
      const window = await getMainWindow();
      const isMaximized = await window.isMaximized();

      if (isMaximized) {
        await window.unmaximize();
      } else {
        await window.toggleMaximize();
      }
    } catch (error) {
      console.error("Failed to toggle maximize main window:", error);
    }
  };

  return (
    <div className="fixed top-[8px] left-[8px] space-x-[8px] flex">
      {/* Close button (red) */}
      <button
        type="button"
        onClick={handleClose}
        className="w-[10px] h-[10px] bg-border rounded-full hover:bg-red-500 cursor-pointer"
        aria-label="Close window"
      />
      {/* Minimize button (yellow) */}
      <button
        type="button"
        onClick={handleMinimize}
        className="w-[10px] h-[10px] bg-border rounded-full hover:bg-yellow-500 cursor-pointer"
        aria-label="Minimize window"
      />
      {/* Maximize/Restore button (green) */}
      <button
        type="button"
        onClick={handleMaximize}
        className="w-[10px] h-[10px] bg-border rounded-full hover:bg-green-500 cursor-pointer"
        aria-label="Toggle maximize"
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/display-name.tsx">
"use client";

import { useUserMutation, useUserQuery } from "@/hooks/use-user";
import { useZodForm } from "@/hooks/use-zod-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { z } from "zod";

const formSchema = z.object({
  fullName: z.string().min(1).max(32).optional(),
});

export function DisplayName() {
  const { data: user } = useUserQuery();
  const updateUserMutation = useUserMutation();

  const form = useZodForm(formSchema, {
    defaultValues: {
      fullName: user?.fullName ?? undefined,
    },
  });

  const onSubmit = form.handleSubmit((data) => {
    updateUserMutation.mutate({
      fullName: data?.fullName,
    });
  });

  return (
    <Form {...form}>
      <form onSubmit={onSubmit}>
        <Card>
          <CardHeader>
            <CardTitle>Display Name</CardTitle>
            <CardDescription>
              Please enter your full name, or a display name you are comfortable
              with.
            </CardDescription>
          </CardHeader>

          <CardContent>
            <FormField
              control={form.control}
              name="fullName"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Input
                      {...field}
                      className="max-w-[300px]"
                      autoComplete="off"
                      autoCapitalize="none"
                      autoCorrect="off"
                      spellCheck="false"
                      maxLength={32}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </CardContent>

          <CardFooter className="flex justify-between">
            <div>Please use 32 characters at maximum.</div>
            <SubmitButton
              type="submit"
              disabled={updateUserMutation.isPending}
              isSubmitting={updateUserMutation.isPending}
            >
              Save
            </SubmitButton>
          </CardFooter>
        </Card>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/document-actions.tsx">
"use client";

import { useDocumentParams } from "@/hooks/use-document-params";
import { downloadFile } from "@/lib/download";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useState } from "react";
import { useCopyToClipboard } from "usehooks-ts";

type Props = {
  showDelete?: boolean;
  filePath?: string[] | null;
};

export function DocumentActions({ showDelete = false, filePath }: Props) {
  const [, copy] = useCopyToClipboard();
  const [isCopied, setIsCopied] = useState(false);
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { setParams, params } = useDocumentParams();

  const filename = filePath?.at(-1);

  const shortLinkMutation = useMutation(
    trpc.shortLinks.createForDocument.mutationOptions({
      onMutate: () => {
        setIsCopied(true);
      },
      onSuccess: (data) => {
        if (data?.shortUrl) {
          copy(data.shortUrl);

          setTimeout(() => {
            setIsCopied(false);
          }, 3000);
        }
      },
    }),
  );

  const deleteDocumentMutation = useMutation(
    trpc.documents.delete.mutationOptions({
      onSuccess: () => {
        setParams({ documentId: null });

        queryClient.invalidateQueries({
          queryKey: trpc.documents.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.documents.get.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.search.global.queryKey(),
        });
      },
    }),
  );

  return (
    <div className="flex flex-row">
      <Button
        variant="ghost"
        size="icon"
        onClick={() => {
          if (filePath && filename) {
            downloadFile(
              `/api/download/file?path=${filePath.join("/")}&filename=${filename}`,
              filename,
            );
          }
        }}
      >
        <Icons.ArrowCoolDown className="size-4" />
      </Button>

      <Button
        variant="ghost"
        size="icon"
        onClick={() =>
          shortLinkMutation.mutate({
            filePath: filePath?.join("/") ?? "",
            expireIn: 60 * 60 * 24 * 30, // 30 days
          })
        }
      >
        {isCopied ? (
          <Icons.Check className="size-4" />
        ) : (
          <Icons.Copy className="size-4" />
        )}
      </Button>

      {showDelete && (
        <Button
          variant="ghost"
          size="icon"
          onClick={() =>
            deleteDocumentMutation.mutate({
              id: params.documentId!,
            })
          }
        >
          <Icons.Delete className="size-4" />
        </Button>
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/document-details-skeleton.tsx">
"use client";

import { SheetHeader } from "@midday/ui/sheet";
import { Skeleton } from "@midday/ui/skeleton";
import { VaultRelatedFilesSkeleton } from "./vault/vault-related-files-skeleton";

export function DocumentDetailsSkeleton() {
  return (
    <div className="flex flex-col flex-grow min-h-0 relative h-full w-full">
      <SheetHeader className="mb-4 flex justify-between items-center flex-row">
        <div className="min-w-0 flex-1 max-w-[50%] flex flex-row gap-2 items-end">
          <Skeleton className="h-6 w-3/4" />
        </div>
      </SheetHeader>

      {/* Mimic ScrollArea and FileViewer */}
      <div className="h-full max-h-[763px] p-0 overflow-hidden">
        <Skeleton className="h-full w-full" />
      </div>

      {/* Mimic Footer section */}
      <div className="pt-4">
        <Skeleton className="h-4 w-full mb-4" />
        <Skeleton className="h-4 w-1/3 mb-4" />

        <div className="flex gap-2 flex-wrap mb-6">
          <Skeleton className="h-6 w-20 rounded-full" />
          <Skeleton className="h-6 w-16 rounded-full" />
          <Skeleton className="h-6 w-24 rounded-full" />
          <Skeleton className="h-6 w-12 rounded-full" />
          <Skeleton className="h-6 w-20 rounded-full" />
          <Skeleton className="h-6 w-16 rounded-full" />
        </div>

        <VaultRelatedFilesSkeleton />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/document-details.tsx">
"use client";

import { DocumentActions } from "@/components/document-actions";
import { DocumentDetailsSkeleton } from "@/components/document-details-skeleton";
import { DocumentTags } from "@/components/document-tags";
import { FileViewer } from "@/components/file-viewer";
import { VaultRelatedFiles } from "@/components/vault/vault-related-files";
import { useDocumentParams } from "@/hooks/use-document-params";
import { useTRPC } from "@/trpc/client";
import { formatSize } from "@/utils/format";
import { SheetHeader } from "@midday/ui/sheet";
import { useQuery, useQueryClient } from "@tanstack/react-query";

export function DocumentDetails() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { params } = useDocumentParams();

  const isOpen = Boolean(params.filePath || params.documentId);
  const fullView = Boolean(params.documentId);

  const { data, isLoading } = useQuery({
    ...trpc.documents.getById.queryOptions({
      filePath: params.filePath!,
      id: params.documentId!,
    }),
    enabled: isOpen,
    staleTime: 0, // Always consider data stale so it always refetches
    initialData: () => {
      const pages = queryClient
        .getQueriesData({ queryKey: trpc.documents.get.infiniteQueryKey() })
        // @ts-expect-error
        .flatMap(([, data]) => data?.pages ?? [])
        .flatMap((page) => page.data ?? []);

      return pages.find(
        (d) =>
          d.id === params.documentId ||
          d.path_tokens?.join("/") === params.filePath,
      );
    },
  });

  if (isLoading) {
    return <DocumentDetailsSkeleton />;
  }

  return (
    <div className="flex flex-col flex-grow min-h-0 relative h-full w-full">
      <SheetHeader className="mb-4 flex justify-between items-center flex-row">
        <div className="min-w-0 flex-1 max-w-[70%] flex flex-row gap-2 items-end">
          <h2 className="text-lg truncate flex-0">
            {data?.title ?? data?.name?.split("/").at(-1)}
          </h2>
          <span className="text-sm text-muted-foreground whitespace-nowrap">
            {/* @ts-expect-error - size is not typed (JSONB) */}
            {data?.metadata?.size && formatSize(data?.metadata?.size)}
          </span>
        </div>

        <DocumentActions showDelete={fullView} filePath={data?.pathTokens} />
      </SheetHeader>

      <div className="h-full max-h-[763px] p-0 pb-4 overflow-x-auto scrollbar-hide">
        <div className="flex flex-col flex-grow min-h-0 relative h-full w-full items-center justify-center">
          <FileViewer
            url={`/api/proxy?filePath=vault/${data?.pathTokens?.join("/")}`}
            // @ts-expect-error - mimetype is not typed (JSONB)
            mimeType={data?.metadata?.mimetype}
            maxWidth={565}
          />
        </div>
      </div>

      <div>
        {data?.summary && (
          <p className="text-sm text-[#878787] mb-4 line-clamp-2">
            {data?.summary}
          </p>
        )}

        <DocumentTags tags={data?.documentTagAssignments} id={data?.id!} />

        {fullView && <VaultRelatedFiles />}
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/document-tags.tsx">
"use client";

import { VaultSelectTags } from "@/components/vault/vault-select-tags";
import { useTRPC } from "@/trpc/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { useMutation, useQueryClient } from "@tanstack/react-query";

type Tag = NonNullable<
  RouterOutputs["documents"]["getById"]
>["documentTagAssignments"][number];

interface Props {
  id: string;
  tags?: Tag[];
}

export function DocumentTags({ id, tags }: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const createDocumentTagAssignmentMutation = useMutation(
    trpc.documentTagAssignments.create.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.documents.getById.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.documents.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.documentTags.get.queryKey(),
        });
      },
    }),
  );

  const deleteDocumentTagAssignmentMutation = useMutation(
    trpc.documentTagAssignments.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.documents.getById.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.documents.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.documentTags.get.queryKey(),
        });
      },
    }),
  );

  if (!tags) return null;

  return (
    <VaultSelectTags
      tags={tags.map((tag) => ({
        value: tag.documentTag.id,
        label: tag.documentTag.name,
        id: tag.documentTag.id,
      }))}
      onSelect={(tag) => {
        if (tag.id) {
          createDocumentTagAssignmentMutation.mutate({
            tagId: tag.id,
            documentId: id,
          });
        }
      }}
      onRemove={(tag) => {
        deleteDocumentTagAssignmentMutation.mutate({
          tagId: tag.id,
          documentId: id,
        });
      }}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/enablebanking-connect.tsx">
import { createEnableBankingLinkAction } from "@/actions/institutions/create-enablebanking-link";
import { isDesktopApp } from "@midday/desktop-client/platform";
import { useToast } from "@midday/ui/use-toast";
import { useAction } from "next-safe-action/hooks";
import { BankConnectButton } from "./bank-connect-button";

type Props = {
  id: string;
  onSelect: () => void;
  maximumConsentValidity: number;
  country: string;
  type?: "personal" | "business";
};

export function EnableBankingConnect({
  onSelect,
  id,
  maximumConsentValidity,
  country,
  type,
}: Props) {
  const { toast } = useToast();

  const createEnableBankingLink = useAction(createEnableBankingLinkAction, {
    onError: () => {
      toast({
        duration: 3500,
        variant: "error",
        title: "Something went wrong please try again.",
      });
    },
  });

  const handleOnSelect = () => {
    onSelect();

    createEnableBankingLink.execute({
      institutionId: id,
      maximumConsentValidity,
      country: country === "" ? null : country,
      isDesktop: isDesktopApp(),
      type: type ?? "business",
    });
  };

  return <BankConnectButton onClick={handleOnSelect} />;
}
</file>

<file path="apps/dashboard/src/components/enroll-mfa.tsx">
import { createClient } from "@midday/supabase/client";
import { Button } from "@midday/ui/button";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@midday/ui/collapsible";
import { InputOTP, InputOTPGroup, InputOTPSlot } from "@midday/ui/input-otp";
import { Spinner } from "@midday/ui/spinner";
import { CaretSortIcon } from "@radix-ui/react-icons";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { CopyInput } from "./copy-input";

export function EnrollMFA() {
  const supabase = createClient();
  const router = useRouter();
  const [isValidating, setValidating] = useState(false);
  const [isRedirecting, setIsRedirecting] = useState(false);
  const [factorId, setFactorId] = useState<string | undefined>(undefined);
  const [qr, setQR] = useState<string | undefined>(undefined);
  const [secret, setSecret] = useState<string | undefined>(undefined);
  const [error, setError] = useState(false);
  const [isOpen, setIsOpen] = useState(false);

  const onComplete = async (code: string) => {
    setError(false);

    if (!isValidating && factorId) {
      setValidating(true);

      const challenge = await supabase.auth.mfa.challenge({ factorId });

      if (!challenge.data) {
        setError(true);
        setValidating(false);
        return;
      }

      const verify = await supabase.auth.mfa.verify({
        factorId,
        challengeId: challenge.data.id,
        code,
      });

      if (verify.data) {
        setIsRedirecting(true);
        router.replace("/");
      } else {
        setError(true);
        setValidating(false);
      }
    }
  };

  useEffect(() => {
    async function enroll() {
      const { data, error } = await supabase.auth.mfa.enroll({
        factorType: "totp",
        issuer: "app.midday.ai",
      });

      if (error || !data) {
        setError(true);
        return;
      }

      setFactorId(data.id);

      setQR(data.totp.qr_code);
      setSecret(data.totp.secret);
    }

    enroll();
  }, []);

  const handleOnCancel = () => {
    if (factorId) {
      supabase.auth.mfa.unenroll({
        factorId,
      });
    }
    router.push("/");
  };

  return (
    <>
      <div className="flex items-center justify-center">
        <div className="w-[220px] h-[220px] bg-white rounded-md">
          {qr && (
            <Image src={qr} alt="qr" width={220} height={220} quality={100} />
          )}
        </div>
      </div>
      <div className="my-8">
        <p className="font-medium pb-1 text-2xl text-[#606060]">
          Use an authenticator app to scan the following QR code, and provide
          the code to complete the setup.
        </p>
      </div>

      <Collapsible
        open={isOpen}
        onOpenChange={setIsOpen}
        className="w-full mb-4"
      >
        <CollapsibleTrigger className="p-0 text-sm w-full">
          <div className="flex items-center justify-between">
            <span className="font-medium">Use setup key</span>
            <CaretSortIcon className="h-4 w-4" />
          </div>
        </CollapsibleTrigger>
        <CollapsibleContent>
          {secret && <CopyInput value={secret} className="w-full" />}
        </CollapsibleContent>
      </Collapsible>

      <div className="flex w-full">
        <div className="w-full h-16 flex items-center justify-center">
          {isValidating || isRedirecting ? (
            <div className="flex items-center justify-center h-full bg-background/95 border border-input w-full">
              <div className="flex items-center space-x-2 bg-background px-4 py-2 rounded-md shadow-sm">
                <Spinner size={16} className="text-primary" />
                <span className="text-sm text-foreground font-medium">
                  {isRedirecting ? "Redirecting..." : "Setting up..."}
                </span>
              </div>
            </div>
          ) : (
            <InputOTP
              className={error ? "invalid" : ""}
              maxLength={6}
              autoFocus
              onComplete={onComplete}
              disabled={isValidating || isRedirecting}
              render={({ slots }) => (
                <InputOTPGroup>
                  {slots.map((slot, index) => (
                    <InputOTPSlot key={index.toString()} {...slot} />
                  ))}
                </InputOTPGroup>
              )}
            />
          )}
        </div>
      </div>

      <div className="flex border-t-[1px] pt-4 mt-6 justify-center mb-6">
        <Button
          onClick={handleOnCancel}
          variant="ghost"
          className="text-medium text-sm hover:bg-transparent"
        >
          Cancel
        </Button>
      </div>
    </>
  );
}
</file>

<file path="apps/dashboard/src/components/error-fallback.tsx">
"use client";

import { Button } from "@midday/ui/button";
import { useRouter } from "next/navigation";

export function ErrorFallback() {
  const router = useRouter();

  return (
    <div className="flex flex-col items-center justify-center h-full space-y-4">
      <div>
        <h2 className="text-md">Something went wrong</h2>
      </div>
      <Button onClick={() => router.refresh()} variant="outline">
        Try again
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/export-status.tsx">
"use client";

import { useExportStatus } from "@/hooks/use-export-status";
import { downloadFile } from "@/lib/download";
import { useExportStore } from "@/store/export";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { useToast } from "@midday/ui/use-toast";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { addDays, addYears } from "date-fns";
import { useEffect, useState } from "react";
import { useCopyToClipboard } from "usehooks-ts";

const options = [
  {
    label: "Expire in 1 week",
    expireIn: Math.floor(addDays(new Date(), 7).getTime() / 1000),
  },
  {
    label: "Expire in 1 month",
    expireIn: Math.floor(addDays(new Date(), 30).getTime() / 1000),
  },
  {
    label: "Expire in 1 year",
    expireIn: Math.floor(addYears(new Date(), 1).getTime() / 1000),
  },
] as const;

type ShareOptions = {
  expireIn: number;
  filePath: string;
};

type ExportData = {
  runId?: string;
  accessToken?: string;
};

export function ExportStatus() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { toast, dismiss, update } = useToast();
  const [toastId, setToastId] = useState<string | null>(null);
  const { exportData, setExportData } = useExportStore();
  const { status, progress, result } = useExportStatus(
    exportData as ExportData,
  );
  const [, copy] = useCopyToClipboard();

  const shareFileMutation = useMutation(
    trpc.shortLinks.createForDocument.mutationOptions({
      onError: () => {
        toast({
          duration: 2500,
          variant: "error",
          title: "Something went wrong please try again.",
        });
      },
      onSuccess: ({ shortUrl }) => {
        copy(shortUrl ?? "");

        toast({
          duration: 2500,
          title: "Copied URL to clipboard.",
          variant: "success",
        });
      },
    }),
  );

  const handleOnDownload = () => {
    if (toastId) {
      dismiss(toastId);
    }
  };

  const handleOnShare = ({ expireIn, filePath }: ShareOptions) => {
    shareFileMutation.mutate({ expireIn, filePath });

    if (toastId) {
      dismiss(toastId);
    }
  };

  useEffect(() => {
    if (status === "FAILED") {
      toast({
        duration: 2500,
        variant: "error",
        title: "Something went wrong please try again.",
      });

      setToastId(null);
      setExportData(undefined);
    }
  }, [status]);

  useEffect(() => {
    if (exportData && !toastId) {
      const { id } = toast({
        title: "Exporting transactions.",
        variant: "progress",
        description: "Please do not close browser until completed",
        duration: Number.POSITIVE_INFINITY,
        progress: 0,
      });

      setToastId(id);
    } else if (toastId && status === "IN_PROGRESS") {
      update(toastId, {
        id: toastId,
        progress: Number(progress),
      });
    }

    if (status === "COMPLETED" && result) {
      // Invalidate documents query to refresh the list
      queryClient.invalidateQueries({
        queryKey: trpc.documents.get.infiniteQueryKey(),
      });

      // Invalidate search query to refresh the results
      queryClient.invalidateQueries({
        queryKey: trpc.search.global.queryKey(),
      });

      // @ts-expect-error
      update(toastId, {
        id: toastId,
        title: "Export completed",
        description: `Your export is ready based on ${result.totalItems} transactions. It's stored in your Vault.`,
        variant: "success",
        footer: (
          <div className="mt-4 flex space-x-4">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button
                  size="sm"
                  variant="secondary"
                  className="border space-x-2"
                >
                  <span>Share URL</span>
                  <Icons.ChevronDown />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent className="z-[100]">
                {options.map((option, idx) => (
                  <DropdownMenuItem
                    key={idx.toString()}
                    onClick={() =>
                      handleOnShare({
                        expireIn: option.expireIn,
                        filePath: result.fullPath,
                      })
                    }
                  >
                    {option.label}
                  </DropdownMenuItem>
                ))}
              </DropdownMenuContent>
            </DropdownMenu>

            <Button
              size="sm"
              onClick={() => {
                if (result?.fullPath && result?.fileName) {
                  downloadFile(
                    `/api/download/file?path=${result.fullPath}&filename=${result.fileName}`,
                    result.fileName,
                  );
                }
                handleOnDownload();
              }}
            >
              Download
            </Button>
          </div>
        ),
      });

      setToastId(null);
      setExportData(undefined);
    }
  }, [toastId, progress, status]);

  return null;
}
</file>

<file path="apps/dashboard/src/components/feedback-form.tsx">
"use client";

import { sendFeebackAction } from "@/actions/send-feedback-action";
import { Button } from "@midday/ui/button";
import { Popover, PopoverContent, PopoverTrigger } from "@midday/ui/popover";
import { Textarea } from "@midday/ui/textarea";
import { Loader2 } from "lucide-react";
import { useAction } from "next-safe-action/hooks";
import { useState } from "react";

export function FeedbackForm() {
  const [value, setValue] = useState("");
  const [submitted, setSubmitted] = useState(false);

  const action = useAction(sendFeebackAction, {
    onSuccess: () => {
      setValue("");
      setSubmitted(true);

      setTimeout(() => {
        setSubmitted(false);
      }, 3000);
    },
  });

  return (
    <Popover>
      <PopoverTrigger asChild className="hidden md:block">
        <Button
          variant="outline"
          className="rounded-full font-normal h-[32px] p-0 px-3 text-xs text-[#878787]"
        >
          Feedback
        </Button>
      </PopoverTrigger>
      <PopoverContent
        className="w-[320px] h-[200px]"
        sideOffset={10}
        align="end"
      >
        {submitted ? (
          <div className="flex items-center justify-center flex-col space-y-1 mt-10 text-center">
            <p className="font-medium text-sm">Thank you for your feedback!</p>
            <p className="text-sm text-[#4C4C4C]">
              We will be back with you as soon as possible
            </p>
          </div>
        ) : (
          <form className="space-y-4">
            <Textarea
              name="feedback"
              value={value}
              required
              autoFocus
              placeholder="Ideas to improve this page or issues you are experiencing."
              className="resize-none h-[120px]"
              onChange={(evt) => setValue(evt.target.value)}
            />

            <div className="mt-1 flex items-center justify-end">
              <Button
                type="button"
                onClick={() => action.execute({ feedback: value })}
                disabled={value.length === 0 || action.status === "executing"}
              >
                {action.status === "executing" ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  "Send"
                )}
              </Button>
            </div>
          </form>
        )}
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="apps/dashboard/src/components/file-preview-icon.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";

type Props = {
  mimetype?: string | null;
  className?: string;
};

export function FilePreviewIcon({ mimetype, className }: Props) {
  switch (mimetype) {
    case "application/pdf":
      return <Icons.Pdf className={cn("w-full h-full", className)} />;
    case "application/zip":
      return <Icons.FolderZip className={cn("w-full h-full", className)} />;
    default:
      return <Icons.Description className={cn("w-full h-full", className)} />;
  }
}
</file>

<file path="apps/dashboard/src/components/file-preview.tsx">
"use client";

import { FilePreviewIcon } from "@/components/file-preview-icon";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import { Skeleton } from "@midday/ui/skeleton";
import { useEffect, useState } from "react";

type Props = {
  mimeType: string;
  filePath: string;
};

function ErrorPreview() {
  return (
    <div className="w-full h-full flex items-center justify-center bg-primary/10">
      <div className="flex flex-col items-center justify-center">
        <Icons.BrokenImage className="size-4" />
      </div>
    </div>
  );
}

export function FilePreview({ mimeType, filePath }: Props) {
  const [isLoading, setIsLoading] = useState(true);
  const [isError, setIsError] = useState(false);

  let src = null;

  if (mimeType.startsWith("image/")) {
    src = `/api/proxy?filePath=${filePath}`;
  }

  if (
    mimeType.startsWith("application/pdf") ||
    mimeType.startsWith("application/octet-stream")
  ) {
    // NOTE: Make a image from the pdf
    src = `/api/preview?filePath=${filePath}`;
  }

  useEffect(() => {
    if (src) {
      const img = new Image();
      img.src = src;
      img.onload = () => {
        setIsLoading(false);
        setIsError(false);
      };
      img.onerror = () => {
        setIsLoading(false);
        setIsError(true);
      };
    }
  }, [src]);

  if (!src) {
    return <FilePreviewIcon mimetype={mimeType} />;
  }

  if (isError) {
    return <ErrorPreview />;
  }

  return (
    <div className="w-full h-full relative">
      {isLoading && <Skeleton className="absolute inset-0 w-full h-full" />}

      <img
        src={src}
        alt="File Preview"
        className={cn(
          "w-full h-full object-contain border border-border dark:border-none",
          isLoading ? "opacity-0" : "opacity-100",
          "transition-opacity duration-100",
        )}
        onError={() => setIsError(true)}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/file-viewer.tsx">
"use client";

import { Skeleton } from "@midday/ui/skeleton";
import dynamic from "next/dynamic";
import { FilePreviewIcon } from "./file-preview-icon";

const DynamicImageViewer = dynamic(
  () => import("@/components/image-viewer").then((mod) => mod.ImageViewer),
  { loading: () => <Skeleton className="h-full w-full" /> },
);

const DynamicPdfViewer = dynamic(
  () => import("@/components/pdf-viewer").then((mod) => mod.PdfViewer),
  { loading: () => <Skeleton className="h-full w-full" /> },
);

type Props = {
  mimeType: string | null;
  url: string;
  maxWidth?: number;
};

export function FileViewer({ mimeType, url, maxWidth }: Props) {
  if (
    mimeType === "application/pdf" ||
    mimeType === "application/octet-stream"
  ) {
    return <DynamicPdfViewer url={url} key={url} maxWidth={maxWidth} />;
  }

  if (mimeType?.startsWith("image/")) {
    return <DynamicImageViewer url={url} />;
  }

  return (
    <div className="size-16">
      <FilePreviewIcon mimetype={mimeType} />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/filter-list.tsx">
import { formatAccountName } from "@/utils/format";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { Skeleton } from "@midday/ui/skeleton";
import { format } from "date-fns";
import { motion } from "framer-motion";
import { formatDateRange } from "little-date";

const listVariant = {
  hidden: { y: 10, opacity: 0 },
  show: {
    y: 0,
    opacity: 1,
    transition: {
      duration: 0.05,
      staggerChildren: 0.06,
    },
  },
};

const itemVariant = {
  hidden: { y: 10, opacity: 0 },
  show: { y: 0, opacity: 1 },
};

type FilterKey =
  | "start"
  | "end"
  | "amount_range"
  | "attachments"
  | "recurring"
  | "statuses"
  | "categories"
  | "tags"
  | "accounts"
  | "customers"
  | "assignees"
  | "owners"
  | "status";

type FilterValue = {
  start: string;
  end: string;
  amount_range: string;
  attachments: string;
  recurring: string[];
  statuses: string[];
  categories: string[];
  tags: string[];
  accounts: string[];
  customers: string[];
  assignees: string[];
  owners: string[];
  status: string;
};

interface FilterValueProps {
  key: FilterKey;
  value: FilterValue[FilterKey];
}

interface Props {
  filters: Partial<FilterValue>;
  loading: boolean;
  onRemove: (filters: { [key: string]: null }) => void;
  categories?: { id: string; name: string; slug: string | null }[];
  accounts?: { id: string; name: string; currency: string }[];
  members?: { id: string; name: string }[];
  customers?: { id: string; name: string }[];
  statusFilters?: { id: string; name: string }[];
  attachmentsFilters?: { id: string; name: string }[];
  recurringFilters?: { id: string; name: string }[];
  tags?: { id: string; name: string; slug?: string }[];
  amountRange?: [number, number];
}

export function FilterList({
  filters,
  loading,
  onRemove,
  categories,
  accounts,
  members,
  customers,
  tags,
  statusFilters,
  attachmentsFilters,
  recurringFilters,
  amountRange,
}: Props) {
  const renderFilter = ({ key, value }: FilterValueProps) => {
    switch (key) {
      case "start": {
        const startValue = value as FilterValue["start"];
        if (startValue && filters.end) {
          return formatDateRange(new Date(startValue), new Date(filters.end), {
            includeTime: false,
          });
        }

        return startValue && format(new Date(startValue), "MMM d, yyyy");
      }

      case "amount_range": {
        return `${amountRange?.[0]?.toLocaleString(undefined, {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        })} - ${amountRange?.[1]?.toLocaleString(undefined, {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        })}`;
      }

      case "attachments": {
        const attachmentValue = value as FilterValue["attachments"];
        return attachmentsFilters?.find(
          (filter) => filter.id === attachmentValue,
        )?.name;
      }

      case "recurring": {
        const recurringValue = value as FilterValue["recurring"];
        return recurringValue
          ?.map(
            (slug) =>
              recurringFilters?.find((filter) => filter.id === slug)?.name,
          )
          .join(", ");
      }

      case "statuses": {
        const statusesValue = value as FilterValue["statuses"];
        if (!statusesValue) return null;
        return statusesValue
          .map(
            (status) =>
              statusFilters?.find((filter) => filter.id === status)?.name,
          )
          .join(", ");
      }

      case "status": {
        const statusValue = value as FilterValue["status"];
        if (!statusValue) return null;
        return statusFilters?.find((filter) => filter.id === statusValue)?.name;
      }

      case "categories": {
        const categoriesValue = value as FilterValue["categories"];
        if (!categoriesValue) return null;
        return categoriesValue
          .map(
            (slug) =>
              categories?.find((category) => category.slug === slug)?.name,
          )
          .join(", ");
      }

      case "tags": {
        const tagsValue = value as FilterValue["tags"];
        if (!tagsValue) return null;
        return tagsValue
          .map(
            (id) =>
              tags?.find((tag) => tag?.id === id || tag?.slug === id)?.name,
          )
          .join(", ");
      }

      case "accounts": {
        const accountsValue = value as FilterValue["accounts"];
        if (!accountsValue) return null;
        return accountsValue
          .map((id) => {
            const account = accounts?.find((account) => account.id === id);
            return formatAccountName({
              name: account?.name,
              currency: account?.currency,
            });
          })
          .join(", ");
      }

      case "customers": {
        const customersValue = value as FilterValue["customers"];
        if (!customersValue) return null;
        return customersValue
          .map((id) => customers?.find((customer) => customer.id === id)?.name)
          .join(", ");
      }

      case "assignees":
      case "owners": {
        const membersValue = value as FilterValue["assignees"];
        if (!membersValue) return null;
        return membersValue
          .map((id) => {
            const member = members?.find((member) => member.id === id);
            return member?.name;
          })
          .join(", ");
      }

      default:
        return null;
    }
  };

  const handleOnRemove = (key: FilterKey) => {
    if (key === "start" || key === "end") {
      onRemove({ start: null, end: null });
      return;
    }

    onRemove({ [key]: null });
  };

  return (
    <motion.ul
      variants={listVariant}
      initial="hidden"
      animate="show"
      className="flex space-x-2"
    >
      {loading && (
        <div className="flex space-x-2">
          <motion.li key="1" variants={itemVariant}>
            <Skeleton className="h-8 w-[100px]" />
          </motion.li>
          <motion.li key="2" variants={itemVariant}>
            <Skeleton className="h-8 w-[100px]" />
          </motion.li>
        </div>
      )}

      {!loading &&
        Object.entries(filters)
          .filter(([key, value]) => value !== null && key !== "end")
          .map(([key, value]) => {
            const filterKey = key as FilterKey;
            return (
              <motion.li key={key} variants={itemVariant}>
                <Button
                  className="h-9 px-2 bg-secondary hover:bg-secondary font-normal text-[#878787] flex space-x-1 items-center group rounded-none"
                  onClick={() => handleOnRemove(filterKey)}
                >
                  <Icons.Clear className="scale-0 group-hover:scale-100 transition-all w-0 group-hover:w-4" />
                  <span>
                    {renderFilter({
                      key: filterKey,
                      value: value as FilterValue[FilterKey],
                    })}
                  </span>
                </Button>
              </motion.li>
            );
          })}
    </motion.ul>
  );
}
</file>

<file path="apps/dashboard/src/components/format-amount.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { formatAmount } from "@/utils/format";

type Props = {
  amount: number;
  currency: string;
  maximumFractionDigits?: number;
  minimumFractionDigits?: number;
  locale?: string;
};

export function FormatAmount({
  amount,
  currency,
  maximumFractionDigits,
  minimumFractionDigits,
  locale,
}: Props) {
  const { data: user } = useUserQuery();

  return formatAmount({
    locale: locale || user?.locale,
    amount: amount,
    currency,
    maximumFractionDigits,
    minimumFractionDigits,
  });
}
</file>

<file path="apps/dashboard/src/components/github-sign-in.tsx">
"use client";

import { getUrl } from "@/utils/environment";
import { isDesktopApp } from "@midday/desktop-client/platform";
import { createClient } from "@midday/supabase/client";
import { Icons } from "@midday/ui/icons";
import { SubmitButton } from "@midday/ui/submit-button";
import { useSearchParams } from "next/navigation";
import { useState } from "react";

export function GithubSignIn() {
  const [isLoading, setLoading] = useState(false);
  const supabase = createClient();
  const searchParams = useSearchParams();
  const returnTo = searchParams.get("return_to");

  const handleSignIn = async () => {
    setLoading(true);

    if (isDesktopApp()) {
      const redirectTo = new URL("/api/auth/callback", getUrl());

      redirectTo.searchParams.append("provider", "github");
      redirectTo.searchParams.append("client", "desktop");

      await supabase.auth.signInWithOAuth({
        provider: "github",
        options: {
          redirectTo: redirectTo.toString(),
          queryParams: {
            client: "desktop",
          },
        },
      });
    } else {
      const redirectTo = new URL("/api/auth/callback", getUrl());

      if (returnTo) {
        redirectTo.searchParams.append("return_to", returnTo);
      }

      redirectTo.searchParams.append("provider", "github");

      await supabase.auth.signInWithOAuth({
        provider: "github",
        options: {
          redirectTo: redirectTo.toString(),
        },
      });
    }

    setTimeout(() => {
      setLoading(false);
    }, 2000);
  };

  return (
    <SubmitButton
      onClick={handleSignIn}
      className="bg-primary px-6 py-4 text-secondary font-medium h-[40px] w-full"
      isSubmitting={isLoading}
    >
      <div className="flex items-center space-x-2">
        <Icons.Github />
        <span>Continue with Github</span>
      </div>
    </SubmitButton>
  );
}
</file>

<file path="apps/dashboard/src/components/global-timer-indicator.tsx">
"use client";

import { useGlobalTimerStatus } from "@/hooks/use-global-timer-status";
import { secondsToHoursAndMinutes } from "@/utils/format";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";

interface GlobalTimerIndicatorProps {
  className?: string;
}

export function GlobalTimerIndicator({ className }: GlobalTimerIndicatorProps) {
  const { isRunning, elapsedTime, currentProject } = useGlobalTimerStatus();

  if (!isRunning || !currentProject) {
    return null;
  }

  return (
    <div
      className={cn(
        "flex items-center gap-2 px-3 py-1.5 bg-green-50 dark:bg-green-950 border border-green-200 dark:border-green-800 rounded-md text-sm",
        className,
      )}
    >
      <div className="flex items-center gap-1.5">
        <div className="relative">
          <Icons.PlayOutline
            size={14}
            className="text-green-600 dark:text-green-400"
          />
          <span className="absolute -top-0.5 -right-0.5 h-2 w-2 bg-green-500 rounded-full animate-pulse" />
        </div>
        <span className="font-mono text-green-700 dark:text-green-300">
          {secondsToHoursAndMinutes(elapsedTime)}
        </span>
        <span className="text-green-600 dark:text-green-400 truncate max-w-[120px]">
          {currentProject}
        </span>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/global-timer-provider.tsx">
"use client";

import { useGlobalTimerStatus } from "@/hooks/use-global-timer-status";

export function GlobalTimerProvider() {
  // This hook handles all the global timer status updates
  useGlobalTimerStatus();

  // This component doesn't render anything, it just runs the hook
  return null;
}
</file>

<file path="apps/dashboard/src/components/gocardless-connect.tsx">
import { createGoCardLessLinkAction } from "@/actions/institutions/create-gocardless-link";
import { getUrl } from "@/utils/environment";
import { isDesktopApp } from "@midday/desktop-client/platform";
import { useToast } from "@midday/ui/use-toast";
import { useAction } from "next-safe-action/hooks";
import { BankConnectButton } from "./bank-connect-button";

type Props = {
  id: string;
  availableHistory: number;
  onSelect: () => void;
};

export function GoCardLessConnect({ onSelect, id, availableHistory }: Props) {
  const { toast } = useToast();

  const createGoCardLessLink = useAction(createGoCardLessLinkAction, {
    onError: () => {
      toast({
        duration: 3500,
        variant: "error",
        title: "Something went wrong please try again.",
      });
    },
  });

  const handleOnSelect = () => {
    onSelect();

    createGoCardLessLink.execute({
      institutionId: id,
      availableHistory: availableHistory,
      redirectBase: isDesktopApp() ? "midday://" : getUrl(),
    });
  };

  return <BankConnectButton onClick={handleOnSelect} />;
}
</file>

<file path="apps/dashboard/src/components/google-sign-in.tsx">
"use client";

import { getUrl } from "@/utils/environment";
import { isDesktopApp } from "@midday/desktop-client/platform";
import { createClient } from "@midday/supabase/client";
import { Icons } from "@midday/ui/icons";
import { SubmitButton } from "@midday/ui/submit-button";
import { useSearchParams } from "next/navigation";
import { useState } from "react";

export function GoogleSignIn() {
  const [isLoading, setLoading] = useState(false);
  const supabase = createClient();
  const searchParams = useSearchParams();
  const returnTo = searchParams.get("return_to");

  const handleSignIn = async () => {
    setLoading(true);

    if (isDesktopApp()) {
      const redirectTo = new URL("/api/auth/callback", getUrl());

      redirectTo.searchParams.append("provider", "google");
      redirectTo.searchParams.append("client", "desktop");

      await supabase.auth.signInWithOAuth({
        provider: "google",
        options: {
          redirectTo: redirectTo.toString(),
          queryParams: {
            prompt: "select_account",
            client: "desktop",
          },
        },
      });
    } else {
      const redirectTo = new URL("/api/auth/callback", getUrl());

      if (returnTo) {
        redirectTo.searchParams.append("return_to", returnTo);
      }

      redirectTo.searchParams.append("provider", "google");

      await supabase.auth.signInWithOAuth({
        provider: "google",
        options: {
          redirectTo: redirectTo.toString(),
          queryParams: {
            prompt: "select_account",
          },
        },
      });
    }

    setTimeout(() => {
      setLoading(false);
    }, 2000);
  };

  return (
    <SubmitButton
      onClick={handleSignIn}
      className="bg-primary px-6 py-4 text-secondary font-medium h-[40px] w-full"
      isSubmitting={isLoading}
    >
      <div className="flex items-center space-x-2">
        <Icons.Google />
        <span>Continue with Google</span>
      </div>
    </SubmitButton>
  );
}
</file>

<file path="apps/dashboard/src/components/header.tsx">
import { ConnectionStatus } from "@/components/connection-status";
import { NotificationCenter } from "@/components/notification-center";
import { OpenSearchButton } from "@/components/search/open-search-button";
import { Trial } from "@/components/trial";
import { UserMenu } from "@/components/user-menu";
import { MobileMenu } from "./mobile-menu";

export function Header() {
  return (
    <header className="md:m-0 z-50 px-6 md:border-b h-[70px] flex justify-between items-center desktop:sticky desktop:top-0 desktop:bg-background sticky md:static top-0 backdrop-filter backdrop-blur-xl md:backdrop-filter md:backdrop-blur-none dark:bg-[#121212] bg-[#fff] bg-opacity-70 desktop:rounded-t-[10px]">
      <MobileMenu />

      <OpenSearchButton />

      <div className="flex space-x-2 ml-auto">
        <Trial />
        <ConnectionStatus />
        <NotificationCenter />
        <UserMenu />
      </div>
    </header>
  );
}
</file>

<file path="apps/dashboard/src/components/horizontal-pagination.tsx">
"use client";

import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";

interface HorizontalPaginationProps {
  canScrollLeft: boolean;
  canScrollRight: boolean;
  onScrollLeft: () => void;
  onScrollRight: () => void;
  className?: string;
}

export function HorizontalPagination({
  canScrollLeft,
  canScrollRight,
  onScrollLeft,
  onScrollRight,
  className,
}: HorizontalPaginationProps) {
  return (
    <div className={cn("flex items-center space-x-2", className)}>
      <Button
        variant="outline"
        size="sm"
        disabled={!canScrollLeft}
        className="size-6 p-0"
        onClick={onScrollLeft}
      >
        <Icons.ArrowBack
          className={cn("size-3.5", canScrollLeft && "text-primary")}
        />
      </Button>
      <Button
        variant="outline"
        size="sm"
        disabled={!canScrollRight}
        className="size-6 p-0"
        onClick={onScrollRight}
      >
        <Icons.ArrowForward
          className={cn("size-3.5", canScrollRight && "text-primary")}
        />
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/image-viewer.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import { Skeleton } from "@midday/ui/skeleton";
import { useState } from "react";

function ErrorImage() {
  return (
    <div className="w-full h-full flex items-center justify-center bg-primary/10">
      <div className="flex flex-col items-center justify-center">
        <Icons.BrokenImage className="size-4" />
      </div>
    </div>
  );
}

export function ImageViewer({ url }: { url: string }) {
  const [isLoading, setIsLoading] = useState(true);
  const [isError, setIsError] = useState(false);

  if (!url) return <ErrorImage />;

  return (
    <div className="relative flex h-full w-full items-center justify-center bg-primary/10">
      {isLoading && !isError && (
        <Skeleton className="absolute inset-0 h-full w-full" />
      )}

      {isError && <ErrorImage />}

      <img
        src={url}
        alt="Viewer content"
        className={cn(
          "max-h-full max-w-full object-contain",
          isLoading ? "opacity-0" : "opacity-100",
        )}
        onLoad={() => setIsLoading(false)}
        onError={() => setIsError(true)}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/inactive-clients.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { Card, CardContent, CardHeader, CardTitle } from "@midday/ui/card";
import NumberFlow from "@number-flow/react";
import { useSuspenseQuery } from "@tanstack/react-query";

export function InactiveClients() {
  const trpc = useTRPC();
  const { data } = useSuspenseQuery(
    trpc.invoice.inactiveClientsCount.queryOptions(),
  );

  return (
    <Card className="hidden sm:block">
      <CardHeader className="pb-3">
        <CardTitle className="font-mono font-medium text-2xl">
          <NumberFlow value={data} willChange />
        </CardTitle>
      </CardHeader>

      <CardContent className="pb-[34px]">
        <div className="flex flex-col gap-2">
          <div>Inactive Clients</div>
          <div className="text-sm text-muted-foreground">
            No invoices or time tracked past 30 days
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/inbox-sheet-details.tsx">
"use client";

import { FileViewer } from "@/components/file-viewer";
import { FormatAmount } from "@/components/format-amount";
import { InboxActions } from "@/components/inbox/inbox-actions";
import { useInboxParams } from "@/hooks/use-inbox-params";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { formatDate, getInitials } from "@/utils/format";
import { getWebsiteLogo } from "@/utils/logos";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { Separator } from "@midday/ui/separator";
import { SheetHeader } from "@midday/ui/sheet";
import { Skeleton } from "@midday/ui/skeleton";
import { useQuery, useQueryClient } from "@tanstack/react-query";

export function InboxSheetDetails() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { params } = useInboxParams();
  const { data: user } = useUserQuery();

  const isOpen = Boolean(params.inboxId && params.type === "details");

  const { data, isLoading } = useQuery({
    ...trpc.inbox.getById.queryOptions({
      id: params.inboxId!,
    }),
    enabled: isOpen,
    staleTime: 0,
    initialData: () => {
      const pages = queryClient
        .getQueriesData({ queryKey: trpc.inbox.get.infiniteQueryKey() })
        // @ts-expect-error
        .flatMap(([, data]) => data?.pages ?? [])
        .flatMap((page) => page.data ?? []);

      return pages.find((d) => d.id === params.inboxId);
    },
  });

  if (isLoading || !data) {
    return (
      <div className="flex flex-col flex-grow min-h-0 relative h-full w-full">
        <SheetHeader className="mb-4 flex justify-between items-center flex-row">
          <div className="min-w-0 flex-1 max-w-[70%] flex flex-row gap-2 items-end">
            <Skeleton className="h-6 w-32" />
            <Skeleton className="h-4 w-16" />
          </div>
          <Skeleton className="h-8 w-8 rounded-full" />
        </SheetHeader>

        <div className="flex-1 mb-4 overflow-hidden relative flex items-center justify-center">
          <Skeleton className="h-full w-full max-w-[565px]" />
        </div>
      </div>
    );
  }

  const isProcessing =
    data.status === "processing" || data.status === "analyzing";
  const logoUrl = getWebsiteLogo(data.website);

  return (
    <div className="flex flex-col flex-grow min-h-0 relative h-full w-full">
      {/* Document info header */}
      <div className="mb-4">
        <div className="flex items-start justify-between">
          <div className="flex items-start gap-3">
            {logoUrl && (
              <div className="relative">
                <Avatar className="size-9 border">
                  <AvatarImageNext
                    src={logoUrl}
                    alt={data.website || ""}
                    width={36}
                    height={36}
                    quality={100}
                  />
                  <AvatarFallback className="text-[9px] font-medium">
                    {data.website ? getInitials(data.website) : ""}
                  </AvatarFallback>
                </Avatar>
              </div>
            )}

            <div className="grid gap-1 select-text">
              <div className="font-semibold">
                {isProcessing ? (
                  <Skeleton className="h-3 w-[120px] mb-1" />
                ) : (
                  data.displayName
                )}
              </div>
              <div className="line-clamp-1 text-xs">
                {isProcessing && !data.currency && (
                  <Skeleton className="h-3 w-[50px]" />
                )}
                {data.currency && data.amount != null && (
                  <FormatAmount amount={data.amount} currency={data.currency} />
                )}
              </div>
            </div>
          </div>
          <div className="grid gap-1 ml-auto text-right">
            <div className="text-xs text-muted-foreground select-text">
              {isProcessing && !data.date && (
                <Skeleton className="h-3 w-[50px]" />
              )}
              {data.date && formatDate(data.date, user?.dateFormat)}
            </div>
          </div>
        </div>
      </div>

      <Separator className="mb-4" />

      {/* Document preview */}
      <div className="flex-1 mb-4 overflow-hidden relative">
        {data?.filePath && (
          <div className="h-full flex items-center justify-center">
            <FileViewer
              mimeType={data.contentType}
              url={`/api/proxy?filePath=vault/${data.filePath.join("/")}`}
              maxWidth={565}
            />
          </div>
        )}

        <div className="absolute bottom-4 z-10 left-4 right-4">
          <InboxActions data={data} key={data.id} />
        </div>
      </div>

      <Separator className="mb-4" />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/input-color.tsx">
import { getColorFromName, getRandomColor } from "@/utils/categories";
import { Input } from "@midday/ui/input";
import { useState } from "react";
import { ColorPicker } from "./color-picker";

type Props = {
  placeholder: string;
  defaultValue?: string;
  defaultColor?: string;
  autoFocus?: boolean;
  onChange: (values: { name: string; color: string }) => void;
};

export function InputColor({
  placeholder,
  defaultValue,
  onChange,
  defaultColor,
  autoFocus,
}: Props) {
  const [color, setColor] = useState(defaultColor ?? getRandomColor());
  const [value, setValue] = useState(defaultValue);

  return (
    <div className="relative">
      <ColorPicker
        value={color ?? ""}
        onSelect={(newColor) => {
          setColor(newColor);

          if (value) {
            onChange({
              color: newColor,
              name: value,
            });
          }
        }}
      />

      <Input
        placeholder={placeholder}
        autoComplete="off"
        autoCapitalize="none"
        autoFocus={autoFocus}
        autoCorrect="off"
        spellCheck="false"
        className="pl-7"
        value={value}
        onChange={(evt) => {
          const newName = evt.target.value;
          const newColor = getColorFromName(newName);

          setColor(newColor);
          setValue(newName);

          if (newColor) {
            onChange({
              color: newColor,
              name: newName,
            });
          }
        }}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/institution-info.tsx">
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import type { ReactNode } from "react";

type Props = {
  provider: string;
  children: ReactNode;
};

export function InstitutionInfo({ provider, children }: Props) {
  const getDescription = () => {
    switch (provider) {
      case "gocardless":
        return "With GoCardLess we can connect to more than 2,500 banks in 31 countries across the UK and Europe.";
      case "plaid":
        return `With Plaid we can connect to 12,000+ financial institutions across the US, Canada, UK, and Europe are covered by Plaid's network`;
      case "teller":
        return "With Teller we can connect instantly to more than 5,000 financial institutions in the US.";
      case "enablebanking":
        return "With Enable Banking we can connect to more than 2,500 banks in Europe.";
      default:
        break;
    }
  };

  return (
    <TooltipProvider delayDuration={100}>
      <Tooltip>
        <TooltipTrigger asChild>{children}</TooltipTrigger>
        <TooltipContent className="w-[300px] text-xs" side="right">
          {getDescription()}
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-actions.tsx">
"use client";

import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { useTRPC } from "@/trpc/client";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@midday/ui/alert-dialog";
import { Button } from "@midday/ui/button";
import { Calendar } from "@midday/ui/calendar";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { useToast } from "@midday/ui/use-toast";
import { useMutation, useQueryClient } from "@tanstack/react-query";

type Props = {
  status: string;
  id: string;
};

export function InvoiceActions({ status, id }: Props) {
  const trpc = useTRPC();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const { setParams } = useInvoiceParams();

  const updateInvoiceMutation = useMutation(
    trpc.invoice.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.getById.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.invoiceSummary.queryKey(),
        });
      },
    }),
  );

  const deleteInvoiceMutation = useMutation(
    trpc.invoice.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.infiniteQueryKey(),
        });

        // Widget uses regular query
        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.getById.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.invoiceSummary.queryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.invoice.defaultSettings.queryKey(),
        });
      },
    }),
  );

  const sendReminderMutation = useMutation(
    trpc.invoice.remind.mutationOptions({
      onSuccess: () => {
        toast({
          duration: 2500,
          title: "Reminder sent",
          variant: "success",
        });
      },
    }),
  );

  const handleDeleteInvoice = () => {
    deleteInvoiceMutation.mutate({ id });
    setParams(null);
  };

  switch (status) {
    case "canceled":
    case "paid":
      return (
        <div className="absolute right-4 mt-7">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                size="icon"
                variant="secondary"
                className="hover:bg-secondary"
              >
                <Icons.MoreHoriz className="size-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent sideOffset={10} align="end">
              <DropdownMenuItem
                onClick={() =>
                  updateInvoiceMutation.mutate({
                    id,
                    status: "unpaid",
                    paidAt: null,
                  })
                }
              >
                Mark as unpaid
              </DropdownMenuItem>
              <DropdownMenuItem
                className="text-destructive"
                onClick={handleDeleteInvoice}
              >
                Delete
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      );

    case "overdue":
    case "unpaid":
      return (
        <div className="flex space-x-2 mt-8">
          <AlertDialog>
            <AlertDialogTrigger asChild>
              <Button
                size="sm"
                variant="secondary"
                className="flex items-center space-x-2 hover:bg-secondary w-full"
              >
                <Icons.Notifications className="size-3.5" />
                <span>Remind</span>
              </Button>
            </AlertDialogTrigger>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Send Reminder</AlertDialogTitle>
                <AlertDialogDescription>
                  Are you sure you want to send a reminder for this invoice?
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction
                  onClick={() =>
                    sendReminderMutation.mutate({
                      id,
                      date: new Date().toISOString(),
                    })
                  }
                  disabled={sendReminderMutation.isPending}
                >
                  Send Reminder
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>

          <Button
            size="sm"
            variant="secondary"
            className="flex items-center space-x-2 hover:bg-secondary w-full"
            onClick={() => setParams({ invoiceId: id, type: "edit" })}
          >
            <Icons.Edit className="size-3.5" />
            <span>Edit</span>
          </Button>

          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                size="sm"
                variant="secondary"
                className="hover:bg-secondary"
              >
                <Icons.MoreHoriz className="size-4" />
              </Button>
            </DropdownMenuTrigger>

            <DropdownMenuContent sideOffset={10} align="end">
              <DropdownMenuSub>
                <DropdownMenuSubTrigger>Mark as paid</DropdownMenuSubTrigger>
                <DropdownMenuSubContent>
                  <Calendar
                    mode="single"
                    toDate={new Date()}
                    selected={new Date()}
                    onSelect={(date) => {
                      if (date) {
                        updateInvoiceMutation.mutate({
                          id,
                          status: "paid",
                          paidAt: date.toISOString(),
                        });
                      } else {
                        // NOTE: Today is undefined
                        updateInvoiceMutation.mutate({
                          id,
                          status: "paid",
                          paidAt: new Date().toISOString(),
                        });
                      }
                    }}
                    initialFocus
                  />
                </DropdownMenuSubContent>
              </DropdownMenuSub>
              <DropdownMenuItem
                className="text-destructive"
                onClick={handleDeleteInvoice}
              >
                Delete
              </DropdownMenuItem>
              <DropdownMenuItem
                className="text-destructive"
                onClick={() =>
                  updateInvoiceMutation.mutate({
                    id,
                    status: "canceled",
                  })
                }
              >
                Cancel
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      );
    case "draft":
      return (
        <div className="flex space-x-2 mt-8">
          <Button
            size="sm"
            variant="secondary"
            className="flex items-center space-x-2 hover:bg-secondary w-full"
            onClick={() => setParams({ invoiceId: id, type: "edit" })}
          >
            <Icons.Edit className="size-3.5" />
            <span>Edit</span>
          </Button>

          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                size="sm"
                variant="secondary"
                className="hover:bg-secondary"
              >
                <Icons.MoreHoriz className="size-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent sideOffset={10} align="end">
              <DropdownMenuItem
                className="text-destructive"
                onClick={handleDeleteInvoice}
              >
                Delete draft
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      );
    default:
      return null;
  }
}
</file>

<file path="apps/dashboard/src/components/invoice-column-visibility.tsx">
"use client";

import { useInvoiceStore } from "@/store/invoice";
import { Button } from "@midday/ui/button";
import { Checkbox } from "@midday/ui/checkbox";
import { Icons } from "@midday/ui/icons";
import { Popover, PopoverContent, PopoverTrigger } from "@midday/ui/popover";

export function InvoiceColumnVisibility() {
  const { columns } = useInvoiceStore();

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button variant="outline" size="icon">
          <Icons.Tune size={18} />
        </Button>
      </PopoverTrigger>

      <PopoverContent className="w-[200px] p-0" align="end" sideOffset={8}>
        <div className="flex flex-col p-4 space-y-2 h-[410px]">
          {columns
            .filter(
              (column) =>
                column.columnDef.enableHiding !== false &&
                column.id !== "actions",
            )
            .map((column) => {
              return (
                <div key={column.id} className="flex items-center space-x-2">
                  <Checkbox
                    id={column.id}
                    checked={column.getIsVisible()}
                    onCheckedChange={(checked) =>
                      column.toggleVisibility(checked === true)
                    }
                  />
                  <label
                    htmlFor={column.id}
                    className="text-sm peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                  >
                    {column.columnDef.header?.toString() ?? column.id}
                  </label>
                </div>
              );
            })}
        </div>
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-content.tsx">
"use client";

import { InvoiceSuccess } from "@/components/invoice-success";
import { Form } from "@/components/invoice/form";
import { SettingsMenu } from "@/components/invoice/settings-menu";
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { SheetContent, SheetHeader } from "@midday/ui/sheet";
import { useFormContext } from "react-hook-form";

export function InvoiceContent() {
  const { type } = useInvoiceParams();
  const { watch } = useFormContext();
  const templateSize = watch("template.size");

  const size = templateSize === "a4" ? 650 : 740;

  if (type === "success") {
    return (
      <SheetContent className="bg-white dark:bg-[#0C0C0C] transition-[max-width] duration-300 ease-in-out">
        <InvoiceSuccess />
      </SheetContent>
    );
  }

  return (
    <SheetContent
      style={{ maxWidth: size }}
      className="bg-white dark:bg-[#0C0C0C] transition-[max-width] duration-300 ease-in-out"
    >
      <SheetHeader className="mb-6 flex justify-between items-center flex-row">
        <div className="ml-auto">
          <SettingsMenu />
        </div>
      </SheetHeader>

      <Form />
    </SheetContent>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-details-skeleton.tsx">
"use client";

import { Skeleton } from "@midday/ui/skeleton";

export function InvoiceDetailsSkeleton() {
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div className="flex space-x-2 mt-1 items-center">
          <Skeleton className="size-5 rounded-full" />
          <Skeleton className="h-4 w-32" />
        </div>
        <Skeleton className="h-6 w-20" />
      </div>

      <div className="flex justify-between items-center mt-6 mb-3 relative">
        <div className="flex flex-col w-full space-y-1">
          <Skeleton className="h-10 w-40" />
          <Skeleton className="h-3 w-24" />
        </div>
      </div>

      <Skeleton className="h-10 w-full" />

      <div className="mt-8 flex flex-col space-y-1">
        <Skeleton className="h-6 w-48" />
        <Skeleton className="h-4 w-36" />
      </div>

      <div className="mt-6 flex flex-col space-y-4 border-t border-border pt-6">
        {[...Array(4)].map((_, index) => (
          <div
            key={index.toString()}
            className="flex justify-between items-center"
          >
            <Skeleton className="h-4 w-24" />
            <Skeleton className="h-4 w-32" />
          </div>
        ))}
      </div>

      <div className="mt-6 flex flex-col space-y-2 border-t border-border pt-6">
        <Skeleton className="h-4 w-24" />
        <div className="flex w-full gap-2">
          <Skeleton className="h-10 flex-1" />
          <Skeleton className="h-10 w-10" />
        </div>
      </div>

      <div className="mt-6">
        <Skeleton className="h-10 w-full" />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-details.tsx">
"use client";

import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { useUserQuery } from "@/hooks/use-user";
import { downloadFile } from "@/lib/download";
import { useTRPC } from "@/trpc/client";
import { getUrl } from "@/utils/environment";
import { getWebsiteLogo } from "@/utils/logos";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import { useQuery } from "@tanstack/react-query";
import { format } from "date-fns";
import { CopyInput } from "./copy-input";
import { FormatAmount } from "./format-amount";
import { InvoiceActions } from "./invoice-actions";
import { InvoiceDetailsSkeleton } from "./invoice-details-skeleton";
import { InvoiceNote } from "./invoice-note";
import { InvoiceStatus } from "./invoice-status";
import { InvoiceActivity } from "./invoice/activity";
import { OpenURL } from "./open-url";

export function InvoiceDetails() {
  const trpc = useTRPC();
  const { invoiceId } = useInvoiceParams();
  const { data: user } = useUserQuery();

  const isOpen = invoiceId !== null;

  const { data, isLoading } = useQuery({
    ...trpc.invoice.getById.queryOptions({ id: invoiceId! }),
    enabled: isOpen,
  });

  if (isLoading) {
    return <InvoiceDetailsSkeleton />;
  }

  if (!data) {
    return null;
  }

  const {
    id,
    customer,
    amount,
    currency,
    status,
    vat,
    tax,
    paidAt,
    dueDate,
    issueDate,
    invoiceNumber,
    template,
    token,
    internalNote,
    updatedAt,
    sentAt,
    sentTo,
    customerName,
    scheduledAt,
  } = data;

  return (
    <div className="h-full">
      <div className="flex justify-between items-center">
        <div className="flex space-x-2 mt-1 items-center">
          <Avatar className="size-5">
            {customer?.website && (
              <AvatarImageNext
                src={getWebsiteLogo(customer?.website)}
                alt={`${customer?.name} logo`}
                width={20}
                height={20}
                quality={100}
              />
            )}
            <AvatarFallback className="text-[9px] font-medium">
              {customer?.name?.at(0) || customerName?.at(0)}
            </AvatarFallback>
          </Avatar>

          <span className="text-sm line-clamp-1">{customer?.name}</span>
        </div>
        <InvoiceStatus status={status} />
      </div>

      <div className="flex justify-between items-center mt-6 mb-3 relative">
        <div className="flex flex-col w-full space-y-1">
          <span
            className={cn("text-4xl font-mono select-text", {
              "line-through": status === "canceled",
            })}
          >
            {currency && (
              <FormatAmount amount={amount ?? 0} currency={currency} />
            )}
          </span>

          <div className="h-3 space-x-2">
            {vat !== 0 && vat != null && currency && (
              <span className="text-[#606060] text-xs select-text">
                {template?.vatLabel}{" "}
                <FormatAmount amount={vat} currency={currency} />
              </span>
            )}

            {tax !== 0 && tax != null && currency && (
              <span className="text-[#606060] text-xs select-text">
                {template?.taxLabel}{" "}
                <FormatAmount amount={tax} currency={currency} />
              </span>
            )}
          </div>
        </div>
      </div>

      <InvoiceActions status={status} id={id} />

      <div className="h-full p-0 pb-[143px] overflow-y-auto scrollbar-hide">
        {status === "paid" && (
          <div className="mt-8 flex flex-col space-y-1">
            <span className="text-base font-medium">
              Paid on {paidAt && format(new Date(paidAt), "MMM dd")}
            </span>
            <span className="text-xs">
              <span className="text-[#606060]">Marked as paid</span>
            </span>
          </div>
        )}

        {status === "canceled" && (
          <div className="mt-8 flex flex-col space-y-1">
            <span className="text-base font-medium">
              Canceled on {updatedAt && format(new Date(updatedAt), "MMM dd")}
            </span>
            <span className="text-xs">
              <span className="text-[#606060]">Marked as canceled</span>
            </span>
          </div>
        )}

        <div className="mt-6 flex flex-col space-y-4 border-t border-border pt-6">
          <div className="flex justify-between items-center">
            <span className="text-sm text-[#606060]">Due date</span>
            <span className="text-sm">
              <span>{dueDate && format(new Date(dueDate), "MMM dd")}</span>
            </span>
          </div>
          <div className="flex justify-between items-center">
            <span className="text-sm text-[#606060]">Issue date</span>
            <span className="text-sm">
              <span>{issueDate && format(new Date(issueDate), "MMM dd")}</span>
            </span>
          </div>

          {scheduledAt && status === "scheduled" && (
            <div className="flex justify-between items-center">
              <span className="text-sm text-[#606060]">Scheduled at</span>
              <span className="text-sm">
                <span>
                  {format(
                    new Date(scheduledAt),
                    `MMM d, ${user?.timeFormat === 24 ? "HH:mm" : "h:mm a"}`,
                  )}
                </span>
              </span>
            </div>
          )}

          {sentAt && (
            <div className="flex justify-between items-center">
              <span className="text-sm text-[#606060]">Sent at</span>
              <span className="text-sm">
                <span>{sentAt && format(new Date(sentAt), "MMM dd")}</span>
              </span>
            </div>
          )}

          {sentTo && (
            <div className="flex justify-between items-center">
              <span className="text-sm text-[#606060]">Sent to</span>
              <span className="text-sm">{sentTo}</span>
            </div>
          )}

          <div className="flex justify-between items-center">
            <span className="text-sm text-[#606060]">Invoice no.</span>
            <span className="text-sm">
              <span>{invoiceNumber}</span>
            </span>
          </div>
        </div>

        {customer && (
          <div className="mt-6 flex flex-col space-y-2 border-t border-border pt-6">
            <span className="text-sm text-[#606060]">Invoice link</span>
            <div className="flex w-full gap-2">
              <div className="flex-1 min-w-0 relative">
                <CopyInput value={`${getUrl()}/i/${token}`} className="pr-14" />

                <div className="absolute right-10 top-[11px] border-r border-border pr-2">
                  <OpenURL href={`${getUrl()}/i/${token}`}>
                    <Icons.OpenInNew />
                  </OpenURL>
                </div>
              </div>

              {status !== "draft" && (
                <Button
                  variant="secondary"
                  className="size-[38px] hover:bg-secondary shrink-0"
                  onClick={() => {
                    downloadFile(
                      `/api/download/invoice?id=${id}`,
                      `${invoiceNumber}.pdf`,
                    );
                  }}
                >
                  <div>
                    <Icons.ArrowCoolDown className="size-4" />
                  </div>
                </Button>
              )}
            </div>
          </div>
        )}

        <Accordion
          type="multiple"
          className="mt-6"
          defaultValue={internalNote ? ["note", "activity"] : ["activity"]}
        >
          <AccordionItem value="activity">
            <AccordionTrigger>Activity</AccordionTrigger>
            <AccordionContent>
              <InvoiceActivity data={data} />
            </AccordionContent>
          </AccordionItem>
          <AccordionItem value="note">
            <AccordionTrigger>Internal note</AccordionTrigger>
            <AccordionContent>
              <InvoiceNote id={id} defaultValue={internalNote} />
            </AccordionContent>
          </AccordionItem>
        </Accordion>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-header.tsx">
import { InvoiceSearchFilter } from "@/components/invoice-search-filter";
import { InvoiceColumnVisibility } from "./invoice-column-visibility";
import { OpenInvoiceSheet } from "./open-invoice-sheet";

export function InvoiceHeader() {
  return (
    <div className="flex items-center justify-between">
      <InvoiceSearchFilter />

      <div className="hidden sm:flex space-x-2">
        <InvoiceColumnVisibility />
        <OpenInvoiceSheet />
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-note.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { Textarea } from "@midday/ui/textarea";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useEffect, useState } from "react";
import { useDebounceValue } from "usehooks-ts";

type Props = {
  id: string;
  defaultValue?: string | null;
};

export function InvoiceNote({ id, defaultValue }: Props) {
  const queryClient = useQueryClient();
  const trpc = useTRPC();
  const [value, setValue] = useState(defaultValue);
  const [debouncedValue] = useDebounceValue(value, 500);

  const updateInvoiceMutation = useMutation(
    trpc.invoice.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.invoice.getById.queryKey({ id }),
        });
      },
    }),
  );

  useEffect(() => {
    if (debouncedValue !== defaultValue) {
      updateInvoiceMutation.mutate({
        id,
        internalNote:
          debouncedValue && debouncedValue.length > 0 ? debouncedValue : null,
      });
    }
  }, [debouncedValue, defaultValue, id, updateInvoiceMutation]);

  return (
    <Textarea
      defaultValue={defaultValue ?? ""}
      id="note"
      placeholder="Note"
      className="min-h-[100px] resize-none"
      onChange={(evt) => setValue(evt.target.value)}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-payment-score.tsx">
"use client";

import { useI18n } from "@/locales/client";
import { useTRPC } from "@/trpc/client";
import { Card, CardContent, CardHeader, CardTitle } from "@midday/ui/card";
import { Skeleton } from "@midday/ui/skeleton";
import { useSuspenseQuery } from "@tanstack/react-query";
import { PaymentScoreVisualizer } from "./payment-score-visualizer";

export function InvoicePaymentScoreSkeleton() {
  return (
    <Card>
      <CardHeader className="pb-2 flex flex-row justify-between">
        <CardTitle>
          <Skeleton className="h-8 w-32" />
        </CardTitle>
      </CardHeader>

      <CardContent>
        <div className="flex flex-col gap-2">
          <Skeleton className="h-5 w-24" />
          <Skeleton className="h-4 w-full" />
        </div>
      </CardContent>
    </Card>
  );
}

export function InvoicePaymentScore() {
  const trpc = useTRPC();
  const { data } = useSuspenseQuery(trpc.invoice.paymentStatus.queryOptions());
  const t = useI18n();

  return (
    <Card>
      <CardHeader className="pb-2 flex flex-col xl:flex-row justify-between">
        <CardTitle className="font-mono font-medium text-2xl">
          {/* @ts-expect-error */}
          {t(`payment_status.${data?.paymentStatus}`)}
        </CardTitle>

        <PaymentScoreVisualizer
          score={data?.score}
          paymentStatus={data?.paymentStatus}
        />
      </CardHeader>

      <CardContent className="sm:hidden xl:flex">
        <div className="flex flex-col gap-2">
          <div>Payment score</div>
          <div className="text-sm text-muted-foreground">
            {/* @ts-expect-error */}
            {t(`payment_status_description.${data?.paymentStatus}`)}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-search-filter.tsx">
"use client";

import { generateInvoiceFilters } from "@/actions/ai/filters/generate-invoice-filters";
import { useInvoiceFilterParams } from "@/hooks/use-invoice-filter-params";
import { useI18n } from "@/locales/client";
import { useTRPC } from "@/trpc/client";
import { Calendar } from "@midday/ui/calendar";
import { cn } from "@midday/ui/cn";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { Input } from "@midday/ui/input";
import { useQuery } from "@tanstack/react-query";
import { readStreamableValue } from "ai/rsc";
import { formatISO } from "date-fns";
import { useRef, useState } from "react";
import { useHotkeys } from "react-hotkeys-hook";
import { FilterList } from "./filter-list";

const allowedStatuses = [
  "draft",
  "overdue",
  "paid",
  "unpaid",
  "canceled",
  "scheduled",
];

export function InvoiceSearchFilter() {
  const [prompt, setPrompt] = useState("");
  const inputRef = useRef<HTMLInputElement>(null);
  const t = useI18n();
  const [streaming, setStreaming] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const trpc = useTRPC();

  const { setFilter, filter } = useInvoiceFilterParams();

  const { data: customersData } = useQuery(trpc.customers.get.queryOptions());

  const statusFilters = allowedStatuses.map((status) => ({
    id: status,
    // @ts-expect-error
    name: t(`invoice_status.${status}`),
  }));

  useHotkeys(
    "esc",
    () => {
      setPrompt("");
      setFilter(null);
      setIsOpen(false);
    },
    {
      enableOnFormTags: true,
      enabled: Boolean(prompt),
    },
  );

  useHotkeys("meta+s", (evt) => {
    evt.preventDefault();
    inputRef.current?.focus();
  });

  const handleSearch = (evt: React.ChangeEvent<HTMLInputElement>) => {
    const value = evt.target.value;

    if (value) {
      setPrompt(value);
    } else {
      setFilter(null);
      setPrompt("");
    }
  };

  const handleSubmit = async () => {
    // If the user is typing a query with multiple words, we want to stream the results
    if (prompt.split(" ").length > 1) {
      setStreaming(true);

      setStreaming(true);

      const { object } = await generateInvoiceFilters(
        prompt,
        `Invoice payment statuses: ${statusFilters.map((filter) => filter.name).join(", ")}
         Customers: ${customersData?.data?.map((customer) => customer.name).join(", ")}
      `,
      );

      let finalObject = {};

      for await (const partialObject of readStreamableValue(object)) {
        if (partialObject) {
          finalObject = {
            ...finalObject,
            statuses: Array.isArray(partialObject?.statuses)
              ? partialObject?.statuses
              : partialObject?.statuses
                ? [partialObject.statuses]
                : null,
            customers:
              partialObject?.customers?.map(
                (name: string) =>
                  customersData?.data?.find(
                    (customer) => customer.name === name,
                  )?.id,
              ) ?? null,
            q: partialObject?.name ?? null,
            start: partialObject?.start ?? null,
            end: partialObject?.end ?? null,
          };
        }
      }

      setFilter({
        q: null,
        ...finalObject,
      });

      setStreaming(false);
    } else {
      setFilter({ q: prompt.length > 0 ? prompt : null });
    }
  };

  const validFilters = Object.fromEntries(
    Object.entries(filter).filter(([key]) => key !== "q"),
  );

  const hasValidFilters = Object.values(validFilters).some(
    (value) => value !== null,
  );

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <div className="flex flex-col sm:flex-row sm:space-x-4 space-y-4 sm:space-y-0 items-start sm:items-center w-full">
        <form
          className="relative w-full sm:w-auto"
          onSubmit={(e) => {
            e.preventDefault();
            handleSubmit();
          }}
        >
          <Icons.Search className="absolute pointer-events-none left-3 top-[11px]" />
          <Input
            ref={inputRef}
            placeholder="Search or filter"
            className="pl-9 w-full sm:w-[350px] pr-8"
            value={prompt}
            onChange={handleSearch}
            autoComplete="off"
            autoCapitalize="none"
            autoCorrect="off"
            spellCheck="false"
          />

          <DropdownMenuTrigger asChild>
            <button
              onClick={() => setIsOpen((prev) => !prev)}
              type="button"
              className={cn(
                "absolute z-10 right-3 top-[10px] opacity-50 transition-opacity duration-300 hover:opacity-100",
                hasValidFilters && "opacity-100",
                isOpen && "opacity-100",
              )}
            >
              <Icons.Filter />
            </button>
          </DropdownMenuTrigger>
        </form>

        <FilterList
          filters={validFilters}
          loading={streaming}
          onRemove={setFilter}
          statusFilters={statusFilters}
          customers={customersData?.data}
        />
      </div>

      <DropdownMenuContent
        className="w-[350px]"
        sideOffset={19}
        alignOffset={-11}
        side="bottom"
        align="end"
      >
        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.CalendarMonth className="mr-2 h-4 w-4" />
              <span>Due Date</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                alignOffset={-4}
                className="p-0"
              >
                <Calendar
                  mode="range"
                  initialFocus
                  selected={{
                    from: filter?.start ? new Date(filter.start) : undefined,
                    to: filter?.end ? new Date(filter.end) : undefined,
                  }}
                  onSelect={(range) => {
                    setFilter({
                      start: range?.from
                        ? formatISO(range.from, { representation: "date" })
                        : null,
                      end: range?.to
                        ? formatISO(range.to, { representation: "date" })
                        : null,
                    });
                  }}
                />
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>

        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.Face className="mr-2 h-4 w-4" />
              <span>Customer</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                alignOffset={-4}
                className="p-0"
              >
                {customersData?.data?.map((customer) => (
                  <DropdownMenuCheckboxItem
                    key={customer.id}
                    onCheckedChange={() => {
                      setFilter({
                        customers: filter?.customers?.includes(customer.id)
                          ? filter.customers.filter((s) => s !== customer.id)
                          : [...(filter?.customers ?? []), customer.id],
                      });
                    }}
                  >
                    {customer.name}
                  </DropdownMenuCheckboxItem>
                ))}

                {!customersData?.data?.length && (
                  <DropdownMenuItem disabled>
                    No customers found
                  </DropdownMenuItem>
                )}
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>

        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.Status className="mr-2 h-4 w-4" />
              <span>Status</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                alignOffset={-4}
                className="p-0"
              >
                {statusFilters?.map((status) => (
                  <DropdownMenuCheckboxItem
                    key={status.id}
                    onCheckedChange={() => {
                      setFilter({
                        statuses: filter?.statuses?.includes(status.id)
                          ? filter.statuses.filter((s) => s !== status.id)
                          : [...(filter?.statuses ?? []), status.id],
                      });
                    }}
                  >
                    {status.name}
                  </DropdownMenuCheckboxItem>
                ))}
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-sheet-header.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { SheetHeader } from "@midday/ui/sheet";
import { useQuery } from "@tanstack/react-query";

type Props = {
  invoiceId: string;
};

export function InvoiceSheetHeader({ invoiceId }: Props) {
  const trpc = useTRPC();

  const { data: invoice } = useQuery(
    trpc.invoice.getById.queryOptions(
      {
        id: invoiceId,
      },
      {
        enabled: Boolean(invoiceId),
      },
    ),
  );

  if (invoice?.template?.deliveryType === "create_and_send") {
    return (
      <SheetHeader className="mb-6 flex flex-col">
        <h2 className="text-xl">Created & Sent</h2>
        <p className="text-sm text-[#808080]">
          Your invoice was created and sent successfully
        </p>
      </SheetHeader>
    );
  }

  if (invoice?.template?.deliveryType === "scheduled") {
    return (
      <SheetHeader className="mb-6 flex flex-col">
        <h2 className="text-xl">Scheduled</h2>
        <p className="text-sm text-[#808080]">
          Your invoice was scheduled successfully
        </p>
      </SheetHeader>
    );
  }

  // Default: created
  return (
    <SheetHeader className="mb-6 flex flex-col">
      <h2 className="text-xl">Created</h2>
      <p className="text-sm text-[#808080]">
        Your invoice was created successfully
      </p>
    </SheetHeader>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-status.tsx">
"use client";

import { useI18n } from "@/locales/client";
import { cn } from "@midday/ui/cn";
import { Skeleton } from "@midday/ui/skeleton";

export function InvoiceStatus({
  status,
  isLoading,
  className,
}: {
  status?: "draft" | "overdue" | "paid" | "unpaid" | "canceled" | "scheduled";
  isLoading?: boolean;
  className?: string;
}) {
  const t = useI18n();

  if (isLoading) {
    return <Skeleton className="w-24 h-6 rounded-full" />;
  }

  if (!status) {
    return null;
  }

  return (
    <div
      className={cn(
        "px-2 py-0.5 rounded-full cursor-default font-mono inline-flex max-w-full text-[11px]",
        (status === "draft" || status === "canceled") &&
          "text-[#878787] bg-[#F2F1EF] text-[10px] dark:text-[#878787] dark:bg-[#1D1D1D]",
        status === "overdue" &&
          "bg-[#FFD02B]/10 text-[#FFD02B] dark:bg-[#FFD02B]/10 dark:text-[#FFD02B]",
        status === "paid" &&
          "text-[#00C969] bg-[#DDF1E4] dark:text-[#00C969] dark:bg-[#00C969]/10",
        status === "unpaid" &&
          "text-[#1D1D1D] bg-[#878787]/10 dark:text-[#F5F5F3] dark:bg-[#F5F5F3]/10",
        status === "scheduled" &&
          "text-[#1F6FEB] bg-[#DDEBFF] dark:text-[#1F6FEB] dark:bg-[#1F6FEB]/10",
        className,
      )}
    >
      <span className="line-clamp-1 truncate inline-block">
        {t(`invoice_status.${status}`)}
      </span>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-success.tsx">
"use client";

import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { downloadFile } from "@/lib/download";
import { useTRPC } from "@/trpc/client";
import { getUrl } from "@/utils/environment";
import { formatEditorContent } from "@midday/invoice/format-to-html";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { useQuery } from "@tanstack/react-query";
import { format } from "date-fns";
import { motion } from "framer-motion";
import { CopyInput } from "./copy-input";
import { FormatAmount } from "./format-amount";
import { InvoiceSheetHeader } from "./invoice-sheet-header";
import { OpenURL } from "./open-url";

export function InvoiceSuccess() {
  const trpc = useTRPC();
  const { invoiceId, setParams } = useInvoiceParams();

  const { data: invoice } = useQuery(
    trpc.invoice.getById.queryOptions(
      {
        id: invoiceId!,
      },
      {
        enabled: !!invoiceId,
      },
    ),
  );

  if (!invoice) {
    return null;
  }

  return (
    <>
      <InvoiceSheetHeader invoiceId={invoiceId!} />

      <div className="flex flex-col justify-center h-[calc(100vh-260px)]">
        <div className="bg-[#F2F2F2] dark:bg-background p-6 relative">
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ duration: 0.3 }}
            className="flex items-center justify-between mb-6"
          >
            <div className="flex space-x-1 items-center">
              <div className="flex items-center">
                <span className="text-[11px] text-[#878787] font-mono">
                  {invoice.template.invoiceNoLabel}
                </span>
                <span className="text-[11px] text-[#878787] font-mono">:</span>
              </div>

              <span className="font-mono text-[11px]">
                {invoice.invoiceNumber}
              </span>
            </div>

            <div className="flex space-x-1 items-center">
              <div className="flex items-center">
                <span className="text-[11px] text-[#878787] font-mono">
                  {invoice.template.dueDateLabel}
                </span>
                <span className="text-[11px] text-[#878787] font-mono">:</span>
              </div>

              <span className="font-mono text-[11px]">
                {format(
                  new Date(invoice.dueDate!),
                  invoice.template.dateFormat,
                )}
              </span>
            </div>
          </motion.div>

          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.2, duration: 0.3 }}
          >
            <span className="text-[11px] font-mono">
              {invoice.template.customerLabel}
            </span>
            <div className="font-mono text-[#878787]">
              {/* @ts-expect-error - customerDetails is JSONB */}
              {formatEditorContent(invoice.customerDetails)}
            </div>
          </motion.div>

          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.4, duration: 0.3 }}
            className="flex items-center justify-between mt-10 border-b border-border border-dashed pb-4"
          >
            <span className="text-[11px] text-[#878787] font-mono">
              {invoice.template.totalSummaryLabel}
            </span>

            <span className="font-mono text-xl">
              {invoice.amount && invoice.currency && (
                <FormatAmount
                  amount={invoice.amount}
                  currency={invoice.currency}
                />
              )}
            </span>
          </motion.div>

          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.4, duration: 0.3 }}
            className="flex flex-col space-y-6 mt-10 mb-6"
          >
            <h2>Details</h2>

            {invoice.sentTo && (
              <div className="flex flex-col space-y-1">
                <span className="text-[11px] text-[#878787] font-mono">
                  Invoice sent to
                </span>
                <span className="text-sm">{invoice.sentTo}</span>
              </div>
            )}

            <div>
              <span className="text-[11px] text-[#878787] font-mono">
                Share link
              </span>
              <div className="flex w-full gap-2 mt-1">
                <div className="flex-1 min-w-0">
                  <CopyInput value={`${getUrl()}/i/${invoice.token}`} />
                </div>

                <Button
                  variant="secondary"
                  className="size-[40px] hover:bg-secondary shrink-0"
                  onClick={() => {
                    downloadFile(
                      `/api/download/invoice?id=${invoice.id}`,
                      `${invoice.invoiceNumber}.pdf`,
                    );
                  }}
                >
                  <div>
                    <Icons.ArrowCoolDown className="size-4" />
                  </div>
                </Button>
              </div>
            </div>
          </motion.div>

          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.4, duration: 0.3 }}
            className="flex flex-wrap gap-3 absolute -bottom-[15px] left-0 right-0 w-full justify-center"
          >
            {Array.from({ length: 10 }).map((_, index) => (
              <div
                key={index.toString()}
                className="size-[30px] rounded-full bg-background dark:bg-[#0C0C0C]"
              />
            ))}
          </motion.div>
        </div>
      </div>

      <div className="flex mt-auto absolute bottom-6 justify-end gap-4 right-6 left-6">
        <OpenURL href={`${getUrl()}/i/${invoice.token}`}>
          <Button variant="secondary">View invoice</Button>
        </OpenURL>

        <Button
          onClick={() => {
            setParams(null);

            setTimeout(() => {
              setParams({ type: "create" });
            }, 600);
          }}
        >
          Create another
        </Button>
      </div>
    </>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-summary.tsx">
"use client";

import { useTeamQuery } from "@/hooks/use-team";
import { useI18n } from "@/locales/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Card, CardContent, CardHeader, CardTitle } from "@midday/ui/card";
import { cn } from "@midday/ui/cn";
import { Skeleton } from "@midday/ui/skeleton";
import { useState } from "react";
import { AnimatedNumber } from "./animated-number";

type Props = {
  data: RouterOutputs["invoice"]["invoiceSummary"];
  totalInvoiceCount: number;
  title: string;
};

export function InvoiceSummarySkeleton() {
  return (
    <Card>
      <CardHeader className="pb-3">
        <CardTitle>
          <Skeleton className="h-[30px] w-32" />
        </CardTitle>
      </CardHeader>

      <CardContent className="pb-[34px]">
        <div className="flex flex-col gap-2">
          <Skeleton className="h-5 w-16" />
          <Skeleton className="h-4 w-24" />
        </div>
      </CardContent>
    </Card>
  );
}

export function InvoiceSummary({ data, totalInvoiceCount, title }: Props) {
  const t = useI18n();
  const [activeIndex, setActiveIndex] = useState(0);
  const { data: team } = useTeamQuery();

  const dataWithDefaultCurrency = data?.length
    ? data
    : [{ currency: team?.baseCurrency, totalAmount: 0 }];

  const item = dataWithDefaultCurrency[activeIndex];

  if (!item) {
    return null;
  }

  return (
    <Card>
      <CardHeader className="pb-2 relative">
        <CardTitle className="font-mono font-medium text-2xl">
          <AnimatedNumber
            key={item.currency}
            value={item.totalAmount}
            currency={item.currency ?? team?.baseCurrency ?? "USD"}
            maximumFractionDigits={0}
            minimumFractionDigits={0}
          />

          {dataWithDefaultCurrency.length > 1 && (
            <div className="flex space-x-2 top-[63px] absolute">
              {dataWithDefaultCurrency.map((item, idx) => (
                <div
                  key={item.currency}
                  onMouseEnter={() => setActiveIndex(idx)}
                  onClick={() => setActiveIndex(idx)}
                  className={cn(
                    "w-[10px] h-[3px] bg-[#1D1D1D] dark:bg-[#D9D9D9] opacity-30 transition-all",
                    idx === activeIndex && "opacity-100",
                  )}
                />
              ))}
            </div>
          )}
        </CardTitle>
      </CardHeader>

      <CardContent>
        <div className="flex flex-col gap-2">
          <div>{title}</div>
          <div className="text-sm text-muted-foreground">
            {t("invoice_count", {
              count: totalInvoiceCount ?? 0,
            })}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/invoice-toolbar.tsx">
"use client";

import { downloadFile } from "@/lib/download";
import { Button } from "@midday/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { motion } from "framer-motion";
import { MdContentCopy, MdOutlineFileDownload } from "react-icons/md";
import { useCopyToClipboard } from "usehooks-ts";

type Props = {
  token: string;
  invoiceNumber: string;
};

export default function InvoiceToolbar({ token, invoiceNumber }: Props) {
  const [, copy] = useCopyToClipboard();

  const handleCopyLink = () => {
    const url = window.location.href;
    copy(url);
  };

  return (
    <motion.div
      className="fixed inset-x-0 -bottom-1 flex justify-center"
      initial={{ opacity: 0, filter: "blur(8px)", y: 0 }}
      animate={{ opacity: 1, filter: "blur(0px)", y: -24 }}
      transition={{ type: "spring", stiffness: 300, damping: 25 }}
    >
      <div className="backdrop-filter backdrop-blur-lg dark:bg-[#1A1A1A]/80 bg-[#F6F6F3]/80 rounded-full pl-2 pr-4 py-3 h-10 flex items-center justify-center border-[0.5px] border-border">
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="rounded-full size-8"
                onClick={() => {
                  downloadFile(
                    `/api/download/invoice?token=${token}`,
                    `${invoiceNumber}.pdf`,
                  );
                }}
              >
                <MdOutlineFileDownload className="size-[18px]" />
              </Button>
            </TooltipTrigger>
            <TooltipContent
              sideOffset={15}
              className="text-[10px] px-2 py-1 rounded-sm font-medium"
            >
              <p>Download</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>

        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="rounded-full size-8"
                onClick={handleCopyLink}
              >
                <MdContentCopy />
              </Button>
            </TooltipTrigger>
            <TooltipContent
              sideOffset={15}
              className="text-[10px] px-2 py-1 rounded-sm font-medium"
            >
              <p>Copy link</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
    </motion.div>
  );
}
</file>

<file path="apps/dashboard/src/components/invoices-open.tsx">
"use client";

import { useInvoiceFilterParams } from "@/hooks/use-invoice-filter-params";
import { useTRPC } from "@/trpc/client";
import { useSuspenseQuery } from "@tanstack/react-query";
import { InvoiceSummary } from "./invoice-summary";

export function InvoicesOpen() {
  const trpc = useTRPC();
  const { data } = useSuspenseQuery(
    trpc.invoice.invoiceSummary.queryOptions({
      status: "unpaid",
    }),
  );
  const { setFilter } = useInvoiceFilterParams();

  const totalInvoiceCount = data?.reduce(
    (acc, curr) => acc + (curr.invoiceCount ?? 0),
    0,
  );

  return (
    <button
      type="button"
      onClick={() =>
        setFilter({
          statuses: ["draft", "overdue", "unpaid"],
        })
      }
      className="hidden sm:block text-left"
    >
      <InvoiceSummary
        data={data}
        totalInvoiceCount={totalInvoiceCount ?? 0}
        title="Open"
      />
    </button>
  );
}
</file>

<file path="apps/dashboard/src/components/invoices-overdue.tsx">
"use client";

import { useInvoiceFilterParams } from "@/hooks/use-invoice-filter-params";
import { useTRPC } from "@/trpc/client";
import { useSuspenseQuery } from "@tanstack/react-query";
import { InvoiceSummary } from "./invoice-summary";

export function InvoicesOverdue() {
  const trpc = useTRPC();
  const { setFilter } = useInvoiceFilterParams();
  const { data } = useSuspenseQuery(
    trpc.invoice.invoiceSummary.queryOptions({
      status: "overdue",
    }),
  );

  const totalInvoiceCount = data?.at(0)?.invoiceCount;

  return (
    <button
      type="button"
      onClick={() =>
        setFilter({
          statuses: ["overdue"],
        })
      }
      className="hidden sm:block text-left"
    >
      <InvoiceSummary
        data={data}
        totalInvoiceCount={totalInvoiceCount ?? 0}
        title="Overdue"
      />
    </button>
  );
}
</file>

<file path="apps/dashboard/src/components/invoices-paid.tsx">
"use client";

import { useInvoiceFilterParams } from "@/hooks/use-invoice-filter-params";
import { useTRPC } from "@/trpc/client";
import { useSuspenseQuery } from "@tanstack/react-query";
import { InvoiceSummary } from "./invoice-summary";

export function InvoicesPaid() {
  const { setFilter } = useInvoiceFilterParams();
  const trpc = useTRPC();
  const { data } = useSuspenseQuery(
    trpc.invoice.invoiceSummary.queryOptions({
      status: "paid",
    }),
  );

  const totalInvoiceCount = data?.at(0)?.invoiceCount;

  return (
    <button
      type="button"
      onClick={() =>
        setFilter({
          statuses: ["paid"],
        })
      }
      className="hidden sm:block text-left"
    >
      <InvoiceSummary
        data={data}
        totalInvoiceCount={totalInvoiceCount ?? 0}
        title="Paid"
      />
    </button>
  );
}
</file>

<file path="apps/dashboard/src/components/load-more.tsx">
"use client";

import { Spinner } from "@midday/ui/spinner";
import type { ForwardedRef } from "react";

export function LoadMore({
  hasNextPage,
  ref,
}: {
  hasNextPage: boolean;
  ref: ForwardedRef<HTMLDivElement>;
}) {
  if (!hasNextPage) return null;

  return (
    <div className="flex items-center justify-center mt-6" ref={ref}>
      <div className="flex items-center space-x-2 py-5">
        <Spinner />
        <span className="text-sm text-[#606060]">Loading more...</span>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/loading-transactions-event.tsx">
"use client";

import { useConnectParams } from "@/hooks/use-connect-params";
import { useInitialConnectionStatus } from "@/hooks/use-initial-connection-status";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { useQueryClient } from "@tanstack/react-query";
import { useTheme } from "next-themes";
import dynamic from "next/dynamic";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";

const Lottie = dynamic(() => import("lottie-react"), {
  ssr: false,
});

type Props = {
  accessToken?: string;
  runId?: string;
  setRunId: (runId?: string) => void;
  onClose: () => void;
  setActiveTab: (value: "support" | "loading" | "select-accounts") => void;
};

export function LoadingTransactionsEvent({
  accessToken,
  runId,
  setRunId,
  onClose,
  setActiveTab,
}: Props) {
  const queryClient = useQueryClient();
  const [step, setStep] = useState(1);
  const { resolvedTheme } = useTheme();
  const { setParams } = useConnectParams();

  const { status } = useInitialConnectionStatus({
    runId,
    accessToken,
  });

  useEffect(() => {
    if (status === "SYNCING") {
      setStep(2);
    }

    if (status === "COMPLETED") {
      setStep(3);

      // Invalidate queries to refresh the data
      queryClient.invalidateQueries();

      setTimeout(() => {
        setRunId(undefined);
        setParams(null);
      }, 1000);
    }
  }, [status]);

  return (
    <div className="w-full">
      <Lottie
        className="mb-6"
        animationData={
          resolvedTheme === "dark"
            ? require("public/assets/setup-animation.json")
            : require("public/assets/setup-animation-dark.json")
        }
        loop={true}
        style={{ width: 50, height: 50 }}
        rendererSettings={{
          preserveAspectRatio: "xMidYMid slice",
        }}
      />
      <h2 className="text-lg font-semibold leading-none tracking-tight mb-2">
        Setting up account
      </h2>

      <p className="text-sm text-[#878787] mb-8">
        Depending on the bank it can take up to 1 hour to fetch all
        transactions, feel free to close this window and we will notify you when
        it is done.
      </p>

      <ul className="text-md text-[#878787] space-y-4 transition-all">
        <li
          className={cn(
            "opacity-50 dark:opacity-20",
            step > 0 && "!opacity-100",
          )}
        >
          Connecting bank
          {step === 1 && <span className="loading-ellipsis" />}
        </li>
        <li
          className={cn(
            "opacity-50 dark:opacity-20",
            step > 1 && "!opacity-100",
          )}
        >
          Getting transactions
          {step === 2 && <span className="loading-ellipsis" />}
        </li>
        <li
          className={cn(
            "opacity-50 dark:opacity-20",
            step > 2 && "!opacity-100",
          )}
        >
          Completed
          {step === 3 && <span className="loading-ellipsis" />}
        </li>
      </ul>

      <div className="w-full mt-12">
        <Button className="w-full" onClick={onClose}>
          Close
        </Button>

        <div className="flex justify-center mt-4">
          <button
            type="button"
            className="text-xs text-[#878787]"
            onClick={() => setActiveTab("support")}
          >
            Need support
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/locale-settings.tsx">
"use client";

import { useUserMutation, useUserQuery } from "@/hooks/use-user";
import { useI18n } from "@/locales/client";
import { countries } from "@midday/location/countries-intl";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { ComboboxDropdown } from "@midday/ui/combobox-dropdown";

export function LocaleSettings() {
  const t = useI18n();
  const { data: user } = useUserQuery();
  const updateUserMutation = useUserMutation();

  const localeItems = Object.values(countries).map((c, index) => ({
    id: index.toString(),
    label: `${c.name} (${c.default_locale})`,
    value: c.default_locale,
  }));

  return (
    <Card className="flex justify-between items-center">
      <CardHeader>
        <CardTitle>{t("locale.title")}</CardTitle>
        <CardDescription>{t("locale.description")}</CardDescription>
      </CardHeader>

      <CardContent>
        <div className="w-[250px]">
          <ComboboxDropdown
            placeholder={t("locale.placeholder")}
            selectedItem={localeItems.find(
              (item) => item.value === user?.locale,
            )}
            searchPlaceholder={t("locale.searchPlaceholder")}
            items={localeItems}
            className="text-xs py-1"
            onSelect={(item) => {
              updateUserMutation.mutate({ locale: item.value });
            }}
          />
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/logo-upload.tsx">
"use client";

import { useUpload } from "@/hooks/use-upload";
import { Avatar, AvatarImage } from "@midday/ui/avatar";
import { Spinner } from "@midday/ui/spinner";
import { nanoid } from "nanoid";
import { useRef, useState } from "react";

type Props = {
  logoUrl?: string | null;
  onUpload?: (url: string) => void;
  size?: number;
};

export const LogoUpload = ({ logoUrl: initialLogoUrl, onUpload }: Props) => {
  const [logo, setLogo] = useState(initialLogoUrl);
  const inputRef = useRef<HTMLInputElement>(null);

  const { isLoading, uploadFile } = useUpload();

  const handleUpload = async (evt: React.ChangeEvent<HTMLInputElement>) => {
    const { files } = evt.target;
    const selectedFile = files as FileList;

    if (!selectedFile[0]) return;

    const originalFilename = selectedFile[0]?.name ?? "";
    const extension = originalFilename.split(".").pop() || "";
    const filename = extension ? `${nanoid()}.${extension}` : nanoid();

    const { url } = await uploadFile({
      bucket: "apps",
      path: ["logos", filename],
      file: selectedFile[0] as File,
    });

    if (url) {
      setLogo(url);
      onUpload?.(url);
    }
  };

  return (
    <Avatar
      className="rounded-none w-16 h-16 flex items-center justify-center bg-accent cursor-pointer"
      onClick={() => inputRef?.current?.click()}
    >
      {isLoading ? (
        <Spinner className="h-4 w-4" />
      ) : (
        <>
          <AvatarImage
            src={logo ?? undefined}
            alt="Logo"
            width={64}
            height={64}
          />
        </>
      )}

      <input
        ref={inputRef}
        type="file"
        style={{ display: "none" }}
        multiple={false}
        onChange={handleUpload}
      />
    </Avatar>
  );
};
</file>

<file path="apps/dashboard/src/components/main-menu.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { useEffect, useState } from "react";

const icons = {
  "/": () => <Icons.Overview size={20} />,
  "/transactions": () => <Icons.Transactions size={20} />,
  "/invoices": () => <Icons.Invoice size={20} />,
  "/tracker": () => <Icons.Tracker size={20} />,
  "/customers": () => <Icons.Customers size={20} />,
  "/vault": () => <Icons.Vault size={20} />,
  "/settings": () => <Icons.Settings size={20} />,
  "/apps": () => <Icons.Apps size={20} />,
  "/inbox": () => <Icons.Inbox2 size={20} />,
} as const;

const items = [
  {
    path: "/",
    name: "Overview",
  },
  {
    path: "/inbox",
    name: "Inbox",
    children: [{ path: "/inbox/settings", name: "Settings" }],
  },
  {
    path: "/transactions",
    name: "Transactions",
    children: [
      {
        path: "/transactions/categories",
        name: "Categories",
      },
      {
        path: "/transactions?step=connect",
        name: "Connect bank",
      },
      {
        path: "/transactions?step=import&hide=true",
        name: "Import",
      },
      { path: "/transactions?createTransaction=true", name: "Create new" },
    ],
  },
  {
    path: "/invoices",
    name: "Invoices",
    children: [
      { path: "/invoices?statuses=paid", name: "Paid" },
      { path: "/invoices?statuses=unpaid", name: "Unpaid" },
      { path: "/invoices?statuses=overdue", name: "Overdue" },
      { path: "/invoices?statuses=draft", name: "Draft" },
      { path: "/invoices?statuses=scheduled", name: "Scheduled" },
      { path: "/invoices?type=create", name: "Create new" },
    ],
  },
  {
    path: "/tracker",
    name: "Tracker",
    children: [{ path: "/tracker?create=true", name: "Create new" }],
  },
  {
    path: "/customers",
    name: "Customers",
    children: [{ path: "/customers?createCustomer=true", name: "Create new" }],
  },
  {
    path: "/vault",
    name: "Vault",
  },
  {
    path: "/apps",
    name: "Apps",
    children: [
      { path: "/apps", name: "All" },
      { path: "/apps?tab=installed", name: "Installed" },
    ],
  },
  {
    path: "/settings",
    name: "Settings",
    children: [
      { path: "/settings", name: "General" },
      { path: "/settings/billing", name: "Billing" },
      { path: "/settings/accounts", name: "Bank Connections" },
      { path: "/settings/members", name: "Members" },
      { path: "/settings/notifications", name: "Notifications" },
      { path: "/settings/developer", name: "Developer" },
    ],
  },
];

interface ItemProps {
  item: {
    path: string;
    name: string;
    children?: { path: string; name: string }[];
  };
  isActive: boolean;
  isExpanded: boolean;
  isItemExpanded: boolean;
  onToggle: (path: string) => void;
  onSelect?: () => void;
}

const ChildItem = ({
  child,
  isActive,
  isExpanded,
  shouldShow,
  onSelect,
  index,
}: {
  child: { path: string; name: string };
  isActive: boolean;
  isExpanded: boolean;
  shouldShow: boolean;
  onSelect?: () => void;
  index: number;
}) => {
  const showChild = isExpanded && shouldShow;

  return (
    <Link
      prefetch
      href={child.path}
      onClick={() => onSelect?.()}
      className="block group/child"
    >
      <div className="relative">
        {/* Child item text */}
        <div
          className={cn(
            "ml-[35px] mr-[15px] h-[32px] flex items-center",
            "border-l border-[#DCDAD2] dark:border-[#2C2C2C] pl-3",
            "transition-all duration-200 ease-out",
            showChild
              ? "opacity-100 translate-x-0"
              : "opacity-0 -translate-x-2",
          )}
          style={{
            transitionDelay: showChild
              ? `${40 + index * 20}ms`
              : `${index * 20}ms`,
          }}
        >
          <span
            className={cn(
              "text-xs font-medium transition-colors duration-200",
              "text-[#888] group-hover/child:text-primary",
              "whitespace-nowrap overflow-hidden",
              isActive && "text-primary",
            )}
          >
            {child.name}
          </span>
        </div>
      </div>
    </Link>
  );
};

const Item = ({
  item,
  isActive,
  isExpanded,
  isItemExpanded,
  onToggle,
  onSelect,
}: ItemProps) => {
  const Icon = icons[item.path as keyof typeof icons];
  const pathname = usePathname();
  const hasChildren = item.children && item.children.length > 0;

  // Children should be visible when: expanded sidebar AND this item is expanded
  const shouldShowChildren = isExpanded && isItemExpanded;

  const handleChevronClick = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    onToggle(item.path);
  };

  return (
    <div className="group">
      <Link
        prefetch
        href={item.path}
        onClick={() => onSelect?.()}
        className="group"
      >
        <div className="relative">
          {/* Background that expands */}
          <div
            className={cn(
              "border border-transparent h-[40px] transition-all duration-200 ease-&lsqb;cubic-bezier(0.4,0,0.2,1)&rsqb; ml-[15px] mr-[15px]",
              isActive &&
                "bg-[#F2F1EF] dark:bg-secondary border-[#DCDAD2] dark:border-[#2C2C2C]",
              isExpanded ? "w-[calc(100%-30px)]" : "w-[40px]",
            )}
          />

          {/* Icon - always in same position from sidebar edge */}
          <div className="absolute top-0 left-[15px] w-[40px] h-[40px] flex items-center justify-center dark:text-[#666666] text-black group-hover:!text-primary pointer-events-none">
            <div className={cn(isActive && "dark:!text-white")}>
              <Icon />
            </div>
          </div>

          {isExpanded && (
            <div className="absolute top-0 left-[55px] right-[4px] h-[40px] flex items-center pointer-events-none">
              <span
                className={cn(
                  "text-sm font-medium transition-opacity duration-200 ease-in-out text-[#666] group-hover:text-primary",
                  "whitespace-nowrap overflow-hidden",
                  hasChildren ? "pr-2" : "",
                  isActive && "text-primary",
                )}
              >
                {item.name}
              </span>
              {hasChildren && (
                <button
                  type="button"
                  onClick={handleChevronClick}
                  className={cn(
                    "w-8 h-8 flex items-center justify-center transition-all duration-200 ml-auto mr-3",
                    "text-[#888] hover:text-primary pointer-events-auto",
                    isActive && "text-primary/60",
                    shouldShowChildren && "rotate-180",
                  )}
                >
                  <Icons.ChevronDown size={16} />
                </button>
              )}
            </div>
          )}
        </div>
      </Link>

      {/* Children */}
      {hasChildren && (
        <div
          className={cn(
            "transition-all duration-300 ease-out overflow-hidden",
            shouldShowChildren ? "max-h-96 mt-1" : "max-h-0",
          )}
        >
          {item.children!.map((child, index) => {
            const isChildActive = pathname === child.path;
            return (
              <ChildItem
                key={child.path}
                child={child}
                isActive={isChildActive}
                isExpanded={isExpanded}
                shouldShow={shouldShowChildren}
                onSelect={onSelect}
                index={index}
              />
            );
          })}
        </div>
      )}
    </div>
  );
};

type Props = {
  onSelect?: () => void;
  isExpanded?: boolean;
};

export function MainMenu({ onSelect, isExpanded = false }: Props) {
  const pathname = usePathname();
  const part = pathname?.split("/")[1];
  const [expandedItem, setExpandedItem] = useState<string | null>(null);

  // Reset expanded item when sidebar expands/collapses
  useEffect(() => {
    setExpandedItem(null);
  }, [isExpanded]);

  return (
    <div className="mt-6 w-full">
      <nav className="w-full">
        <div className="flex flex-col gap-2">
          {items.map((item) => {
            const isActive =
              (pathname === "/" && item.path === "/") ||
              (pathname !== "/" && item.path.startsWith(`/${part}`));

            return (
              <Item
                key={item.path}
                item={item}
                isActive={isActive}
                isExpanded={isExpanded}
                isItemExpanded={expandedItem === item.path}
                onToggle={(path) => {
                  setExpandedItem(expandedItem === path ? null : path);
                }}
                onSelect={onSelect}
              />
            );
          })}
        </div>
      </nav>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/manage-subscription.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { Card } from "@midday/ui/card";
import { SubmitButton } from "@midday/ui/submit-button";
import Link from "next/link";
import { useState } from "react";

export function ManageSubscription() {
  const [isLoading, setIsLoading] = useState(false);

  const { data: user } = useUserQuery();

  return (
    <div>
      <h2 className="text-lg font-medium leading-none tracking-tight mb-4">
        Subscription
      </h2>

      <Card className="flex justify-between p-4">
        <div className="flex flex-col gap-1">
          <p className="text-sm text-muted-foreground">Current plan</p>
          <p className="text-lg font-medium">Pro</p>
        </div>

        <div className="mt-auto">
          <Link
            href={`/api/portal?id=${user?.team?.id}`}
            className="text-sm text-muted-foreground hover:text-primary"
            onClick={() => setIsLoading(true)}
            prefetch={false}
          >
            <SubmitButton
              variant="secondary"
              className="h-9 hover:bg-primary hover:text-secondary"
              isSubmitting={isLoading}
            >
              Manage subscription
            </SubmitButton>
          </Link>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/manual-accounts.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { useSuspenseQuery } from "@tanstack/react-query";
import { BankAccount } from "./bank-account";

export function ManualAccounts() {
  const trpc = useTRPC();

  const { data } = useSuspenseQuery(
    trpc.bankAccounts.get.queryOptions({
      manual: true,
    }),
  );

  return (
    <div className="px-6 pb-6 space-y-6 divide-y">
      {data?.map((account) => (
        <BankAccount key={account.id} data={account} />
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/markdown.tsx">
import { type FC, memo } from "react";
import ReactMarkdown, { type Options } from "react-markdown";

export const MemoizedReactMarkdown: FC<Options> = memo(
  ReactMarkdown,
  (prevProps, nextProps) => prevProps.children === nextProps.children,
);
</file>

<file path="apps/dashboard/src/components/mfa-list.tsx">
import { getI18n } from "@/locales/server";
import { createClient } from "@midday/supabase/server";
import { Skeleton } from "@midday/ui/skeleton";
import { format } from "date-fns";
import { RemoveMFAButton } from "./remove-mfa-button";

export function MFAListSkeleton() {
  return (
    <div className="flex justify-between items-center h-[36px]">
      <Skeleton className="h-4 w-[200px]" />
    </div>
  );
}

export async function MFAList() {
  const supabase = await createClient();

  const { data } = await supabase.auth.mfa.listFactors();
  const t = await getI18n();

  return data?.all
    ?.sort((a) => (a.status === "verified" ? -1 : 1))
    .map((factor) => {
      return (
        <div
          key={factor.id}
          className="flex justify-between items-center space-y-4"
        >
          <div>
            <p className="text-sm">
              Added on {format(new Date(factor.created_at), "pppp")}
            </p>

            <p className="text-xs text-[#606060] mt-0.5">
              {t(`mfa_status.${factor.status}`)}
            </p>
          </div>

          <RemoveMFAButton factorId={factor.id} />
        </div>
      );
    });
}
</file>

<file path="apps/dashboard/src/components/mfa-settings-list.tsx">
import { Button } from "@midday/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import Link from "next/link";
import { UnenrollMFA } from "./unenroll-mfa";

export function MfaSettingsList() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Multi-factor authentication</CardTitle>
        <CardDescription>
          Add an additional layer of security to your account by requiring more
          than just a password to sign in.
        </CardDescription>
      </CardHeader>

      <CardContent>
        <UnenrollMFA />
      </CardContent>

      <CardFooter className="flex justify-between">
        <div />
        <Link href="?add=device">
          <Button>Add new device</Button>
        </Link>
      </CardFooter>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/mobile-menu.tsx">
"use client";

import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { Sheet, SheetContent, SheetTrigger } from "@midday/ui/sheet";
import { useState } from "react";
import { MainMenu } from "./main-menu";

export function MobileMenu() {
  const [isOpen, setOpen] = useState(false);

  return (
    <Sheet open={isOpen} onOpenChange={setOpen}>
      <div>
        <Button
          variant="outline"
          size="icon"
          onClick={() => setOpen(true)}
          className="rounded-full w-8 h-8 items-center relative flex md:hidden"
        >
          <Icons.Menu size={16} />
        </Button>
      </div>
      <SheetContent side="left" className="border-none rounded-none -ml-4">
        <div className="ml-2 mb-8">
          <Icons.LogoSmall />
        </div>

        <div className="-ml-2">
          <MainMenu onSelect={() => setOpen(false)} isExpanded={true} />
        </div>
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="apps/dashboard/src/components/most-active-client.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { Card, CardContent, CardHeader, CardTitle } from "@midday/ui/card";
import { useSuspenseQuery } from "@tanstack/react-query";

export function MostActiveClient() {
  const trpc = useTRPC();
  const { data } = useSuspenseQuery(
    trpc.invoice.mostActiveClient.queryOptions(),
  );

  if (!data) {
    return (
      <Card>
        <CardHeader className="pb-3">
          <CardTitle className="font-mono font-medium text-2xl">
            No Active Client
          </CardTitle>
        </CardHeader>

        <CardContent className="pb-[34px]">
          <div className="flex flex-col gap-2">
            <div>Most Active Client</div>
            <div className="text-sm text-muted-foreground">
              No client activity past 30 days
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  const trackerHours = Math.round(data.totalTrackerTime / 3600);
  const trackerMinutes = Math.round((data.totalTrackerTime % 3600) / 60);

  const timeDisplay =
    trackerHours > 0
      ? `${trackerHours}h${trackerMinutes > 0 ? ` ${trackerMinutes}m` : ""}`
      : `${trackerMinutes}m`;

  return (
    <Card>
      <CardHeader className="pb-3">
        <CardTitle className="font-mono font-medium text-2xl">
          {data.customerName}
        </CardTitle>
      </CardHeader>

      <CardContent className="pb-[34px]">
        <div className="flex flex-col gap-2">
          <div>Most Active Client</div>
          <div className="text-sm text-muted-foreground">
            {data.totalTrackerTime > 0 && (
              <>
                {timeDisplay} tracked
                {data.invoiceCount > 0 && " and "}
              </>
            )}
            {data.invoiceCount > 0 && (
              <>
                {data.invoiceCount} invoice{data.invoiceCount !== 1 ? "s" : ""}
              </>
            )}
            {" past 30 days"}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/new-customers-this-month.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { Card, CardContent, CardHeader, CardTitle } from "@midday/ui/card";
import NumberFlow from "@number-flow/react";
import { useSuspenseQuery } from "@tanstack/react-query";

export function NewCustomersThisMonth() {
  const trpc = useTRPC();
  const { data } = useSuspenseQuery(
    trpc.invoice.newCustomersCount.queryOptions(),
  );

  return (
    <Card className="hidden sm:block">
      <CardHeader className="pb-3">
        <CardTitle className="font-mono font-medium text-2xl">
          <NumberFlow value={data} willChange />
        </CardTitle>
      </CardHeader>

      <CardContent className="pb-[34px]">
        <div className="flex flex-col gap-2">
          <div>New Customers</div>
          <div className="text-sm text-muted-foreground">
            Added past 30 days
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/note.tsx">
import { Textarea } from "@midday/ui/textarea";
import { useEffect, useState } from "react";
import { useDebounceValue } from "usehooks-ts";

type Props = {
  defaultValue: string;
  onChange: (value: string | null) => void;
};

export function Note({ defaultValue, onChange }: Props) {
  const [value, setValue] = useState(defaultValue);
  const [debouncedValue] = useDebounceValue(value, 500);

  useEffect(() => {
    if (debouncedValue !== defaultValue) {
      onChange(debouncedValue?.length > 0 ? debouncedValue : null);
    }
  }, [debouncedValue, defaultValue, onChange]);

  return (
    <Textarea
      defaultValue={defaultValue}
      required
      autoFocus
      placeholder="Note"
      className="min-h-[100px] resize-none"
      onChange={(evt) => setValue(evt.target.value)}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/notification-setting.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { Checkbox } from "@midday/ui/checkbox";
import { Label } from "@midday/ui/label";
import { useMutation, useQueryClient } from "@tanstack/react-query";

type Props = {
  type: string;
  name: string;
  description: string;
  settings: {
    channel: "in_app" | "email" | "push";
    enabled: boolean;
  }[];
};

export function NotificationSetting({
  type,
  name,
  description,
  settings,
}: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const updateSetting = useMutation(
    trpc.notificationSettings.update.mutationOptions({
      onMutate: async (variables) => {
        // Cancel any outgoing refetches (so they don't overwrite our optimistic update)
        await queryClient.cancelQueries({
          queryKey: trpc.notificationSettings.getAll.queryKey(),
        });

        // Snapshot the previous value
        const previousData = queryClient.getQueryData(
          trpc.notificationSettings.getAll.queryKey(),
        );

        // Optimistically update the cache
        queryClient.setQueryData(
          trpc.notificationSettings.getAll.queryKey(),
          (old) => {
            if (!old) return old;

            return old.map((notificationType) => {
              if (notificationType.type !== variables.notificationType) {
                return notificationType;
              }

              return {
                ...notificationType,
                settings: notificationType.settings.map((setting) => {
                  if (setting.channel !== variables.channel) {
                    return setting;
                  }
                  return {
                    ...setting,
                    enabled: variables.enabled,
                  };
                }),
              };
            });
          },
        );

        // Return a context object with the snapshotted value
        return { previousData };
      },
      onError: (_, __, context) => {
        // If the mutation fails, use the context returned from onMutate to roll back
        if (context?.previousData) {
          queryClient.setQueryData(
            trpc.notificationSettings.getAll.queryKey(),
            context.previousData,
          );
        }
      },
      onSettled: () => {
        // Always refetch after error or success to ensure we have the latest data
        queryClient.invalidateQueries({
          queryKey: trpc.notificationSettings.getAll.queryKey(),
        });
      },
    }),
  );

  const onChange = (
    channel: "in_app" | "email" | "push",
    newEnabled: boolean,
  ) => {
    updateSetting.mutate({
      notificationType: type,
      channel,
      enabled: newEnabled,
    });
  };

  const getSettingByChannel = (channel: "in_app" | "email" | "push") => {
    return settings.find((s) => s.channel === channel);
  };

  return (
    <div className="border-b-[1px] pb-4 mb-4">
      <div className="flex items-start justify-between">
        {/* Left side - Name and Description */}
        <div className="flex-1 pr-8">
          <Label className="text-sm font-medium">{name}</Label>
          <p className="text-sm text-[#606060] mt-1">{description}</p>
        </div>

        <div className="flex gap-8 items-center">
          {/* In-App Checkbox */}
          {getSettingByChannel("in_app") && (
            <div className="flex flex-col items-center space-y-2">
              <Label className="text-xs font-medium text-[#606060]">
                In-app
              </Label>
              <Checkbox
                id={`${type}-in_app`}
                checked={getSettingByChannel("in_app")?.enabled ?? false}
                onCheckedChange={(checked) => onChange("in_app", !!checked)}
              />
            </div>
          )}

          {getSettingByChannel("email") && (
            <div className="flex flex-col items-center space-y-2">
              <Label className="text-xs font-medium text-[#606060]">
                Email
              </Label>
              <Checkbox
                id={`${type}-email`}
                checked={getSettingByChannel("email")?.enabled ?? false}
                onCheckedChange={(checked) => onChange("email", !!checked)}
              />
            </div>
          )}

          {getSettingByChannel("push") && (
            <div className="flex flex-col items-center space-y-2">
              <Label className="text-xs font-medium text-[#606060]">Push</Label>
              <Checkbox
                id={`${type}-push`}
                checked={getSettingByChannel("push")?.enabled ?? false}
                onCheckedChange={(checked) => onChange("push", !!checked)}
              />
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/notification-settings.tsx">
"use client";

import { useI18n } from "@/locales/client";
import { useTRPC } from "@/trpc/client";
import {
  getCategoryDisplayTitle,
  getNotificationDisplayInfoWithFallback,
} from "@/utils/notification-definitions";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { Skeleton } from "@midday/ui/skeleton";
import { useQuery } from "@tanstack/react-query";
import { ChevronDown } from "lucide-react";
import { NotificationSetting } from "./notification-setting";

export function NotificationSettingsSkeleton() {
  return (
    <div className="space-y-6">
      {[...Array(3)].map((_, categoryIndex) => (
        <div key={categoryIndex.toString()} className="border-b border-border">
          {/* Category header skeleton - closed accordion */}
          <div className="flex flex-1 items-center justify-between py-4">
            <Skeleton className="h-5 w-24" />
            <ChevronDown className="h-4 w-4 shrink-0 text-muted-foreground" />
          </div>
        </div>
      ))}
    </div>
  );
}

export function NotificationSettings() {
  const t = useI18n();
  const trpc = useTRPC();

  const { data: notificationTypes, isLoading } = useQuery(
    trpc.notificationSettings.getAll.queryOptions(),
  );

  if (isLoading) {
    return <NotificationSettingsSkeleton />;
  }

  // Group notifications by category
  const groupedNotifications = notificationTypes?.reduce(
    (acc, notificationType) => {
      // Include all channel settings (in_app, email, push)
      const filteredSettings = notificationType.settings.filter(
        (
          setting,
        ): setting is {
          channel: "in_app" | "email" | "push";
          enabled: boolean;
        } =>
          setting.channel === "in_app" ||
          setting.channel === "email" ||
          setting.channel === "push",
      );

      // Skip if no settings remain after filtering
      if (filteredSettings.length === 0) return acc;

      const category = notificationType.category || "other";
      const order = notificationType.order || 999;

      if (!acc[category]) {
        acc[category] = {
          category,
          order,
          notifications: [],
        };
      }

      // Get display info from i18n translations
      const displayInfo = getNotificationDisplayInfoWithFallback(
        notificationType.type,
        t,
      );

      acc[category].notifications.push({
        type: notificationType.type,
        name: displayInfo.name,
        description: displayInfo.description,
        settings: filteredSettings,
      });

      return acc;
    },
    {} as Record<
      string,
      {
        category: string;
        order: number;
        notifications: Array<{
          type: string;
          name: string;
          description: string;
          settings: Array<{
            channel: "in_app" | "email" | "push";
            enabled: boolean;
          }>;
        }>;
      }
    >,
  );

  // Sort categories by order, then by name
  const sortedCategories = Object.values(groupedNotifications || {}).sort(
    (a, b) => {
      if (a.order !== b.order) {
        return a.order - b.order;
      }
      return a.category.localeCompare(b.category);
    },
  );

  return (
    <div className="space-y-6">
      <Accordion type="multiple" className="w-full">
        {sortedCategories.map((categoryGroup) => (
          <AccordionItem
            key={categoryGroup.category}
            value={categoryGroup.category}
          >
            <AccordionTrigger className="text-base">
              {getCategoryDisplayTitle(categoryGroup.category, t)}
            </AccordionTrigger>
            <AccordionContent>
              <div className="space-y-4 pt-2">
                {categoryGroup.notifications.map((notification) => (
                  <NotificationSetting
                    key={notification.type}
                    type={notification.type}
                    name={notification.name}
                    description={notification.description}
                    settings={notification.settings}
                  />
                ))}
              </div>
            </AccordionContent>
          </AccordionItem>
        ))}
      </Accordion>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/notifications-settings-list.tsx">
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { ErrorBoundary } from "next/dist/client/components/error-boundary";
import { Suspense } from "react";
import { ErrorFallback } from "./error-fallback";
import {
  NotificationSettings,
  NotificationSettingsSkeleton,
} from "./notification-settings";

export async function NotificationsSettingsList() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Notifications</CardTitle>
        <CardDescription>
          Manage your personal notification settings for this team.
        </CardDescription>
      </CardHeader>

      <CardContent>
        <ErrorBoundary errorComponent={ErrorFallback}>
          <Suspense fallback={<NotificationSettingsSkeleton />}>
            <NotificationSettings />
          </Suspense>
        </ErrorBoundary>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/oauth-application-status-badge.tsx">
import { cn } from "@midday/ui/cn";

type OAuthApplicationStatus =
  | "approved"
  | "rejected"
  | "pending"
  | "draft"
  | null;

type Props = {
  status: OAuthApplicationStatus;
  className?: string;
};

export function OAuthApplicationStatusBadge({ status, className }: Props) {
  const getStatusColor = (status: OAuthApplicationStatus) => {
    switch (status) {
      case "approved":
        return "dark:bg-green-900 dark:text-green-300 text-green-600 bg-green-100";
      case "rejected":
        return "bg-red-100 text-red-700 dark:bg-red-900/20 dark:text-red-400";
      case "pending":
        return "bg-amber-100 text-amber-700 dark:bg-amber-900/20 dark:text-amber-400";
      case "draft":
        return "text-[#878787] bg-[#F2F1EF] text-[10px] dark:bg-[#1D1D1D]";
      default:
        return "text-[#878787] bg-[#F2F1EF] text-[10px] dark:bg-[#1D1D1D]";
    }
  };

  return (
    <div
      className={cn(
        "text-[10px] px-3 py-1 rounded-full font-mono capitalize",
        getStatusColor(status),
        className,
      )}
    >
      {status === "pending" ? "Reviewing" : status}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/open-customer-sheet.tsx">
"use client";

import { useCustomerParams } from "@/hooks/use-customer-params";
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";

export function OpenCustomerSheet() {
  const { setParams } = useCustomerParams();

  return (
    <div>
      <Button
        variant="outline"
        size="icon"
        onClick={() => setParams({ createCustomer: true })}
      >
        <Icons.Add />
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/open-invoice-sheet.tsx">
"use client";

import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";

export function OpenInvoiceSheet() {
  const { setParams } = useInvoiceParams();

  return (
    <div>
      <Button
        variant="outline"
        size="icon"
        onClick={() => setParams({ type: "create" })}
      >
        <Icons.Add />
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/open-tracker-sheet.tsx">
"use client";

import { useTrackerParams } from "@/hooks/use-tracker-params";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";

export function OpenTrackerSheet() {
  const { setParams } = useTrackerParams();

  return (
    <div>
      <Button
        variant="outline"
        size="icon"
        onClick={() => setParams({ create: true })}
      >
        <Icons.Add />
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/open-url.tsx">
"use client";

import { openUrl } from "@midday/desktop-client/core";
import { isDesktopApp } from "@midday/desktop-client/platform";
import { cn } from "@midday/ui/cn";

export function OpenURL({
  href,
  children,
  className,
}: { href: string; children: React.ReactNode; className?: string }) {
  const handleOnClick = () => {
    if (isDesktopApp()) {
      openUrl(href);
    } else {
      window.open(href, "_blank");
    }
  };

  return (
    <span onClick={handleOnClick} className={cn("cursor-pointer", className)}>
      {children}
    </span>
  );
}
</file>

<file path="apps/dashboard/src/components/order-status.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { Skeleton } from "@midday/ui/skeleton";

export function OrderStatus({
  status,
  isLoading,
  className,
}: {
  status?: string;
  isLoading?: boolean;
  className?: string;
}) {
  if (isLoading) {
    return <Skeleton className="w-24 h-6 rounded-full" />;
  }

  if (!status) {
    return null;
  }

  return (
    <div
      className={cn(
        "px-2 py-0.5 rounded-full cursor-default font-mono inline-flex max-w-full text-[11px]",
        status === "paid" &&
          "text-[#00C969] bg-[#DDF1E4] dark:text-[#00C969] dark:bg-[#00C969]/10",
        status === "pending" &&
          "bg-[#FFD02B]/10 text-[#FFD02B] dark:bg-[#FFD02B]/10 dark:text-[#FFD02B]",
        (status === "cancelled" || status === "canceled") &&
          "text-[#878787] bg-[#F2F1EF] text-[10px] dark:text-[#878787] dark:bg-[#1D1D1D]",
        status === "failed" &&
          "text-[#1D1D1D] bg-[#878787]/10 dark:text-[#F5F5F3] dark:bg-[#F5F5F3]/10",
        className,
      )}
    >
      <span className="line-clamp-1 truncate inline-block capitalize">
        {status}
      </span>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/orders.tsx">
import { Suspense } from "react";
import { OrdersDataTable, OrdersSkeleton } from "./tables/orders";

export function Orders() {
  return (
    <div>
      <h2 className="text-lg font-medium leading-none tracking-tight mb-4">
        Orders
      </h2>

      <Suspense fallback={<OrdersSkeleton />}>
        <OrdersDataTable />
      </Suspense>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/otp-sign-in.tsx">
"use client";

import { verifyOtpAction } from "@/actions/verify-otp-action";
import { zodResolver } from "@hookform/resolvers/zod";
import { createClient } from "@midday/supabase/client";
import { cn } from "@midday/ui/cn";
import { Form, FormControl, FormField, FormItem } from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { InputOTP, InputOTPGroup, InputOTPSlot } from "@midday/ui/input-otp";
import { Spinner } from "@midday/ui/spinner";
import { SubmitButton } from "@midday/ui/submit-button";
import { useAction } from "next-safe-action/hooks";
import { useSearchParams } from "next/navigation";
import { useState } from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";

const formSchema = z.object({
  email: z.string().email(),
});

type Props = {
  className?: string;
};

export function OTPSignIn({ className }: Props) {
  const verifyOtp = useAction(verifyOtpAction);
  const [isLoading, setLoading] = useState(false);
  const [isSent, setSent] = useState(false);
  const [isVerifying, setIsVerifying] = useState(false);
  const [email, setEmail] = useState<string>();
  const supabase = createClient();
  const searchParams = useSearchParams();

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: "",
    },
  });

  async function onSubmit({ email }: z.infer<typeof formSchema>) {
    setLoading(true);

    setEmail(email);

    await supabase.auth.signInWithOtp({ email });

    setSent(true);
    setLoading(false);
  }

  async function onComplete(token: string) {
    if (!email) return;

    setIsVerifying(true);

    verifyOtp.execute({
      token,
      email,
      redirectTo: `${window.location.origin}/${searchParams.get("return_to") || ""}`,
    });
  }

  if (isSent) {
    return (
      <div className={cn("flex flex-col space-y-4 items-center", className)}>
        <div className="h-[62px] w-full flex items-center justify-center">
          {verifyOtp.isExecuting || isVerifying ? (
            <div className="flex items-center justify-center h-full bg-background/95 border border-input w-full">
              <div className="flex items-center space-x-2 bg-background px-4 py-2 rounded-md shadow-sm">
                <Spinner size={16} className="text-primary" />
                <span className="text-sm text-foreground font-medium">
                  Verifying...
                </span>
              </div>
            </div>
          ) : (
            <InputOTP
              maxLength={6}
              autoFocus
              onComplete={onComplete}
              disabled={verifyOtp.isExecuting || isVerifying}
              render={({ slots }) => (
                <InputOTPGroup>
                  {slots.map((slot, index) => (
                    <InputOTPSlot
                      key={index.toString()}
                      {...slot}
                      className="w-[62px] h-[62px]"
                    />
                  ))}
                </InputOTPGroup>
              )}
            />
          )}
        </div>

        <div className="flex space-x-2">
          <span className="text-sm text-[#878787]">
            Didn't receive the email?
          </span>
          <button
            onClick={() => setSent(false)}
            type="button"
            className="text-sm text-primary underline font-medium"
            disabled={verifyOtp.isExecuting || isVerifying}
          >
            Resend code
          </button>
        </div>
      </div>
    );
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <div className={cn("flex flex-col space-y-4", className)}>
          <FormField
            control={form.control}
            name="email"
            render={({ field }) => (
              <FormItem>
                <FormControl>
                  <Input
                    placeholder="Enter email address"
                    {...field}
                    autoCapitalize="false"
                    autoCorrect="false"
                    spellCheck="false"
                  />
                </FormControl>
              </FormItem>
            )}
          />

          <SubmitButton
            type="submit"
            className="bg-primary px-6 py-4 text-secondary font-medium flex space-x-2 h-[40px] w-full"
            isSubmitting={isLoading}
          >
            Continue
          </SubmitButton>
        </div>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/payment-score-visualizer.tsx">
"use client";

import { motion } from "framer-motion";

interface PaymentScoreVisualizerProps {
  score: number;
  paymentStatus: string;
}

export function PaymentScoreVisualizer({
  score,
  paymentStatus,
}: PaymentScoreVisualizerProps) {
  return (
    <div className="flex items-end gap-[6px]">
      {[...Array(10)].map((_, index) => {
        let color: string;

        switch (paymentStatus) {
          case "good":
            color = "bg-green-500";
            break;
          case "average":
            color = "bg-primary";
            break;
          case "bad":
            color = "bg-red-500";
            break;
          default:
            color = "bg-primary";
        }
        return (
          <div className="relative" key={index.toString()}>
            <motion.div
              className={`w-1 ${color} relative z-10`}
              initial={{
                scaleY: 0,
                height: index >= 8 ? "31px" : "27px",
                y: index >= 8 ? -4 : 0,
              }}
              animate={{
                scaleY: 1,
                height: "27px",
                y: 0,
                opacity: index < score ? 1 : 0.3,
              }}
              transition={{
                duration: 0.15,
                delay: index * 0.02,
                scaleY: { duration: 0.15, delay: index * 0.02 },
                height: { duration: 0.1, delay: 0.15 + index * 0.02 },
                y: { duration: 0.1, delay: 0.15 + index * 0.02 },
                opacity: { duration: 0.1, delay: 0.15 + index * 0.02 },
              }}
              style={{ originY: 1 }}
            />
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/pdf-viewer.tsx">
"use client";

import { useState } from "react";
import { Document, Page, PasswordResponses, pdfjs } from "react-pdf";
import "react-pdf/dist/Page/TextLayer.css";
import { Alert, AlertDescription } from "@midday/ui/alert";
import { cn } from "@midday/ui/cn";
import { Input } from "@midday/ui/input";
import { ScrollArea } from "@midday/ui/scroll-area";
import { Skeleton } from "@midday/ui/skeleton";

pdfjs.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.mjs`;

interface PdfViewerProps {
  url: string;
  maxWidth?: number;
}

export function PdfViewer({ url, maxWidth }: PdfViewerProps) {
  const [numPages, setNumPages] = useState<number>();
  const [isPasswordProtected, setIsPasswordProtected] = useState(false);
  const [passwordCancelled, setPasswordCancelled] = useState(false);
  const [password, setPassword] = useState("");
  const [passwordError, setPasswordError] = useState("");
  const [isSubmittingPassword, setIsSubmittingPassword] = useState(false);
  const [submittedPassword, setSubmittedPassword] = useState<string | null>(
    null,
  );
  const [pendingCallback, setPendingCallback] = useState<
    ((password: string | null) => void) | null
  >(null);

  function onDocumentLoadSuccess({ numPages }: { numPages: number }): void {
    setNumPages(numPages);
    setIsPasswordProtected(false);
    setPasswordCancelled(false);
    setPassword("");
    setPasswordError("");
    setIsSubmittingPassword(false);
    setSubmittedPassword(null);
    setPendingCallback(null);
  }

  function onDocumentLoadError(error: Error): void {
    // Check if it's a password-related error
    const errorMessage = error.message.toLowerCase();
    if (
      errorMessage.includes("password") ||
      errorMessage.includes("encrypted")
    ) {
      setIsPasswordProtected(true);
    }
  }

  function onPassword(
    callback: (password: string | null) => void,
    reason: number,
  ): void {
    switch (reason) {
      case PasswordResponses.NEED_PASSWORD: {
        // If we already submitted a password, use it immediately
        if (submittedPassword) {
          callback(submittedPassword);
          return;
        }

        // First time asking for password - show the form
        setPendingCallback(() => callback);
        setIsPasswordProtected(true);
        setPasswordError("");
        break;
      }
      case PasswordResponses.INCORRECT_PASSWORD: {
        setPendingCallback(() => callback);
        setPasswordError("Invalid password. Please try again.");
        setIsSubmittingPassword(false);
        setIsPasswordProtected(true);
        setSubmittedPassword(null); // Clear the submitted password
        break;
      }
      default:
        callback(null);
    }
  }

  function handlePasswordSubmit() {
    if (pendingCallback && password.trim()) {
      setIsSubmittingPassword(true);
      setPasswordError("");
      setIsPasswordProtected(false); // Hide the password form while loading
      setSubmittedPassword(password); // Store the password for potential reuse
      pendingCallback(password);
    }
  }

  function handlePasswordCancel() {
    if (pendingCallback) {
      pendingCallback(null);
      setPasswordCancelled(true);
    }
    setPassword("");
    setPasswordError("");
  }

  // Show password protection message if PDF is password protected and user cancelled
  if (isPasswordProtected && passwordCancelled) {
    return (
      <div className="flex flex-col w-full h-full overflow-hidden items-center justify-center p-8">
        <Alert className="max-w-md">
          <AlertDescription>
            This PDF is password protected and cannot be viewed without the
            correct password.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  return (
    <div
      className={cn(
        "flex flex-col w-full h-full overflow-hidden",
        numPages && "bg-white",
      )}
    >
      <ScrollArea className="w-full flex-1">
        {isPasswordProtected && !isSubmittingPassword ? (
          <div className="absolute inset-0 flex items-center justify-center p-8">
            <div className="max-w-md w-full space-y-6 text-center">
              <div className="space-y-1">
                <h3 className="text-[#878787]">
                  This document is password protected.
                </h3>
                <p className="text-xs text-[#878787]">
                  Please enter the password below.
                </p>
              </div>
              <div className="space-y-2">
                <form
                  onSubmit={(e) => {
                    e.preventDefault();
                    handlePasswordSubmit();
                  }}
                  autoComplete="off"
                  data-lpignore="true"
                  data-1p-ignore="true"
                >
                  <Input
                    type="password"
                    placeholder="Enter password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === "Enter" && password.trim()) {
                        handlePasswordSubmit();
                      }
                    }}
                    disabled={isSubmittingPassword}
                    autoComplete="one-time-code"
                    data-form-type="other"
                    data-lpignore="true"
                    data-1p-ignore="true"
                    data-bitwarden-watching="false"
                    name="document-unlock-password"
                    className="text-center bg-transparent focus:ring-0 focus:outline-none"
                  />
                </form>
                {passwordError && (
                  <p className="text-sm text-red-500">{passwordError}</p>
                )}
              </div>
            </div>
          </div>
        ) : (
          <Document
            key={`${url}_${isPasswordProtected}`}
            file={url}
            onLoadSuccess={onDocumentLoadSuccess}
            onLoadError={onDocumentLoadError}
            onPassword={onPassword}
            loading={
              <Skeleton className="w-full h-[calc(100vh-theme(spacing.24))]" />
            }
            error={
              <div className="flex flex-col items-center justify-center p-8 text-center">
                <p className="text-sm text-muted-foreground">
                  Failed to load PDF. The file may be corrupted or unsupported.
                </p>
              </div>
            }
          >
            {numPages &&
              Array.from(new Array(numPages), (_, index) => (
                <Page
                  width={maxWidth}
                  key={`${url}_${index + 1}`}
                  pageNumber={index + 1}
                  renderAnnotationLayer={false}
                  renderTextLayer={true}
                />
              ))}
          </Document>
        )}
      </ScrollArea>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/plans.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { isDesktopApp } from "@midday/desktop-client/platform";
import { cn } from "@midday/ui/cn";
import { SubmitButton } from "@midday/ui/submit-button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useQuery } from "@tanstack/react-query";
import { Check } from "lucide-react";
import Link from "next/link";
import { useState } from "react";

export function Plans() {
  const isDesktop = isDesktopApp();
  const [isSubmitting, setIsSubmitting] = useState(0);
  const trpc = useTRPC();

  const { data: user } = useUserQuery();
  const { data, isLoading } = useQuery(trpc.team.availablePlans.queryOptions());

  return (
    <TooltipProvider delayDuration={0}>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-7 w-full">
        {/* Starter Plan */}
        <div className="flex flex-col p-6 border bg-background">
          <h2 className="text-xl mb-2 text-left">Starter</h2>
          <div className="mt-1 flex items-baseline">
            <span className="text-2xl font-medium tracking-tight">$29</span>
            <span className="ml-1 text-xl font-medium">/mo</span>
            <span className="ml-2 text-xs text-muted-foreground">
              Excl. VAT
            </span>
          </div>

          <div className="mt-4">
            <h3 className="text-xs font-medium uppercase tracking-wide text-left text-[#878787] font-mono">
              INCLUDING
            </h3>
            <ul className="mt-4 space-y-2">
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">
                  Send up to 10 invoices per month
                </span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">2 connected banks</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">Unlimited bank accounts</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">Financial overview</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">Time Tracker</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">50 inbox items per month</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">Customer management</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">Export CSV & reports</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">Assistant</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">10GB Vault Storage</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">2 users</span>
              </li>
            </ul>
          </div>

          <div className="mt-8 border-t-[1px] border-border pt-4">
            <Tooltip>
              <TooltipTrigger asChild>
                <Link
                  prefetch={false}
                  href={`/api/checkout?plan=starter&teamId=${user?.team?.id}&isDesktop=${isDesktop}&planType=starter`}
                  className={cn(!data?.starter && "opacity-50 cursor-default")}
                  onClick={(evt) => {
                    if (!data?.starter) {
                      evt.preventDefault();
                      return;
                    }

                    setIsSubmitting(1);
                  }}
                >
                  <SubmitButton
                    variant="secondary"
                    className={cn(
                      "h-9 hover:bg-primary hover:text-secondary",
                      !isLoading && !data?.starter && "pointer-events-none",
                    )}
                    isSubmitting={isSubmitting === 1}
                  >
                    Choose starter plan
                  </SubmitButton>
                </Link>
              </TooltipTrigger>
              {!isLoading && !data?.starter && (
                <TooltipContent className="text-xs max-w-[300px]">
                  <p>
                    This plan is not applicable since you have exceeded the
                    limits for this subscription (users or bank connections).
                  </p>
                </TooltipContent>
              )}
            </Tooltip>
          </div>
        </div>

        {/* Pro Plan */}
        <div className="flex flex-col p-6 border border-primary bg-background relative">
          <div className="absolute top-6 right-6 rounded-full text-[#878787] text-[9px] font-normal border px-2 py-1 font-mono">
            Limited offer
          </div>
          <h2 className="text-xl text-left mb-2">Pro</h2>
          <div className="mt-1 flex items-baseline">
            <span
              className={cn(
                "text-2xl font-medium tracking-tight",
                "line-through text-[#878787]",
              )}
            >
              $99
            </span>
            <span className="ml-1 text-2xl font-medium tracking-tight">
              $49
            </span>

            <span className="ml-1 text-xl font-medium">/mo</span>
            <span className="ml-2 text-xs text-muted-foreground">
              Excl. VAT
            </span>
          </div>

          <div className="mt-4">
            <h3 className="text-xs font-medium uppercase tracking-wide text-left text-[#878787] font-mono">
              INCLUDING
            </h3>
            <ul className="mt-4 space-y-2">
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">
                  Send up to 50 invoices per month
                </span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">10 connected banks</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">Unlimited bank accounts</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">Financial overview</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">Time Tracker</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">500 inbox items per month</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">Customer management</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">Export CSV & reports</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">Assistant</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">100GB Vault Storage</span>
              </li>
              <li className="flex items-start">
                <Check className="h-4 w-4 text-primary flex-shrink-0 mr-2" />
                <span className="text-xs">10 users</span>
              </li>
            </ul>
          </div>

          <div className="mt-8 border-t border-border pt-4">
            <Link
              prefetch={false}
              href={`/api/checkout?plan=pro&teamId=${user?.team?.id}&isDesktop=${isDesktop}&planType=pro`}
            >
              <SubmitButton
                className="h-9"
                onClick={() => setIsSubmitting(2)}
                isSubmitting={isSubmitting === 2}
              >
                Choose pro plan
              </SubmitButton>
            </Link>
          </div>
        </div>
      </div>
    </TooltipProvider>
  );
}
</file>

<file path="apps/dashboard/src/components/project-members.tsx">
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";

interface ProjectMembersProps {
  members: RouterOutputs["trackerProjects"]["get"]["data"][number]["users"];
}

export function ProjectMembers({ members }: ProjectMembersProps) {
  return (
    <div className="flex space-x-2">
      {members?.map((member) => (
        <div key={member.id} className="relative">
          <Avatar className="rounded-full w-5 h-5">
            <AvatarImageNext
              src={member?.avatarUrl ?? ""}
              alt={member?.fullName ?? ""}
              width={20}
              height={20}
            />
            <AvatarFallback>
              <span className="text-xs">
                {member?.fullName?.charAt(0)?.toUpperCase()}
              </span>
            </AvatarFallback>
          </Avatar>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/reconnect-provider.tsx">
import { createPlaidLinkTokenAction } from "@/actions/institutions/create-plaid-link";
import { reconnectEnableBankingLinkAction } from "@/actions/institutions/reconnect-enablebanking-link";
import { reconnectGoCardLessLinkAction } from "@/actions/institutions/reconnect-gocardless-link";
import { getUrl } from "@/utils/environment";
import { isDesktopApp } from "@midday/desktop-client/platform";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { Spinner } from "@midday/ui/spinner";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useToast } from "@midday/ui/use-toast";
import { useAction } from "next-safe-action/hooks";
import { useTheme } from "next-themes";
import { useEffect, useState } from "react";
import { usePlaidLink } from "react-plaid-link";
import { useScript } from "usehooks-ts";

type Props = {
  id: string;
  provider: string;
  enrollmentId: string | null;
  institutionId: string;
  referenceId?: string | null;
  accessToken: string | null;
  onManualSync: () => void;
  variant?: "button" | "icon";
};

export function ReconnectProvider({
  id,
  provider,
  enrollmentId,
  institutionId,
  referenceId,
  accessToken,
  onManualSync,
  variant,
}: Props) {
  const { toast } = useToast();
  const { theme } = useTheme();
  const [plaidToken, setPlaidToken] = useState<string | undefined>();
  const [isLoading, setIsLoading] = useState(false);

  const reconnectGoCardLessLink = useAction(reconnectGoCardLessLinkAction, {
    onExecute: () => {
      setIsLoading(true);
    },
    onError: () => {
      setIsLoading(false);

      toast({
        duration: 2500,
        variant: "error",
        title: "Something went wrong please try again.",
      });
    },
    onSuccess: () => {
      setIsLoading(false);
    },
  });

  const reconnectEnableBankingLink = useAction(
    reconnectEnableBankingLinkAction,
    {
      onExecute: () => {
        setIsLoading(true);
      },
      onError: () => {
        setIsLoading(false);

        toast({
          duration: 2500,
          variant: "error",
          title: "Something went wrong please try again.",
        });
      },
      onSuccess: () => {
        setIsLoading(false);
      },
    },
  );

  useScript("https://cdn.teller.io/connect/connect.js", {
    removeOnUnmount: false,
  });

  const { open: openPlaid } = usePlaidLink({
    token: plaidToken,
    publicKey: "",
    env: process.env.NEXT_PUBLIC_PLAID_ENVIRONMENT!,
    clientName: "Midday",
    product: ["transactions"],
    onSuccess: () => {
      setPlaidToken(undefined);
      onManualSync();
    },
    onExit: () => {
      setPlaidToken(undefined);
    },
  });

  const openTeller = () => {
    // @ts-expect-error
    const teller = window.TellerConnect.setup({
      applicationId: process.env.NEXT_PUBLIC_TELLER_APPLICATION_ID!,
      environment: process.env.NEXT_PUBLIC_TELLER_ENVIRONMENT,
      enrollmentId,
      appearance: theme,
      onSuccess: () => {
        onManualSync();
      },
      onFailure: () => {},
    });

    if (teller) {
      teller.open();
    }
  };

  useEffect(() => {
    if (plaidToken) {
      openPlaid();
    }
  }, [plaidToken, openPlaid]);

  const handleOnClick = async () => {
    switch (provider) {
      case "plaid": {
        const token = await createPlaidLinkTokenAction(
          accessToken ?? undefined,
        );

        if (token) {
          setPlaidToken(token);
        }

        return;
      }
      case "gocardless": {
        return reconnectGoCardLessLink.execute({
          id,
          institutionId,
          availableHistory: 60,
          redirectTo: `${getUrl()}/api/gocardless/reconnect`,
          isDesktop: isDesktopApp(),
        });
      }
      case "enablebanking": {
        return reconnectEnableBankingLink.execute({
          institutionId,
          isDesktop: isDesktopApp(),
          sessionId: referenceId!,
        });
      }
      case "teller":
        return openTeller();
      default:
        return;
    }
  };

  if (variant === "button") {
    return (
      <Button variant="outline" onClick={handleOnClick} disabled={isLoading}>
        {isLoading ? <Spinner className="size-3.5" /> : "Reconnect"}
      </Button>
    );
  }

  return (
    <TooltipProvider delayDuration={70}>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            variant="outline"
            size="icon"
            className="rounded-full w-7 h-7 flex items-center"
            onClick={handleOnClick}
            disabled={isLoading}
          >
            {isLoading ? (
              <Spinner className="size-3.5" />
            ) : (
              <Icons.Reconnect size={16} />
            )}
          </Button>
        </TooltipTrigger>

        <TooltipContent className="px-3 py-1.5 text-xs" sideOffset={10}>
          Reconnect
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}
</file>

<file path="apps/dashboard/src/components/remove-mfa-button.tsx">
"use client";

import { unenrollMfaAction } from "@/actions/unenroll-mfa-action";
import { Button } from "@midday/ui/button";
import { useToast } from "@midday/ui/use-toast";
import { useAction } from "next-safe-action/hooks";

type Props = {
  factorId: string;
};

export function RemoveMFAButton({ factorId }: Props) {
  const { toast } = useToast();

  const unenroll = useAction(unenrollMfaAction, {
    onError: () => {
      toast({
        duration: 3500,
        variant: "error",
        title: "Something went wrong please try again.",
      });
    },
  });

  return (
    <Button variant="outline" onClick={() => unenroll.execute({ factorId })}>
      Remove
    </Button>
  );
}
</file>

<file path="apps/dashboard/src/components/scope-selector.tsx">
"use client";

import { RESOURCES } from "@/utils/scopes";
import type { Scope } from "@api/utils/scopes";
import { FormDescription } from "@midday/ui/form";
import { RadioGroup, RadioGroupItem } from "@midday/ui/radio-group";
import { ScrollArea } from "@midday/ui/scroll-area";

type Props = {
  selectedScopes: Scope[];
  onResourceScopeChange: (resourceKey: string, scope: string) => void;
  description?: string;
  height?: string;
  errorMessage?: string;
};

export function ScopeSelector({
  selectedScopes,
  onResourceScopeChange,
  description = "Select which scopes this application can request access to.",
  height = "max-h-[300px]",
  errorMessage,
}: Props) {
  // Helper function to get the selected scope for a resource
  const getResourceScope = (resourceKey: string): string => {
    const resource = RESOURCES.find((r) => r.key === resourceKey);
    if (!resource) return "";

    // Find which scope from this resource is currently selected
    for (const scope of resource.scopes) {
      if (selectedScopes.includes(scope.scope as Scope)) {
        return scope.scope;
      }
    }
    return "";
  };

  return (
    <div className="space-y-4">
      <FormDescription>{description}</FormDescription>

      <ScrollArea className={`flex flex-col text-sm ${height}`}>
        {RESOURCES.map((resource) => (
          <div
            className="flex items-center justify-between py-4 border-b"
            key={resource.key}
          >
            <div className="flex items-center gap-1.5">
              <span className="text-sm font-medium text-[#878787]">
                {resource.name}
              </span>
            </div>
            <div>
              <RadioGroup
                value={getResourceScope(resource.key)}
                className="flex gap-4"
                onValueChange={(value) =>
                  onResourceScopeChange(resource.key, value)
                }
              >
                <div className="flex items-center space-x-2">
                  <RadioGroupItem value="" id={`${resource.key}-none`} />
                  <label htmlFor={`${resource.key}-none`} className="text-sm">
                    None
                  </label>
                </div>
                {resource.scopes.map((scope) => (
                  <div
                    className="flex items-center space-x-2"
                    key={scope.scope}
                  >
                    <RadioGroupItem
                      value={scope.scope}
                      id={`${resource.key}-${scope.type}`}
                    />
                    <label
                      htmlFor={`${resource.key}-${scope.type}`}
                      className="text-sm font-normal capitalize text-[#878787]"
                    >
                      {scope.label}
                    </label>
                  </div>
                ))}
              </RadioGroup>
            </div>
          </div>
        ))}
      </ScrollArea>

      {errorMessage && (
        <p className="text-sm font-medium text-destructive mt-2">
          {errorMessage}
        </p>
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/search-address-input.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import {
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
  Command as CommandPrimitive,
} from "@midday/ui/command";
import { useJsApiLoader } from "@react-google-maps/api";
import { Check } from "lucide-react";
import { useCallback, useEffect, useRef, useState } from "react";
import usePlacesAutoComplete, { getDetails } from "use-places-autocomplete";
import { useOnClickOutside } from "usehooks-ts";

type Libraries = Parameters<typeof useJsApiLoader>[0]["libraries"];
const libraries: Libraries = ["places"];

type Props = {
  id?: string;
  defaultValue?: string;
  onSelect: (addressDetails: AddressDetails) => void;
  placeholder?: string;
  disabled?: boolean;
  emptyMessage?: string;
};

export type AddressDetails = {
  address_line_1: string;
  city: string;
  state: string;
  zip: string;
  country: string;
  country_code: string;
};

type Option = {
  value: string;
  label: string;
};

const getAddressDetailsByAddressId = async (
  addressId: string,
): Promise<AddressDetails> => {
  const details = (await getDetails({
    placeId: addressId,
    fields: ["address_component"],
  })) as google.maps.places.PlaceResult;

  const comps = details.address_components;

  const streetNumber =
    comps?.find((c) => c.types.includes("street_number"))?.long_name ?? "";
  const streetAddress =
    comps?.find((c) => c.types.includes("route"))?.long_name ?? "";
  const city =
    comps?.find((c) => c.types.includes("postal_town"))?.long_name ||
    comps?.find((c) => c.types.includes("locality"))?.long_name ||
    comps?.find((c) => c.types.includes("sublocality_level_1"))?.long_name ||
    "";
  const state =
    comps?.find((c) => c.types.includes("administrative_area_level_1"))
      ?.short_name || "";
  const zip =
    comps?.find((c) => c.types.includes("postal_code"))?.long_name || "";
  const country =
    comps?.find((c) => c.types.includes("country"))?.long_name || "";
  const countryCode =
    comps?.find((c) => c.types.includes("country"))?.short_name || "";

  return {
    address_line_1: `${streetNumber} ${streetAddress}`.trim(),
    city,
    state,
    zip,
    country,
    country_code: countryCode,
  };
};

export function SearchAddressInput({
  onSelect,
  placeholder,
  defaultValue,
  disabled = false,
  emptyMessage = "No results found.",
}: Props) {
  const inputRef = useRef<HTMLInputElement>(null);
  const ref = useRef<HTMLDivElement>(null);
  const [isOpen, setOpen] = useState(false);
  const [selected, setSelected] = useState<Option | null>(null);
  const [inputValue, setInputValue] = useState<string>(defaultValue || "");

  const { isLoaded } = useJsApiLoader({
    googleMapsApiKey: process.env.NEXT_PUBLIC_GOOGLE_API_KEY as string,
    libraries,
  });

  const {
    ready,
    suggestions: { status, data },
    setValue,
  } = usePlacesAutoComplete({
    initOnMount: isLoaded,
    debounce: 300,
    requestOptions: {
      language: "en",
    },
  });

  useEffect(() => {
    if (defaultValue) {
      setValue(defaultValue, false);
      setInputValue(defaultValue);
    }
  }, [defaultValue, setValue]);

  const options: Option[] = data.map((item) => ({
    value: item.place_id,
    label: item.description,
  }));

  const handleKeyDown = useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      const input = inputRef.current;

      if (!input) {
        return;
      }

      if (!isOpen) {
        setOpen(true);
      }

      if (event.key === "Enter" && input.value !== "") {
        const optionToSelect = options.find(
          (option) => option.label === input.value,
        );
        if (optionToSelect) {
          setSelected(optionToSelect);
          handleSelect(optionToSelect);
        }
      }

      if (event.key === "Escape") {
        input.blur();
      }
    },
    [isOpen, options],
  );

  const handleBlur = useCallback(() => {
    setInputValue(selected?.label || "");
  }, [selected]);

  const handleSelectOption = useCallback(
    (selectedOption: Option) => {
      setInputValue(selectedOption.label);
      setSelected(selectedOption);
      handleSelect(selectedOption);
      setOpen(false);

      setTimeout(() => {
        inputRef?.current?.blur();
      }, 0);
    },
    [onSelect],
  );

  const handleSelect = async (address: Option) => {
    setValue(address.label, false);
    const addressDetails = await getAddressDetailsByAddressId(address.value);

    onSelect(addressDetails);
  };

  // @ts-expect-error
  useOnClickOutside(ref, () => {
    setOpen(false);
  });

  return (
    <div ref={ref} className="relative">
      <CommandPrimitive onKeyDown={handleKeyDown}>
        <div className="relative">
          <CommandInput
            ref={inputRef}
            value={inputValue}
            onValueChange={(value) => {
              setInputValue(value);
              setValue(value);
              setOpen(true);
            }}
            onBlur={handleBlur}
            onFocus={() => setOpen(true)}
            placeholder={placeholder}
            disabled={disabled || !ready}
            className="border border-border px-3 py-1 text-sm h-9"
            autoComplete="off"
          />
        </div>

        {isOpen && (
          <CommandList className="absolute top-full left-0 right-0 z-10 mt-1 bg-background">
            {options.length > 0 ? (
              <CommandGroup className="border border-border max-h-[165px] overflow-auto">
                {options.map((option) => {
                  const isSelected = selected?.value === option.value;

                  return (
                    <CommandItem
                      key={option.value}
                      value={option.label}
                      onMouseDown={(event) => {
                        event.preventDefault();
                        event.stopPropagation();
                      }}
                      onSelect={() => handleSelectOption(option)}
                      className={cn(
                        "flex w-full items-center gap-2",
                        !isSelected ? "pl-8" : null,
                      )}
                    >
                      {option.label}
                      {isSelected ? <Check className="w-4" /> : null}
                    </CommandItem>
                  );
                })}
              </CommandGroup>
            ) : null}
            {inputValue &&
            options.length === 0 &&
            !selected &&
            status === "ZERO_RESULTS" ? (
              <CommandEmpty className="select-none px-2 py-3 text-center text-sm">
                {emptyMessage}
              </CommandEmpty>
            ) : null}
          </CommandList>
        )}
      </CommandPrimitive>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/search-customers.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { ComboboxDropdown } from "@midday/ui/combobox-dropdown";
import { useQuery } from "@tanstack/react-query";

type Props = {
  onSelect: (id: string) => void;
  onCreate?: (name: string) => void;
  onEdit?: (id: string) => void;
  selectedId?: string;
};

export function SearchCustomers({
  onCreate,
  onSelect,
  onEdit,
  selectedId,
}: Props) {
  const trpc = useTRPC();

  const { data: customers } = useQuery(
    trpc.customers.get.queryOptions({
      pageSize: 100,
    }),
  );

  const formattedData = customers?.data?.map((customer) => ({
    id: customer.id,
    label: customer.name,
  }));

  const selectedItem = selectedId
    ? formattedData?.find((item) => item.id === selectedId)
    : undefined;

  return (
    <ComboboxDropdown
      placeholder="Select customer"
      searchPlaceholder="Search customer"
      className="text-xs"
      items={formattedData ?? []}
      onSelect={({ id }) => onSelect(id)}
      selectedItem={selectedItem}
      onCreate={(name) => {
        onCreate?.(name);
      }}
      renderListItem={(item) => {
        return (
          <div className="flex items-center justify-between w-full group">
            <span>{item.item.label}</span>
            <button
              type="button"
              onClick={() => onEdit?.(item.item.id)}
              className="text-xs opacity-0 group-hover:opacity-50 hover:opacity-100"
            >
              Edit
            </button>
          </div>
        );
      }}
      renderOnCreate={(name) => {
        return (
          <div className="flex items-center space-x-2">
            <button
              type="button"
              onClick={() => onCreate?.(name)}
            >{`Create "${name}"`}</button>
          </div>
        );
      }}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/search-field.tsx">
"use client";

import { Icons } from "@midday/ui/icons";
import { Input } from "@midday/ui/input";
import { useQueryState } from "nuqs";
import { useHotkeys } from "react-hotkeys-hook";

type Props = {
  placeholder: string;
  shallow?: boolean;
};

export function SearchField({ placeholder }: Props) {
  const [search, setSearch] = useQueryState("q");

  useHotkeys("esc", () => setSearch(null), {
    enableOnFormTags: true,
  });

  const handleSearch = (evt: React.ChangeEvent<HTMLInputElement>) => {
    const value = evt.target.value;

    if (value) {
      setSearch(value);
    } else {
      setSearch(null);
    }
  };

  return (
    <div className="w-full md:max-w-[380px] relative">
      <Icons.Search className="absolute pointer-events-none left-3 top-[11px]" />
      <Input
        placeholder={placeholder}
        className="pl-9 w-full"
        value={search ?? ""}
        onChange={handleSearch}
        autoComplete="off"
        autoCapitalize="none"
        autoCorrect="off"
        spellCheck="false"
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/secondary-menu.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import Link from "next/link";
import { usePathname } from "next/navigation";

type Item = {
  path: string;
  label: string;
};

type Props = {
  items: Item[];
};

export function SecondaryMenu({ items }: Props) {
  const pathname = usePathname();

  return (
    <nav className="py-4">
      <ul className="flex space-x-6 text-sm overflow-auto scrollbar-hide">
        {items.map((item) => (
          <Link
            prefetch
            key={item.path}
            href={item.path}
            className={cn(
              "text-[#606060]",
              pathname === item.path &&
                "text-primary font-medium underline underline-offset-8",
            )}
          >
            <span>{item.label}</span>
          </Link>
        ))}
      </ul>
    </nav>
  );
}
</file>

<file path="apps/dashboard/src/components/select-account.tsx">
import { useTRPC } from "@/trpc/client";
import { formatAccountName } from "@/utils/format";
import {
  ComboboxDropdown,
  type ComboboxItem,
} from "@midday/ui/combobox-dropdown";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useEffect, useState } from "react";
import { TransactionBankAccount } from "./transaction-bank-account";

type SelectedItem = ComboboxItem & {
  id: string;
  label: string;
  logo: string | null;
  currency: string | null;
  type?: string | null;
};

type Props = {
  placeholder: string;
  className?: string;
  value?: string;
  onChange: (value: SelectedItem) => void;
};

export function SelectAccount({ placeholder, onChange, value }: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const [selectedItem, setSelectedItem] = useState<SelectedItem | null>(null);

  const { data, isLoading } = useQuery(trpc.bankAccounts.get.queryOptions());

  const createBankAccountMutation = useMutation(
    trpc.bankAccounts.create.mutationOptions({
      onSuccess: (data) => {
        queryClient.invalidateQueries({
          queryKey: trpc.bankAccounts.get.queryKey(),
        });

        if (data) {
          onChange({
            id: data.id,
            label: data.name ?? "",
            logo: null,
            currency: null,
          });

          setSelectedItem({
            id: data.id,
            label: data.name ?? "",
            logo: null,
            currency: null,
          });
        }
      },
    }),
  );

  useEffect(() => {
    if (value && data) {
      const found = data.find((d) => d.id === value);

      if (found) {
        setSelectedItem({
          id: found.id,
          label: found.name ?? "",
          logo: found.bankConnection?.logoUrl ?? null,
          currency: found.currency ?? null,
        });
      }
    }
  }, [value, data]);

  if (isLoading) {
    return null;
  }

  return (
    <ComboboxDropdown
      disabled={createBankAccountMutation.isPending}
      placeholder={placeholder}
      searchPlaceholder="Select or create account"
      items={
        data?.map((d) => ({
          id: d.id,
          label: d.name ?? "",
          logo: d.bankConnection?.logoUrl ?? null,
          currency: d.currency ?? null,
        })) ?? []
      }
      selectedItem={selectedItem ?? undefined}
      onSelect={(item) => {
        onChange(item);
      }}
      onCreate={(name) => {
        createBankAccountMutation.mutate({ name, manual: true });
      }}
      renderSelectedItem={(selectedItem) => {
        return (
          <TransactionBankAccount
            name={formatAccountName({
              name: selectedItem.label,
              currency: selectedItem?.currency,
            })}
            logoUrl={selectedItem?.logo ?? undefined}
          />
        );
      }}
      renderOnCreate={(value) => {
        return (
          <div className="flex items-center space-x-2">
            <span>{`Create "${value}"`}</span>
          </div>
        );
      }}
      renderListItem={({ item }) => {
        return (
          <TransactionBankAccount
            name={formatAccountName({
              name: item.label,
              currency: item?.currency,
            })}
            logoUrl={item.logo ?? undefined}
          />
        );
      }}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/select-attachment.tsx">
import { useDocumentParams } from "@/hooks/use-document-params";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { formatDate } from "@/utils/format";
import { Badge } from "@midday/ui/badge";
import { Combobox } from "@midday/ui/combobox";
import { useQuery } from "@tanstack/react-query";
import { useState } from "react";
import { useDebounceValue } from "usehooks-ts";
import { FilePreview } from "./file-preview";
import { FormatAmount } from "./format-amount";

type Attachment = {
  id: string;
  name: string;
  data?: unknown;
};

type Props = {
  placeholder: string;
  onSelect: (file: Attachment) => void;
  transactionId?: string;
};

export function SelectAttachment({
  placeholder,
  onSelect,
  transactionId,
}: Props) {
  const [debouncedValue, setDebouncedValue] = useDebounceValue("", 200);
  const [isOpen, setIsOpen] = useState(false);
  const { data: user } = useUserQuery();
  const { setParams } = useDocumentParams();

  const trpc = useTRPC();

  // Always fetch suggestions/search results so they're ready when sheet opens
  const { data: items, isLoading } = useQuery({
    ...trpc.inbox.search.queryOptions({
      q: debouncedValue.length > 0 ? debouncedValue : undefined,
      transactionId: debouncedValue.length > 0 ? undefined : transactionId,
      limit: debouncedValue.length > 0 ? 30 : 3,
    }),
    enabled: Boolean(debouncedValue.length > 0 || transactionId), // Enable for search OR suggestions
  });

  const handleOnSelect = (item: Attachment) => {
    onSelect(item);
  };

  // Only create options if we have items and should show results
  const hasResults = items && items.length > 0;
  const shouldShowResults = isOpen && (Boolean(debouncedValue) || hasResults);

  const options = hasResults
    ? items.map((item, index) => ({
        id: item.id,
        name: item.displayName,
        data: item,
        component: () => {
          const filePath = `${item?.filePath?.join("/")}`;
          const isSmartSuggestion =
            debouncedValue.length === 0 && transactionId;
          const showBestMatch =
            isSmartSuggestion && index === 0 && items?.length > 1;

          return (
            <div className="flex w-full items-center justify-between gap-2 text-sm">
              <div className="flex gap-2 items-center">
                <div className="w-7 h-7 overflow-hidden">
                  <button
                    type="button"
                    onClick={(e) => {
                      e.stopPropagation();
                      setParams({ filePath });
                    }}
                  >
                    <FilePreview
                      mimeType={item.contentType!}
                      filePath={filePath}
                    />
                  </button>
                </div>
                <div className="flex flex-col">
                  <span className="truncate">
                    {item.displayName || item.fileName}
                  </span>
                  {item?.date && (
                    <span className="text-muted-foreground text-xs">
                      {formatDate(item.date, user?.dateFormat, true)}
                    </span>
                  )}
                </div>
              </div>

              <div className="flex flex-shrink-0 items-center gap-4">
                {showBestMatch && (
                  <Badge variant="outline" className="px-2 py-0">
                    Best Match
                  </Badge>
                )}
                {item?.amount && item?.currency && (
                  <FormatAmount amount={item.amount} currency={item.currency} />
                )}
              </div>
            </div>
          );
        },
      }))
    : [];

  const handleFocus = () => {
    if (!isOpen && !debouncedValue) {
      setIsOpen(true);
    }
  };

  return (
    <Combobox
      className="border border-border p-2 pl-10"
      placeholder={placeholder}
      onValueChange={(query) => {
        setDebouncedValue(query);
      }}
      onSelect={(value) => {
        if (value) {
          handleOnSelect(value);
        }
      }}
      options={options.map((opt) => ({
        ...opt,
        name: opt.name!,
      }))}
      isLoading={isLoading && Boolean(debouncedValue)} // Only show loading when actively searching
      classNameList="mt-2 max-h-[161px]"
      open={shouldShowResults} // Only open when we should show results
      onOpenChange={setIsOpen}
      onFocus={handleFocus}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/select-category.tsx">
import { useTRPC } from "@/trpc/client";
import { getColorFromName } from "@/utils/categories";
import { ComboboxDropdown } from "@midday/ui/combobox-dropdown";
import { Spinner } from "@midday/ui/spinner";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { CategoryColor } from "./category";

type Selected = {
  id: string;
  name: string;
  color?: string | null;
  slug: string;
  children?: Selected[];
};

type Props = {
  selected?: Selected;
  onChange: (selected: Selected) => void;
  headless?: boolean;
  hideLoading?: boolean;
};

function transformCategory(category: {
  id: string;
  name: string;
  color: string | null;
  slug: string | null;
  description: string | null;
  system: boolean | null;
  taxRate: number | null;
  taxType: string | null;
  parentId: string | null;
  children?: any[];
}): {
  id: string;
  label: string;
  color: string;
  slug: string;
  children: any[];
} {
  return {
    id: category.id,
    label: category.name,
    color: category.color ?? getColorFromName(category.name) ?? "#606060",
    slug: category.slug ?? "",
    children: category.children?.map(transformCategory) || [],
  };
}

// Flatten categories to include both parents and children
function flattenCategories(categories: any[]): any[] {
  const flattened: any[] = [];

  for (const category of categories) {
    // Add parent category
    flattened.push({
      ...category,
      isChild: false,
    });

    // Add children if they exist
    if (category.children && category.children.length > 0) {
      for (const child of category.children) {
        flattened.push({
          ...child,
          label: `  ${child.label}`, // Add indentation for visual hierarchy
          isChild: true,
          parentId: category.id,
        });
      }
    }
  }

  return flattened;
}

export function SelectCategory({
  selected,
  onChange,
  headless,
  hideLoading,
}: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { data, isLoading } = useQuery(
    trpc.transactionCategories.get.queryOptions(),
  );

  // Transform and flatten categories to include children
  const transformedCategories = data?.map(transformCategory) ?? [];
  const categories = flattenCategories(transformedCategories);

  const createCategoryMutation = useMutation(
    trpc.transactionCategories.create.mutationOptions({
      onSuccess: (data) => {
        queryClient.invalidateQueries({
          queryKey: trpc.transactionCategories.get.queryKey(),
        });

        if (data) {
          onChange({
            id: data.id,
            name: data.name,
            color: data.color,
            slug: data.slug!,
          });
        }
      },
    }),
  );

  // @ts-expect-error - slug is not nullable
  const selectedValue = selected ? transformCategory(selected) : undefined;

  if (!selected && isLoading && !hideLoading) {
    return (
      <div className="w-full h-full flex items-center justify-center">
        <Spinner />
      </div>
    );
  }

  return (
    <ComboboxDropdown
      headless={headless}
      disabled={createCategoryMutation.isPending}
      placeholder="Select category"
      searchPlaceholder="Search category"
      items={categories}
      selectedItem={selectedValue}
      onSelect={(item) => {
        onChange({
          id: item.id,
          name: item.label,
          color: item.color,
          slug: item.slug,
        });
      }}
      {...(!headless && {
        onCreate: (value) => {
          createCategoryMutation.mutate({
            name: value,
            color: getColorFromName(value),
          });
        },
      })}
      renderSelectedItem={(selectedItem) => (
        <div className="flex items-center space-x-2">
          <CategoryColor color={selectedItem.color} />
          <span className="text-left truncate max-w-[90%]">
            {selectedItem.label}
          </span>
        </div>
      )}
      renderOnCreate={(value) => {
        if (!headless) {
          return (
            <div className="flex items-center space-x-2">
              <CategoryColor color={getColorFromName(value)} />
              <span>{`Create "${value}"`}</span>
            </div>
          );
        }
      }}
      renderListItem={({ item }) => {
        return (
          <div className="flex items-center space-x-2">
            <CategoryColor color={item.color} />
            <span className="line-clamp-1">{item.label}</span>
          </div>
        );
      }}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/select-currency.tsx">
import { ComboboxDropdown } from "@midday/ui/combobox-dropdown";

type Props = {
  value?: string;
  headless?: boolean;
  className?: string;
  currencies: string[];
  onChange: (value: string) => void;
};

export function SelectCurrency({
  currencies,
  value,
  onChange,
  headless,
  className,
}: Props) {
  const data = currencies?.map((currency) => ({
    id: currency.toLowerCase(),
    value: currency.toUpperCase(),
    label: currency,
  }));

  return (
    <ComboboxDropdown
      headless={headless}
      placeholder="Select currency"
      selectedItem={data?.find((item) => item.id === value?.toLowerCase())}
      searchPlaceholder="Search currencies"
      items={data}
      className={className}
      onSelect={(item) => {
        onChange(item.value);
      }}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/select-customer.tsx">
"use client";

import { useCustomerParams } from "@/hooks/use-customer-params";
import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { useTRPC } from "@/trpc/client";
import { Button } from "@midday/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@midday/ui/command";
import { Popover, PopoverContent, PopoverTrigger } from "@midday/ui/popover";
import { useQuery } from "@tanstack/react-query";
import React from "react";

export function SelectCustomer() {
  const trpc = useTRPC();
  const { setParams: setCustomerParams } = useCustomerParams();
  const { setParams: setInvoiceParams } = useInvoiceParams();
  const [open, setOpen] = React.useState(false);
  const [value, setValue] = React.useState("");

  const { data: customers } = useQuery(
    trpc.customers.get.queryOptions({
      pageSize: 100,
    }),
  );

  const formatData = customers?.data?.map((item) => ({
    value: item.name,
    label: item.name,
    id: item.id,
  }));

  const handleSelect = (id: string) => {
    if (id === "create-customer") {
      setCustomerParams({ createCustomer: true, name: value });
    } else {
      setInvoiceParams({ selectedCustomerId: id });
    }

    setOpen(false);
  };

  if (!customers?.data?.length) {
    return (
      <Button
        type="button"
        variant="ghost"
        onClick={() => setCustomerParams({ createCustomer: true })}
        className="font-mono text-[#434343] p-0 text-[11px] h-auto hover:bg-transparent"
      >
        Select customer
      </Button>
    );
  }

  return (
    <Popover open={open} onOpenChange={setOpen} modal>
      <PopoverTrigger asChild>
        <Button
          type="button"
          variant="ghost"
          aria-expanded={open}
          className="font-mono text-[#434343] p-0 text-[11px] h-auto hover:bg-transparent"
        >
          Select customer
        </Button>
      </PopoverTrigger>

      <PopoverContent
        className="w-[200px] p-0"
        side="bottom"
        sideOffset={10}
        align="start"
      >
        <Command>
          <CommandInput
            value={value}
            onValueChange={setValue}
            placeholder="Search customer..."
            className="p-2 text-xs"
          />
          <CommandList className="max-h-[180px] overflow-auto">
            <CommandEmpty className="text-xs border-t-[1px] border-border p-2">
              <button
                type="button"
                onClick={() =>
                  setCustomerParams({ createCustomer: true, name: value })
                }
              >
                Create customer
              </button>
            </CommandEmpty>
            <CommandGroup>
              {formatData?.map((item) => (
                <CommandItem
                  key={item.value}
                  value={item.value}
                  onSelect={() => handleSelect(item.id)}
                  className="group text-xs"
                >
                  {item.label}
                  <button
                    type="button"
                    onClick={(e) => {
                      e.stopPropagation();
                      setCustomerParams({ customerId: item.id });
                    }}
                    className="ml-auto text-xs opacity-0 group-hover:opacity-50 hover:opacity-100"
                  >
                    Edit
                  </button>
                </CommandItem>
              ))}
              <CommandItem
                value="create-customer"
                onSelect={handleSelect}
                className="text-xs border-t-[1px] border-border pt-2 mt-2"
              >
                Create customer
              </CommandItem>
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="apps/dashboard/src/components/select-tags.tsx">
import { useTRPC } from "@/trpc/client";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@midday/ui/dialog";
import { Input } from "@midday/ui/input";
import { Label } from "@midday/ui/label";
import MultipleSelector from "@midday/ui/multiple-selector";
import { SubmitButton } from "@midday/ui/submit-button";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import React, { useState } from "react";

type Option = {
  id?: string;
  value: string;
  label: string;
};

type Props = {
  tags?: Option[];
  onSelect?: (tag: Option) => void;
  onRemove?: (tag: Option) => void;
  onChange?: (tags: Option[]) => void;
};

export function SelectTags({ tags, onSelect, onRemove, onChange }: Props) {
  const [isOpen, setIsOpen] = useState(false);
  const [selected, setSelected] = useState<Option[]>(tags ?? []);
  const [editingTag, setEditingTag] = useState<Option | null>(null);

  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { data } = useQuery(trpc.tags.get.queryOptions());

  const updateTagMutation = useMutation(
    trpc.tags.update.mutationOptions({
      onSuccess: () => {
        setIsOpen(false);
        queryClient.invalidateQueries({
          queryKey: trpc.tags.get.queryKey(),
        });
      },
    }),
  );

  const deleteTagMutation = useMutation(
    trpc.tags.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.tags.get.queryKey(),
        });
      },
    }),
  );

  const createTagMutation = useMutation(
    trpc.tags.create.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: trpc.tags.get.queryKey() });
      },
    }),
  );

  const transformedTags = data
    ?.map((tag) => ({
      value: tag.name,
      label: tag.name,
      id: tag.id,
    }))
    .filter((tag) => !selected.some((s) => s.id === tag.id));

  const handleDelete = () => {
    if (editingTag?.id) {
      deleteTagMutation.mutate({ id: editingTag.id });

      setSelected(selected.filter((tag) => tag.id !== editingTag.id));
      setIsOpen(false);
    }
  };

  const handleUpdate = () => {
    if (editingTag?.id) {
      updateTagMutation.mutate({
        id: editingTag.id,
        name: editingTag.label,
      });
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <div className="w-full">
        <MultipleSelector
          options={transformedTags ?? []}
          value={selected}
          placeholder="Select tags"
          creatable
          emptyIndicator={<p className="text-sm">No results found.</p>}
          renderOption={(option) => (
            <div className="flex items-center justify-between w-full group">
              <span>{option.label}</span>

              <button
                type="button"
                className="text-xs group-hover:opacity-50 opacity-0"
                onClick={(event) => {
                  event.stopPropagation();
                  setEditingTag(option);
                  setIsOpen(true);
                }}
              >
                Edit
              </button>
            </div>
          )}
          onCreate={(option) => {
            createTagMutation.mutate(
              { name: option.value },
              {
                onSuccess: (data) => {
                  if (data) {
                    const newTag = {
                      id: data.id,
                      label: data.name,
                      value: data.name,
                    };

                    setSelected([...selected, newTag]);
                    onSelect?.(newTag);
                  }
                },
              },
            );
          }}
          onChange={(options) => {
            setSelected(options);
            onChange?.(options);

            const newTag = options.find(
              (tag) => !selected.find((opt) => opt.value === tag.value),
            );

            if (newTag) {
              onSelect?.(newTag);
              return;
            }

            if (options.length < selected.length) {
              const removedTag = selected.find(
                (tag) => !options.find((opt) => opt.value === tag.value),
              ) as Option & { id: string };

              if (removedTag) {
                onRemove?.(removedTag);
                setSelected(options);
              }
            }
          }}
        />
      </div>

      <DialogContent className="max-w-[455px]">
        <div className="p-4">
          <DialogHeader>
            <DialogTitle>Edit Tag</DialogTitle>
            <DialogDescription>
              Make changes to the tag here. Click save when you're done.
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-2 w-full flex flex-col mt-4">
            <Label>Name</Label>
            <Input
              value={editingTag?.label}
              onChange={(event) => {
                if (editingTag) {
                  setEditingTag({
                    id: editingTag.id,
                    label: event.target.value,
                    value: editingTag.value,
                  });
                }
              }}
            />
          </div>

          <DialogFooter className="mt-8 w-full">
            <div className="space-y-2 w-full flex flex-col">
              <SubmitButton
                isSubmitting={updateTagMutation.isPending}
                onClick={handleUpdate}
              >
                Save
              </SubmitButton>

              <SubmitButton
                isSubmitting={deleteTagMutation.isPending}
                variant="outline"
                onClick={handleDelete}
              >
                Delete
              </SubmitButton>
            </div>
          </DialogFooter>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="apps/dashboard/src/components/select-tax-type.tsx">
"use client";

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";
import { taxTypes } from "@midday/utils/tax";

type Props = {
  value: string;
  onChange: (value: string) => void;
};

export function SelectTaxType({ value, onChange }: Props) {
  return (
    <Select value={value} onValueChange={onChange}>
      <SelectTrigger>
        <SelectValue placeholder="Select a tax type" />
      </SelectTrigger>
      <SelectContent>
        {taxTypes.map((taxType) => (
          <SelectItem key={taxType.value} value={taxType.value}>
            {taxType.label}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  );
}
</file>

<file path="apps/dashboard/src/components/select-user.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { Spinner } from "@midday/ui/spinner";
import { useQuery } from "@tanstack/react-query";
import { AssignedUser } from "./assigned-user";

type User = {
  id: string;
  avatarUrl?: string | null;
  fullName: string | null;
};

type Props = {
  onSelect: (selected: User) => void;
};

export function SelectUser({ onSelect }: Props) {
  const trpc = useTRPC();
  const { data: users, isLoading } = useQuery(trpc.team.members.queryOptions());

  if (isLoading) {
    return (
      <div className="w-full h-full flex items-center justify-center">
        <Spinner />
      </div>
    );
  }

  return users?.map(({ user }) => {
    return (
      <button
        type="button"
        key={user?.id}
        className="flex items-center text-sm cursor-default"
        onClick={() => {
          if (user) {
            onSelect(user);
          }
        }}
      >
        <AssignedUser avatarUrl={user?.avatarUrl} fullName={user?.fullName} />
      </button>
    );
  });
}
</file>

<file path="apps/dashboard/src/components/setup-form.tsx">
"use client";

import { useUserMutation } from "@/hooks/use-user";
import { useZodForm } from "@/hooks/use-zod-form";
import { useTRPC } from "@/trpc/client";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import { SubmitButton } from "@midday/ui/submit-button";
import { useQueryClient, useSuspenseQuery } from "@tanstack/react-query";
import { useRouter } from "next/navigation";
import { useRef, useState } from "react";
import { z } from "zod";
import { AvatarUpload } from "./avatar-upload";

const formSchema = z.object({
  fullName: z.string().min(2).max(32),
});

export function SetupForm() {
  const router = useRouter();
  const uploadRef = useRef<HTMLInputElement>(null);
  const queryClient = useQueryClient();
  const [isRedirecting, setIsRedirecting] = useState(false);

  const trpc = useTRPC();
  const { data: user } = useSuspenseQuery(trpc.user.me.queryOptions());

  const updateUserMutation = useUserMutation();

  const form = useZodForm(formSchema, {
    defaultValues: {
      fullName: user?.fullName ?? "",
    },
  });

  function handleSubmit(data: z.infer<typeof formSchema>) {
    updateUserMutation.mutate(data, {
      onSuccess: async () => {
        setIsRedirecting(true);
        // Invalidate all queries to ensure fresh data
        await queryClient.invalidateQueries();
        // Redirect directly to teams page
        router.push("/teams");
      },
      onError: () => {
        setIsRedirecting(false);
      },
    });
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-8">
        <div className="flex justify-between items-end gap-4">
          <AvatarUpload
            userId={user?.id ?? ""}
            avatarUrl={user?.avatarUrl}
            size={80}
            ref={uploadRef}
          />
        </div>

        <FormField
          control={form.control}
          name="fullName"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Full name</FormLabel>
              <FormControl>
                <Input placeholder="John Doe" {...field} />
              </FormControl>
              <FormDescription>
                This is your first and last name.
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <SubmitButton
          type="submit"
          className="w-full"
          isSubmitting={updateUserMutation.isPending || isRedirecting}
        >
          Save
        </SubmitButton>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/setup-mfa.tsx">
"use client";

import { EnrollMFA } from "@/components/enroll-mfa";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import Link from "next/link";
import { useState } from "react";

type Props = {
  setEnroll: (enroll: boolean) => void;
};

function MfaStart({ setEnroll }: Props) {
  return (
    <>
      <div className="flex w-full flex-col relative">
        <div className="pb-4">
          <div className="text-center">
            <h1 className="text-lg mb-2 font-serif">
              Multi-factor authentication
            </h1>
            <p className="text-[#878787] text-sm">
              Add an additional layer of security to your account.
            </p>
          </div>
        </div>

        <div className="pointer-events-auto mt-6 flex flex-col mb-4">
          <Button className="w-full" onClick={() => setEnroll(true)}>
            Generate QR
          </Button>
        </div>
      </div>

      <div className="flex border-t-[1px] pt-4 mt-4 justify-center mb-6">
        <Link href="/" className="text-medium text-sm" prefetch>
          Skip
        </Link>
      </div>

      <p className="text-xs text-[#878787]">
        Generate one-time passwords via authenticator apps like 1Password,
        Authy, etc. as a second factor to verify your identity during sign-in.
      </p>
    </>
  );
}

export function SetupMfa() {
  const [enroll, setEnroll] = useState(false);

  return (
    <div>
      <div className="absolute left-5 top-4 md:left-10 md:top-10">
        <Link href="https://midday.ai">
          <Icons.LogoSmall />
        </Link>
      </div>

      <div className="flex min-h-screen justify-center items-center overflow-hidden p-6 md:p-0">
        <div className="relative z-20 m-auto flex w-full max-w-[380px] flex-col">
          {enroll ? <EnrollMFA /> : <MfaStart setEnroll={setEnroll} />}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/sidebar.tsx">
"use client";

import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import Link from "next/link";
import { useState } from "react";
import { MainMenu } from "./main-menu";
import { TeamDropdown } from "./team-dropdown";

export function Sidebar() {
  const [isExpanded, setIsExpanded] = useState(false);

  return (
    <aside
      className={cn(
        "h-screen flex-shrink-0 flex-col desktop:overflow-hidden desktop:rounded-tl-[10px] desktop:rounded-bl-[10px] justify-between fixed top-0 pb-4 items-center hidden md:flex z-50 transition-all duration-200 ease-&lsqb;cubic-bezier(0.4,0,0.2,1)&rsqb;",
        "bg-background border-r border-border",
        isExpanded ? "w-[240px]" : "w-[70px]",
      )}
      onMouseEnter={() => setIsExpanded(true)}
      onMouseLeave={() => setIsExpanded(false)}
    >
      <div
        className={cn(
          "absolute top-0 left-0 h-[70px] flex items-center justify-center bg-background border-b border-border transition-all duration-200 ease-&lsqb;cubic-bezier(0.4,0,0.2,1)&rsqb;",
          isExpanded ? "w-full" : "w-[69px]",
        )}
      >
        <Link href="/" className="absolute left-[22px] transition-none">
          <Icons.LogoSmall />
        </Link>
      </div>

      <div className="flex flex-col w-full pt-[70px] flex-1">
        <MainMenu isExpanded={isExpanded} />
      </div>

      <TeamDropdown isExpanded={isExpanded} />
    </aside>
  );
}
</file>

<file path="apps/dashboard/src/components/sign-out-button.tsx">
"use client";

import { createClient } from "@midday/supabase/client";
import { Button } from "@midday/ui/button";

export function SignOutButton() {
  const supabase = createClient();

  return (
    <Button
      variant="outline"
      className="w-full"
      onClick={() => supabase.auth.signOut()}
    >
      Sign out
    </Button>
  );
}
</file>

<file path="apps/dashboard/src/components/sign-out.tsx">
"use client";

import { createClient } from "@midday/supabase/client";
import { DropdownMenuItem } from "@midday/ui/dropdown-menu";
import { useRouter } from "next/navigation";
import { useState } from "react";

export function SignOut() {
  const [isLoading, setLoading] = useState(false);
  const supabase = createClient();
  const router = useRouter();

  const handleSignOut = async () => {
    setLoading(true);

    await supabase.auth.signOut({
      scope: "local",
    });

    router.push("/login");
  };

  return (
    <DropdownMenuItem onClick={handleSignOut}>
      {isLoading ? "Loading..." : "Sign out"}
    </DropdownMenuItem>
  );
}
</file>

<file path="apps/dashboard/src/components/suggested-match.tsx">
"use client";

import { useDocumentParams } from "@/hooks/use-document-params";
import { useLocalStorage } from "@/hooks/use-local-storage";
import { useTRPC } from "@/trpc/client";
import { LocalStorageKeys } from "@/utils/constants";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import { Skeleton } from "@midday/ui/skeleton";
import { SubmitButton } from "@midday/ui/submit-button";
import { useToast } from "@midday/ui/use-toast";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { FilePreview } from "./file-preview";
import { FormatAmount } from "./format-amount";

type Suggestion = NonNullable<
  RouterOutputs["transactions"]["getById"]
>["suggestion"];

type SuggestedMatchProps = {
  suggestion?: Suggestion;
  transactionId: string;
  className?: string;
  isLoading?: boolean;
};

export function SuggestedMatch({
  suggestion,
  transactionId,
  className,
  isLoading,
}: SuggestedMatchProps) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { setParams } = useDocumentParams();
  const { toast } = useToast();
  const [hasSeenLearningToast, setHasSeenLearningToast] = useLocalStorage(
    LocalStorageKeys.MatchLearningToastSeen,
    false,
  );

  const confirmMutation = useMutation(
    trpc.inbox.confirmMatch.mutationOptions({
      onSuccess: () => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.getById.queryKey({ id: transactionId }),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });

        showLearningToast();
      },
    }),
  );

  const declineMutation = useMutation(
    trpc.inbox.declineMatch.mutationOptions({
      onSuccess: () => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.getById.queryKey({ id: transactionId }),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });

        showLearningToast();
      },
    }),
  );

  const showLearningToast = () => {
    if (!hasSeenLearningToast) {
      toast({
        title: "Midday AI",
        description: "We learn from your choices to improve matches over time.",
        variant: "ai",
        duration: 5000,
      });
      setHasSeenLearningToast(true);
    }
  };

  const handleConfirm = async () => {
    if (!suggestion?.suggestionId || !suggestion?.inboxId) return;

    confirmMutation.mutate({
      suggestionId: suggestion.suggestionId,
      inboxId: suggestion.inboxId,
      transactionId: transactionId,
    });
  };

  const handleDecline = async () => {
    if (!suggestion?.suggestionId || !suggestion?.inboxId) return;

    declineMutation.mutate({
      suggestionId: suggestion.suggestionId,
      inboxId: suggestion.inboxId,
    });
  };

  const handleExpandDocument = () => {
    if (!filePath) return;
    setParams({ filePath });
  };

  // Determine mime type from file path
  const getMimeType = (filePath: string[] | null): string => {
    if (!filePath || filePath.length === 0) return "application/octet-stream";

    const pathString = filePath.join("/");
    const extension = pathString.split(".").pop()?.toLowerCase();
    switch (extension) {
      case "pdf":
        return "application/pdf";
      case "jpg":
      case "jpeg":
        return "image/jpeg";
      case "png":
        return "image/png";
      case "gif":
        return "image/gif";
      case "webp":
        return "image/webp";
      default:
        return "application/octet-stream";
    }
  };

  const documentName = suggestion?.documentName || "Document";
  const mimeType = getMimeType(suggestion?.documentPath || null);
  const filePath = suggestion?.documentPath
    ? suggestion.documentPath.join("/")
    : null;

  if (isLoading) {
    return (
      <div className={cn("space-y-4", className)}>
        <div className="flex items-center space-x-2 text-sm">
          <Skeleton className="h-4 w-24" />
          <Skeleton className="h-3 w-20" />
        </div>

        <div className="border border-border overflow-hidden">
          {/* Document Preview Skeleton */}
          <div className="relative bg-[#F6F6F3] dark:bg-[#1A1A1A] p-4 h-[300px] flex items-center justify-center">
            <Skeleton className="w-full h-full max-w-[248px]" />
          </div>

          <div className="p-4 border-t border-border">
            <div className="flex items-center justify-between">
              <div>
                <Skeleton className="h-4 w-32 mb-2" />
                <Skeleton className="h-3 w-20" />
              </div>
              <Skeleton className="h-4 w-16" />
            </div>

            <div className="flex gap-2 mt-4">
              <Skeleton className="h-8 w-full" />
              <Skeleton className="h-8 w-full" />
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className={cn("space-y-4", className)}>
      <div className="flex items-center space-x-2 text-sm">
        <span>Suggested match</span>
        <span className="text-xs text-[#878787]">
          ({Math.round((suggestion?.confidenceScore || 0) * 100)}% confidence)
        </span>
      </div>

      <div className="border border-border overflow-hidden">
        {/* Document Preview */}
        <div className="relative bg-[#F6F6F3] dark:bg-[#1A1A1A] p-4 h-[300px] flex items-center justify-center">
          {filePath && (
            <Button
              variant="ghost"
              size="sm"
              onClick={handleExpandDocument}
              className="absolute top-2 right-2 z-10 h-8 w-8 p-0 "
            >
              <Icons.ExpandContent className="h-4 w-4 text-[#878787]" />
            </Button>
          )}
          {filePath ? (
            <div className="w-full h-full max-w-[248px] mx-auto">
              <FilePreview mimeType={mimeType} filePath={filePath} />
            </div>
          ) : (
            <div className="flex flex-col items-center space-y-2">
              <Icons.Description className="h-12 w-12 text-[#878787]" />
              <span className="text-sm text-[#878787]">
                No preview available
              </span>
            </div>
          )}
        </div>

        <div className="p-4 border-t border-border">
          <div className="flex items-center justify-between">
            <div>
              <h4 className="font-medium text-sm">{documentName}</h4>
              {suggestion?.documentAmount && suggestion?.documentCurrency && (
                <p className="text-[#606060] text-xs mt-1">
                  <FormatAmount
                    amount={suggestion.documentAmount}
                    currency={suggestion.documentCurrency}
                  />
                </p>
              )}
            </div>
            <div className="flex items-center space-x-2">
              <SubmitButton
                variant="outline"
                size="sm"
                onClick={handleDecline}
                className="h-8 px-3"
                isSubmitting={declineMutation.isPending}
              >
                <div className="flex items-center gap-1">
                  <Icons.Close className="size-3.5" />
                  <span>Decline</span>
                </div>
              </SubmitButton>
              <SubmitButton
                size="sm"
                onClick={handleConfirm}
                isSubmitting={confirmMutation.isPending}
                className="h-8 px-3"
              >
                <div className="flex items-center gap-1">
                  <Icons.Check className="size-3.5" />
                  <span>Confirm</span>
                </div>
              </SubmitButton>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/support-form.tsx">
"use client";

import { sendSupportAction } from "@/actions/send-support-action";
import { useZodForm } from "@/hooks/use-zod-form";
import { Button } from "@midday/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@midday/ui/form";
import { Input } from "@midday/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";
import { Textarea } from "@midday/ui/textarea";
import { useToast } from "@midday/ui/use-toast";
import { Loader2 } from "lucide-react";
import { useAction } from "next-safe-action/hooks";
import { z } from "zod";

const formSchema = z.object({
  subject: z.string(),
  priority: z.string(),
  type: z.string(),
  message: z.string(),
  url: z.string().optional(),
});

export function SupportForm() {
  const { toast } = useToast();

  const form = useZodForm(formSchema, {
    defaultValues: {
      subject: undefined,
      type: undefined,
      priority: undefined,
      message: undefined,
    },
  });

  const sendSupport = useAction(sendSupportAction, {
    onSuccess: () => {
      toast({
        duration: 2500,
        title: "Support ticket sent.",
        variant: "success",
      });

      form.reset();
    },
    onError: () => {
      toast({
        duration: 3500,
        variant: "error",
        title: "Something went wrong please try again.",
      });
    },
  });

  return (
    <Form {...form}>
      <form
        onSubmit={form.handleSubmit(sendSupport.execute)}
        className="space-y-8"
      >
        <FormField
          control={form.control}
          name="subject"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Subject</FormLabel>
              <FormControl>
                <Input
                  placeholder="Summary of the problem you have"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="flex space-x-4">
          <FormField
            control={form.control}
            name="type"
            render={({ field }) => (
              <FormItem className="w-full">
                <FormLabel>Product</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select Product" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="Transactions">Transactions</SelectItem>
                    <SelectItem value="Vault">Vault</SelectItem>
                    <SelectItem value="Inbox">Inbox</SelectItem>
                    <SelectItem value="Invoicing">Invoicing</SelectItem>
                    <SelectItem value="Tracker">Tracker</SelectItem>
                    <SelectItem value="AI">AI</SelectItem>
                    <SelectItem value="General">General</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
          <FormField
            control={form.control}
            name="priority"
            render={({ field }) => (
              <FormItem className="w-full">
                <FormLabel>Severity</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select severity" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="low">Low</SelectItem>
                    <SelectItem value="normal">Normal</SelectItem>
                    <SelectItem value="high">High</SelectItem>
                    <SelectItem value="urgent">Urgent</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <FormField
          control={form.control}
          name="message"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Message</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Describe the issue you're facing, along with any relevant information. Please be as detailed and specific as possible."
                  className="resize-none min-h-[150px]"
                  {...field}
                />
              </FormControl>

              <FormMessage />
            </FormItem>
          )}
        />

        <Button
          type="submit"
          disabled={
            sendSupport.status === "executing" || !form.formState.isValid
          }
        >
          {sendSupport.status === "executing" ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            "Submit"
          )}
        </Button>
      </form>
    </Form>
  );
}
</file>

<file path="apps/dashboard/src/components/sync-transactions.tsx">
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";

type Props = {
  disabled: boolean;
  onClick: () => void;
};

export function SyncTransactions({ onClick, disabled }: Props) {
  return (
    <TooltipProvider delayDuration={70}>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            variant="outline"
            size="icon"
            className="rounded-full w-7 h-7 flex items-center"
            disabled={disabled}
            onClick={onClick}
          >
            <Icons.Refresh size={16} />
          </Button>
        </TooltipTrigger>

        <TooltipContent className="px-3 py-1.5 text-xs" sideOffset={10}>
          Synchronize
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}
</file>

<file path="apps/dashboard/src/components/system-banner.tsx">
export function SystemBanner() {
  return (
    <div className="p-1 fixed left-0 right-0 top-0 bg-[#FFD02B] z-50 text-center flex items-center justify-center text-black text-sm font-medium">
      <span>
        We are currently investigating a technical issue, follow{" "}
        <a href="https://status.midday.ai" className="underline">
          status.midday.ai
        </a>{" "}
        for updates.
      </span>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tax-rate-assistant.tsx">
import { getTaxRateAction } from "@/actions/ai/get-tax-rate";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useAction } from "next-safe-action/hooks";
import { useEffect, useRef, useState } from "react";
import { useDebounceValue } from "usehooks-ts";

type Props = {
  name?: string;
  value?: string | null;
  onSelect: (value: number) => void;
  onSuggestionReceived?: (taxRate: number) => void;
};

export function TaxRateAssistant({
  name,
  onSelect,
  onSuggestionReceived,
  value,
}: Props) {
  const [result, setResult] = useState<
    { taxRate: number; country?: string } | undefined
  >();
  const [isLoading, setLoading] = useState(false);
  const lastProcessedName = useRef<string | undefined>(undefined);

  const getVatRate = useAction(getTaxRateAction, {
    onSuccess: ({ data }) => {
      setLoading(false);

      if (data) {
        setResult(data);
        // Auto-update the input with the AI suggestion
        onSuggestionReceived?.(data.taxRate);
      }
    },
    onError: () => {
      setLoading(false);
    },
  });

  const handleOnSelect = () => {
    if (result?.taxRate) {
      onSelect(result.taxRate);
    }
  };

  // Use debounced name value with 500ms delay
  const [debouncedName] = useDebounceValue(name, 500);

  useEffect(() => {
    // Only trigger API call if debounced name is different from last processed name
    if (
      debouncedName &&
      debouncedName.length > 2 &&
      debouncedName !== lastProcessedName.current
    ) {
      lastProcessedName.current = debouncedName;
      setResult(undefined);
      setLoading(true);
      getVatRate.execute({ name: debouncedName });
    }
  }, [debouncedName, getVatRate]);

  return (
    <TooltipProvider delayDuration={0}>
      <Tooltip>
        <TooltipTrigger asChild>
          <div className="absolute right-2 top-2.5">
            <Icons.AIOutline
              className={cn(
                "pointer-events-none opacity-50 transition-colors",
                result?.taxRate && "opacity-100",
                isLoading && "animate-pulse opacity-100",
              )}
            />
          </div>
        </TooltipTrigger>
        {result?.taxRate && (
          <TooltipContent
            sideOffset={20}
            className="flex flex-col max-w-[310px] space-y-2"
          >
            <div className="flex space-x-2 items-center">
              <span>Tax Rate Assistant</span>
            </div>
            <span className="text-xs text-[#878787]">
              {`The tax rate for ${name} in ${result.country} is generally ${result.taxRate}%. This value has been automatically filled in the input field. Please remember to confirm this with your local Tax office.`}
            </span>

            <div className="flex justify-end mt-3 pt-3">
              <Button
                size="sm"
                className="h-auto py-1"
                onClick={handleOnSelect}
              >
                Apply
              </Button>
            </div>
          </TooltipContent>
        )}
      </Tooltip>
    </TooltipProvider>
  );
}
</file>

<file path="apps/dashboard/src/components/tax-rate-input.tsx">
import { CurrencyInput } from "@midday/ui/currency-input";
import { useState } from "react";
import { TaxRateAssistant } from "./tax-rate-assistant";

type Props = {
  name: string;
  onChange: (value: string) => void;
  onSelect: (vat: number) => void;
  value?: number | null;
};

export function TaxRateInput({
  name,
  onChange,
  onSelect,
  value: defaultValue,
}: Props) {
  const [value, setValue] = useState(defaultValue);

  const handleOnSelect = (vat: number) => {
    setValue(vat);
    onSelect(vat);
  };

  return (
    <div className="relative">
      <CurrencyInput
        suffix="%"
        autoComplete="off"
        value={value ?? ""}
        onValueChange={(values) => {
          setValue(values.floatValue);
          onChange(values.value);
        }}
        placeholder="Tax Rate"
        thousandSeparator={false}
        decimalScale={2}
        isAllowed={(values) => {
          const { floatValue } = values;
          return (
            floatValue === undefined || (floatValue >= 0 && floatValue <= 100)
          );
        }}
        allowNegative={false}
      />

      <TaxRateAssistant
        name={name}
        value={value?.toString() ?? ""}
        onSelect={handleOnSelect}
        onSuggestionReceived={(taxRate) => {
          setValue(taxRate);
          onChange(taxRate.toString());
        }}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/team-dropdown.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { AnimatePresence, motion } from "framer-motion";
import Link from "next/link";
import { useEffect, useRef, useState } from "react";
import { useOnClickOutside } from "usehooks-ts";

type Props = {
  isExpanded?: boolean;
};

export function TeamDropdown({ isExpanded = false }: Props) {
  const ref = useRef<HTMLDivElement>(null);
  const { data: user } = useUserQuery();
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const [selectedId, setSelectedId] = useState<string | undefined>(
    user?.team?.id,
  );
  const [isActive, setActive] = useState(false);
  const [isChangingTeam, setIsChangingTeam] = useState(false);

  const changeTeamMutation = useMutation(
    trpc.user.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries();
        setIsChangingTeam(false);
      },
    }),
  );

  const { data: teams } = useQuery(trpc.team.list.queryOptions());

  useEffect(() => {
    if (user?.team?.id) {
      setSelectedId(user.team.id);
    }
  }, [user?.team?.id]);

  const sortedTeams =
    teams?.sort((a, b) => {
      if (a.id === selectedId) return -1;
      if (b.id === selectedId) return 1;

      return (a.id ?? "").localeCompare(b.id ?? "");
    }) ?? [];

  // @ts-expect-error
  useOnClickOutside(ref, () => {
    if (!isChangingTeam) {
      setActive(false);
    }
  });

  const toggleActive = () => setActive((prev) => !prev);

  const handleTeamChange = (teamId: string) => {
    if (teamId === selectedId) {
      toggleActive();
      return;
    }

    setIsChangingTeam(true);
    setSelectedId(teamId);
    setActive(false);

    changeTeamMutation.mutate({ teamId });
  };

  return (
    <div className="relative h-[32px]" ref={ref}>
      {/* Avatar - fixed position that absolutely never changes */}
      <div className="fixed left-[19px] bottom-4 w-[32px] h-[32px]">
        <div className="relative w-[32px] h-[32px]">
          <AnimatePresence>
            {isActive && (
              <motion.div
                className="w-[32px] h-[32px] left-0 overflow-hidden absolute"
                style={{ zIndex: 1 }}
                initial={{ y: 0, opacity: 0 }}
                animate={{ y: -(32 + 10) * sortedTeams.length, opacity: 1 }}
                transition={{
                  type: "spring",
                  stiffness: 400,
                  damping: 25,
                  mass: 1.2,
                }}
              >
                <Link href="/teams/create" onClick={() => setActive(false)}>
                  <Button
                    className="w-[32px] h-[32px]"
                    size="icon"
                    variant="outline"
                  >
                    <Icons.Add />
                  </Button>
                </Link>
              </motion.div>
            )}
            {sortedTeams.map((team, index) => (
              <motion.div
                key={team.id}
                className="w-[32px] h-[32px] left-0 overflow-hidden absolute"
                style={{ zIndex: -index }}
                initial={{
                  scale: `${100 - index * 16}%`,
                  y: index * 5,
                }}
                animate={
                  isActive
                    ? {
                        y: -(32 + 10) * index,
                        scale: "100%",
                      }
                    : {
                        scale: `${100 - index * 16}%`,
                        y: index * 5,
                      }
                }
                transition={{
                  type: "spring",
                  stiffness: 400,
                  damping: 25,
                  mass: 1.2,
                }}
              >
                <Avatar
                  className="w-[32px] h-[32px] rounded-none border border-[#DCDAD2] dark:border-[#2C2C2C] cursor-pointer"
                  onClick={() => {
                    if (index === 0) {
                      toggleActive();
                    } else {
                      handleTeamChange(team?.id ?? "");
                    }
                  }}
                >
                  <AvatarImageNext
                    src={team?.logoUrl ?? ""}
                    alt={team?.name ?? ""}
                    width={20}
                    height={20}
                    quality={100}
                  />
                  <AvatarFallback className="rounded-none w-[32px] h-[32px]">
                    <span className="text-xs">
                      {team?.name?.charAt(0)?.toUpperCase()}
                      {team?.name?.charAt(1)?.toUpperCase()}
                    </span>
                  </AvatarFallback>
                </Avatar>
              </motion.div>
            ))}
          </AnimatePresence>
        </div>
      </div>

      {/* Team name - appears to the right of the fixed avatar */}
      {isExpanded && sortedTeams[0] && (
        <div className="fixed left-[62px] bottom-4 h-[32px] flex items-center">
          <span
            className="text-sm text-primary truncate transition-opacity duration-200 ease-in-out cursor-pointer hover:opacity-80"
            onClick={(e) => {
              e.stopPropagation();
              toggleActive();
            }}
          >
            {sortedTeams[0].name}
          </span>
        </div>
      )}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/team-invite.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { Avatar, AvatarFallback } from "@midday/ui/avatar";
import { AvatarImage } from "@midday/ui/avatar";
import { SubmitButton } from "@midday/ui/submit-button";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useRouter } from "next/navigation";

type Props = {
  invite: RouterOutputs["team"]["invitesByEmail"][number];
};

export function TeamInvite({ invite }: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const router = useRouter();

  const updateUserMutation = useMutation(
    trpc.user.update.mutationOptions({
      onSuccess: async () => {
        await queryClient.invalidateQueries();
        router.push("/");
      },
    }),
  );

  const acceptInviteMutation = useMutation(
    trpc.team.acceptInvite.mutationOptions({
      onSuccess: (data) => {
        if (!data.teamId) {
          return;
        }

        // Update the user's teamId
        updateUserMutation.mutate({
          teamId: data.teamId,
        });
      },
    }),
  );

  const declineInviteMutation = useMutation(
    trpc.team.declineInvite.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.team.invitesByEmail.queryKey(),
        });
      },
    }),
  );

  return (
    <div className="flex justify-between items-center">
      <div className="flex items-center gap-4">
        <Avatar className="size-8 rounded-none">
          <AvatarImage
            src={invite.team?.logoUrl ?? ""}
            className="rounded-none"
            width={32}
            height={32}
          />
          <AvatarFallback className="rounded-none">
            <span className="text-xs">
              {invite.team?.name?.charAt(0)?.toUpperCase()}
            </span>
          </AvatarFallback>
        </Avatar>

        <span className="text-sm font-medium">{invite.team?.name}</span>
      </div>

      <div className="flex gap-2">
        <SubmitButton
          isSubmitting={acceptInviteMutation.isPending}
          variant="outline"
          onClick={() =>
            acceptInviteMutation.mutate({
              id: invite.id,
            })
          }
        >
          Accept
        </SubmitButton>
        <SubmitButton
          isSubmitting={declineInviteMutation.isPending}
          variant="outline"
          onClick={() =>
            declineInviteMutation.mutate({
              id: invite.id,
            })
          }
        >
          Decline
        </SubmitButton>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/team-invites.tsx">
"use client";

import { useTRPC } from "@/trpc/client";
import { useSuspenseQuery } from "@tanstack/react-query";
import { TeamInvite } from "./team-invite";

export function TeamInvites() {
  const trpc = useTRPC();
  const { data: invites } = useSuspenseQuery(
    trpc.team.invitesByEmail.queryOptions(),
  );

  return (
    <div className="mt-4">
      <span className="text-sm font-mono text-[#878787] mb-4">Invitations</span>

      <div className="mt-6 space-y-4">
        {invites.map((invite) => (
          <TeamInvite key={invite.id} invite={invite} />
        ))}
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/team-members.tsx">
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@midday/ui/tabs";
import { Suspense } from "react";
import { DataTable as MembersTable } from "./tables/members";
import { DataTable as PendingInvitesTable } from "./tables/pending-invites";
import { PendingInvitesSkeleton } from "./tables/pending-invites/skeleton";

export function TeamMembers() {
  return (
    <Tabs defaultValue="members">
      <TabsList className="bg-transparent border-b-[1px] w-full justify-start rounded-none mb-1 p-0 h-auto pb-4">
        <TabsTrigger value="members" className="p-0 m-0 mr-4">
          Team Members
        </TabsTrigger>
        <TabsTrigger value="pending" className="p-0 m-0">
          Pending Invitations
        </TabsTrigger>
      </TabsList>

      <TabsContent value="members">
        <Suspense fallback={<PendingInvitesSkeleton />}>
          <MembersTable />
        </Suspense>
      </TabsContent>

      <TabsContent value="pending">
        <Suspense fallback={<PendingInvitesSkeleton />}>
          <PendingInvitesTable />
        </Suspense>
      </TabsContent>
    </Tabs>
  );
}
</file>

<file path="apps/dashboard/src/components/teller-connect.tsx">
import { useConnectParams } from "@/hooks/use-connect-params";
import { track } from "@midday/events/client";
import { LogEvents } from "@midday/events/events";
import { useTheme } from "next-themes";
import { useEffect, useState } from "react";
import { BankConnectButton } from "./bank-connect-button";

type Props = {
  id: string;
  onSelect: (id: string) => void;
};

export function TellerConnect({ id, onSelect }: Props) {
  const [institution, setInstitution] = useState<string | undefined>();
  const { setParams } = useConnectParams();
  const { theme } = useTheme();

  useEffect(() => {
    if (institution) {
      // @ts-expect-error
      const teller = window.TellerConnect.setup({
        applicationId: process.env.NEXT_PUBLIC_TELLER_APPLICATION_ID!,
        environment: process.env.NEXT_PUBLIC_TELLER_ENVIRONMENT,
        institution,
        appearance: theme,
        onSuccess: (authorization: {
          accessToken: string;
          enrollment: { id: string };
        }) => {
          setParams({
            step: "account",
            provider: "teller",
            token: authorization.accessToken,
            enrollment_id: authorization.enrollment.id,
          });

          track({
            event: LogEvents.ConnectBankAuthorized.name,
            channel: LogEvents.ConnectBankAuthorized.channel,
            provider: "teller",
          });
        },
        onExit: () => {
          setParams({ step: "connect" });
          track({
            event: LogEvents.ConnectBankCanceled.name,
            channel: LogEvents.ConnectBankCanceled.channel,
            provider: "teller",
          });

          setParams({ step: "connect" });
        },
        onFailure: () => {
          setParams({ step: "connect" });
        },
      });

      // NOTE: Because we are configure Teller with institution we need to
      // Regenerate the SDK, and that gives us a white background, let's wait until it's fully loaded
      setTimeout(() => {
        teller.open();
      }, 1000);
    }
  }, [institution]);

  return (
    <BankConnectButton
      onClick={() => {
        onSelect(id);
        setInstitution(id);
      }}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/theme-provider.tsx">
"use client";

import { ThemeProvider as NextThemesProvider } from "next-themes";
import * as React from "react";
type ThemeProviderProps = Parameters<typeof NextThemesProvider>[0];

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}
</file>

<file path="apps/dashboard/src/components/theme-switch.tsx">
"use client";

import { Monitor, Moon, Sun } from "lucide-react";
import { useTheme } from "next-themes";
import { useEffect, useState } from "react";

import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";

type Theme = "dark" | "system" | "light";

type Props = {
  currentTheme?: Theme;
};

const ThemeIcon = ({ currentTheme }: Props) => {
  switch (currentTheme) {
    case "dark":
      return <Moon size={12} />;
    case "system":
      return <Monitor size={12} />;
    default:
      return <Sun size={12} />;
  }
};

export const ThemeSwitch = () => {
  const { theme, setTheme, themes, resolvedTheme } = useTheme();
  const [mounted, setMounted] = useState(false);

  // After mounting, we have access to the theme
  useEffect(() => setMounted(true), []);

  if (!mounted) {
    return <div className="h-[32px]" />;
  }

  return (
    <div className="flex items-center relative">
      <Select value={theme} onValueChange={(value: Theme) => setTheme(value)}>
        <SelectTrigger className="w-full pl-6 pr-3 py-1.5 bg-transparent outline-none capitalize h-[32px] text-xs">
          <SelectValue>
            {theme
              ? theme.charAt(0).toUpperCase() + theme.slice(1)
              : "Select theme"}
          </SelectValue>
        </SelectTrigger>
        <SelectContent>
          <SelectGroup>
            {themes.map((theme) => (
              <SelectItem key={theme} value={theme} className="capitalize">
                {theme}
              </SelectItem>
            ))}
          </SelectGroup>
        </SelectContent>
      </Select>

      <div className="absolute left-2 pointer-events-none">
        <ThemeIcon currentTheme={resolvedTheme as Theme} />
      </div>
    </div>
  );
};
</file>

<file path="apps/dashboard/src/components/time-format-settings.tsx">
"use client";

import { useUserMutation, useUserQuery } from "@/hooks/use-user";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";

export function TimeFormatSettings() {
  const updateUserMutation = useUserMutation();
  const { data: user } = useUserQuery();

  return (
    <Card className="flex justify-between items-center">
      <CardHeader>
        <CardTitle>Time Display Format</CardTitle>
        <CardDescription>
          Choose between 12-hour or 24-hour clock format for displaying time.
        </CardDescription>
      </CardHeader>

      <CardContent>
        <Select
          defaultValue={user?.timeFormat?.toString() ?? undefined}
          onValueChange={(value) => {
            updateUserMutation.mutate({ timeFormat: +value });
          }}
        >
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Time format" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="12">12 hours (AM/PM)</SelectItem>
            <SelectItem value="24">24 hours</SelectItem>
          </SelectContent>
        </Select>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/timezone-detector.tsx">
"use client";

import { useUserMutation, useUserQuery } from "@/hooks/use-user";
import { useEffect, useRef } from "react";

export function TimezoneDetector() {
  const { data: user } = useUserQuery();
  const updateUserMutation = useUserMutation();

  // Track if we've already attempted detection in this session
  const hasAttemptedDetection = useRef(false);

  useEffect(() => {
    // Skip if we've already attempted detection in this session
    if (hasAttemptedDetection.current) {
      return;
    }

    // Skip if user data isn't loaded yet
    if (!user) {
      return;
    }

    // Skip if currently updating to avoid race conditions
    if (updateUserMutation.isPending) {
      return;
    }

    let detectedTimezone: string;

    try {
      // Detect browser timezone using native API
      detectedTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    } catch (error) {
      hasAttemptedDetection.current = true;
      return;
    }

    // Skip if no valid timezone was detected
    if (!detectedTimezone) {
      hasAttemptedDetection.current = true;
      return;
    }

    const shouldUpdate =
      // Update if user has no timezone set (null/undefined)
      !user.timezone ||
      // Update if auto-sync is enabled (default true) AND detected timezone differs
      (user.timezoneAutoSync !== false && user.timezone !== detectedTimezone);

    if (shouldUpdate) {
      // Mark as attempted before making the request
      hasAttemptedDetection.current = true;

      updateUserMutation.mutate({ timezone: detectedTimezone });
    } else {
      // Mark as attempted even if no update was needed
      hasAttemptedDetection.current = true;
    }
  }, [user, updateUserMutation]);

  // This component doesn't render anything - it's a utility component
  return null;
}
</file>

<file path="apps/dashboard/src/components/top-revenue-client.tsx">
"use client";

import { useTeamQuery } from "@/hooks/use-team";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { Card, CardContent, CardHeader, CardTitle } from "@midday/ui/card";
import { useSuspenseQuery } from "@tanstack/react-query";
import { FormatAmount } from "./format-amount";

export function TopRevenueClient() {
  const trpc = useTRPC();
  const { data: team } = useTeamQuery();
  const { data: user } = useUserQuery();
  const { data } = useSuspenseQuery(
    trpc.invoice.topRevenueClient.queryOptions(),
  );

  if (!data) {
    return (
      <Card className="hidden sm:block">
        <CardHeader className="pb-3">
          <CardTitle className="font-mono font-medium text-2xl">
            No Revenue Client
          </CardTitle>
        </CardHeader>

        <CardContent className="pb-[34px]">
          <div className="flex flex-col gap-2">
            <div>Top Revenue Client</div>
            <div className="text-sm text-muted-foreground">
              No revenue generated past 30 days
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="hidden sm:block">
      <CardHeader className="pb-3">
        <CardTitle className="font-mono font-medium text-2xl">
          {data.customerName}
        </CardTitle>
      </CardHeader>

      <CardContent className="pb-[34px]">
        <div className="flex flex-col gap-2">
          <div>Top Revenue Client</div>
          <div className="text-sm text-muted-foreground">
            <FormatAmount
              amount={data.totalRevenue}
              currency={data.currency || team?.baseCurrency || "USD"}
              locale={user?.locale ?? undefined}
            />{" "}
            from {data.invoiceCount} invoice{data.invoiceCount !== 1 ? "s" : ""}{" "}
            past 30 days
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/total-earnings.tsx">
"use client";

import { useTrackerParams } from "@/hooks/use-tracker-params";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { secondsToHoursAndMinutes } from "@/utils/format";
import { TZDate } from "@date-fns/tz";
import {
  HoverCard,
  HoverCardContent,
  HoverCardTrigger,
} from "@midday/ui/hover-card";
import { useQuery } from "@tanstack/react-query";
import {
  endOfMonth,
  endOfWeek,
  formatISO,
  startOfMonth,
  startOfWeek,
} from "date-fns";
import { useMemo } from "react";
import { FormatAmount } from "./format-amount";

type Props = {
  selectedView: "week" | "month";
};

export function TotalEarnings({ selectedView }: Props) {
  const { data: user } = useUserQuery();
  const trpc = useTRPC();
  const { date: currentDate } = useTrackerParams();

  const weekStartsOnMonday = user?.weekStartsOnMonday ?? false;
  const currentTZDate = new TZDate(currentDate, "UTC");

  // Calculate date range based on current view
  const dateRange = useMemo(() => {
    if (selectedView === "week") {
      const weekStart = startOfWeek(currentTZDate, {
        weekStartsOn: weekStartsOnMonday ? 1 : 0,
      });
      const weekEnd = endOfWeek(currentTZDate, {
        weekStartsOn: weekStartsOnMonday ? 1 : 0,
      });
      return {
        from: formatISO(weekStart, { representation: "date" }),
        to: formatISO(weekEnd, { representation: "date" }),
      };
    }
    return {
      from: formatISO(startOfMonth(currentTZDate), { representation: "date" }),
      to: formatISO(endOfMonth(currentTZDate), { representation: "date" }),
    };
  }, [selectedView, currentTZDate, weekStartsOnMonday]);

  const { data } = useQuery(
    trpc.trackerEntries.byRange.queryOptions(dateRange),
  );

  // Calculate earnings by currency from billable entries
  const earningsByCurrency = useMemo(() => {
    if (!data?.result) return {};

    const earnings: Record<string, number> = {};

    // Iterate through all days and entries
    for (const entry of Object.values(data.result).flat()) {
      // Only include entries from billable projects with rates
      if (
        entry.trackerProject?.billable &&
        entry.trackerProject?.rate &&
        entry.duration
      ) {
        const currency = entry.trackerProject.currency || "USD";
        const rate = Number(entry.trackerProject.rate);
        const hours = entry.duration / 3600; // Convert seconds to hours
        const earning = rate * hours;

        earnings[currency] = (earnings[currency] || 0) + earning;
      }
    }

    return earnings;
  }, [data?.result]);

  // Calculate earnings breakdown by project
  const projectBreakdown = useMemo(() => {
    if (!data?.result) return [];

    const projects: Record<
      string,
      {
        name: string;
        duration: number;
        amount: number;
        currency: string;
      }
    > = {};

    // Iterate through all days and entries
    for (const entry of Object.values(data.result).flat()) {
      // Only include entries from billable projects with rates
      if (
        entry.trackerProject?.billable &&
        entry.trackerProject?.rate &&
        entry.duration
      ) {
        const projectId = entry.trackerProject.id;
        const projectName = entry.trackerProject.name;
        const currency = entry.trackerProject.currency || "USD";
        const rate = Number(entry.trackerProject.rate);
        const hours = entry.duration / 3600; // Convert seconds to hours for calculation
        const earning = rate * hours;

        if (projects[projectId]) {
          projects[projectId].duration += entry.duration;
          projects[projectId].amount += earning;
        } else {
          projects[projectId] = {
            name: projectName,
            duration: entry.duration,
            amount: earning,
            currency,
          };
        }
      }
    }

    return Object.values(projects).sort((a, b) => b.amount - a.amount);
  }, [data?.result]);

  const currencyEntries = Object.entries(earningsByCurrency);

  return (
    <div className="flex flex-wrap gap-4 h-4">
      {currencyEntries.map(([currency, amount]) => (
        <HoverCard key={currency} openDelay={0} closeDelay={100}>
          <HoverCardTrigger asChild>
            <button
              type="button"
              className="text-sm text-[#666] cursor-pointer"
            >
              <span className="font-mono">
                <FormatAmount
                  amount={Math.round(amount)}
                  currency={currency}
                  minimumFractionDigits={0}
                  maximumFractionDigits={0}
                />
              </span>
              <span> this {selectedView === "week" ? "week" : "month"}</span>
            </button>
          </HoverCardTrigger>
          <HoverCardContent className="w-48 p-2 mt-1" align="start">
            <div className="space-y-1">
              {projectBreakdown
                .filter((project) => project.currency === currency)
                .map((project) => (
                  <div
                    key={`${project.name}-${project.currency}`}
                    className="space-y-0.5"
                  >
                    <div className="flex items-center justify-between text-[11px]">
                      <div className="font-medium truncate flex-1 min-w-0 mr-1">
                        {project.name}
                      </div>
                      <div className="font-mono text-right">
                        <FormatAmount
                          amount={Math.round(project.amount)}
                          currency={project.currency}
                          minimumFractionDigits={0}
                          maximumFractionDigits={0}
                        />
                      </div>
                    </div>
                    <div className="text-[9px] text-muted-foreground">
                      {secondsToHoursAndMinutes(project.duration)}
                    </div>
                  </div>
                ))}
              {projectBreakdown.filter(
                (project) => project.currency === currency,
              ).length === 0 && (
                <div className="text-[11px] text-muted-foreground text-center py-1">
                  No billable projects this{" "}
                  {selectedView === "week" ? "week" : "month"}
                </div>
              )}
            </div>
          </HoverCardContent>
        </HoverCard>
      ))}
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-calendar-type.tsx">
"use client";

import { setWeeklyCalendarAction } from "@/actions/set-weekly-calendar-action";
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { Tabs, TabsList, TabsTrigger } from "@midday/ui/tabs";
import { useAction } from "next-safe-action/hooks";

const options = [
  {
    value: "week",
    label: "Week",
  },
  {
    value: "month",
    label: "Month",
  },
] as const;

type Props = {
  selectedView: "week" | "month";
};

export function TrackerCalendarType({ selectedView }: Props) {
  const { setParams } = useTrackerParams();
  const setWeeklyCalendar = useAction(setWeeklyCalendarAction);

  const handleChange = (value: string) => {
    setParams({ view: value as "week" | "month" });
    setWeeklyCalendar.execute(value === "week");
  };

  return (
    <Tabs
      className="h-[37px]"
      value={selectedView}
      onValueChange={handleChange}
    >
      <TabsList className="p-0 h-[37px]">
        {options.map((option) => (
          <TabsTrigger
            key={option.value}
            value={option.value}
            className="!bg-transparent h-[37px]"
          >
            {option.label}
          </TabsTrigger>
        ))}
      </TabsList>
    </Tabs>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-calendar.tsx">
"use client";

import { useCalendarDates } from "@/hooks/use-calendar-dates";
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { TZDate } from "@date-fns/tz";
import { useQuery } from "@tanstack/react-query";
import {
  addMonths,
  addWeeks,
  eachDayOfInterval,
  endOfMonth,
  endOfWeek,
  formatISO,
  startOfMonth,
  startOfWeek,
  subMonths,
  subWeeks,
} from "date-fns";
import { useRef, useState } from "react";
import React from "react";
import { useHotkeys } from "react-hotkeys-hook";
import { useOnClickOutside } from "usehooks-ts";
import { CalendarHeader } from "./tracker/calendar-header";
import { CalendarMonthView } from "./tracker/calendar-month-view";
import { CalendarWeekView } from "./tracker/calendar-week-view";

type Props = {
  weeklyCalendar: boolean;
};

export function TrackerCalendar({ weeklyCalendar }: Props) {
  const ref = useRef(null);
  const { data: user } = useUserQuery();
  const trpc = useTRPC();

  const weekStartsOnMonday = user?.weekStartsOnMonday ?? false;

  const {
    date: currentDate,
    range,
    setParams,
    selectedDate,
    view,
  } = useTrackerParams();

  const selectedView = view ?? (weeklyCalendar ? "week" : "month");

  const [isDragging, setIsDragging] = useState(false);
  const [localRange, setLocalRange] = useState<[string | null, string | null]>([
    null,
    null,
  ]);

  const currentTZDate = new TZDate(currentDate, "UTC");

  const { calendarDays, firstWeek } = useCalendarDates(
    currentTZDate,
    weekStartsOnMonday,
  );

  // Calculate current week days for week view
  const currentWeekDays = React.useMemo(() => {
    const weekStart = startOfWeek(currentTZDate, {
      weekStartsOn: weekStartsOnMonday ? 1 : 0,
    });
    const weekEnd = endOfWeek(currentTZDate, {
      weekStartsOn: weekStartsOnMonday ? 1 : 0,
    });
    return eachDayOfInterval({
      start: weekStart,
      end: weekEnd,
    }).map((date) => new TZDate(date, "UTC"));
  }, [currentTZDate, weekStartsOnMonday]);

  // Dynamic data fetching based on view
  const getDateRange = () => {
    if (selectedView === "week") {
      const weekStart = startOfWeek(currentTZDate, {
        weekStartsOn: weekStartsOnMonday ? 1 : 0,
      });
      const weekEnd = endOfWeek(currentTZDate, {
        weekStartsOn: weekStartsOnMonday ? 1 : 0,
      });
      return {
        from: formatISO(weekStart, { representation: "date" }),
        to: formatISO(weekEnd, { representation: "date" }),
      };
    }
    // For monthly view, extend the range to include buffer days for midnight-spanning entries
    const monthStart = startOfMonth(currentTZDate);
    const monthEnd = endOfMonth(currentTZDate);

    // Add 1 day buffer before and after to handle midnight-spanning entries
    const extendedStart = new Date(monthStart);
    extendedStart.setDate(extendedStart.getDate() - 1);

    const extendedEnd = new Date(monthEnd);
    extendedEnd.setDate(extendedEnd.getDate() + 1);

    return {
      from: formatISO(extendedStart, { representation: "date" }),
      to: formatISO(extendedEnd, { representation: "date" }),
    };
  };

  const { data } = useQuery(
    trpc.trackerEntries.byRange.queryOptions(getDateRange()),
  );

  function handlePeriodChange(direction: number) {
    if (selectedView === "week") {
      const newDate =
        direction > 0 ? addWeeks(currentTZDate, 1) : subWeeks(currentTZDate, 1);
      setParams({
        date: formatISO(
          startOfWeek(newDate, { weekStartsOn: weekStartsOnMonday ? 1 : 0 }),
          { representation: "date" },
        ),
      });
    } else {
      const newDate =
        direction > 0
          ? addMonths(currentTZDate, 1)
          : subMonths(currentTZDate, 1);
      setParams({
        date: formatISO(newDate, { representation: "date" }),
      });
    }
  }

  useHotkeys("arrowLeft", () => handlePeriodChange(-1), {
    enabled: !selectedDate,
  });

  useHotkeys("arrowRight", () => handlePeriodChange(1), {
    enabled: !selectedDate,
  });

  // @ts-expect-error
  useOnClickOutside(ref, () => {
    if (range && range.length === 1) setParams({ range: null });
  });

  const handleMouseDown = (date: TZDate) => {
    setIsDragging(true);
    const formatted = formatISO(date, { representation: "date" });
    setLocalRange([formatted, null]);
    setParams({ selectedDate: null, range: null });
  };

  const handleMouseEnter = (date: TZDate) => {
    if (isDragging && localRange[0]) {
      setLocalRange((prev) => [
        prev[0],
        formatISO(date, { representation: "date" }),
      ]);
    }
  };

  const handleMouseUp = () => {
    setIsDragging(false);
    if (localRange[0] && localRange[1]) {
      let start = new TZDate(localRange[0], "UTC");
      let end = new TZDate(localRange[1], "UTC");
      if (start > end) [start, end] = [end, start];

      const formattedStart = formatISO(start, { representation: "date" });
      const formattedEnd = formatISO(end, { representation: "date" });

      setParams({
        range: [formattedStart, formattedEnd],
        selectedDate: null,
        eventId: null,
      });
    } else if (localRange[0]) {
      setParams({ selectedDate: localRange[0], range: null, eventId: null });
    }
    setLocalRange([null, null]);
  };

  const handleEventClick = (eventId: string, date: TZDate) => {
    const formattedDate = formatISO(date, { representation: "date" });
    setParams({
      selectedDate: formattedDate,
      eventId: eventId,
      range: null,
    });
  };

  const validRange: [string, string] | null =
    range && range.length === 2 ? [range[0]!, range[1]!] : null;

  return (
    <div ref={ref}>
      <div className="mt-8">
        <CalendarHeader
          totalDuration={data?.meta?.totalDuration}
          selectedView={selectedView as "week" | "month"}
        />
        {selectedView === "month" ? (
          <CalendarMonthView
            firstWeek={firstWeek}
            calendarDays={calendarDays}
            currentDate={currentTZDate}
            selectedDate={selectedDate}
            data={data?.result}
            range={validRange}
            localRange={localRange}
            isDragging={isDragging}
            weekStartsOnMonday={weekStartsOnMonday}
            handleMouseDown={handleMouseDown}
            handleMouseEnter={handleMouseEnter}
            handleMouseUp={handleMouseUp}
            onEventClick={handleEventClick}
          />
        ) : (
          <CalendarWeekView
            weekDays={currentWeekDays}
            currentDate={currentTZDate}
            selectedDate={selectedDate}
            data={data?.result}
            range={validRange}
            localRange={localRange}
            isDragging={isDragging}
            weekStartsOnMonday={weekStartsOnMonday}
            handleMouseDown={handleMouseDown}
            handleMouseEnter={handleMouseEnter}
            handleMouseUp={handleMouseUp}
            onEventClick={handleEventClick}
          />
        )}
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-create-invoice.tsx">
"use client";

import { useInvoiceParams } from "@/hooks/use-invoice-params";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { TZDate } from "@date-fns/tz";
import { Calendar } from "@midday/ui/calendar";
import {
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
} from "@midday/ui/dropdown-menu";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";
import { SubmitButton } from "@midday/ui/submit-button";
import { useToast } from "@midday/ui/use-toast";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import {
  endOfMonth,
  endOfWeek,
  formatISO,
  getDate,
  startOfMonth,
  startOfWeek,
  subMonths,
  subWeeks,
} from "date-fns";
import React, { useState } from "react";
import type { DateRange } from "react-day-picker";

type Props = {
  projectId: string;
  projectName: string;
};

type PresetOption = {
  label: string;
  value: string;
  dateRange: DateRange;
};

const getPresetOptions = (weekStartsOnMonday: boolean): PresetOption[] => {
  const now = new TZDate(new Date(), "UTC");
  const weekStartsOn = weekStartsOnMonday ? 1 : 0;

  return [
    {
      label: "This Week",
      value: "this-week",
      dateRange: {
        from: startOfWeek(now, { weekStartsOn }),
        to: endOfWeek(now, { weekStartsOn }),
      },
    },
    {
      label: "Last Week",
      value: "last-week",
      dateRange: {
        from: startOfWeek(subWeeks(now, 1), { weekStartsOn }),
        to: endOfWeek(subWeeks(now, 1), { weekStartsOn }),
      },
    },
    {
      label: "This Month",
      value: "this-month",
      dateRange: {
        from: startOfMonth(now),
        to: endOfMonth(now),
      },
    },
    {
      label: "Last Month",
      value: "last-month",
      dateRange: {
        from: startOfMonth(subMonths(now, 1)),
        to: endOfMonth(subMonths(now, 1)),
      },
    },
  ];
};

export function TrackerCreateInvoice({ projectId }: Props) {
  const { setParams: setInvoiceParams } = useInvoiceParams();
  const { toast } = useToast();
  const { data: user } = useUserQuery();
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const weekStartsOnMonday = user?.weekStartsOnMonday ?? false;
  const presetOptions = getPresetOptions(weekStartsOnMonday);
  const defaultPreset = "last-month";
  const defaultPresetOption = presetOptions.find(
    (option) => option.value === defaultPreset,
  );

  const [selectedPreset, setSelectedPreset] = useState<string>(defaultPreset);
  const [date, setDate] = useState<DateRange | undefined>(
    defaultPresetOption?.dateRange,
  );

  const createInvoiceFromTrackerMutation = useMutation(
    trpc.invoice.createFromTracker.mutationOptions({
      onSuccess: (data) => {
        // Invalidate invoice queries
        queryClient.invalidateQueries({
          queryKey: trpc.invoice.get.infiniteQueryKey(),
        });

        // Open the created invoice for editing
        if (data?.id) {
          setInvoiceParams({
            type: "edit",
            invoiceId: data.id,
          });
        }
      },
      onError: (error) => {
        let title = "Failed to create invoice";
        let description = "An error occurred while creating the invoice.";

        // Handle specific error codes
        switch (error.message) {
          case "PROJECT_NOT_BILLABLE":
            title = "Project not billable";
            description =
              "This project is not set as billable. Please enable billing for this project in the settings.";
            break;
          case "PROJECT_NO_RATE":
            title = "Missing hourly rate";
            description =
              "This project does not have a valid hourly rate. Please set an hourly rate for this project.";
            break;
          case "NO_TRACKED_HOURS":
            title = "No tracked time";
            description =
              "No tracked hours found for this project in the selected date range. Please track some time first.";
            break;
          case "PROJECT_NOT_FOUND":
            title = "Project not found";
            description = "The selected project could not be found.";
            break;
          default:
            // Use the original error message as fallback
            description = error.message;
        }

        toast({
          title,
          description,
        });
      },
    }),
  );

  const handlePresetSelect = (presetValue: string) => {
    const preset = presetOptions.find((option) => option.value === presetValue);
    if (preset) {
      setSelectedPreset(preset.value);
      setDate(preset.dateRange);
    }
  };

  const handleCreateInvoice = () => {
    if (!date?.from || !date?.to) {
      toast({
        title: "Please select a date range",
        description: "You need to select both start and end dates.",
      });
      return;
    }

    createInvoiceFromTrackerMutation.mutate({
      projectId,
      dateFrom: formatISO(date.from, { representation: "date" }),
      dateTo: formatISO(date.to, { representation: "date" }),
    });
  };

  return (
    <DropdownMenuGroup>
      <DropdownMenuSub>
        <DropdownMenuSubTrigger>Create Invoice</DropdownMenuSubTrigger>
        <DropdownMenuPortal>
          <DropdownMenuSubContent>
            <div className="p-4 space-y-4">
              <Select value={selectedPreset} onValueChange={handlePresetSelect}>
                <SelectTrigger className="w-full">
                  <SelectValue placeholder="Select preset" />
                </SelectTrigger>
                <SelectContent>
                  {presetOptions.map((preset) => (
                    <SelectItem key={preset.value} value={preset.value}>
                      {preset.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>

              <Calendar
                key={selectedPreset}
                className="!p-0 mt-0"
                mode="range"
                selected={date}
                onSelect={(newDate) => {
                  setDate(newDate);
                  setSelectedPreset(""); // Clear preset selection when custom date is selected
                }}
                disabled={(date) => date > new Date()}
                defaultMonth={date?.from}
                weekStartsOn={weekStartsOnMonday ? 1 : 0}
              />

              <SubmitButton
                onClick={handleCreateInvoice}
                className="w-full"
                disabled={!date?.from || !date?.to}
                isSubmitting={createInvoiceFromTrackerMutation.isPending}
              >
                Create Invoice
              </SubmitButton>
            </div>
          </DropdownMenuSubContent>
        </DropdownMenuPortal>
      </DropdownMenuSub>
    </DropdownMenuGroup>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-day-select.tsx">
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { formatDateRange } from "@/utils/format";
import { getTrackerDates } from "@/utils/tracker";
import { TZDate } from "@date-fns/tz";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import { addDays, formatISO, subDays } from "date-fns";
import { useHotkeys } from "react-hotkeys-hook";

type Props = {
  className?: string;
};

export function TrackerDaySelect({ className }: Props) {
  const { setParams, range, selectedDate } = useTrackerParams();
  const currentDate = getTrackerDates(range, selectedDate);

  const selectPrevDay = () => {
    if (currentDate[0]) {
      const prevDay = new TZDate(subDays(currentDate[0], 1), "UTC");
      setParams({
        selectedDate: formatISO(prevDay, { representation: "date" }),
        range: null,
      });
    }
  };

  const selectNextDay = () => {
    if (currentDate[0]) {
      const nextDay = new TZDate(addDays(currentDate[0], 1), "UTC");
      setParams({
        selectedDate: formatISO(nextDay, { representation: "date" }),
        range: null,
      });
    }
  };

  useHotkeys("arrowLeft", selectPrevDay);
  useHotkeys("arrowRight", selectNextDay);

  return (
    <div className={cn("flex items-center border h-9", className)}>
      <Button
        variant="ghost"
        size="icon"
        className="p-0 w-6 h-6 hover:bg-transparent mr-4 ml-2"
        onClick={selectPrevDay}
      >
        <Icons.ChevronLeft className="w-6 h-6" />
      </Button>
      <span className="w-full text-center">
        {formatDateRange(
          range
            ? [
                new TZDate(currentDate[0]?.getTime() ?? 0, "UTC"),
                new TZDate(
                  currentDate[1]?.getTime() ?? currentDate[0]?.getTime() ?? 0,
                  "UTC",
                ),
              ]
            : [new TZDate(currentDate[0]?.getTime() ?? 0, "UTC")],
        )}
      </span>
      <Button
        variant="ghost"
        size="icon"
        className="p-0 w-6 h-6 hover:bg-transparent ml-4 mr-2"
        onClick={selectNextDay}
      >
        <Icons.ChevronRight className="w-6 h-6" />
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-export-csv.tsx">
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { secondsToHoursAndMinutes } from "@/utils/format";
import { Button } from "@midday/ui/button";
import { Calendar } from "@midday/ui/calendar";
import {
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
} from "@midday/ui/dropdown-menu";
import { useQueryClient } from "@tanstack/react-query";
import { endOfMonth, format, startOfMonth } from "date-fns";
import Papa from "papaparse";
import React, { useState } from "react";
import type { DateRange } from "react-day-picker";

interface TrackerEntry {
  date: string;
  description?: string | null;
  duration?: number | null;
  assigned?: { full_name: string } | null;
}

type Props = {
  name: string;
  projectId: string;
};

export function TrackerExportCSV({ name, projectId }: Props) {
  const trpc = useTRPC();
  const { data: user } = useUserQuery();
  const queryClient = useQueryClient();
  const [date, setDate] = useState<DateRange | undefined>({
    from: startOfMonth(new Date()),
    to: endOfMonth(new Date()),
  });

  async function downloadCSV() {
    if (!date?.from || !date?.to) return;

    const queryOptions = trpc.trackerEntries.byRange.queryOptions({
      from: date?.from?.toISOString(),
      to: date?.to?.toISOString(),
      projectId,
    });

    const data = await queryClient.fetchQuery(queryOptions);

    const entries = Object.values(data?.result ?? {}).flat() as TrackerEntry[];

    const formattedData = entries.map((item: TrackerEntry) => {
      const formattedItem: Record<string, string | null> = {
        Date: format(new Date(item.date), user?.dateFormat ?? "P"),
        Description: item.description ?? null,
        Time: secondsToHoursAndMinutes(item.duration ?? 0),
        Assigned: item.assigned?.full_name ?? null,
      };

      return formattedItem;
    });

    const totalTimeInSeconds = data?.meta?.totalDuration ?? 0;

    const dataWithFooter = [
      ...(formattedData ?? []),
      {
        Date: "Total Time",
        Assigned: null,
        Description: null,
        Time: secondsToHoursAndMinutes(totalTimeInSeconds),
      },
    ];

    const csv = Papa.unparse(dataWithFooter);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.href = url;

    link.setAttribute("download", `${name}.csv`);

    document.body.appendChild(link);
    link.click();

    document.body.removeChild(link);
  }

  return (
    <DropdownMenuGroup>
      <DropdownMenuSub>
        <DropdownMenuSubTrigger>Export</DropdownMenuSubTrigger>
        <DropdownMenuPortal>
          <DropdownMenuSubContent>
            <Calendar
              mode="range"
              selected={date}
              onSelect={setDate}
              disabled={(date) => date > new Date()}
              defaultMonth={date?.from}
              weekStartsOn={user?.weekStartsOnMonday ? 1 : 0}
            />

            <div className="p-4 space-y-4">
              <Button onClick={downloadCSV} className="w-full" disabled={!date}>
                Export
              </Button>
            </div>
          </DropdownMenuSubContent>
        </DropdownMenuPortal>
      </DropdownMenuSub>
    </DropdownMenuGroup>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-pagination.tsx">
"use client";

import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import {
  addMonths,
  format,
  formatISO,
  startOfMonth,
  subMonths,
} from "date-fns";

type Props = {
  numberOfMonths: number;
  onChange: (date: string) => void;
  startDate: Date;
};

export function TrackerPagination({
  numberOfMonths,
  onChange,
  startDate,
}: Props) {
  const selectPrevPeriod = () => {
    onChange(
      formatISO(startOfMonth(subMonths(startDate, numberOfMonths)), {
        representation: "date",
      }),
    );
  };

  const selectNextPeriod = () => {
    onChange(
      formatISO(startOfMonth(addMonths(startDate, numberOfMonths)), {
        representation: "date",
      }),
    );
  };

  return (
    <div className="flex items-center border h-9">
      <Button
        variant="ghost"
        size="icon"
        className="p-0 w-6 h-6 hover:bg-transparent mr-4 ml-2"
        onClick={selectPrevPeriod}
      >
        <Icons.ChevronLeft className="w-6 h-6" />
      </Button>
      <span className="w-full text-center">
        {format(subMonths(startDate, numberOfMonths), "MMM")} -{" "}
        {format(startDate, "MMM")}
      </span>
      <Button
        variant="ghost"
        size="icon"
        className="p-0 w-6 h-6 hover:bg-transparent ml-4 mr-2"
        onClick={selectNextPeriod}
      >
        <Icons.ChevronRight className="w-6 h-6" />
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-period-select.tsx">
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { useUserQuery } from "@/hooks/use-user";
import { TZDate } from "@date-fns/tz";
import { Button } from "@midday/ui/button";
import { cn } from "@midday/ui/cn";
import { Icons } from "@midday/ui/icons";
import {
  addMonths,
  addWeeks,
  endOfWeek,
  format,
  formatISO,
  startOfMonth,
  startOfWeek,
} from "date-fns";

type Props = {
  className?: string;
  dateFormat?: string;
};

export function TrackerPeriodSelect({ className, dateFormat = "MMM" }: Props) {
  const { date, view, setParams } = useTrackerParams();
  const { data: user } = useUserQuery();

  const weekStartsOnMonday = user?.weekStartsOnMonday ?? false;
  const currentDate = date
    ? new TZDate(date, "UTC")
    : new TZDate(new Date(), "UTC");

  const selectPrevPeriod = () => {
    if (view === "week") {
      setParams({
        date: formatISO(
          startOfWeek(addWeeks(currentDate, -1), {
            weekStartsOn: weekStartsOnMonday ? 1 : 0,
          }),
          {
            representation: "date",
          },
        ),
      });
    } else {
      setParams({
        date: formatISO(startOfMonth(addMonths(currentDate, -1)), {
          representation: "date",
        }),
      });
    }
  };

  const selectNextPeriod = () => {
    if (view === "week") {
      setParams({
        date: formatISO(
          startOfWeek(addWeeks(currentDate, 1), {
            weekStartsOn: weekStartsOnMonday ? 1 : 0,
          }),
          {
            representation: "date",
          },
        ),
      });
    } else {
      setParams({
        date: formatISO(startOfMonth(addMonths(currentDate, 1)), {
          representation: "date",
        }),
      });
    }
  };

  const getPeriodLabel = () => {
    if (view === "week") {
      const weekStart = startOfWeek(currentDate, {
        weekStartsOn: weekStartsOnMonday ? 1 : 0,
      });
      const weekEnd = endOfWeek(currentDate, {
        weekStartsOn: weekStartsOnMonday ? 1 : 0,
      });

      // If week spans across months, show both months
      if (weekStart.getMonth() !== weekEnd.getMonth()) {
        return `${format(weekStart, "MMM d")} - ${format(weekEnd, "MMM d, yyyy")}`;
      }

      // If same month, show month once
      return `${format(weekStart, "MMM d")} - ${format(weekEnd, "d, yyyy")}`;
    }
    return format(currentDate, dateFormat);
  };

  return (
    <div className={cn("flex items-center border h-9", className)}>
      <Button
        variant="ghost"
        size="icon"
        className="p-0 w-6 h-6 hover:bg-transparent mr-4 ml-2"
        onClick={selectPrevPeriod}
      >
        <Icons.ChevronLeft className="w-6 h-6" />
      </Button>
      <span className="w-full text-center text-sm">{getPeriodLabel()}</span>
      <Button
        variant="ghost"
        size="icon"
        className="p-0 w-6 h-6 hover:bg-transparent ml-4 mr-2"
        onClick={selectNextPeriod}
      >
        <Icons.ChevronRight className="w-6 h-6" />
      </Button>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-schedule.tsx">
"use client";

import { useLatestProjectId } from "@/hooks/use-latest-project-id";
import { useTrackerParams } from "@/hooks/use-tracker-params";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { secondsToHoursAndMinutes } from "@/utils/format";
import {
  NEW_EVENT_ID,
  calculateDuration,
  createSafeDate,
  formatHour,
  getDates,
  getSlotFromDate,
  isValidTimeSlot,
} from "@/utils/tracker";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { TZDate, tz } from "@date-fns/tz";
import { UTCDate } from "@date-fns/utc";
import { cn } from "@midday/ui/cn";
import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuShortcut,
  ContextMenuTrigger,
} from "@midday/ui/context-menu";
import { ScrollArea } from "@midday/ui/scroll-area";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import {
  addDays,
  addMinutes,
  endOfDay,
  format,
  isValid,
  parseISO,
  startOfDay,
} from "date-fns";
import React, { useCallback, useEffect, useRef, useState } from "react";
import { useHotkeys } from "react-hotkeys-hook";
import { TrackerEntriesForm } from "./forms/tracker-entries-form";
import { TrackerDaySelect } from "./tracker-day-select";

/**
 * Converts user input time to UTC using @date-fns/utc
 * @param dateStr - Date in YYYY-MM-DD format
 * @param timeStr - Time in HH:MM format
 * @param timezone - IANA timezone identifier
 * @returns UTC Date object for database storage
 */
const userTimeToUTC = (
  dateStr: string,
  timeStr: string,
  timezone: string,
): Date => {
  try {
    // Create a date in the user's timezone
    const tzDate = tz(timezone);
    const userDate = tzDate(`${dateStr} ${timeStr}`);

    // Return as a regular Date object (which is in UTC)
    return new Date(userDate.getTime());
  } catch (error) {
    console.warn("Timezone conversion failed, falling back to UTC:", {
      dateStr,
      timeStr,
      timezone,
      error,
    });
    // Safe fallback: treat input as UTC using UTCDate
    return new UTCDate(`${dateStr}T${timeStr}:00Z`);
  }
};

/**
 * Displays UTC timestamp in user's preferred timezone using native APIs
 * @param utcDate - UTC Date from database
 * @param timezone - IANA timezone identifier
 * @returns Formatted time string (HH:MM)
 */
const displayInUserTimezone = (utcDate: Date, timezone: string): string => {
  try {
    // Use native Intl API for reliable timezone conversion
    return utcDate.toLocaleString("en-US", {
      timeZone: timezone,
      hour12: false,
      hour: "2-digit",
      minute: "2-digit",
    });
  } catch (error) {
    console.warn("Timezone display failed, using UTC:", { timezone, error });
    // Fallback to UTC formatting
    return utcDate.toLocaleString("en-US", {
      hour12: false,
      hour: "2-digit",
      minute: "2-digit",
      timeZone: "UTC",
    });
  }
};

/**
 * Converts UTC timestamp to visual slot position using tz() function
 * @param dateStr - UTC timestamp string or null
 * @param userTimezone - User's timezone for display
 * @returns Slot index (0 = midnight, 95 = 23:45)
 */
const safeGetSlot = (dateStr: string | null, userTimezone?: string): number => {
  if (!dateStr) return 0;

  const utcDate = createSafeDate(dateStr);
  const timezone = userTimezone || "UTC";

  try {
    // Use tz() function to create timezone-aware date
    const createTZDate = tz(timezone);
    const tzDate = createTZDate(utcDate);

    const hour = tzDate.getHours();
    const minute = tzDate.getMinutes();
    const slot = hour * 4 + Math.floor(minute / 15);

    return slot;
  } catch (error) {
    console.warn("Slot calculation failed, using native API:", {
      timezone,
      error,
    });
    // Fallback to native toLocaleString
    const userTimeStr = utcDate.toLocaleString("en-US", {
      timeZone: timezone,
      hour12: false,
      hour: "2-digit",
      minute: "2-digit",
    });

    const [hourStr, minuteStr] = userTimeStr.split(":");
    const hour = Number(hourStr) || 0;
    const minute = Number(minuteStr) || 0;

    return hour * 4 + Math.floor(minute / 15);
  }
};

/**
 * Gets user's timezone with safe fallback
 * @param user - User object with timezone property
 * @returns IANA timezone string
 */
const getUserTimezone = (user?: { timezone?: string | null }): string => {
  return user?.timezone || "UTC";
};

/**
 * Safely formats UTC timestamp for display using library functions
 * @param dateStr - UTC timestamp string
 * @param userTimezone - User's display timezone
 * @returns Formatted time string
 */
const safeFormatTime = (
  dateStr: string | null,
  userTimezone?: string,
): string => {
  if (!dateStr) return "";

  try {
    const utcDate = createSafeDate(dateStr);
    const timezone = userTimezone || "UTC";

    // Try using tz() function first
    const createTZDate = tz(timezone);
    const tzDate = createTZDate(utcDate);

    return format(tzDate, "HH:mm");
  } catch (error) {
    console.warn("Time formatting with tz() failed, using native API:", error);
    // Fallback to displayInUserTimezone
    return displayInUserTimezone(
      createSafeDate(dateStr),
      userTimezone || "UTC",
    );
  }
};

/**
 * Safely calculates duration between timestamps
 * @param start - Start timestamp string
 * @param stop - Stop timestamp string
 * @returns Duration in seconds
 */
const safeCalculateDuration = (
  start: string | null,
  stop: string | null,
): number => {
  if (!start || !stop) return 0;
  return calculateDuration(createSafeDate(start), createSafeDate(stop));
};

type TrackerRecord = NonNullable<
  RouterOutputs["trackerEntries"]["byDate"]["data"]
>[number];

type ProcessedScheduleEntry = TrackerRecord & {
  isFirstPart: boolean;
  originalDuration: number | null;
  displayStart: string | null;
  displayStop: string | null;
};

type PositionedScheduleEntry = ProcessedScheduleEntry & {
  column: number;
  totalColumns: number;
  width: number;
  left: number;
  leftPx?: number; // For pixel-based left positioning in cascading layout
};

/**
 * Detect if two events overlap in time
 */
const eventsOverlap = (
  event1: ProcessedScheduleEntry,
  event2: ProcessedScheduleEntry,
): boolean => {
  if (
    !event1.displayStart ||
    !event1.displayStop ||
    !event2.displayStart ||
    !event2.displayStop
  ) {
    return false;
  }

  const event1Start = new Date(event1.displayStart).getTime();
  const event1End = new Date(event1.displayStop).getTime();
  const event2Start = new Date(event2.displayStart).getTime();
  const event2End = new Date(event2.displayStop).getTime();

  return event1Start < event2End && event2Start < event1End;
};

/**
 * Group overlapping events and calculate positioning
 */
const calculateScheduleEventPositions = (
  entries: ProcessedScheduleEntry[],
): PositionedScheduleEntry[] => {
  if (entries.length === 0) return [];

  // Sort events by start time, then by duration (longer events first)
  const sortedEntries = [...entries].sort((a, b) => {
    if (a.displayStart && b.displayStart) {
      const aStart = new Date(a.displayStart).getTime();
      const bStart = new Date(b.displayStart).getTime();
      if (aStart !== bStart) {
        return aStart - bStart;
      }
    }
    // If start times are the same, put longer events first
    const aDuration =
      a.displayStart && a.displayStop
        ? new Date(a.displayStop).getTime() - new Date(a.displayStart).getTime()
        : 0;
    const bDuration =
      b.displayStart && b.displayStop
        ? new Date(b.displayStop).getTime() - new Date(b.displayStart).getTime()
        : 0;
    return bDuration - aDuration;
  });

  // Build overlap groups using a more robust algorithm
  const overlapGroups: ProcessedScheduleEntry[][] = [];
  const processed = new Set<ProcessedScheduleEntry>();

  for (const entry of sortedEntries) {
    if (processed.has(entry)) continue;

    // Start a new group with this entry
    const currentGroup: ProcessedScheduleEntry[] = [entry];
    processed.add(entry);

    // Keep expanding the group until no more overlaps are found
    let foundNewOverlap = true;
    while (foundNewOverlap) {
      foundNewOverlap = false;

      for (const candidate of sortedEntries) {
        if (processed.has(candidate)) continue;

        // Check if this candidate overlaps with ANY event in the current group
        const overlapsWithGroup = currentGroup.some((groupEntry) =>
          eventsOverlap(candidate, groupEntry),
        );

        if (overlapsWithGroup) {
          currentGroup.push(candidate);
          processed.add(candidate);
          foundNewOverlap = true;
          // Don't break here - keep checking other candidates in this iteration
        }
      }
    }

    overlapGroups.push(currentGroup);
  }

  const positionedEntries: PositionedScheduleEntry[] = [];

  // Process each overlap group separately
  for (const group of overlapGroups) {
    if (group.length === 1) {
      // Single event - no overlap, use full width
      const entry = group[0];
      if (entry) {
        positionedEntries.push({
          ...entry,
          column: 0,
          totalColumns: 1,
          width: 100,
          left: 0,
        });
      }
    } else {
      // Multiple overlapping events - use cascading/staggered layout

      // Sort group by start time for proper stacking order
      const sortedGroup = [...group].sort((a, b) => {
        if (a.displayStart && b.displayStart) {
          const aStart = new Date(a.displayStart).getTime();
          const bStart = new Date(b.displayStart).getTime();
          if (aStart !== bStart) {
            return aStart - bStart;
          }
        }
        const aDuration =
          a.displayStart && a.displayStop
            ? new Date(a.displayStop).getTime() -
              new Date(a.displayStart).getTime()
            : 0;
        const bDuration =
          b.displayStart && b.displayStop
            ? new Date(b.displayStop).getTime() -
              new Date(b.displayStart).getTime()
            : 0;
        return bDuration - aDuration;
      });

      sortedGroup.forEach((entry, index) => {
        // Cascading layout parameters
        const offsetStep = 8; // Pixels to offset each event
        const baseWidth = 80; // Width for overlapping events (not the base)
        const widthReduction = 3; // How much to reduce width for each subsequent event

        // Calculate cascading properties
        const totalEvents = sortedGroup.length;

        // First event (index 0) gets full width, others get progressively smaller
        const width =
          index === 0
            ? 100
            : Math.max(60, baseWidth - (index - 1) * widthReduction);

        // Each event is offset to the right (except the first one)
        const leftOffset = index * offsetStep;
        const left = leftOffset;

        positionedEntries.push({
          ...entry,
          column: index,
          totalColumns: totalEvents,
          width,
          left,
          // Add a custom property for pixel-based left positioning
          leftPx: leftOffset,
        });
      });
    }
  }

  return positionedEntries;
};

const ROW_HEIGHT = 36;
const SLOT_HEIGHT = 9;

/**
 * Creates new tracker event from user interaction
 * @param slot - Visual slot position (0-95)
 * @param selectedProjectId - Project ID or null
 * @param selectedDate - Date string or null
 * @param projects - Available projects data
 * @param user - User object with timezone
 * @returns New TrackerRecord
 */
const createNewEvent = (
  slot: number,
  selectedProjectId: string | null,
  selectedDate?: string | null,
  projects?: RouterOutputs["trackerProjects"]["get"]["data"],
  user?: { timezone?: string | null },
): TrackerRecord => {
  // Get base date for event
  let baseDate: Date;
  if (selectedDate) {
    baseDate = parseISO(selectedDate);
  } else {
    const timezone = getUserTimezone(user);
    try {
      const now = new Date();
      const userTzDate = new TZDate(now, timezone);
      baseDate = startOfDay(userTzDate);
    } catch (error) {
      console.warn("Today calculation failed, using system date:", error);
      baseDate = new Date();
    }
  }
  const dateStr = format(baseDate, "yyyy-MM-dd");
  const timezone = getUserTimezone(user);

  // Convert slot to time
  const hour = Math.floor(slot / 4);
  const minute = (slot % 4) * 15;
  const startTimeStr = `${String(hour).padStart(2, "0")}:${String(minute).padStart(2, "0")}`;

  // 15-minute default duration
  const endMinute = minute + 15;
  const endHour = endMinute >= 60 ? hour + 1 : hour;
  const finalEndMinute = endMinute >= 60 ? endMinute - 60 : endMinute;
  const endTimeStr = `${String(endHour).padStart(2, "0")}:${String(finalEndMinute).padStart(2, "0")}`;

  // Convert to UTC for storage
  const startDate = userTimeToUTC(dateStr, startTimeStr, timezone);
  const endDate = userTimeToUTC(dateStr, endTimeStr, timezone);

  // Find project details
  const selectedProject = projects?.find((p) => p.id === selectedProjectId);

  return {
    id: NEW_EVENT_ID,
    date: format(baseDate, "yyyy-MM-dd"),
    description: null,
    duration: 15 * 60,
    start: startDate.toISOString(),
    stop: endDate.toISOString(),
    user: null,
    trackerProject: selectedProjectId
      ? {
          id: selectedProjectId,
          name: selectedProject?.name || "",
          currency: selectedProject?.currency || null,
          rate: selectedProject?.rate || null,
          customer: selectedProject?.customer || null,
        }
      : null,
  };
};

const updateEventTime = (
  event: TrackerRecord,
  start: Date,
  stop: Date,
): TrackerRecord => {
  return {
    ...event,
    start: start.toISOString(),
    stop: stop.toISOString(),
    duration: calculateDuration(start, stop),
  };
};

// Hook for managing tracker data
const useTrackerData = (selectedDate: string | null) => {
  const trpc = useTRPC();
  const { setParams: setTrackerParams } = useTrackerParams();
  const queryClient = useQueryClient();
  const [data, setData] = useState<TrackerRecord[]>([]);
  const [totalDuration, setTotalDuration] = useState(0);

  const { data: trackerData, refetch } = useQuery({
    ...trpc.trackerEntries.byDate.queryOptions(
      { date: selectedDate ?? "" },
      {
        enabled: !!selectedDate,
      },
    ),
  });

  const deleteTrackerEntry = useMutation(
    trpc.trackerEntries.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.trackerEntries.byRange.queryKey(),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.trackerProjects.get.infiniteQueryKey(),
        });
        refetch();
      },
    }),
  );

  const upsertTrackerEntry = useMutation(
    trpc.trackerEntries.upsert.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.trackerEntries.byRange.queryKey(),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.trackerProjects.get.infiniteQueryKey(),
        });
        refetch();

        // Close the tracker project form
        setTrackerParams({ selectedDate: null });
      },
    }),
  );

  // Process API data
  useEffect(() => {
    if (trackerData?.data) {
      setData(trackerData.data);
      setTotalDuration(trackerData.meta?.totalDuration || 0);
    } else {
      setData([]);
      setTotalDuration(0);
    }
  }, [trackerData]);

  return {
    data,
    setData,
    totalDuration,
    deleteTrackerEntry,
    upsertTrackerEntry,
  };
};

// Hook for managing selected event
const useSelectedEvent = () => {
  const [selectedEvent, setSelectedEvent] = useState<TrackerRecord | null>(
    null,
  );

  const selectEvent = useCallback((event: TrackerRecord | null) => {
    setSelectedEvent(event);
  }, []);

  const clearNewEvent = useCallback(
    (setData: React.Dispatch<React.SetStateAction<TrackerRecord[]>>) => {
      if (selectedEvent?.id === NEW_EVENT_ID) {
        setData((prevData) => prevData.filter((e) => e.id !== NEW_EVENT_ID));
        setSelectedEvent(null);
      }
    },
    [selectedEvent],
  );

  return {
    selectedEvent,
    selectEvent,
    clearNewEvent,
  };
};

export function TrackerSchedule() {
  const { data: user } = useUserQuery();
  const {
    selectedDate,
    range,
    projectId: urlProjectId,
    eventId,
    setParams,
  } = useTrackerParams();
  const { latestProjectId } = useLatestProjectId();
  const scrollRef = useRef<HTMLDivElement>(null);
  const trpc = useTRPC();

  // Load projects to get project names
  const { data: projectsData } = useQuery(
    trpc.trackerProjects.get.queryOptions({
      pageSize: 100,
    }),
  );

  const {
    data,
    setData,
    totalDuration,
    deleteTrackerEntry,
    upsertTrackerEntry,
  } = useTrackerData(selectedDate);

  const { selectedEvent, selectEvent, clearNewEvent } = useSelectedEvent();

  // State to force re-render for running timers
  const [currentTime, setCurrentTime] = useState(new Date());

  // Update current time every 5 seconds for running timers
  useEffect(() => {
    // Check if any running timers exist (no stop time)
    const hasRunningTimers = data.some(
      (event) => !event.stop || event.stop === null,
    );

    if (hasRunningTimers) {
      const interval = setInterval(() => {
        setCurrentTime(new Date());
      }, 5000); // Update every 5 seconds for better visual feedback

      return () => clearInterval(interval);
    }
  }, [data]);
  const hasScrolledForEventId = useRef<string | null>(null);

  // Auto-select event when eventId is present in URL
  useEffect(() => {
    if (eventId && data.length > 0) {
      const eventToSelect = data.find((event) => event.id === eventId);
      if (eventToSelect) {
        selectEvent(eventToSelect);

        // Auto-scroll to the event position only once per eventId
        if (scrollRef.current && hasScrolledForEventId.current !== eventId) {
          const userTimezone = getUserTimezone(user);
          const startSlot = safeGetSlot(eventToSelect.start, userTimezone);
          const scrollPosition = startSlot * SLOT_HEIGHT;

          // Add some padding to center the event better
          const containerHeight = scrollRef.current.clientHeight;
          const adjustedScrollPosition = Math.max(
            0,
            scrollPosition - containerHeight / 3,
          );

          scrollRef.current.scrollTo({
            top: adjustedScrollPosition,
            behavior: "smooth",
          });

          // Mark that we've scrolled for this eventId
          hasScrolledForEventId.current = eventId;
        }
      }
    }
  }, [eventId, data, selectEvent]);

  // Reset scroll tracking when eventId changes
  useEffect(() => {
    if (!eventId) {
      hasScrolledForEventId.current = null;
    }
  }, [eventId]);

  // Interaction state
  const [isDragging, setIsDragging] = useState(false);
  const [dragStartSlot, setDragStartSlot] = useState<number | null>(null);
  const [resizingEvent, setResizingEvent] = useState<TrackerRecord | null>(
    null,
  );
  const [resizeStartY, setResizeStartY] = useState(0);
  const [resizeType, setResizeType] = useState<"top" | "bottom" | null>(null);
  const [movingEvent, setMovingEvent] = useState<TrackerRecord | null>(null);
  const [moveStartY, setMoveStartY] = useState(0);
  const [isContextMenuOpen, setIsContextMenuOpen] = useState(false);
  const [selectedProjectId, setSelectedProjectId] = useState<string | null>(
    urlProjectId || latestProjectId || null,
  );

  // Update selectedProjectId when URL projectId or latestProjectId changes
  useEffect(() => {
    setSelectedProjectId(urlProjectId || latestProjectId || null);
  }, [urlProjectId, latestProjectId]);

  const hours = Array.from({ length: 24 }, (_, i) => i);
  const sortedRange = range?.sort((a, b) => a.localeCompare(b));

  // Scroll to appropriate time on mount (using user timezone)
  useEffect(() => {
    if (scrollRef.current) {
      let currentHour: number;
      try {
        const timezone = getUserTimezone(user);
        const now = new Date();
        const userTzDate = new TZDate(now, timezone);
        currentHour = userTzDate.getHours();
      } catch (error) {
        console.warn("TZDate current hour calculation failed:", error);
        currentHour = new Date().getHours();
      }

      if (currentHour >= 12) {
        scrollRef.current.scrollTo({ top: scrollRef.current.scrollHeight });
      } else {
        scrollRef.current.scrollTo({ top: ROW_HEIGHT * 6 });
      }
    }
  }, [user]);

  // Event handlers
  const handleDeleteEvent = useCallback(
    (eventId: string) => {
      if (eventId !== NEW_EVENT_ID) {
        deleteTrackerEntry.mutate({ id: eventId });
        setData((prevData) => prevData.filter((event) => event.id !== eventId));
        selectEvent(null);
      }
    },
    [deleteTrackerEntry, setData, selectEvent],
  );

  const getBaseDate = useCallback(() => {
    if (selectedDate) {
      return parseISO(selectedDate);
    }

    // Get "today" in user's timezone, not browser timezone
    const userTimezone = getUserTimezone(user);
    try {
      const now = new Date();
      const userTzDate = new TZDate(now, userTimezone);
      return startOfDay(userTzDate);
    } catch (error) {
      console.warn("TZDate today calculation failed:", error);
      return startOfDay(new Date());
    }
  }, [selectedDate, user]);

  const handleCreateEvent = useCallback(
    (formValues: {
      id?: string;
      duration: number;
      projectId: string;
      start: string;
      stop: string;
      assignedId?: string;
      description?: string;
    }) => {
      const baseDate = getBaseDate();
      const dateStr = format(baseDate, "yyyy-MM-dd");
      const timezone = getUserTimezone(user);

      // Handle next day stop time (e.g., 23:00-01:00)
      const startHour = Number.parseInt(
        formValues.start.split(":")[0] || "0",
        10,
      );
      const stopHour = Number.parseInt(
        formValues.stop.split(":")[0] || "0",
        10,
      );
      const isNextDay = stopHour < startHour;

      const stopDateStr = isNextDay
        ? format(addDays(baseDate, 1), "yyyy-MM-dd")
        : dateStr;

      // Convert user timezone input to UTC for storage
      const startDate = userTimeToUTC(dateStr, formValues.start, timezone);
      const stopDate = userTimeToUTC(stopDateStr, formValues.stop, timezone);

      if (!isValid(startDate) || !isValid(stopDate)) {
        console.warn("Invalid dates created:", { startDate, stopDate });
        return;
      }

      // Calculate dates array based on where the user expects to see the entry
      // Store entries under the date where they visually start from the user's perspective
      let dates: string[];

      if (sortedRange && sortedRange.length > 0) {
        // For range selections, use the original range logic
        dates = getDates(selectedDate, sortedRange);
      } else {
        // For single date entries, store under the date the user selected
        // The UI will handle displaying the split correctly
        dates = [dateStr];
      }

      const apiData = {
        id: formValues.id === NEW_EVENT_ID ? undefined : formValues.id,
        start: startDate.toISOString(),
        stop: stopDate.toISOString(),
        dates,
        projectId: formValues.projectId,
        description: formValues.description || null,
        duration: formValues.duration,
        assignedId: user?.id || null,
      };

      upsertTrackerEntry.mutate(apiData);
    },
    [selectedDate, sortedRange, getBaseDate, upsertTrackerEntry, user],
  );

  const handleMouseDown = useCallback(
    (slot: number) => {
      if (!isValidTimeSlot(slot)) return;

      clearNewEvent(setData);
      setIsDragging(true);
      setDragStartSlot(slot);

      // Clear eventId when creating a new event
      if (eventId) {
        setParams({ eventId: null });
      }

      const newEvent = createNewEvent(
        slot,
        selectedProjectId,
        selectedDate,
        projectsData?.data,
        user,
      );
      setData((prevData) => [...prevData, newEvent]);
      selectEvent(newEvent);
    },
    [
      clearNewEvent,
      setData,
      selectedProjectId,
      selectedDate,
      selectEvent,
      projectsData,
      eventId,
      setParams,
      user?.timezone,
    ],
  );

  const handleMouseMove = useCallback(
    (e: React.MouseEvent) => {
      const rect = e.currentTarget.getBoundingClientRect();
      const y = e.clientY - rect.top;
      const slot = Math.floor(y / SLOT_HEIGHT);

      if (isDragging && dragStartSlot !== null && selectedEvent) {
        const start = Math.min(dragStartSlot, slot);
        const end = Math.max(dragStartSlot, slot);

        // Use timezone-aware time creation instead of browser timezone
        const dateStr = format(getBaseDate(), "yyyy-MM-dd");
        const timezone = getUserTimezone(user);
        const startHour = Math.floor(start / 4);
        const startMinute = (start % 4) * 15;
        const startTimeStr = `${String(startHour).padStart(2, "0")}:${String(startMinute).padStart(2, "0")}`;

        const startDate = userTimeToUTC(dateStr, startTimeStr, timezone);
        const endDate = new Date(
          startDate.getTime() + (end - start + 1) * 15 * 60 * 1000,
        );

        const updatedEvent = updateEventTime(selectedEvent, startDate, endDate);
        setData((prevData) =>
          prevData.map((event) =>
            event.id === selectedEvent.id ? updatedEvent : event,
          ),
        );
        selectEvent(updatedEvent);
      } else if (resizingEvent && resizingEvent.id !== NEW_EVENT_ID) {
        const deltaY = e.clientY - resizeStartY;
        const deltaSlots = Math.round(deltaY / SLOT_HEIGHT);

        if (resizeType === "bottom") {
          const currentStop = createSafeDate(resizingEvent.stop);
          const newEnd = addMinutes(currentStop, deltaSlots * 15);
          const currentStart = createSafeDate(resizingEvent.start);
          const updatedEvent = updateEventTime(
            resizingEvent,
            currentStart,
            newEnd,
          );
          setData((prevData) =>
            prevData.map((event) =>
              event.id === resizingEvent.id ? updatedEvent : event,
            ),
          );
          selectEvent(updatedEvent);
        } else if (resizeType === "top") {
          const currentStart = createSafeDate(resizingEvent.start);
          const newStart = addMinutes(currentStart, deltaSlots * 15);
          const currentStop = createSafeDate(resizingEvent.stop);
          const updatedEvent = updateEventTime(
            resizingEvent,
            newStart,
            currentStop,
          );
          setData((prevData) =>
            prevData.map((event) =>
              event.id === resizingEvent.id ? updatedEvent : event,
            ),
          );
          selectEvent(updatedEvent);
        }
      } else if (movingEvent) {
        const deltaY = e.clientY - moveStartY;
        const deltaSlots = Math.round(deltaY / SLOT_HEIGHT);
        const currentStart = createSafeDate(movingEvent.start);
        const currentStop = createSafeDate(movingEvent.stop);
        const newStart = addMinutes(currentStart, deltaSlots * 15);
        const newEnd = addMinutes(currentStop, deltaSlots * 15);

        // Ensure the event doesn't move before start of day or after end of day
        const dayStart = startOfDay(currentStart);
        const dayEnd = endOfDay(currentStart);

        if (newStart >= dayStart && newEnd <= dayEnd) {
          const updatedEvent = updateEventTime(movingEvent, newStart, newEnd);
          setData((prevData) =>
            prevData.map((event) =>
              event.id === movingEvent.id ? updatedEvent : event,
            ),
          );
          selectEvent(updatedEvent);
        }
      }
    },
    [
      isDragging,
      dragStartSlot,
      selectedEvent,
      resizingEvent,
      resizeStartY,
      resizeType,
      movingEvent,
      moveStartY,
      getBaseDate,
      setData,
      selectEvent,
    ],
  );

  const handleMouseUp = useCallback(() => {
    setIsDragging(false);
    setDragStartSlot(null);
    setResizingEvent(null);
    setResizeType(null);
    setMovingEvent(null);
  }, []);

  // Mouse event listeners
  useEffect(() => {
    window.addEventListener("mouseup", handleMouseUp);
    return () => window.removeEventListener("mouseup", handleMouseUp);
  }, [handleMouseUp]);

  // Keyboard shortcuts
  useHotkeys(
    "backspace",
    () => {
      if (selectedEvent && selectedEvent.id !== NEW_EVENT_ID) {
        handleDeleteEvent(selectedEvent.id);
      }
    },
    [selectedEvent, handleDeleteEvent],
  );

  const handleEventResizeStart = useCallback(
    (e: React.MouseEvent, event: TrackerRecord, type: "top" | "bottom") => {
      if (event.id !== NEW_EVENT_ID) {
        e.stopPropagation();
        setResizingEvent(event);
        setResizeStartY(e.clientY);
        setResizeType(type);
        selectEvent(event);
      }
    },
    [selectEvent],
  );

  const handleEventMoveStart = useCallback(
    (e: React.MouseEvent, event: TrackerRecord) => {
      e.stopPropagation();
      clearNewEvent(setData);
      setMovingEvent(event);
      setMoveStartY(e.clientY);
      selectEvent(event);
    },
    [clearNewEvent, setData, selectEvent],
  );

  const handleEventClick = useCallback(
    (event: TrackerRecord) => {
      clearNewEvent(setData);
      selectEvent(event);
    },
    [clearNewEvent, setData, selectEvent],
  );

  const handleTimeChange = useCallback(
    ({ start, end }: { start?: string; end?: string }) => {
      const baseDate = getBaseDate();
      let currentEvent = data.find((ev) => ev.id === selectedEvent?.id) || null;
      let eventCreated = false;

      const isCompleteStartTime =
        start && (/^\d{4}$/.test(start) || /^\d{2}:\d{2}$/.test(start));

      if (
        start &&
        isCompleteStartTime &&
        !currentEvent &&
        !data.some((ev) => ev.id === NEW_EVENT_ID)
      ) {
        // Format HHMM to HH:mm if necessary
        let formattedStartTimeStr = start;
        if (/^\d{4}$/.test(start)) {
          formattedStartTimeStr = `${start.substring(0, 2)}:${start.substring(2)}`;
        }

        // Use timezone-aware parsing instead of browser timezone
        const dateStr = format(baseDate, "yyyy-MM-dd");
        const timezone = getUserTimezone(user);
        const startTime = userTimeToUTC(
          dateStr,
          formattedStartTimeStr,
          timezone,
        );

        if (isValid(startTime)) {
          const endTime = new Date(startTime.getTime() + 15 * 60 * 1000);

          // Clear eventId when creating a new event
          if (eventId) {
            setParams({ eventId: null });
          }

          const timezone = getUserTimezone(user);
          const newEvent = createNewEvent(
            getSlotFromDate(startTime, timezone),
            selectedProjectId,
            selectedDate,
            projectsData?.data,
            user,
          );

          if (newEvent) {
            const timedNewEvent = updateEventTime(newEvent, startTime, endTime);
            setData((prevData) => [
              ...prevData.filter((ev) => ev.id !== NEW_EVENT_ID),
              timedNewEvent,
            ]);
            selectEvent(timedNewEvent);
            currentEvent = timedNewEvent;
            eventCreated = true;
          }
        }
      } else if (currentEvent && !eventCreated) {
        if (start !== undefined || end !== undefined) {
          let newStart: Date = createSafeDate(currentEvent.start);
          let startChanged = false;

          if (start !== undefined) {
            const isCompleteFormat =
              /^\d{4}$/.test(start) || /^\d{2}:\d{2}$/.test(start);
            if (isCompleteFormat) {
              let formattedStart = start;
              if (/^\d{4}$/.test(start))
                formattedStart = `${start.substring(0, 2)}:${start.substring(2)}`;

              // Use timezone-aware parsing instead of browser timezone
              const dateStr = format(baseDate, "yyyy-MM-dd");
              const timezone = getUserTimezone(user);
              const parsedStart = userTimeToUTC(
                dateStr,
                formattedStart,
                timezone,
              );

              if (
                isValid(parsedStart) &&
                parsedStart.getTime() !== newStart.getTime()
              ) {
                newStart = parsedStart;
                startChanged = true;
              }
            }
          }

          let newEnd: Date = createSafeDate(currentEvent.stop);
          let endChanged = false;

          if (end !== undefined) {
            const isCompleteFormat =
              /^\d{4}$/.test(end) || /^\d{2}:\d{2}$/.test(end);
            if (isCompleteFormat) {
              let formattedEnd = end;
              if (/^\d{4}$/.test(end))
                formattedEnd = `${end.substring(0, 2)}:${end.substring(2)}`;

              // Use timezone-aware parsing instead of browser timezone
              const dateStr = format(baseDate, "yyyy-MM-dd");
              const timezone = getUserTimezone(user);
              const parsedEnd = userTimeToUTC(dateStr, formattedEnd, timezone);

              if (
                isValid(parsedEnd) &&
                parsedEnd.getTime() !== newEnd.getTime()
              ) {
                newEnd = parsedEnd;
                endChanged = true;
              }
            }
          }

          if (
            (startChanged || endChanged) &&
            isValid(newStart) &&
            isValid(newEnd)
          ) {
            // If end time is before start time, assume it's on the next day
            if (newEnd < newStart) {
              newEnd = addDays(newEnd, 1);
            }

            const updatedEvent = updateEventTime(
              currentEvent,
              newStart,
              newEnd,
            );
            setData((prevData) =>
              prevData.map((event) =>
                event.id === currentEvent?.id ? updatedEvent : event,
              ),
            );
            if (selectedEvent?.id === currentEvent.id) {
              selectEvent(updatedEvent);
            }
          }
        }
      }
    },
    [
      getBaseDate,
      data,
      selectedEvent,
      selectedProjectId,
      selectedDate,
      setData,
      selectEvent,
      projectsData,
      eventId,
      setParams,
      user?.timezone,
    ],
  );

  const handleSelectProject = useCallback(
    (project: { id: string; name: string }) => {
      setSelectedProjectId(project.id);

      const eventToUpdate = data.find((ev) => ev.id === selectedEvent?.id);
      if (eventToUpdate) {
        const updatedEvent = {
          ...eventToUpdate,
          trackerProject: {
            id: project.id,
            name: project.name,
            currency: null,
            rate: null,
            customer: null,
          },
        };

        setData((prevData) =>
          prevData.map((ev) =>
            ev.id === eventToUpdate.id ? updatedEvent : ev,
          ),
        );

        selectEvent(updatedEvent);

        if (eventToUpdate.id !== NEW_EVENT_ID) {
          const duration = safeCalculateDuration(
            eventToUpdate.start,
            eventToUpdate.stop,
          );
          handleCreateEvent({
            id: eventToUpdate.id,
            start: safeFormatTime(
              eventToUpdate.start,
              user?.timezone ? user.timezone : undefined,
            ),
            stop: safeFormatTime(
              eventToUpdate.stop,
              user?.timezone ? user.timezone : undefined,
            ),
            projectId: project.id,
            description: eventToUpdate.description ?? undefined,
            duration: duration,
          });
        }
      }
    },
    [
      data,
      selectedEvent,
      setData,
      selectEvent,
      handleCreateEvent,
      user?.timezone,
    ],
  );

  const renderScheduleEntries = () => {
    // Process events to handle midnight spanning
    const processedEntries: ProcessedScheduleEntry[] = [];

    if (data) {
      for (const event of data) {
        const startDate = createSafeDate(event.start);
        const endDate = createSafeDate(event.stop);

        // Check if this entry spans midnight by comparing dates in user timezone
        const timezone = getUserTimezone(user);

        // Use TZDate for reliable timezone conversion
        let spansMidnight: boolean;
        let startDateStr: string;
        try {
          const startTzDate = new TZDate(startDate, timezone);
          const endTzDate = new TZDate(endDate, timezone);
          // Use date-fns format with timezone-aware dates
          startDateStr = format(startTzDate, "yyyy-MM-dd");
          const endDateStr = format(endTzDate, "yyyy-MM-dd");

          spansMidnight = startDateStr !== endDateStr;
        } catch (error) {
          console.warn("TZDate midnight detection failed:", error);
          // Fallback to toLocaleString
          startDateStr = startDate.toLocaleString("en-CA", {
            timeZone: timezone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
          });
          const endDateStr = endDate.toLocaleString("en-CA", {
            timeZone: timezone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
          });
          spansMidnight = startDateStr !== endDateStr;
        }

        if (spansMidnight) {
          // This is a split entry - only show the first part (with → arrow)
          // Get current date in user timezone for midnight-spanning comparison
          let currentSelectedDate: string;
          if (selectedDate) {
            currentSelectedDate = selectedDate;
          } else {
            const timezone = getUserTimezone(user);
            try {
              const now = new Date();
              const userTzDate = new TZDate(now, timezone);
              currentSelectedDate = format(userTzDate, "yyyy-MM-dd");
            } catch (error) {
              console.warn("TZDate today formatting failed:", error);
              currentSelectedDate = format(new Date(), "yyyy-MM-dd");
            }
          }

          if (startDateStr === currentSelectedDate) {
            // This is the first part of the entry (ends at midnight in user timezone)
            // Calculate end of day in user timezone, then convert back to UTC
            const timezone = getUserTimezone(user);
            const nextDay = format(
              addDays(parseISO(currentSelectedDate), 1),
              "yyyy-MM-dd",
            );
            const endOfDayUtc = userTimeToUTC(nextDay, "00:00", timezone);

            const firstPartDuration = Math.round(
              (endOfDayUtc.getTime() - startDate.getTime()) / 1000,
            );

            processedEntries.push({
              ...event,
              duration: firstPartDuration,
              isFirstPart: true,
              originalDuration: event.duration ?? null,
              displayStart: event.start ?? null,
              displayStop: endOfDayUtc.toISOString() ?? null,
            });
          }
          // Skip the continuation part for the next day
        } else {
          // Normal entry that doesn't span midnight
          processedEntries.push({
            ...event,
            isFirstPart: false,
            originalDuration: event.duration ?? null,
            displayStart: event.start ?? null,
            displayStop: event.stop ?? null,
          });
        }
      }
    }

    // Calculate positions for overlapping events
    const positionedEntries = calculateScheduleEventPositions(processedEntries);

    return positionedEntries.map((event) => {
      const userTimezone = getUserTimezone(user);
      const startSlot = safeGetSlot(event.displayStart, userTimezone);
      let endSlot: number;
      let isRunningTimer = false;

      // Check if this is a running timer (no stop time)
      if (!event.displayStop || event.stop === null) {
        isRunningTimer = true;
        // Calculate current time slot for running timer using state
        const currentSlot = safeGetSlot(
          currentTime.toISOString(),
          userTimezone,
        );
        // Ensure running timer doesn't extend beyond current time
        endSlot = Math.max(startSlot + 1, currentSlot); // At least 1 slot minimum
      } else {
        // For midnight-spanning entries, extend to end of day
        if (event.isFirstPart) {
          endSlot = 96; // 24 hours * 4 slots = 96 (end of day)
        } else {
          endSlot = safeGetSlot(event.displayStop, userTimezone);
          // Handle midnight crossing - if end slot is before start slot,
          // it means the entry crosses midnight, so extend to end of day
          if (endSlot < startSlot) {
            endSlot = 96; // 24 hours * 4 slots = 96 (end of day)
          }
        }
      }

      // Calculate actual height but enforce minimum for usability
      const actualHeight = (endSlot - startSlot) * SLOT_HEIGHT;
      const minHeight = 24; // Minimum height for interaction (resize handles + content)
      const height = Math.max(actualHeight, minHeight);

      return (
        <ContextMenu
          key={`${event.id}-${event.isFirstPart ? "first" : "normal"}`}
          onOpenChange={(open) => {
            if (!open) {
              setTimeout(() => setIsContextMenuOpen(false), 50);
            } else {
              setIsContextMenuOpen(true);
            }
          }}
        >
          <ContextMenuTrigger>
            <div
              onClick={() => handleEventClick(event)}
              className={cn(
                "absolute transition-colors",
                // Same styling for all events
                "bg-[#F0F0F0]/[0.95] dark:bg-[#1D1D1D]/[0.95] text-[#606060] dark:text-[#878787] border-t border-border",
                selectedEvent?.id === event.id && "!text-primary",
                event.id !== NEW_EVENT_ID && "cursor-move",
                event.totalColumns > 1 && event.column > 0
                  ? "border border-border"
                  : "",
              )}
              style={{
                top: `${startSlot * SLOT_HEIGHT}px`,
                height: `${height}px`,
                left:
                  event.leftPx !== undefined
                    ? `${event.leftPx}px`
                    : `${event.left}%`,
                width:
                  event.leftPx !== undefined
                    ? `calc(${event.width}% - ${event.leftPx}px)`
                    : `${event.width}%`,
                zIndex: event.totalColumns > 1 ? 20 + event.column : 10,
              }}
              onMouseDown={(e) =>
                event.id !== NEW_EVENT_ID && handleEventMoveStart(e, event)
              }
            >
              <div className="text-xs p-4 flex justify-between flex-col select-none pointer-events-none">
                <div className="flex items-center gap-2">
                  {/* Subtle green dot indicator for running timers */}
                  {isRunningTimer && (
                    <div className="flex items-center">
                      <span className="relative flex h-1.5 w-1.5">
                        <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-500 opacity-75" />
                        <span className="relative inline-flex rounded-full h-1.5 w-1.5 bg-green-500" />
                      </span>
                    </div>
                  )}
                  <span>
                    {event.trackerProject?.name || "No Project"}
                    {event.isFirstPart && " →"}
                    {isRunningTimer
                      ? ` (${secondsToHoursAndMinutes(Math.max(0, Math.round((currentTime.getTime() - createSafeDate(event.start).getTime()) / 1000)))})`
                      : ` (${secondsToHoursAndMinutes(event.duration ?? 0)})`}
                  </span>
                </div>
                {event?.trackerProject?.customer && (
                  <span>{event.trackerProject.customer.name}</span>
                )}
                <span>{event.description}</span>
              </div>
              {event.id !== NEW_EVENT_ID && !isRunningTimer && (
                <>
                  <div
                    className="absolute top-0 left-0 right-0 h-3 cursor-ns-resize"
                    onMouseDown={(e) => handleEventResizeStart(e, event, "top")}
                  />
                  <div
                    className="absolute bottom-0 left-0 right-0 h-3 cursor-ns-resize"
                    onMouseDown={(e) =>
                      handleEventResizeStart(e, event, "bottom")
                    }
                  />
                </>
              )}
            </div>
          </ContextMenuTrigger>
          <ContextMenuContent>
            <ContextMenuItem
              onClick={(e) => {
                e.stopPropagation();
                handleDeleteEvent(event.id);
              }}
            >
              Delete <ContextMenuShortcut>⌫</ContextMenuShortcut>
            </ContextMenuItem>
          </ContextMenuContent>
        </ContextMenu>
      );
    });
  };

  // Find the event to pass to the form
  const formEvent =
    data.find((event) => event.id === NEW_EVENT_ID) || selectedEvent;

  return (
    <div className="w-full">
      <div className="text-left mb-8">
        <h2 className="text-xl text-[#878787]">
          {secondsToHoursAndMinutes(totalDuration)}
        </h2>
      </div>

      <TrackerDaySelect />

      <ScrollArea ref={scrollRef} className="h-[calc(100vh-480px)] mt-8">
        <div className="flex text-[#878787] text-xs">
          <div className="w-20 flex-shrink-0 select-none">
            {hours.map((hour) => (
              <div
                key={hour}
                className="pr-4 flex font-mono flex-col"
                style={{ height: `${ROW_HEIGHT}px` }}
              >
                {formatHour(hour, user?.timeFormat, getUserTimezone(user))}
              </div>
            ))}
          </div>

          <div
            className="relative flex-grow border border-border border-t-0 cursor-default select-none"
            onMouseMove={handleMouseMove}
            onMouseDown={(e) => {
              if (e.button === 0 && !isContextMenuOpen) {
                const rect = e.currentTarget.getBoundingClientRect();
                const y = e.clientY - rect.top;
                const slot = Math.floor(y / SLOT_HEIGHT);
                handleMouseDown(slot);
              }
            }}
          >
            {hours.map((hour) => (
              <React.Fragment key={hour}>
                <div
                  className="absolute w-full border-t border-border user-select-none"
                  style={{ top: `${hour * ROW_HEIGHT}px` }}
                />
              </React.Fragment>
            ))}
            {renderScheduleEntries()}
          </div>
        </div>
      </ScrollArea>

      <TrackerEntriesForm
        key={formEvent?.id === NEW_EVENT_ID ? "new" : (formEvent?.id ?? "new")}
        eventId={formEvent?.id}
        onCreate={handleCreateEvent}
        isSaving={upsertTrackerEntry.isPending}
        userId={user?.id || ""}
        teamId={user?.teamId || ""}
        projectId={formEvent?.trackerProject?.id ?? selectedProjectId}
        description={formEvent?.description ?? undefined}
        start={
          formEvent?.start
            ? safeFormatTime(
                formEvent.start,
                user?.timezone ? user.timezone : undefined,
              )
            : undefined
        }
        stop={
          formEvent?.stop
            ? safeFormatTime(
                formEvent.stop,
                user?.timezone ? user.timezone : undefined,
              )
            : undefined
        }
        onSelectProject={handleSelectProject}
        onTimeChange={handleTimeChange}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-search-filter.tsx">
"use client";

import { generateTrackerFilters } from "@/actions/ai/filters/generate-tracker-filters";
import { useTrackerFilterParams } from "@/hooks/use-tracker-filter-params";
import { useTRPC } from "@/trpc/client";
import { Calendar } from "@midday/ui/calendar";
import { cn } from "@midday/ui/cn";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { Input } from "@midday/ui/input";
import { useQuery } from "@tanstack/react-query";
import { readStreamableValue } from "ai/rsc";
import { formatISO } from "date-fns";
import { useRef, useState } from "react";
import { useHotkeys } from "react-hotkeys-hook";
import { FilterList } from "./filter-list";

const statusFilters = [
  { id: "in_progress", name: "In Progress" },
  { id: "completed", name: "Completed" },
];

export function TrackerSearchFilter() {
  const [prompt, setPrompt] = useState("");
  const inputRef = useRef<HTMLInputElement>(null);
  const [streaming, setStreaming] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const trpc = useTRPC();

  const { filter, setFilter } = useTrackerFilterParams();

  const shouldFetch = isOpen;

  const { data: customersData } = useQuery({
    ...trpc.customers.get.queryOptions(),
    enabled: shouldFetch || Boolean(filter.customers?.length),
  });

  const { data: membersData } = useQuery({
    ...trpc.team.members.queryOptions(),
    enabled: shouldFetch || Boolean(filter.customers?.length),
  });

  const { data: tagsData } = useQuery({
    ...trpc.tags.get.queryOptions(),
    enabled: shouldFetch || Boolean(filter.tags?.length),
  });

  useHotkeys(
    "esc",
    () => {
      setPrompt("");
      setFilter(null);
      setIsOpen(false);
    },
    {
      enableOnFormTags: true,
      enabled: Boolean(prompt) && isFocused,
    },
  );

  useHotkeys("meta+s", (evt) => {
    evt.preventDefault();
    inputRef.current?.focus();
  });

  const handleSearch = (evt: React.ChangeEvent<HTMLInputElement>) => {
    const value = evt.target.value;

    if (value) {
      setPrompt(value);
    } else {
      setFilter(null);
      setPrompt("");
    }
  };

  const handleSubmit = async () => {
    // If the user is typing a query with multiple words, we want to stream the results
    if (prompt.split(" ").length > 1) {
      setStreaming(true);

      const { object } = await generateTrackerFilters(
        prompt,
        `
        Customers: ${customersData?.data?.map((customer) => customer.name).join(", ")}
        Tags: ${tagsData?.map((tag) => tag.name).join(", ")}
        `,
      );

      let finalObject = {};

      for await (const partialObject of readStreamableValue(object)) {
        if (partialObject) {
          finalObject = {
            ...finalObject,
            ...partialObject,
            status: partialObject?.status ?? null,
            start: partialObject?.start ?? null,
            end: partialObject?.end ?? null,
            q: partialObject?.name ?? null,
            tags: partialObject?.tags ?? null,
            customers:
              partialObject?.customers?.map(
                (name: string) =>
                  customersData?.data?.find(
                    (customer) => customer.name === name,
                  )?.id,
              ) ?? null,
          };
        }
      }

      setFilter({
        q: null,
        ...finalObject,
      });

      setStreaming(false);
    } else {
      setFilter({ q: prompt.length > 0 ? prompt : null });
    }
  };

  const validFilters = Object.fromEntries(
    Object.entries(filter).filter(([key]) => key !== "q"),
  );

  const hasValidFilters = Object.values(validFilters).some(
    (value) => value !== null,
  );

  const members = membersData?.map((member) => ({
    id: member.user!.id as string,
    name: member.user!.fullName as string,
  }));

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <div className="flex space-x-4 items-center">
        <FilterList
          filters={validFilters}
          loading={streaming}
          onRemove={setFilter}
          members={members}
          customers={customersData?.data}
          statusFilters={statusFilters}
          tags={tagsData}
        />

        <form
          className="relative"
          onSubmit={(e) => {
            e.preventDefault();
            handleSubmit();
          }}
        >
          <Icons.Search className="absolute pointer-events-none left-3 top-[11px]" />
          <Input
            ref={inputRef}
            placeholder="Search or type filter"
            className="pl-9 w-full md:w-[350px] pr-8"
            value={prompt}
            onChange={handleSearch}
            autoComplete="off"
            autoCapitalize="none"
            autoCorrect="off"
            spellCheck="false"
            onFocus={() => setIsFocused(true)}
            onBlur={() => setIsFocused(false)}
          />

          <DropdownMenuTrigger asChild>
            <button
              onClick={() => setIsOpen((prev) => !prev)}
              type="button"
              className={cn(
                "absolute z-10 right-3 top-[10px] opacity-50 transition-opacity duration-300 hover:opacity-100",
                hasValidFilters && "opacity-100",
                isOpen && "opacity-100",
              )}
            >
              <Icons.Filter />
            </button>
          </DropdownMenuTrigger>
        </form>
      </div>

      <DropdownMenuContent
        className="w-[350px]"
        align="end"
        sideOffset={19}
        alignOffset={-11}
        side="bottom"
      >
        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.CalendarMonth className="mr-2 h-4 w-4" />
              <span>Date</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                alignOffset={-4}
                className="p-0"
              >
                <Calendar
                  mode="range"
                  initialFocus
                  toDate={new Date()}
                  selected={
                    filter.start || filter.end
                      ? {
                          from: filter.start
                            ? new Date(filter.start)
                            : undefined,
                          to: filter.end ? new Date(filter.end) : undefined,
                        }
                      : undefined
                  }
                  onSelect={(range) => {
                    if (!range) return;

                    const newRange = {
                      start: range.from
                        ? formatISO(range.from, { representation: "date" })
                        : filter.start,
                      end: range.to
                        ? formatISO(range.to, { representation: "date" })
                        : filter.end,
                    };

                    setFilter(newRange);
                  }}
                />
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>

        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.ProjectStatus className="mr-2 h-4 w-4 rotate-180" />
              <span>Status</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                alignOffset={-4}
                className="p-0"
              >
                {statusFilters.map(({ id, name }) => (
                  <DropdownMenuCheckboxItem
                    key={id}
                    checked={filter?.status === id}
                    onCheckedChange={() => {
                      setFilter({
                        status: id as "completed" | "in_progress" | null,
                      });
                    }}
                  >
                    {name}
                  </DropdownMenuCheckboxItem>
                ))}
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>

        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.Face className="mr-2 h-4 w-4" />
              <span>Customer</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                alignOffset={-4}
                className="p-0"
              >
                {customersData?.data?.map((customer) => (
                  <DropdownMenuCheckboxItem
                    key={customer.id}
                    onCheckedChange={() => {
                      setFilter({
                        customers: filter?.customers?.includes(customer.id)
                          ? filter.customers.filter((s) => s !== customer.id)
                          : [...(filter?.customers ?? []), customer.id],
                      });
                    }}
                  >
                    {customer.name}
                  </DropdownMenuCheckboxItem>
                ))}

                {!customersData?.data?.length && (
                  <DropdownMenuItem disabled>
                    No customers found
                  </DropdownMenuItem>
                )}
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>

        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Icons.Status className="mr-2 h-4 w-4" />
              <span>Tags</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent
                sideOffset={14}
                alignOffset={-4}
                className="p-0"
              >
                {tagsData?.map((tag) => (
                  <DropdownMenuCheckboxItem
                    key={tag.id}
                    onCheckedChange={() => {
                      setFilter({
                        tags: filter?.tags?.includes(tag.id)
                          ? filter.tags.filter((s) => s !== tag.id)
                          : [...(filter?.tags ?? []), tag.id],
                      });
                    }}
                  >
                    {tag.name}
                  </DropdownMenuCheckboxItem>
                ))}

                {!tagsData?.length && (
                  <DropdownMenuItem disabled>No tags found</DropdownMenuItem>
                )}
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-select-project.tsx">
"use client";

import { useLatestProjectId } from "@/hooks/use-latest-project-id";
import { useTRPC } from "@/trpc/client";
import { Combobox } from "@midday/ui/combobox";
import { useToast } from "@midday/ui/use-toast";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useEffect, useState } from "react";

type Props = {
  selectedId?: string;
  onSelect: (selected: Option) => void;
  onCreate: (project: { id: string; name: string }) => void;
};

type Option = {
  id: string;
  name: string;
};

export function TrackerSelectProject({
  selectedId,
  onSelect,
  onCreate,
}: Props) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const [value, setValue] = useState<Option | undefined>();
  const { setLatestProjectId } = useLatestProjectId();

  const { data, isLoading, refetch } = useQuery(
    trpc.trackerProjects.get.queryOptions({
      pageSize: 100,
    }),
  );

  const upsertTrackerProjectMutation = useMutation(
    trpc.trackerProjects.upsert.mutationOptions({
      onSuccess: (result) => {
        if (result?.id && result?.name) {
          const project = { id: result.id, name: result.name };
          onCreate(project);
          handleSelect(project);
          setLatestProjectId(result.id);
          refetch();

          queryClient.invalidateQueries({
            queryKey: trpc.trackerProjects.get.infiniteQueryKey(),
          });

          // Invalidate global search
          queryClient.invalidateQueries({
            queryKey: trpc.search.global.queryKey(),
          });
        }
      },
      onError: () => {
        toast({
          duration: 3500,
          variant: "error",
          title: "Something went wrong please try again.",
        });
      },
    }),
  );

  const options =
    data?.data.map((project) => ({
      id: project.id,
      name: project.customer?.name
        ? `${project.name} · ${project.customer.name}`
        : project.name,
    })) ?? [];

  useEffect(() => {
    const foundProject = options?.find((project) => project?.id === selectedId);

    if (foundProject) {
      setValue({ id: foundProject.id, name: foundProject.name });
    }
  }, [selectedId, data]);

  const handleSelect = (selected?: Option) => {
    if (selected) {
      setLatestProjectId(selected?.id);
      setValue(selected);
      onSelect(selected);
    }
  };

  return (
    <Combobox
      key={value?.id}
      placeholder="Search or create project"
      classNameList="-top-[4px] border-t-0 rounded-none rounded-b-md"
      className="w-full bg-transparent px-12 border py-3"
      onSelect={handleSelect}
      options={options}
      value={value}
      isLoading={isLoading}
      onCreate={(name) => {
        if (name) {
          upsertTrackerProjectMutation.mutate({ name });
        }
      }}
    />
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-settings.tsx">
"use client";

import { useUserMutation, useUserQuery } from "@/hooks/use-user";
import { Button } from "@midday/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";

export function TrackerSettings() {
  const { data: user } = useUserQuery();
  const userMutation = useUserMutation();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Icons.Tune className="w-4 h-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56" align="end" sideOffset={10}>
        <DropdownMenuLabel className="text-xs text-muted-foreground font-normal">
          Time format
        </DropdownMenuLabel>
        <DropdownMenuRadioGroup
          value={user?.timeFormat?.toString() ?? "24"}
          onValueChange={(value) => {
            userMutation.mutate({ timeFormat: +value });
          }}
        >
          <DropdownMenuRadioItem value="24">24h</DropdownMenuRadioItem>
          <DropdownMenuRadioItem value="12">12h</DropdownMenuRadioItem>
        </DropdownMenuRadioGroup>

        <DropdownMenuSeparator />

        <DropdownMenuLabel className="text-xs text-muted-foreground font-normal">
          Week starts on Monday
        </DropdownMenuLabel>
        <DropdownMenuRadioGroup
          value={user?.weekStartsOnMonday ? "yes" : "no"}
          onValueChange={(value) => {
            userMutation.mutate({ weekStartsOnMonday: value === "yes" });
          }}
        >
          <DropdownMenuRadioItem value="yes">Yes</DropdownMenuRadioItem>
          <DropdownMenuRadioItem value="no">No</DropdownMenuRadioItem>
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-status.tsx">
"use client";

import { useI18n } from "@/locales/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { cn } from "@midday/ui/cn";

type Props = {
  status: NonNullable<RouterOutputs["trackerProjects"]["getById"]>["status"];
};

export function TrackerStatus({ status }: Props) {
  const t = useI18n();

  return (
    <div className="flex items-center space-x-4">
      <div
        className={cn(
          "w-[6px] h-[6px] rounded-full bg-[#FFD02B]",
          status === "completed" && "bg-primary",
        )}
      />
      {/* @ts-expect-error */}
      <span>{t(`tracker_status.${status}`)}</span>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/tracker-timer.tsx">
"use client";

import { useGlobalTimerStatus } from "@/hooks/use-global-timer-status";
import { useTRPC } from "@/trpc/client";
import { secondsToHoursAndMinutes } from "@/utils/format";
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";
import { useToast } from "@midday/ui/use-toast";
import NumberFlow from "@number-flow/react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

interface TrackerTimerProps {
  projectId: string;
  projectName: string;
  initialDuration?: number;
  onClick?: () => void;
  alwaysShowButton?: boolean;
}

export function TrackerTimer({
  projectId,
  projectName,
  onClick,
  alwaysShowButton = false,
}: TrackerTimerProps) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { toast } = useToast();

  // Use global timer status to avoid duplicate intervals
  const { isRunning: globalIsRunning, elapsedTime: globalElapsedTime } =
    useGlobalTimerStatus();

  // Hold-to-stop state
  const [isHolding, setIsHolding] = useState(false);
  const [holdProgress, setHoldProgress] = useState(0);
  const holdTimerRef = useRef<NodeJS.Timeout | null>(null);
  const holdProgressRef = useRef<NodeJS.Timeout | null>(null);

  // Get current timer status - reduced refetch frequency
  const { data: timerStatus } = useQuery({
    ...trpc.trackerEntries.getTimerStatus.queryOptions(),
    refetchInterval: (query) => {
      // Only refetch if there's a running timer, and less frequently
      return query.state.data?.isRunning ? 60000 : false; // Sync every 60 seconds when running
    },
    staleTime: 30000, // Consider data fresh for 30 seconds
  });

  // Check if this specific project is the one running
  const isThisProjectRunning = useMemo(
    () =>
      timerStatus?.isRunning &&
      timerStatus?.currentEntry?.projectId === projectId,
    [timerStatus?.isRunning, timerStatus?.currentEntry?.projectId, projectId],
  );

  // Check if there's a different timer running
  const isDifferentTimerRunning = useMemo(
    () =>
      timerStatus?.isRunning &&
      timerStatus?.currentEntry?.projectId !== projectId,
    [timerStatus?.isRunning, timerStatus?.currentEntry?.projectId, projectId],
  );

  // Use global elapsed time when this project is running
  const totalElapsedSeconds = useMemo(() => {
    if (isThisProjectRunning && globalIsRunning) {
      return globalElapsedTime;
    }
    return 0;
  }, [isThisProjectRunning, globalIsRunning, globalElapsedTime]);

  // Start timer mutation
  const startTimerMutation = useMutation(
    trpc.trackerEntries.startTimer.mutationOptions({
      onMutate: async (variables) => {
        // Cancel any outgoing refetches
        await queryClient.cancelQueries({
          queryKey: trpc.trackerEntries.getTimerStatus.queryKey(),
        });

        // Optimistically update to the new value
        queryClient.setQueryData(
          trpc.trackerEntries.getTimerStatus.queryKey(),
          (old: any) => ({
            ...old,
            isRunning: true,
            currentEntry: {
              ...old?.currentEntry,
              projectId: variables.projectId,
            },
            elapsedTime: 0,
          }),
        );
      },
      onSuccess: () => {
        // Invalidate queries to sync with server
        queryClient.invalidateQueries({
          queryKey: trpc.trackerEntries.getTimerStatus.queryKey(),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.trackerEntries.getCurrentTimer.queryKey(),
        });
      },
    }),
  );

  // Stop timer mutation
  const stopTimerMutation = useMutation(
    trpc.trackerEntries.stopTimer.mutationOptions({
      onMutate: async () => {
        // Cancel any outgoing refetches
        await queryClient.cancelQueries({
          queryKey: trpc.trackerEntries.getTimerStatus.queryKey(),
        });

        // Capture elapsed time and project name before stopping
        const currentElapsedTime = totalElapsedSeconds;
        const currentProjectName = projectName;

        // Optimistically update to stop the timer
        queryClient.setQueryData(
          trpc.trackerEntries.getTimerStatus.queryKey(),
          (old: any) => ({
            ...old,
            isRunning: false,
            currentEntry: null,
            elapsedTime: 0,
          }),
        );

        return { currentElapsedTime, currentProjectName };
      },
      onSuccess: (_, __, context) => {
        // Invalidate queries to sync with server
        queryClient.invalidateQueries({
          queryKey: trpc.trackerEntries.getTimerStatus.queryKey(),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.trackerEntries.getCurrentTimer.queryKey(),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.trackerEntries.byDate.queryKey(),
        });
        queryClient.invalidateQueries({
          queryKey: trpc.trackerEntries.byRange.queryKey(),
        });

        toast({
          title: "Timer stopped",
          description: `${secondsToHoursAndMinutes(context?.currentElapsedTime)} added to ${context?.currentProjectName}`,
          variant: "success",
        });
      },
    }),
  );

  // Hold-to-stop handlers
  const startHolding = useCallback(() => {
    if (!isThisProjectRunning) return;

    setIsHolding(true);
    setHoldProgress(0);

    // Start progress animation
    let progress = 0;
    holdProgressRef.current = setInterval(() => {
      progress += 100 / 15; // 15 steps over 1.5 seconds = 100ms intervals
      setHoldProgress(Math.min(progress, 100));
    }, 100);

    // Execute stop after 1.5 seconds
    holdTimerRef.current = setTimeout(() => {
      stopTimerMutation.mutate({});
      resetHold();
    }, 1500);
  }, [isThisProjectRunning, stopTimerMutation]);

  const resetHold = useCallback(() => {
    setIsHolding(false);
    setHoldProgress(0);

    if (holdTimerRef.current) {
      clearTimeout(holdTimerRef.current);
      holdTimerRef.current = null;
    }

    if (holdProgressRef.current) {
      clearInterval(holdProgressRef.current);
      holdProgressRef.current = null;
    }
  }, []);

  // Cleanup hold timers on unmount
  useEffect(() => {
    return () => {
      resetHold();
    };
  }, [resetHold]);

  const formatTime = useCallback((seconds: number) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    // For durations less than 1 hour, show only minutes and seconds
    if (hours === 0) {
      return { showHours: false, minutes, seconds: secs };
    }

    return { showHours: true, hours, minutes, seconds: secs };
  }, []);

  const handleButtonClick = useCallback(() => {
    if (!isThisProjectRunning) {
      // Check if there's a different timer running
      if (isDifferentTimerRunning) {
        const currentProjectName =
          timerStatus?.currentEntry?.trackerProject?.name || "Unknown Project";
        toast({
          title: "Timer already running",
          description: `You have a timer running for "${currentProjectName}". Please stop it first before starting a new timer.`,
        });
        return;
      }

      // Start timer for this project
      startTimerMutation.mutate({
        projectId,
      });
    }
    // For stop, we only use hold-to-stop, so no immediate action
  }, [
    isThisProjectRunning,
    isDifferentTimerRunning,
    startTimerMutation,
    projectId,
    timerStatus?.currentEntry?.trackerProject?.name,
    toast,
  ]);

  // Memoize formatted time
  const formattedTime = useMemo(() => {
    if (!isThisProjectRunning) return null;
    return formatTime(totalElapsedSeconds);
  }, [isThisProjectRunning, totalElapsedSeconds, formatTime]);

  return (
    <div className="flex items-center">
      <div className="relative">
        <TooltipProvider delayDuration={20}>
          <Tooltip>
            <TooltipTrigger asChild>
              <button
                type="button"
                className={`p-1 h-6 rounded transition-all text-[#666] duration-200 ease-in-out hover:bg-accent flex items-center justify-center overflow-hidden ${
                  isThisProjectRunning
                    ? "w-6 mr-1 opacity-100 scale-100"
                    : alwaysShowButton
                      ? "w-6 mr-1 opacity-100 scale-100"
                      : "w-0 mr-0 opacity-0 scale-75 group-hover:w-6 group-hover:mr-1 group-hover:opacity-100 group-hover:scale-100"
                }`}
                onClick={(e) => {
                  e.stopPropagation();
                  handleButtonClick();
                }}
                onMouseDown={(e) => {
                  e.stopPropagation();
                  if (isThisProjectRunning) {
                    startHolding();
                  }
                }}
                onMouseUp={(e) => {
                  e.stopPropagation();
                  resetHold();
                }}
                onMouseLeave={(e) => {
                  e.stopPropagation();
                  resetHold();
                }}
                onTouchStart={(e) => {
                  e.stopPropagation();
                  if (isThisProjectRunning) {
                    startHolding();
                  }
                }}
                onTouchEnd={(e) => {
                  e.stopPropagation();
                  resetHold();
                }}
              >
                {isThisProjectRunning ? (
                  <Icons.StopOutline size={18} />
                ) : (
                  <Icons.PlayOutline size={18} />
                )}
              </button>
            </TooltipTrigger>
            {isThisProjectRunning && (
              <TooltipContent
                side="top"
                sideOffset={5}
                className="text-xs px-2 py-1 text-[#878787]"
              >
                <p>Hold down to stop</p>
              </TooltipContent>
            )}
          </Tooltip>
        </TooltipProvider>

        {/* Circular Progress Bar */}
        {isHolding && isThisProjectRunning && (
          <svg
            className="absolute inset-0 w-6 h-6 -rotate-90 pointer-events-none"
            viewBox="0 0 24 24"
          >
            <circle
              cx="12"
              cy="12"
              r="10"
              fill="none"
              stroke="currentColor"
              strokeWidth="1.5"
              className="text-primary opacity-30"
            />
            <circle
              cx="12"
              cy="12"
              r="10"
              fill="none"
              stroke="currentColor"
              strokeWidth="1.5"
              strokeLinecap="round"
              className="text-primary"
              style={{
                strokeDasharray: "62.83", // 2 * π * 10
                strokeDashoffset: 62.83 * (1 - holdProgress / 100),
                transition: "stroke-dashoffset 100ms linear",
              }}
            />
          </svg>
        )}
      </div>

      <div className="cursor-pointer flex-1" onClick={onClick}>
        <div className="flex items-center gap-2">
          <span>{projectName}</span>
          <div
            className={`flex items-center gap-px font-mono text-xs text-[#666] ml-auto transition-all duration-300 ease-in-out ${
              isThisProjectRunning
                ? "opacity-100 translate-y-0"
                : "opacity-0 translate-y-2"
            }`}
          >
            {isThisProjectRunning && formattedTime && (
              <>
                <div className="flex items-center mr-[5px]">
                  <span className="relative flex h-[5px] w-[5px]">
                    <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-[#00C969] opacity-75" />
                    <span className="relative inline-flex rounded-full h-[5px] w-[5px] bg-[#00C969]" />
                  </span>
                </div>
                <NumberFlow
                  value={formattedTime.hours ?? 0}
                  format={{ minimumIntegerDigits: 2 }}
                />
                <span>:</span>
                <NumberFlow
                  value={formattedTime.minutes}
                  format={{ minimumIntegerDigits: 2 }}
                />
                <span>:</span>
                <NumberFlow
                  value={formattedTime.seconds}
                  format={{ minimumIntegerDigits: 2 }}
                />
              </>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/transaction-attachments.tsx">
"use client";

import { useUpload } from "@/hooks/use-upload";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import { formatAmount } from "@/utils/format";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { cn } from "@midday/ui/cn";
import { useToast } from "@midday/ui/use-toast";
import { stripSpecialCharacters } from "@midday/utils";
import { getTaxTypeLabel } from "@midday/utils/tax";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useEffect, useState } from "react";
import { useDropzone } from "react-dropzone";
import { type Attachment, AttachmentItem } from "./attachment-item";
import { SelectAttachment } from "./select-attachment";

const normalizePath = (path: unknown): string[] => {
  if (Array.isArray(path)) return path;
  if (typeof path === "string") return path.split("/");
  return [];
};

type Props = {
  id: string;
  data?: NonNullable<RouterOutputs["transactions"]["getById"]>["attachments"];
  onUpload?: (files: Attachment[]) => void;
};

export function TransactionAttachments({ id, data, onUpload }: Props) {
  const { toast } = useToast();
  const [files, setFiles] = useState<Attachment[]>([]);
  const { uploadFile } = useUpload();
  const trpc = useTRPC();
  const { data: user } = useUserQuery();
  const queryClient = useQueryClient();
  const [pollingForTax, setPollingForTax] = useState(false);

  const processTransactionAttachmentMutation = useMutation(
    trpc.transactionAttachments.processAttachment.mutationOptions(),
  );

  const createAttachmentsMutation = useMutation(
    trpc.transactionAttachments.createMany.mutationOptions({
      onSuccess: () => {
        // invalidate the transaction list query
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.transactions.getById.queryKey({ id }),
        });

        // Start polling for tax information
        if (
          pollingTransaction?.taxRate !== pollingTransaction?.category?.taxRate
        ) {
          setPollingForTax(true);
        }
      },
    }),
  );

  const deleteattachmentMutation = useMutation(
    trpc.transactionAttachments.delete.mutationOptions({
      onSuccess: () => {
        // invalidate the transaction details query
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.getById.queryKey({ id }),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });
      },
    }),
  );

  // Polling query for tax information
  const { data: pollingTransaction } = useQuery({
    ...trpc.transactions.getById.queryOptions({ id }),
    enabled: pollingForTax,
    refetchInterval: pollingForTax ? 1000 : false,
  });

  // Handle tax information detection
  useEffect(() => {
    if (
      pollingForTax &&
      pollingTransaction?.taxRate &&
      pollingTransaction?.taxRate > 0 &&
      pollingTransaction?.taxType
    ) {
      toast({
        variant: "success",
        duration: 8000,
        title: `${getTaxTypeLabel(pollingTransaction?.taxType)} extracted and applied`,
        description: `${pollingTransaction?.taxRate}% ${getTaxTypeLabel(pollingTransaction?.taxType)} (${formatAmount(
          {
            amount: pollingTransaction?.taxAmount!,
            currency: pollingTransaction?.currency!,
            locale: user?.locale,
          },
        )}) was detected from the uploaded receipt and added to this transaction.`,
      });

      // invalidate the transaction details query
      queryClient.invalidateQueries({
        queryKey: trpc.transactions.getById.queryKey({ id }),
      });

      // invalidate the transaction list query
      queryClient.invalidateQueries({
        queryKey: trpc.transactions.get.infiniteQueryKey(),
      });

      setPollingForTax(false);
    }
  }, [
    pollingTransaction,
    pollingForTax,
    toast,
    trpc.transactions.getById.queryKey,
    queryClient.invalidateQueries,
    user?.locale,
    trpc.transactions.get.infiniteQueryKey,
    id,
  ]);

  // Stop polling after 10 seconds
  useEffect(() => {
    if (pollingForTax) {
      const timeout = setTimeout(() => {
        setPollingForTax(false);
      }, 10000);

      return () => clearTimeout(timeout);
    }
  }, [pollingForTax]);

  const handleOnDelete = (id: string) => {
    setFiles((files) => files.filter((file) => file?.id !== id));
    deleteattachmentMutation.mutate({ id });
  };

  const onDrop = async (acceptedFiles: Array<Attachment>) => {
    setFiles((prev) => [
      ...prev,
      ...acceptedFiles.map((a) => ({
        name: stripSpecialCharacters(a.name),
        size: a.size,
        type: a.type,
        isUploading: true,
      })),
    ]);

    const uploadedFiles = await Promise.all(
      acceptedFiles.map(async (acceptedFile) => {
        const filename = stripSpecialCharacters(acceptedFile.name);

        const { path } = await uploadFile({
          bucket: "vault",
          path: [user?.teamId ?? "", "transactions", id, filename],
          file: acceptedFile as File,
        });

        return {
          path: path,
          name: filename,
          size: acceptedFile.size,
          type: acceptedFile.type,
        };
      }),
    );

    onUpload?.(uploadedFiles);

    createAttachmentsMutation.mutate(
      uploadedFiles.map((file) => ({
        name: file.name,
        type: file.type,
        path: file.path,
        size: file.size,
        transactionId: id,
      })),
    );

    processTransactionAttachmentMutation.mutate(
      uploadedFiles.map((file) => ({
        filePath: file.path,
        mimetype: file.type,
        transactionId: id,
      })),
    );
  };

  // @ts-expect-error
  const handleOnSelectFile = (file) => {
    const filename = stripSpecialCharacters(file.name);

    const item = {
      name: filename,
      size: file.data.size,
      type: file.data.contentType,
      path: file.data.filePath,
      transactionId: id,
    };

    setFiles((prev) => [item, ...prev]);
    createAttachmentsMutation.mutate([item]);
  };

  useEffect(() => {
    if (data) {
      setFiles(
        data.map((item) => ({
          id: item.id,
          name: item.filename!,
          path: normalizePath(item?.path),
          size: item.size,
          type: item.type,
        })),
      );
    }
  }, [data]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    onDropRejected: ([reject]) => {
      if (reject?.errors.find(({ code }) => code === "file-too-large")) {
        toast({
          duration: 2500,
          variant: "error",
          title: "File size to large.",
        });
      }

      if (reject?.errors.find(({ code }) => code === "file-invalid-type")) {
        toast({
          duration: 2500,
          variant: "error",
          title: "File type not supported.",
        });
      }
    },
    maxSize: 3000000, // 3MB
    accept: {
      "image/*": [
        ".jpg",
        ".jpeg",
        ".png",
        ".gif",
        ".webp",
        ".heic",
        ".heif",
        ".avif",
        ".tiff",
        ".bmp",
      ],
      "application/pdf": [".pdf"],
    },
  });

  return (
    <div>
      <SelectAttachment
        placeholder="Search attachment"
        onSelect={handleOnSelectFile}
        transactionId={id}
      />
      <div
        className={cn(
          "mt-4 w-full h-[120px] border-dotted border-2 border-border text-center flex flex-col justify-center space-y-1 transition-colors text-[#606060]",
          isDragActive && "bg-secondary text-primary",
        )}
        {...getRootProps()}
      >
        <input {...getInputProps()} />
        {isDragActive ? (
          <div>
            <p className="text-xs">Drop your files upload</p>
          </div>
        ) : (
          <div>
            <p className="text-xs">
              Drop your files here, or{" "}
              <span className="underline underline-offset-1">
                click to browse.
              </span>
            </p>
            <p className="text-xs text-dark-gray">3MB file limit.</p>
          </div>
        )}
      </div>

      <ul className="mt-4 space-y-4">
        {files.map((file, idx) => (
          <AttachmentItem
            key={`${file.name}-${idx}`}
            file={file}
            onDelete={() => handleOnDelete(file?.id!)}
          />
        ))}
      </ul>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/transaction-bank-account.tsx">
import { BankLogo } from "@/components/bank-logo";
import { cn } from "@midday/ui/cn";

type Props = {
  logoUrl?: string;
  name?: string;
  size?: number;
  className?: string;
};

export function TransactionBankAccount({
  logoUrl,
  name,
  size = 20,
  className,
}: Props) {
  return (
    <div className="flex space-x-2 mt-1 items-center">
      {logoUrl && (
        <div
          className="rounded-full overflow-hidden flex-shrink-0"
          style={{ width: size, height: size }}
        >
          <BankLogo size={size} src={logoUrl} alt={name ?? ""} />
        </div>
      )}
      <span className={cn("text-sm line-clamp-1", className)}>{name}</span>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/transaction-details.tsx">
"use client";

import { useTransactionParams } from "@/hooks/use-transaction-params";
import { useTRPC } from "@/trpc/client";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { cn } from "@midday/ui/cn";
import { Label } from "@midday/ui/label";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@midday/ui/select";
import { Skeleton } from "@midday/ui/skeleton";
import { Switch } from "@midday/ui/switch";
import { ToastAction } from "@midday/ui/toast";
import { toast } from "@midday/ui/use-toast";
import { getTaxTypeLabel } from "@midday/utils/tax";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { format } from "date-fns";
import { AssignUser } from "./assign-user";
import { FormatAmount } from "./format-amount";
import { Note } from "./note";
import { SelectCategory } from "./select-category";
import { SelectTags } from "./select-tags";
import { SuggestedMatch } from "./suggested-match";
import { TransactionAttachments } from "./transaction-attachments";
import { TransactionBankAccount } from "./transaction-bank-account";
import { TransactionShortcuts } from "./transaction-shortcuts";

export function TransactionDetails() {
  const trpc = useTRPC();
  const { transactionId } = useTransactionParams();

  const queryClient = useQueryClient();

  const { data, isLoading, isFetching } = useQuery({
    ...trpc.transactions.getById.queryOptions({ id: transactionId! }),
    enabled: Boolean(transactionId),
    staleTime: 0, // Always consider data stale so it always refetches
    initialData: () => {
      const pages = queryClient
        .getQueriesData({ queryKey: trpc.transactions.get.infiniteQueryKey() })
        // @ts-expect-error
        .flatMap(([, data]) => data?.pages ?? [])
        .flatMap((page) => page.data ?? []);

      return pages.find((d) => d.id === transactionId);
    },
  });

  const updateTransactionMutation = useMutation(
    trpc.transactions.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });
      },
      onMutate: async (variables) => {
        // Cancel any outgoing refetches
        await Promise.all([
          queryClient.cancelQueries({
            queryKey: trpc.transactions.getById.queryKey({
              id: transactionId!,
            }),
          }),
          queryClient.cancelQueries({
            queryKey: trpc.transactions.get.infiniteQueryKey(),
          }),
        ]);

        // Snapshot the previous values
        const previousData = {
          details: queryClient.getQueryData(
            trpc.transactions.getById.queryKey({ id: transactionId! }),
          ),
          list: queryClient.getQueryData(
            trpc.transactions.get.infiniteQueryKey(),
          ),
        };

        // Optimistically update details view
        queryClient.setQueryData(
          trpc.transactions.getById.queryKey({ id: transactionId! }),
          (old: any) => {
            if (variables.categorySlug) {
              const categories = queryClient.getQueryData(
                trpc.transactionCategories.get.queryKey(),
              );
              const category = categories?.find(
                (c) => c.slug === variables.categorySlug,
              );

              if (category) {
                return {
                  ...old,
                  ...variables,
                  category,
                };
              }
            }

            return {
              ...old,
              ...variables,
            };
          },
        );

        // Optimistically update list view
        queryClient.setQueryData(
          trpc.transactions.get.infiniteQueryKey(),
          (old: any) => {
            if (!old?.pages) return old;

            return {
              ...old,
              pages: old.pages.map((page: any) => ({
                ...page,
                data: page.data.map((transaction: any) =>
                  transaction.id === transactionId
                    ? {
                        ...transaction,
                        ...variables,
                        ...(variables.categorySlug && {
                          category: queryClient
                            .getQueryData(
                              trpc.transactionCategories.get.queryKey(),
                            )
                            ?.find((c) => c.slug === variables.categorySlug),
                        }),
                      }
                    : transaction,
                ),
              })),
            };
          },
        );

        return { previousData };
      },
      onError: (_, __, context) => {
        // Revert both caches on error
        queryClient.setQueryData(
          trpc.transactions.getById.queryKey({ id: transactionId! }),
          context?.previousData.details,
        );
        queryClient.setQueryData(
          trpc.transactions.get.infiniteQueryKey(),
          context?.previousData.list,
        );
      },
      onSettled: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.getById.queryKey({ id: transactionId! }),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });
      },
    }),
  );

  const createTransactionTagMutation = useMutation(
    trpc.transactionTags.create.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.getById.queryKey({ id: transactionId! }),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });
      },
    }),
  );

  const deleteTransactionTagMutation = useMutation(
    trpc.transactionTags.delete.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.getById.queryKey({ id: transactionId! }),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });
      },
    }),
  );

  const updateTransactionsMutation = useMutation(
    trpc.transactions.updateMany.mutationOptions({
      onSuccess: (_, data) => {
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.getById.queryKey({ id: transactionId! }),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });
      },
    }),
  );

  if (isLoading || !data) {
    return null;
  }

  const defaultValue = ["attachment"];

  if (data?.note) {
    defaultValue.push("note");
  }

  return (
    <div className="h-[calc(100vh-80px)] scrollbar-hide overflow-auto pb-12">
      <div className="flex justify-between mb-8">
        <div className="flex-1 flex-col">
          {isLoading ? (
            <div className="flex items-center justify-between  mt-1 mb-6">
              <div className="flex space-x-2 items-center">
                <Skeleton className="h-5 w-5 rounded-full" />
                <Skeleton className="w-[100px] h-[14px] rounded-full" />
              </div>
              <Skeleton className="w-[10%] h-[14px] rounded-full" />
            </div>
          ) : (
            <div className="flex items-center justify-between">
              {data?.account?.connection?.logoUrl && (
                <TransactionBankAccount
                  name={data?.account?.name ?? undefined}
                  logoUrl={data.account.connection.logoUrl}
                  className="text-[#606060] text-xs"
                />
              )}
              <span className="text-[#606060] text-xs select-text">
                {data?.date && format(new Date(data.date), "MMM d, y")}
              </span>
            </div>
          )}

          <h2 className="mt-6 mb-3 select-text">
            {isLoading ? (
              <Skeleton className="w-[35%] h-[22px] rounded-md mb-2" />
            ) : (
              data?.name
            )}
          </h2>
          <div className="flex justify-between items-center">
            <div className="flex flex-col w-full space-y-1">
              {isLoading ? (
                <Skeleton className="w-[50%] h-[30px] rounded-md mb-2" />
              ) : (
                <span
                  className={cn(
                    "text-4xl font-mono select-text",
                    data?.category?.slug === "income" && "text-[#00C969]",
                  )}
                >
                  <FormatAmount
                    amount={data?.amount}
                    currency={data?.currency}
                  />
                </span>
              )}
              <div className="h-3">
                {data?.taxAmount && data.taxAmount > 0 ? (
                  <span className="text-[#606060] text-xs select-text">
                    {data.taxType && `${getTaxTypeLabel(data.taxType)} `}
                    <FormatAmount
                      amount={data.taxAmount}
                      currency={data.currency}
                    />
                  </span>
                ) : null}
              </div>
            </div>
          </div>
        </div>
      </div>

      {data?.description && (
        <div className="border dark:bg-[#1A1A1A]/95 px-4 py-3 text-sm text-popover-foreground select-text">
          {data.description}
        </div>
      )}

      <div className="grid grid-cols-2 gap-4 mt-6 mb-2">
        <div>
          <Label htmlFor="category" className="mb-2 block">
            Category
          </Label>

          <SelectCategory
            id={transactionId}
            // @ts-expect-error
            selected={data?.category ?? undefined}
            onChange={async (category) => {
              if (category) {
                updateTransactionMutation.mutate({
                  id: data?.id,
                  categorySlug: category.slug,
                });

                const similarTransactions = await queryClient.fetchQuery(
                  trpc.transactions.getSimilarTransactions.queryOptions({
                    transactionId: data?.id,
                    name: data.name,
                    categorySlug: category.slug,
                  }),
                );

                if (
                  similarTransactions?.length &&
                  similarTransactions.length > 1
                ) {
                  toast({
                    duration: 6000,
                    variant: "ai",
                    title: "Midday AI",
                    description: `We found ${similarTransactions?.length} similar transactions to "${data?.name}". Mark them as ${category.name} too?`,
                    footer: (
                      <div className="flex space-x-2 mt-4">
                        <ToastAction altText="Cancel" className="pl-5 pr-5">
                          Cancel
                        </ToastAction>
                        <ToastAction
                          altText="Yes"
                          onClick={() => {
                            // Use bulk update with the similar transaction IDs
                            const similarTransactionIds =
                              similarTransactions.map((t) => t.id);
                            updateTransactionsMutation.mutate({
                              ids: similarTransactionIds,
                              categorySlug: category.slug,
                            });
                          }}
                          className="pl-5 pr-5 bg-primary text-primary-foreground hover:bg-primary/90"
                        >
                          Yes
                        </ToastAction>
                      </div>
                    ),
                  });
                }
              }
            }}
          />
        </div>

        <div>
          <Label htmlFor="assign" className="mb-2 block">
            Assign
          </Label>

          {isLoading ? (
            <div className="h-[36px] border">
              <Skeleton className="h-[14px] w-[60%] absolute left-3 top-[39px]" />
            </div>
          ) : (
            <AssignUser
              selectedId={data?.assigned?.id ?? undefined}
              onSelect={(user) => {
                if (user) {
                  updateTransactionMutation.mutate({
                    id: data?.id,
                    assignedId: user.id,
                  });
                }
              }}
            />
          )}
        </div>
      </div>

      <div className="mt-6">
        <Label htmlFor="tags" className="mb-2 block">
          Tags
        </Label>

        <SelectTags
          key={data?.id + data?.tags?.length}
          tags={data?.tags?.map((tag) => ({
            id: tag.id,
            label: tag.name!,
            value: tag.name!,
          }))}
          onSelect={(tag) => {
            if (tag.id) {
              createTransactionTagMutation.mutate({
                tagId: tag.id,
                transactionId: transactionId!,
              });
            }
          }}
          onRemove={(tag) => {
            if (tag.id) {
              deleteTransactionTagMutation.mutate({
                tagId: tag.id,
                transactionId: transactionId!,
              });
            }
          }}
        />
      </div>

      {(data?.suggestion?.suggestionId || data?.hasPendingSuggestion) && (
        <div className="mt-6">
          <SuggestedMatch
            suggestion={data?.suggestion}
            transactionId={transactionId!}
            isLoading={
              data?.hasPendingSuggestion && !data?.suggestion?.suggestionId
            }
          />
        </div>
      )}

      <Accordion type="multiple" defaultValue={defaultValue}>
        <AccordionItem value="attachment">
          <AccordionTrigger>Attachments</AccordionTrigger>
          <AccordionContent className="select-text">
            <TransactionAttachments id={data?.id} data={data?.attachments} />
          </AccordionContent>
        </AccordionItem>

        <AccordionItem value="general">
          <AccordionTrigger>General</AccordionTrigger>
          <AccordionContent className="select-text">
            <div className="mb-4 border-b pb-4">
              <Label className="mb-2 block font-medium text-md">
                Exclude from analytics
              </Label>
              <div className="flex flex-row items-center justify-between">
                <div className="space-y-0.5 pr-4">
                  <p className="text-xs text-muted-foreground">
                    Exclude this transaction from analytics like profit, expense
                    and revenue. This is useful for internal transfers between
                    accounts to avoid double-counting.
                  </p>
                </div>

                <Switch
                  checked={data?.internal ?? false}
                  onCheckedChange={(checked) => {
                    updateTransactionMutation.mutate({
                      id: data?.id,
                      internal: checked,
                    });
                  }}
                />
              </div>
            </div>

            <div className="flex flex-row items-center justify-between">
              <div className="space-y-0.5">
                <Label className="mb-2 block font-medium text-md">
                  Mark as recurring
                </Label>
                <p className="text-xs text-muted-foreground">
                  Mark as recurring. Similar future transactions will be
                  automatically categorized and flagged as recurring.
                </p>
              </div>
              <Switch
                checked={data?.recurring ?? false}
                onCheckedChange={(checked) => {
                  updateTransactionMutation.mutate({
                    id: data?.id,
                    recurring: checked,
                  });
                }}
              />
            </div>

            {data?.recurring && (
              <Select
                value={data?.frequency ?? undefined}
                onValueChange={async (value) => {
                  updateTransactionMutation.mutate({
                    id: data?.id,
                    frequency: value as
                      | "weekly"
                      | "monthly"
                      | "annually"
                      | "irregular",
                  });

                  const similarTransactions = await queryClient.fetchQuery(
                    trpc.transactions.getSimilarTransactions.queryOptions({
                      transactionId: data?.id,
                      name: data.name,
                      frequency: value as
                        | "weekly"
                        | "monthly"
                        | "annually"
                        | "irregular",
                    }),
                  );

                  if (
                    similarTransactions?.length &&
                    similarTransactions.length > 1
                  ) {
                    toast({
                      duration: 6000,
                      variant: "ai",
                      title: "Midday AI",
                      description: `We found ${similarTransactions?.length} similar transactions to "${data?.name}". Mark them as recurring (${value}) too?`,
                      footer: (
                        <div className="flex space-x-2 mt-4">
                          <ToastAction altText="Cancel" className="pl-5 pr-5">
                            Cancel
                          </ToastAction>
                          <ToastAction
                            altText="Yes"
                            onClick={() => {
                              // Use bulk update with the similar transaction IDs
                              const similarTransactionIds =
                                similarTransactions.map((t) => t.id);
                              updateTransactionsMutation.mutate({
                                ids: similarTransactionIds,
                                recurring: true,
                                frequency: value as
                                  | "weekly"
                                  | "monthly"
                                  | "annually"
                                  | "irregular",
                              });
                            }}
                            className="pl-5 pr-5 bg-primary text-primary-foreground hover:bg-primary/90"
                          >
                            Yes
                          </ToastAction>
                        </div>
                      ),
                    });
                  }
                }}
              >
                <SelectTrigger className="w-full mt-4">
                  <SelectValue placeholder="Select frequency" />
                </SelectTrigger>
                <SelectContent>
                  <SelectGroup>
                    {[
                      { id: "weekly", name: "Weekly" },
                      { id: "monthly", name: "Monthly" },
                      { id: "annually", name: "Annually" },
                    ].map(({ id, name }) => (
                      <SelectItem key={id} value={id}>
                        {name}
                      </SelectItem>
                    ))}
                  </SelectGroup>
                </SelectContent>
              </Select>
            )}
          </AccordionContent>
        </AccordionItem>

        <AccordionItem value="note">
          <AccordionTrigger>Note</AccordionTrigger>
          <AccordionContent className="select-text">
            <Note
              defaultValue={data?.note ?? ""}
              onChange={(value) => {
                updateTransactionMutation.mutate({
                  id: data?.id,
                  note: value,
                });
              }}
            />
          </AccordionContent>
        </AccordionItem>
      </Accordion>

      <TransactionShortcuts />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/transaction-method.tsx">
"use client";

import { useI18n } from "@/locales/client";
import type { RouterOutputs } from "@api/trpc/routers/_app";

type Props = {
  method: RouterOutputs["transactions"]["get"]["data"][number]["method"];
};

export function TransactionMethod({ method }: Props) {
  const t = useI18n();

  // @ts-expect-error
  return t(`transaction_methods.${method}`);
}
</file>

<file path="apps/dashboard/src/components/transaction-shortcuts.tsx">
"use client";

import { useTransactionParams } from "@/hooks/use-transaction-params";
import { useTRPC } from "@/trpc/client";
import { Icons } from "@midday/ui/icons";
import { useMutation, useQuery } from "@tanstack/react-query";
import { useQueryClient } from "@tanstack/react-query";
import { useHotkeys } from "react-hotkeys-hook";

export function TransactionShortcuts() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { transactionId } = useTransactionParams();

  const { data: transaction } = useQuery(
    trpc.transactions.getById.queryOptions(
      {
        id: transactionId!,
      },
      {
        enabled: !!transactionId,
      },
    ),
  );

  const updateTransactionMutation = useMutation(
    trpc.transactions.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.getById.queryKey({ id: transactionId! }),
        });

        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });
      },
    }),
  );

  useHotkeys(
    "meta+m",
    (event) => {
      event.preventDefault();
      if (!transaction?.attachments || transaction.attachments.length === 0) {
        updateTransactionMutation.mutate({
          id: transactionId!,
          status: transaction?.status === "completed" ? "posted" : "completed",
        });
      }
    },
    { enabled: !!transactionId },
  );

  return (
    <div className="absolute bottom-4 right-4 left-4 bg-[#FAFAF9] dark:bg-[#121212]">
      <div className="flex justify-between">
        <div className="flex items-center gap-2">
          <span className="text-[10px] h-6 flex items-center justify-center text-[#666] border border-border px-2">
            ⌘ M
          </span>
          <span className="text-[10px] text-[#666]">
            {transaction?.isFulfilled
              ? "Mark as uncompleted"
              : "Mark as completed"}
          </span>
        </div>

        <div className="flex gap-2">
          <div className="flex h-6 w-6 items-center justify-center border border-border text-[#666]">
            <Icons.ArrowUpward className="size-3.5" />
          </div>

          <div className="flex h-6 w-6 items-center justify-center border border-border text-[#666]">
            <Icons.ArrowDownward className="size-3.5" />
          </div>

          <div className="flex items-center gap-2">
            <span className="text-[10px] h-6 flex items-center justify-center text-[#666] border border-border px-2">
              Esc
            </span>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/transaction-status.tsx">
import { Icons } from "@midday/ui/icons";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@midday/ui/tooltip";

type Props = {
  fullfilled: boolean;
  hasPendingSuggestion?: boolean;
};

export function TransactionStatus({ fullfilled, hasPendingSuggestion }: Props) {
  if (fullfilled) {
    return (
      <div className="flex justify-start z-50">
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <div className="flex space-x-1 items-center cursor-default">
                <Icons.Check className="size-4.5 mt-[1px]" />
                <span>Matched</span>
              </div>
            </TooltipTrigger>
            <TooltipContent sideOffset={10} className="text-xs">
              <p>
                This transaction has been successfully <br />
                matched to a receipt or invoice
              </p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
    );
  }

  if (hasPendingSuggestion) {
    return (
      <div className="flex justify-start z-50">
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <div className="flex space-x-1.5 items-center cursor-default">
                <div className="w-1.5 h-1.5 bg-[#FFD02B] rounded-full" />
                <span>Suggested match</span>
              </div>
            </TooltipTrigger>
            <TooltipContent sideOffset={10} className="text-xs">
              <p>
                We found a possible match — confirm <br />
                or dismiss it
              </p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
    );
  }

  return null;
}
</file>

<file path="apps/dashboard/src/components/transactions-actions.tsx">
"use client";

import { AddTransactions } from "@/components/add-transactions";
import { BulkActions } from "@/components/bulk-actions";
import { TransactionsColumnVisibility } from "@/components/transactions-column-visibility";
import { useTransactionsStore } from "@/store/transactions";
import { useTRPC } from "@/trpc/client";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@midday/ui/alert-dialog";
import { Button } from "@midday/ui/button";
import { Icons } from "@midday/ui/icons";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { Loader2 } from "lucide-react";

export function TransactionsActions() {
  const { setRowSelection, canDelete, rowSelection } = useTransactionsStore();
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const deleteTransactionsMutation = useMutation(
    trpc.transactions.deleteMany.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.transactions.get.infiniteQueryKey(),
        });

        setRowSelection({});
      },
    }),
  );

  const transactionIds = Object.keys(rowSelection);

  if (transactionIds?.length) {
    return (
      <AlertDialog>
        <div className="ml-auto">
          <div className="flex items-center">
            <span className="text-sm text-[#606060] w-full">Bulk edit</span>
            <div className="h-8 w-[1px] bg-border ml-4 mr-4" />

            <div className="flex space-x-2">
              <BulkActions ids={transactionIds} />

              <div>
                {canDelete && (
                  <AlertDialogTrigger asChild>
                    <Button
                      size="icon"
                      variant="destructive"
                      className="bg-transparent border border-destructive hover:bg-transparent"
                    >
                      <Icons.Delete className="text-destructive" size={18} />
                    </Button>
                  </AlertDialogTrigger>
                )}
              </div>
            </div>
          </div>
        </div>

        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete your
              transactions.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={() => {
                deleteTransactionsMutation.mutate(transactionIds);
              }}
            >
              {deleteTransactionsMutation.isPending ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                "Confirm"
              )}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    );
  }

  return (
    <div className="space-x-2 hidden md:flex">
      <TransactionsColumnVisibility />
      <AddTransactions />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/transactions-column-visibility.tsx">
import { useTransactionsStore } from "@/store/transactions";
import { Button } from "@midday/ui/button";
import { Checkbox } from "@midday/ui/checkbox";
import { Icons } from "@midday/ui/icons";
import { Popover, PopoverContent, PopoverTrigger } from "@midday/ui/popover";

export function TransactionsColumnVisibility() {
  const { columns } = useTransactionsStore();

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button variant="outline" size="icon">
          <Icons.Tune size={18} />
        </Button>
      </PopoverTrigger>

      <PopoverContent className="w-[200px] p-0" align="end" sideOffset={8}>
        <div className="flex flex-col p-4 space-y-2 max-h-[352px] overflow-auto">
          {columns
            .filter(
              (column) =>
                column.columnDef.enableHiding !== false &&
                column.id !== "status",
            )
            .map((column) => {
              return (
                <div key={column.id} className="flex items-center space-x-2">
                  <Checkbox
                    id={column.id}
                    checked={column.getIsVisible()}
                    onCheckedChange={(checked) =>
                      column.toggleVisibility(checked === true)
                    }
                  />
                  <label
                    htmlFor={column.id}
                    className="text-sm peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                  >
                    {column.columnDef.header?.toString() ?? column.id}
                  </label>
                </div>
              );
            })}
        </div>
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="apps/dashboard/src/components/transactions-search-filter.tsx">
"use client";

import { generateTransactionsFilters } from "@/actions/ai/filters/generate-transactions-filters";
import { useTransactionFilterParams } from "@/hooks/use-transaction-filter-params";
import { useTransactionFilterParamsWithPersistence } from "@/hooks/use-transaction-filter-params-with-persistence";
import { useTRPC } from "@/trpc/client";
import { formatAccountName } from "@/utils/format";
import { Calendar } from "@midday/ui/calendar";
import { cn } from "@midday/ui/cn";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import { Icons } from "@midday/ui/icons";
import { Input } from "@midday/ui/input";
import { useQuery } from "@tanstack/react-query";
import { readStreamableValue } from "ai/rsc";
import { formatISO } from "date-fns";
import { useEffect, useRef, useState } from "react";
import { useHotkeys } from "react-hotkeys-hook";
import { AmountRange } from "./amount-range";
import { FilterList } from "./filter-list";
import { SelectCategory } from "./select-category";

type StatusFilter = "completed" | "uncompleted" | "archived" | "excluded";
type AttachmentFilter = "include" | "exclude";
type RecurringFilter = "all" | "weekly" | "monthly" | "annually";

interface BaseFilterItem {
  name: string;
}

interface FilterItem<T extends string> extends BaseFilterItem {
  id: T;
}

interface FilterMenuItemProps {
  icon: (typeof Icons)[keyof typeof Icons];
  label: string;
  children: React.ReactNode;
}

interface FilterCheckboxItemProps {
  id: string;
  name: string;
  checked?: boolean;
  className?: string;
  onCheckedChange: () => void;
}

// Static data
const defaultSearch = {
  q: null,
  attachments: null,
  start: null,
  end: null,
  categories: null,
  accounts: null,
  assignees: null,
  statuses: null,
  recurring: null,
  tags: null,
  amount_range: null,
};

const PLACEHOLDERS = [
  "Software and taxes last month",
  "Income last year",
  "Software last Q4",
  "From Google without receipt",
  "Search or filter",
  "Without receipts this month",
];

const statusFilters: FilterItem<StatusFilter>[] = [
  { id: "completed", name: "Completed" },
  { id: "uncompleted", name: "Uncompleted" },
  { id: "archived", name: "Archived" },
  { id: "excluded", name: "Excluded" },
];

const attachmentsFilters: FilterItem<AttachmentFilter>[] = [
  { id: "include", name: "Has attachments" },
  { id: "exclude", name: "No attachments" },
];

const recurringFilters: FilterItem<RecurringFilter>[] = [
  { id: "all", name: "All recurring" },
  { id: "weekly", name: "Weekly recurring" },
  { id: "monthly", name: "Monthly recurring" },
  { id: "annually", name: "Annually recurring" },
];

// Reusable components
function FilterMenuItem({ icon: Icon, label, children }: FilterMenuItemProps) {
  return (
    <DropdownMenuGroup>
      <DropdownMenuSub>
        <DropdownMenuSubTrigger>
          <Icon className="mr-2 size-4" />
          <span>{label}</span>
        </DropdownMenuSubTrigger>
        <DropdownMenuPortal>
          <DropdownMenuSubContent
            sideOffset={14}
            alignOffset={-4}
            className="p-0"
          >
            {children}
          </DropdownMenuSubContent>
        </DropdownMenuPortal>
      </DropdownMenuSub>
    </DropdownMenuGroup>
  );
}

function FilterCheckboxItem({
  id,
  name,
  checked = false,
  onCheckedChange,
  className,
}: FilterCheckboxItemProps) {
  return (
    <DropdownMenuCheckboxItem
      key={id}
      checked={checked}
      onCheckedChange={onCheckedChange}
      className={className}
    >
      {name}
    </DropdownMenuCheckboxItem>
  );
}

function useFilterData(isOpen: boolean, isFocused: boolean) {
  const trpc = useTRPC();
  const { filter } = useTransactionFilterParams();

  const shouldFetch = isOpen || isFocused;

  const { data: tagsData } = useQuery({
    ...trpc.tags.get.queryOptions(),
    enabled: shouldFetch || Boolean(filter.tags?.length),
  });

  const { data: bankAccountsData } = useQuery({
    ...trpc.bankAccounts.get.queryOptions({
      enabled: shouldFetch || Boolean(filter.accounts?.length),
    }),
  });

  // We want to fetch the categories data on mount
  const { data: categoriesData } = useQuery({
    ...trpc.transactionCategories.get.queryOptions(),
  });

  return {
    tags: tagsData?.map((tag) => ({
      id: tag.id,
      name: tag.name,
    })),
    accounts: bankAccountsData?.map((bankAccount) => ({
      id: bankAccount.id,
      name: bankAccount.name ?? "",
      currency: bankAccount.currency ?? "",
    })),
    categories: categoriesData?.flatMap((category) => [
      // Include parent category
      {
        id: category.id,
        name: category.name,
        slug: category.slug,
      },
      // Include all child categories
      ...(category.children?.map((child) => ({
        id: child.id,
        name: child.name,
        slug: child.slug,
      })) || []),
    ]),
  };
}

function updateArrayFilter(
  value: string,
  currentValues: string[] | null | undefined,
  setFilter: (update: Record<string, unknown>) => void,
  key: string,
) {
  const normalizedValues = currentValues ?? null;
  const newValues = normalizedValues?.includes(value)
    ? normalizedValues.filter((v) => v !== value).length > 0
      ? normalizedValues.filter((v) => v !== value)
      : null
    : [...(normalizedValues ?? []), value];

  setFilter({ [key]: newValues });
}

export function TransactionsSearchFilter() {
  const [placeholder, setPlaceholder] = useState("");
  const inputRef = useRef<HTMLInputElement>(null);
  const [streaming, setStreaming] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const { filter = defaultSearch, setFilter } =
    useTransactionFilterParamsWithPersistence();
  const { tags, accounts, categories } = useFilterData(isOpen, isFocused);
  const [prompt, setPrompt] = useState(filter.q ?? "");

  useEffect(() => {
    const randomPlaceholder =
      PLACEHOLDERS[Math.floor(Math.random() * PLACEHOLDERS.length)] ??
      "Search or filter";

    setPlaceholder(randomPlaceholder);
  }, []);

  useHotkeys(
    "esc",
    () => {
      setPrompt("");
      setFilter(defaultSearch);
      setIsOpen(false);
    },
    {
      enableOnFormTags: true,
      enabled: Boolean(prompt) && isFocused,
    },
  );

  useHotkeys("meta+s", (evt) => {
    evt.preventDefault();
    inputRef.current?.focus();
  });

  const handleSearch = (evt: React.ChangeEvent<HTMLInputElement>) => {
    const value = evt.target.value;
    if (value) {
      setPrompt(value);
    } else {
      setFilter(defaultSearch);
      setPrompt("");
    }
  };

  const handleSubmit = async () => {
    if (prompt.split(" ").length > 1) {
      setStreaming(true);

      const { object } = await generateTransactionsFilters(
        prompt,
        `
          Categories: ${categories?.map((category) => category.name).join(", ")}
          Tags: ${tags?.map((tag) => tag.name).join(", ")}
        `,
      );

      let finalObject = {};

      for await (const partialObject of readStreamableValue(object)) {
        if (partialObject) {
          finalObject = {
            ...finalObject,
            ...partialObject,
            categories:
              partialObject?.categories?.map(
                (name: string) =>
                  categories?.find((category) => category.name === name)?.slug,
              ) ?? null,
            tags:
              partialObject?.tags?.map(
                (name: string) => tags?.find((tag) => tag.name === name)?.id,
              ) ?? null,
            recurring: partialObject?.recurring ?? null,
            q: partialObject?.name ?? null,
            amount_range: partialObject?.amount_range ?? null,
          };
        }
      }

      setFilter({
        q: null,
        ...finalObject,
      });

      setStreaming(false);
    } else {
      setFilter({ q: prompt.length > 0 ? prompt : null });
    }
  };

  const validFilters = Object.fromEntries(
    Object.entries(filter).filter(([key]) => key !== "q"),
  );

  const hasValidFilters = Object.values(validFilters).some(
    (value) => value !== null,
  );

  const processFiltersForList = () => {
    return Object.fromEntries(
      Object.entries({
        ...validFilters,
        start: filter.start ?? undefined,
        end: filter.end ?? undefined,
        amount_range: filter.amount_range
          ? `${filter.amount_range[0]}-${filter.amount_range[1]}`
          : undefined,
        attachments: filter.attachments ?? undefined,
        categories: filter.categories ?? undefined,
        tags: filter.tags ?? undefined,
        accounts: filter.accounts ?? undefined,
        assignees: filter.assignees ?? undefined,
        statuses: filter.statuses ?? undefined,
        recurring: filter.recurring ?? undefined,
      }).filter(([_, value]) => value !== undefined && value !== null),
    );
  };

  const getAmountRange = () => {
    if (
      !filter.amount_range ||
      !Array.isArray(filter.amount_range) ||
      filter.amount_range.length < 2
    ) {
      return undefined;
    }
    return [filter.amount_range[0], filter.amount_range[1]] as [number, number];
  };

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <div className="flex flex-col sm:flex-row sm:space-x-4 space-y-2 sm:space-y-0 items-stretch sm:items-center w-full md:w-auto">
        <form
          className="relative flex-1 sm:flex-initial"
          onSubmit={(e) => {
            e.preventDefault();
            handleSubmit();
          }}
        >
          <Icons.Search className="absolute pointer-events-none left-3 top-[11px]" />
          <Input
            ref={inputRef}
            placeholder={placeholder}
            className="pl-9 w-full sm:w-[350px] pr-8"
            value={prompt}
            onChange={handleSearch}
            onFocus={() => setIsFocused(true)}
            onBlur={() => setIsFocused(false)}
            autoComplete="off"
            autoCapitalize="none"
            autoCorrect="off"
            spellCheck="false"
          />

          <DropdownMenuTrigger asChild>
            <button
              onClick={() => setIsOpen((prev) => !prev)}
              type="button"
              className={cn(
                "absolute z-10 right-3 top-[10px] opacity-50 transition-opacity duration-300 hover:opacity-100",
                hasValidFilters && "opacity-100",
                isOpen && "opacity-100",
              )}
            >
              <Icons.Filter />
            </button>
          </DropdownMenuTrigger>
        </form>

        <FilterList
          filters={processFiltersForList()}
          loading={streaming}
          onRemove={setFilter}
          categories={categories}
          accounts={accounts}
          statusFilters={statusFilters}
          attachmentsFilters={attachmentsFilters}
          tags={tags}
          recurringFilters={recurringFilters}
          amountRange={getAmountRange()}
        />
      </div>

      <DropdownMenuContent
        className="w-[350px]"
        align="end"
        sideOffset={19}
        alignOffset={-11}
        side="top"
      >
        <FilterMenuItem icon={Icons.CalendarMonth} label="Date">
          <Calendar
            mode="range"
            initialFocus
            toDate={new Date()}
            selected={{
              from: filter.start ? new Date(filter.start) : undefined,
              to: filter.end ? new Date(filter.end) : undefined,
            }}
            onSelect={(range) => {
              if (!range) return;

              const newRange = {
                start: range.from
                  ? formatISO(range.from, { representation: "date" })
                  : null,
                end: range.to
                  ? formatISO(range.to, { representation: "date" })
                  : null,
              };

              setFilter(newRange);
            }}
          />
        </FilterMenuItem>

        <FilterMenuItem icon={Icons.Amount} label="Amount">
          <div className="w-[280px] p-4">
            <AmountRange />
          </div>
        </FilterMenuItem>

        <FilterMenuItem icon={Icons.Status} label="Status">
          {statusFilters.map(({ id, name }) => (
            <FilterCheckboxItem
              key={id}
              id={id}
              name={name}
              checked={filter?.statuses?.includes(id)}
              onCheckedChange={() =>
                updateArrayFilter(id, filter.statuses, setFilter, "statuses")
              }
            />
          ))}
        </FilterMenuItem>

        <FilterMenuItem icon={Icons.Attachments} label="Attachments">
          {attachmentsFilters.map(({ id, name }) => (
            <FilterCheckboxItem
              key={id}
              id={id}
              name={name}
              checked={filter?.attachments === id}
              onCheckedChange={() => {
                setFilter({
                  attachments: id,
                });
              }}
            />
          ))}
        </FilterMenuItem>

        <FilterMenuItem icon={Icons.Category} label="Categories">
          <div className="w-[250px] h-[270px]">
            <SelectCategory
              headless
              onChange={(selected) =>
                updateArrayFilter(
                  selected.slug,
                  filter.categories,
                  setFilter,
                  "categories",
                )
              }
            />
          </div>
        </FilterMenuItem>

        <FilterMenuItem icon={Icons.Status} label="Tags">
          <div className="max-h-[400px] overflow-y-auto">
            {tags && tags.length > 0 ? (
              tags.map((tag) => (
                <FilterCheckboxItem
                  key={tag.id}
                  id={tag.id}
                  name={tag.name}
                  checked={filter?.tags?.includes(tag.id)}
                  onCheckedChange={() =>
                    updateArrayFilter(tag.id, filter.tags, setFilter, "tags")
                  }
                />
              ))
            ) : (
              <p className="text-sm text-[#878787] px-2">No tags found</p>
            )}
          </div>
        </FilterMenuItem>

        <FilterMenuItem icon={Icons.Accounts} label="Accounts">
          {accounts?.map((account) => (
            <FilterCheckboxItem
              key={account.id}
              id={account.id}
              name={formatAccountName({
                name: account.name,
                currency: account.currency,
              })}
              checked={filter?.accounts?.includes(account.id)}
              onCheckedChange={() =>
                updateArrayFilter(
                  account.id,
                  filter.accounts,
                  setFilter,
                  "accounts",
                )
              }
            />
          ))}
        </FilterMenuItem>

        <FilterMenuItem icon={Icons.Repeat} label="Recurring">
          {recurringFilters.map(({ id, name }) => (
            <FilterCheckboxItem
              key={id}
              id={id}
              name={name}
              checked={filter?.recurring?.includes(id)}
              onCheckedChange={() =>
                updateArrayFilter(id, filter.recurring, setFilter, "recurring")
              }
            />
          ))}
        </FilterMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/trial.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { UTCDate } from "@date-fns/utc";
import { addDays, differenceInDays, isSameDay, parseISO } from "date-fns";
import { ChoosePlanButton } from "./choose-plan-button";
import { FeedbackForm } from "./feedback-form";

export function Trial() {
  const { data: user } = useUserQuery();

  const team = user?.team;

  if (!team) {
    return null;
  }

  if (team.plan !== "trial") {
    return <FeedbackForm />;
  }

  // Parse dates using UTCDate for consistent timezone handling
  const rawCreatedAt = parseISO(team.createdAt);
  const today = new UTCDate();

  // Convert to UTCDate for consistent calculation
  const createdAt = new UTCDate(rawCreatedAt);

  // Set trial end date 14 days from creation
  const trialEndDate = addDays(createdAt, 14);

  const daysLeft = isSameDay(createdAt, today)
    ? 14
    : Math.max(0, differenceInDays(trialEndDate, today));

  const isTrialEnded = daysLeft <= 0;

  if (isTrialEnded) {
    return (
      <ChoosePlanButton
        initialIsOpen={false}
        daysLeft={daysLeft}
        hasDiscount
        discountPrice={49}
      >
        Upgrade plan
      </ChoosePlanButton>
    );
  }

  return (
    <ChoosePlanButton hasDiscount discountPrice={49} daysLeft={daysLeft}>
      Pro trial - {daysLeft} {daysLeft === 1 ? "day" : "days"} left
    </ChoosePlanButton>
  );
}
</file>

<file path="apps/dashboard/src/components/unenroll-mfa.tsx">
import { Suspense } from "react";
import { MFAList, MFAListSkeleton } from "./mfa-list";

export function UnenrollMFA() {
  return (
    <Suspense fallback={<MFAListSkeleton />}>
      <MFAList />
    </Suspense>
  );
}
</file>

<file path="apps/dashboard/src/components/unified-app.tsx">
import { useTRPC } from "@/trpc/client";
import { getScopeDescription } from "@/utils/scopes";
import type { UnifiedApp } from "@midday/app-store/types";
import { openUrl } from "@midday/desktop-client/core";
import { isDesktopApp } from "@midday/desktop-client/platform";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@midday/ui/accordion";
import { Badge } from "@midday/ui/badge";
import { Button } from "@midday/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@midday/ui/card";
import {
  Carousel,
  type CarouselApi,
  CarouselContent,
  CarouselItem,
} from "@midday/ui/carousel";
import { ScrollArea } from "@midday/ui/scroll-area";
import { Sheet, SheetContent, SheetHeader } from "@midday/ui/sheet";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import Image from "next/image";
import { parseAsBoolean, parseAsString, useQueryStates } from "nuqs";
import { useEffect, useState } from "react";
import { AppSettings } from "./app-settings";

interface UnifiedAppProps {
  app: UnifiedApp;
  userEmail?: string;
}

function CarouselWithDots({
  images,
  appName,
}: { images: string[]; appName: string }) {
  const [api, setApi] = useState<CarouselApi>();
  const [current, setCurrent] = useState(0);

  useEffect(() => {
    if (!api) {
      return;
    }

    setCurrent(api.selectedScrollSnap());

    api.on("select", () => {
      setCurrent(api.selectedScrollSnap());
    });
  }, [api]);

  return (
    <div className="relative">
      <Carousel className="w-full max-w-[465px]" setApi={setApi}>
        <CarouselContent>
          {images.map((image: string, index: number) => (
            <CarouselItem key={`${appName}-${image}-${index.toString()}`}>
              <Image
                src={image}
                alt={`${appName} screenshot ${index + 1}`}
                width={465}
                height={290}
                quality={100}
              />
            </CarouselItem>
          ))}
        </CarouselContent>
      </Carousel>

      {/* Pagination dots */}
      <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex space-x-2">
        {images.map((image, index) => (
          <button
            key={`dot-${image}-${index.toString()}`}
            type="button"
            className={`w-2 h-2 rounded-full transition-all ${
              index === current
                ? "bg-white shadow-lg"
                : "bg-white/50 hover:bg-white/75"
            }`}
            onClick={() => api?.scrollTo(index)}
            aria-label={`Go to screenshot ${index + 1}`}
          />
        ))}
      </div>
    </div>
  );
}

export function UnifiedAppComponent({ app }: UnifiedAppProps) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const [isLoading, setLoading] = useState(false);
  const [params, setParams] = useQueryStates({
    app: parseAsString,
    settings: parseAsBoolean,
  });

  const disconnectOfficialAppMutation = useMutation(
    trpc.apps.disconnect.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.apps.get.queryKey(),
        });
      },
    }),
  );

  const revokeExternalAppMutation = useMutation(
    trpc.oauthApplications.revokeAccess.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.oauthApplications.authorized.queryKey(),
        });
      },
    }),
  );

  const handleDisconnect = () => {
    if (app.type === "official") {
      disconnectOfficialAppMutation.mutate({ appId: app.id });
    } else {
      revokeExternalAppMutation.mutate({ applicationId: app.id });
    }
  };

  const handleOnInitialize = async () => {
    setLoading(true);

    try {
      if (app.type === "official" && app.onInitialize) {
        await app.onInitialize();
      } else if (app.type === "external" && app.installUrl) {
        // Open the install URL for the OAuth application
        if (isDesktopApp()) {
          openUrl(app.installUrl);
        } else {
          window.open(app.installUrl, "_blank");
        }
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <Card key={app.id} className="w-full flex flex-col">
      <Sheet open={params.app === app.id} onOpenChange={() => setParams(null)}>
        <div className="pt-6 px-6 h-16 flex items-center justify-between">
          {app.type === "official" &&
          app.logo &&
          typeof app.logo !== "string" ? (
            <app.logo />
          ) : (
            <img src={app.logo as string} alt={app.name} className="w-8 h-8" />
          )}

          <div className="flex items-center gap-2">
            {app.installed && (
              <div className="text-green-600 bg-green-100 text-[10px] dark:bg-green-900 dark:text-green-300 px-3 py-1 rounded-full font-mono">
                Installed
              </div>
            )}
          </div>
        </div>

        <CardHeader className="pb-0">
          <div className="flex items-center space-x-2 pb-4">
            <CardTitle className="text-md font-medium leading-none p-0 m-0">
              {app.name}
            </CardTitle>
            {!app.active && (
              <span className="text-[#878787] bg-[#F2F1EF] text-[10px] dark:bg-[#1D1D1D] px-3 py-1 rounded-full font-mono">
                Coming soon
              </span>
            )}
          </div>
        </CardHeader>
        <CardContent className="text-xs text-[#878787] pb-4">
          <p>{app.short_description}</p>
        </CardContent>

        <div className="px-6 pb-6 flex gap-2 mt-auto">
          <Button
            variant="outline"
            className="w-full"
            disabled={!app.active}
            onClick={() => setParams({ app: app.id })}
          >
            Details
          </Button>

          {app.installed ? (
            <Button
              variant="outline"
              className="w-full"
              onClick={handleDisconnect}
              disabled={
                disconnectOfficialAppMutation.isPending ||
                revokeExternalAppMutation.isPending
              }
            >
              {disconnectOfficialAppMutation.isPending ||
              revokeExternalAppMutation.isPending
                ? "Disconnecting..."
                : "Disconnect"}
            </Button>
          ) : (
            <Button
              variant="outline"
              className="w-full"
              onClick={handleOnInitialize}
              disabled={!app.active || isLoading}
            >
              {isLoading ? "Installing..." : "Install"}
            </Button>
          )}
        </div>

        <SheetContent>
          <SheetHeader>
            {app.images.length > 0 && (
              <div className="mb-4">
                {app.images.length === 1 ? (
                  <Image
                    src={app.images[0] as string}
                    alt={app.name}
                    width={465}
                    height={290}
                    quality={100}
                    className="rounded-lg"
                  />
                ) : (
                  <CarouselWithDots images={app.images} appName={app.name} />
                )}
              </div>
            )}

            <div className="flex items-center justify-between border-b border-border pb-2">
              <div className="flex items-center space-x-2">
                {app.type === "official" &&
                app.logo &&
                typeof app.logo !== "string" ? (
                  <app.logo />
                ) : (
                  <img
                    src={app.logo as string}
                    alt={app.name}
                    className="w-8 h-8 rounded"
                  />
                )}
                <div>
                  <div className="flex items-center space-x-2">
                    <h3 className="text-lg leading-none">{app.name}</h3>
                    {app.installed && (
                      <div className="bg-green-600 text-[9px] dark:bg-green-300 rounded-full size-1" />
                    )}
                  </div>

                  <span className="text-xs text-[#878787]">
                    {app.category} •{" "}
                    {app.type === "external"
                      ? `By ${app.developerName}`
                      : "By Midday"}
                  </span>
                </div>
              </div>

              <div>
                {app.installed ? (
                  <Button
                    variant="outline"
                    className="w-full"
                    onClick={handleDisconnect}
                    disabled={
                      disconnectOfficialAppMutation.isPending ||
                      revokeExternalAppMutation.isPending
                    }
                  >
                    {disconnectOfficialAppMutation.isPending ||
                    revokeExternalAppMutation.isPending
                      ? "Disconnecting..."
                      : "Disconnect"}
                  </Button>
                ) : (
                  <Button
                    variant="outline"
                    className="w-full border-primary"
                    onClick={handleOnInitialize}
                    disabled={!app.active || isLoading}
                  >
                    {isLoading ? "Installing..." : "Install"}
                  </Button>
                )}
              </div>
            </div>

            <div className="mt-4">
              <ScrollArea className="h-[calc(100vh-530px)] pt-2" hideScrollbar>
                <Accordion
                  type="multiple"
                  defaultValue={[
                    "description",
                    ...(params.settings ? ["settings"] : []),
                  ]}
                  className="mt-4"
                >
                  <AccordionItem value="description" className="border-none">
                    <AccordionTrigger>How it works</AccordionTrigger>
                    <AccordionContent className="text-[#878787] text-sm">
                      {app.description || app.overview}
                    </AccordionContent>
                  </AccordionItem>

                  {app.type === "official" &&
                    app.settings &&
                    app.settings.length > 0 && (
                      <AccordionItem value="settings" className="border-none">
                        <AccordionTrigger>Settings</AccordionTrigger>
                        <AccordionContent className="text-[#878787] text-sm">
                          <AppSettings
                            appId={app.id}
                            settings={app.settings.map((setting) => {
                              // Find the user setting for this setting ID
                              const userSetting = Array.isArray(
                                app.userSettings,
                              )
                                ? app.userSettings.find(
                                    (us: any) => us.id === setting.id,
                                  )
                                : null;

                              return {
                                ...setting,
                                type: setting.type as
                                  | "switch"
                                  | "text"
                                  | "select",
                                value: userSetting?.value ?? setting.value,
                              };
                            })}
                          />
                        </AccordionContent>
                      </AccordionItem>
                    )}

                  {app.type === "external" && (
                    <>
                      {app.website && (
                        <AccordionItem value="website" className="border-none">
                          <AccordionTrigger>Website</AccordionTrigger>
                          <AccordionContent>
                            <a
                              href={app.website}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="text-sm hover:underline text-[#878787]"
                            >
                              {app.website}
                            </a>
                          </AccordionContent>
                        </AccordionItem>
                      )}

                      {app.scopes && app.scopes.length > 0 && (
                        <AccordionItem
                          value="permissions"
                          className="border-none"
                        >
                          <AccordionTrigger>Permissions</AccordionTrigger>
                          <AccordionContent>
                            <div className="flex flex-wrap gap-2">
                              {app.scopes.map((scope) => (
                                <Badge key={scope} variant="tag">
                                  {getScopeDescription(scope).label}
                                </Badge>
                              ))}
                            </div>
                          </AccordionContent>
                        </AccordionItem>
                      )}
                    </>
                  )}
                </Accordion>
              </ScrollArea>

              <div className="absolute bottom-4 pt-8 border-t border-border">
                <p className="text-[10px] text-[#878787]">
                  All apps on the Midday App Store are open-source and
                  peer-reviewed. Midday Labs AB maintains high standards but
                  doesn't endorse third-party apps. Apps published by Midday are
                  officially certified. Report any concerns about app content or
                  behavior.
                </p>

                <a
                  href="mailto:support@midday.dev"
                  className="text-[10px] text-red-500"
                >
                  Report app
                </a>
              </div>
            </div>
          </SheetHeader>
        </SheetContent>
      </Sheet>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/usage.tsx">
import { getPlanLimits } from "@/utils/plans";
import { Card } from "@midday/ui/card";
import { Skeleton } from "@midday/ui/skeleton";

interface UsageItemProps {
  label: string;
  current: number;
  max: number;
  unit?: string;
  period?: string;
  percentage?: number;
}

function CircularProgress({ value }: { value: number }) {
  return (
    <div className="relative h-6 w-6 flex items-center justify-center">
      <svg className="h-6 w-6" viewBox="0 0 36 36">
        {/* Background circle */}
        <circle
          className="stroke-muted fill-none"
          cx="18"
          cy="18"
          r="16"
          strokeWidth="4"
        />
        {/* Progress circle */}
        <circle
          className="stroke-primary fill-none"
          cx="18"
          cy="18"
          r="16"
          strokeWidth="4"
          strokeDasharray={`${value * 0.01 * 100.53} 100.53`}
          strokeDashoffset="0"
          transform="rotate(-90 18 18)"
        />
      </svg>
    </div>
  );
}

// Helper function to format file size
function formatFileSize(bytes: number): { value: number; unit: string } {
  const KB = 1024;
  const MB = KB * 1024;
  const GB = MB * 1024;

  if (bytes >= GB) {
    return { value: bytes / GB, unit: "GB" };
  }

  if (bytes >= MB) {
    return { value: bytes / MB, unit: "MB" };
  }

  return { value: Math.max(bytes / KB, 0.1), unit: "KB" };
}

function UsageItem({
  label,
  current,
  max,
  unit,
  period,
  percentage,
}: UsageItemProps) {
  // Calculate percentage if not explicitly provided
  const calculatedPercentage =
    percentage !== undefined
      ? percentage
      : Math.min((current / max) * 100, 100);

  // Format values differently based on whether we have a unit or not
  let formattedCurrent: string;
  let formattedMax: string;

  if (unit) {
    // For values with units (like GB), show the decimal value
    formattedCurrent = current.toFixed(1).replace(/\.0$/, "");
    formattedMax = max.toFixed(1).replace(/\.0$/, "");
  } else {
    // For counts without units, use k formatting for large numbers
    formattedCurrent =
      current >= 1000 ? `${(current / 1000).toFixed(1)}k` : current.toString();

    formattedMax = max >= 1000 ? `${(max / 1000).toFixed(1)}k` : max.toString();
  }

  return (
    <div className="flex items-center justify-between py-3 px-4">
      <div className="flex items-center gap-4">
        <CircularProgress value={calculatedPercentage} />
        <span className="text-sm font-medium">{label}</span>
      </div>
      <div className="text-sm text-muted-foreground">
        {formattedCurrent}/{formattedMax} {unit}{" "}
        {period && <span>per {period}</span>}
      </div>
    </div>
  );
}

export function Usage({
  data,
  plan,
}: {
  plan: string;
  data: {
    total_document_size: number;
    number_of_users: number;
    number_of_bank_connections: number;
    inbox_created_this_month: number;
    invoices_created_this_month: number;
  };
}) {
  const GB = 1024 * 1024 * 1024;

  const selectedPlan = getPlanLimits(plan);

  // Always convert to GB regardless of size
  const storageInGB = data?.total_document_size ?? 0 / GB;
  const maxStorageInGB = selectedPlan?.storage ?? 0 / GB;

  return (
    <div>
      <h2 className="text-lg font-medium leading-none tracking-tight mb-4">
        Usage
      </h2>

      <Card className="divide-y">
        <UsageItem
          label="Users"
          current={data?.number_of_users ?? 0}
          max={selectedPlan?.users}
        />
        <UsageItem
          label="Bank connections"
          current={data?.number_of_bank_connections ?? 0}
          max={selectedPlan?.bankConnections}
        />
        {/* <UsageItem
          label="Storage"
          current={storageInGB}
          max={selectedPlan?.storage}
          unit="GB"
          percentage={Math.min(
            (data?.total_document_size ?? 0 / selectedPlan?.storage) * 100,
            100,
          )}
        /> */}
        <UsageItem
          label="Inbox"
          current={data?.inbox_created_this_month ?? 0}
          max={selectedPlan.inbox}
          period="month"
        />
        <UsageItem
          label="Invoices"
          current={data?.invoices_created_this_month ?? 0}
          max={selectedPlan.invoices}
          period="month"
        />
      </Card>
    </div>
  );
}

export function UsageSkeleton() {
  // Define labels to use for keys instead of array indices
  const skeletonItems = [
    "users",
    "connections",
    // "storage",
    "inbox",
    "invoices",
  ];

  return (
    <div>
      <h2 className="text-lg font-medium leading-none tracking-tight mb-4">
        Usage
      </h2>

      <Card className="divide-y">
        {skeletonItems.map((item) => (
          <div
            key={item}
            className="flex items-center justify-between py-3 px-4"
          >
            <div className="flex items-center gap-4">
              <Skeleton className="h-6 w-6 rounded-full" />
              <Skeleton className="h-4 w-24" />
            </div>
            <Skeleton className="h-4 w-20" />
          </div>
        ))}
      </Card>
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/user-avatar.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import {
  Card,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { AvatarUpload } from "./avatar-upload";

export function UserAvatar() {
  const { data: user } = useUserQuery();

  return (
    <Card>
      <div className="flex justify-between items-center pr-6">
        <CardHeader>
          <CardTitle>Avatar</CardTitle>
          <CardDescription>
            This is your avatar. Click on the avatar to upload a custom one from
            your files.
          </CardDescription>
        </CardHeader>

        <AvatarUpload userId={user?.id!} avatarUrl={user?.avatarUrl} />
      </div>
      <CardFooter>An avatar is optional but strongly recommended.</CardFooter>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/components/user-menu.tsx">
"use client";

import { useUserQuery } from "@/hooks/use-user";
import { Avatar, AvatarFallback, AvatarImageNext } from "@midday/ui/avatar";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@midday/ui/dropdown-menu";
import Link from "next/link";
import { SignOut } from "./sign-out";
import { ThemeSwitch } from "./theme-switch";

type Props = {
  onlySignOut?: boolean;
};

export function UserMenu({ onlySignOut }: Props) {
  const { data: user } = useUserQuery();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Avatar className="rounded-full w-8 h-8 cursor-pointer">
          {user?.avatarUrl && (
            <AvatarImageNext
              src={user?.avatarUrl}
              alt={user?.fullName ?? ""}
              width={32}
              height={32}
              quality={100}
            />
          )}
          <AvatarFallback>
            <span className="text-xs">
              {user?.fullName?.charAt(0)?.toUpperCase()}
            </span>
          </AvatarFallback>
        </Avatar>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-[240px]" sideOffset={10} align="end">
        {!onlySignOut && (
          <>
            <DropdownMenuLabel>
              <div className="flex justify-between items-center">
                <div className="flex flex-col">
                  <span className="truncate line-clamp-1 max-w-[155px] block">
                    {user?.fullName}
                  </span>
                  <span className="truncate text-xs text-[#606060] font-normal">
                    {user?.email}
                  </span>
                </div>
              </div>
            </DropdownMenuLabel>

            <DropdownMenuSeparator />

            <DropdownMenuGroup>
              <Link prefetch href="/account">
                <DropdownMenuItem>Account</DropdownMenuItem>
              </Link>

              <Link prefetch href="/account/support">
                <DropdownMenuItem>Support</DropdownMenuItem>
              </Link>

              <Link prefetch href="/account/teams">
                <DropdownMenuItem>Teams</DropdownMenuItem>
              </Link>
            </DropdownMenuGroup>

            <DropdownMenuSeparator />
            <div className="flex flex-row justify-between items-center p-2">
              <p className="text-sm">Theme</p>
              <ThemeSwitch />
            </div>
            <DropdownMenuSeparator />
          </>
        )}

        <SignOut />
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="apps/dashboard/src/components/vat-number-input.tsx">
"use client";

import { Input } from "@midday/ui/input";

type Props = {
  value: string;
  onChange: (value: string) => void;
};

export function VatNumberInput({ value, onChange, ...props }: Props) {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;

    onChange?.(newValue);
  };

  return (
    <div className="relative">
      <Input
        placeholder="Enter VAT number"
        value={value}
        onChange={handleChange}
        autoComplete="off"
        {...props}
      />
    </div>
  );
}
</file>

<file path="apps/dashboard/src/components/verify-mfa.tsx">
import { createClient } from "@midday/supabase/client";
import { InputOTP, InputOTPGroup, InputOTPSlot } from "@midday/ui/input-otp";
import { Spinner } from "@midday/ui/spinner";
import { useRouter, useSearchParams } from "next/navigation";
import { useState } from "react";

export function VerifyMfa() {
  const [isValidating, setValidating] = useState(false);
  const [isRedirecting, setIsRedirecting] = useState(false);
  const [error, setError] = useState(false);
  const supabase = createClient();
  const router = useRouter();
  const searchParams = useSearchParams();

  const onComplete = async (code: string) => {
    setError(false);

    if (!isValidating) {
      setValidating(true);

      const factors = await supabase.auth.mfa.listFactors();

      if (factors.error) {
        setValidating(false);
        setError(true);
      }

      if (!factors.data) {
        setValidating(false);
        setError(true);
        return;
      }

      const totpFactor = factors.data.totp[0];

      if (!totpFactor) {
        setValidating(false);
        setError(true);
        return;
      }

      const factorId = totpFactor.id;

      const challenge = await supabase.auth.mfa.challenge({ factorId });

      if (challenge.error) {
        setValidating(false);
        setError(true);
        return;
      }

      const challengeId = challenge.data.id;

      const verify = await supabase.auth.mfa.verify({
        factorId,
        challengeId,
        code,
      });

      if (verify.error) {
        setValidating(false);
        setError(true);
        return;
      }

      setIsRedirecting(true);
      router.push(
        `${window.location.origin}/${searchParams.get("return_to") || ""}`,
      );
    }
  };

  return (
    <>
      <div className="pb-4">
        <div className="text-center">
          <h1 className="text-lg mb-2 font-serif">Verify your identity.</h1>
          <p className="text-[#878787] text-sm mb-8">
            Please enter the code from your authenticator app.
          </p>
        </div>
      </div>

      <div className="flex w-full mb-6">
        <div className="w-full h-16 flex items-center justify-center">
          {isValidating || isRedirecting ? (
            <div className="flex items-center justify-center h-full bg-background/95 border border-input w-full">
              <div className="flex items-center space-x-2 bg-background px-4 py-2 rounded-md shadow-sm">
                <Spinner size={16} className="text-primary" />
                <span className="text-sm text-foreground font-medium">
                  {isRedirecting ? "Redirecting..." : "Verifying..."}
                </span>
              </div>
            </div>
          ) : (
            <InputOTP
              onComplete={onComplete}
              maxLength={6}
              autoFocus
              className={error ? "invalid" : undefined}
              disabled={isValidating || isRedirecting}
              render={({ slots }) => (
                <InputOTPGroup>
                  {slots.map((slot, index) => (
                    <InputOTPSlot key={index.toString()} {...slot} />
                  ))}
                </InputOTPGroup>
              )}
            />
          )}
        </div>
      </div>

      <p className="text-xs text-[#878787] text-center font-mono">
        Open your authenticator apps like 1Password, Authy, etc. to verify your
        identity.
      </p>
    </>
  );
}
</file>

<file path="apps/dashboard/src/components/week-settings.tsx">
"use client";

import { useUserMutation, useUserQuery } from "@/hooks/use-user";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@midday/ui/card";
import { Switch } from "@midday/ui/switch";

export function WeekSettings() {
  const { data: user } = useUserQuery();
  const updateUserMutation = useUserMutation();

  return (
    <Card className="flex justify-between items-center">
      <CardHeader>
        <CardTitle>Start Week on Monday</CardTitle>
        <CardDescription>
          Set the first day of the week in calendar views.
        </CardDescription>
      </CardHeader>

      <CardContent>
        <Switch
          checked={user?.weekStartsOnMonday ?? false}
          disabled={updateUserMutation.isPending}
          onCheckedChange={(weekStartsOnMonday: boolean) => {
            updateUserMutation.mutate({ weekStartsOnMonday });
          }}
        />
      </CardContent>
    </Card>
  );
}
</file>

<file path="apps/dashboard/src/hooks/use-calendar-dates.ts">
import { TZDate } from "@date-fns/tz";
import {
  eachDayOfInterval,
  endOfMonth,
  endOfWeek,
  startOfMonth,
  startOfWeek,
} from "date-fns";

export function useCalendarDates(
  currentDate: TZDate,
  weekStartsOnMonday: boolean,
) {
  const monthStart = startOfMonth(currentDate);
  const monthEnd = endOfMonth(currentDate);
  const calendarStart = startOfWeek(monthStart, {
    weekStartsOn: weekStartsOnMonday ? 1 : 0,
  });
  const calendarEnd = endOfWeek(monthEnd, {
    weekStartsOn: weekStartsOnMonday ? 1 : 0,
  });
  const calendarDays = eachDayOfInterval({
    start: calendarStart,
    end: calendarEnd,
  }).map((date) => new TZDate(date, "UTC"));
  const firstWeek = eachDayOfInterval({
    start: calendarStart,
    end: endOfWeek(calendarStart, { weekStartsOn: weekStartsOnMonday ? 1 : 0 }),
  }).map((date) => new TZDate(date, "UTC"));

  return {
    monthStart,
    monthEnd,
    calendarStart,
    calendarEnd,
    calendarDays,
    firstWeek,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-connect-params.ts">
import { parseAsString, parseAsStringLiteral, useQueryStates } from "nuqs";

export function useConnectParams(initialCountryCode?: string) {
  const [params, setParams] = useQueryStates({
    step: parseAsStringLiteral(["connect", "account", "import"]),
    countryCode: parseAsString.withDefault(initialCountryCode ?? ""),
    provider: parseAsStringLiteral([
      "teller",
      "plaid",
      "gocardless",
      "enablebanking",
    ]),
    token: parseAsString,
    enrollment_id: parseAsString,
    institution_id: parseAsString,
    search: parseAsString.withDefault("").withOptions({ clearOnDefault: true }),
    error: parseAsString,
    ref: parseAsString,
    details: parseAsString,
  });

  return {
    ...params,
    setParams,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-customer-filter-params.ts">
import { useQueryStates } from "nuqs";
import { createLoader, parseAsArrayOf, parseAsString } from "nuqs/server";

export const customerFilterParamsSchema = {
  q: parseAsString,
  sort: parseAsArrayOf(parseAsString),
  start: parseAsString,
  end: parseAsString,
};

export function useCustomerFilterParams() {
  const [filter, setFilter] = useQueryStates(customerFilterParamsSchema);

  return {
    filter,
    setFilter,
    hasFilters: Object.values(filter).some((value) => value !== null),
  };
}

export const loadCustomerFilterParams = createLoader(
  customerFilterParamsSchema,
);
</file>

<file path="apps/dashboard/src/hooks/use-customer-params.ts">
import { parseAsBoolean, parseAsString, useQueryStates } from "nuqs";

export function useCustomerParams() {
  const [params, setParams] = useQueryStates({
    customerId: parseAsString,
    createCustomer: parseAsBoolean,
    name: parseAsString,
    q: parseAsString,
  });

  return {
    ...params,
    setParams,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-document-filter-params.ts">
import { useQueryStates } from "nuqs";
import { createLoader, parseAsArrayOf, parseAsString } from "nuqs/server";

export const documentFilterParamsSchema = {
  q: parseAsString,
  tags: parseAsArrayOf(parseAsString),
  start: parseAsString,
  end: parseAsString,
};

export function useDocumentFilterParams() {
  const [filter, setFilter] = useQueryStates(documentFilterParamsSchema);

  return {
    filter,
    setFilter,
    hasFilters: Object.values(filter).some((value) => value !== null),
  };
}

export const loadDocumentFilterParams = createLoader(
  documentFilterParamsSchema,
);
</file>

<file path="apps/dashboard/src/hooks/use-document-params.ts">
import { useQueryStates } from "nuqs";
import { parseAsString, parseAsStringLiteral } from "nuqs/server";

export function useDocumentParams() {
  const [params, setParams] = useQueryStates({
    documentId: parseAsString,
    filePath: parseAsString,
    view: parseAsStringLiteral(["grid", "list"]).withDefault("grid"),
  });

  return {
    params,
    setParams,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-download-zip.ts">
import { useTRPC } from "@/trpc/client";
import { useMutation } from "@tanstack/react-query";
import { saveAs } from "file-saver";
import JSZip from "jszip";

function getFilenameFromPath(path: string): string {
  return path.split("/").at(-1) || path;
}

async function zipAndDownloadFiles(
  signedUrls: string[],
  originalFilePaths: string[],
): Promise<void> {
  const validSignedFiles: { path: string; signedUrl: string; name: string }[] =
    [];

  for (const signedUrl of signedUrls) {
    let foundMatch = false;
    for (const originalPath of originalFilePaths) {
      try {
        // Parse the signed URL to extract the pathname
        const url = new URL(signedUrl);
        const pathname = decodeURIComponent(url.pathname); // Decode potentially encoded characters in the path

        // Check if the decoded pathname includes the original file path.
        // This assumes the originalPath is a unique segment within the signed URL's path.
        if (pathname.includes(originalPath)) {
          const derivedName = getFilenameFromPath(originalPath);

          validSignedFiles.push({
            path: originalPath,
            signedUrl: signedUrl,
            name: derivedName,
          });

          foundMatch = true;
          break; // Found the match for this signedUrl, move to the next one
        }
      } catch (e) {
        // Log error if URL parsing fails
        console.error("Invalid URL encountered during matching:", signedUrl, e);
      }
    }

    if (!foundMatch) {
      console.warn(
        "Could not reliably associate signed URL with an original file path:",
        signedUrl,
      );
    }
  }

  if (validSignedFiles.length === 0 && originalFilePaths.length > 0) {
    console.error("No valid signed URLs could be generated or matched.");
    throw new Error("Failed to generate download links for selected files.");
  }

  const zip = new JSZip();

  const filePromises = validSignedFiles.map(async (file) => {
    try {
      const res = await fetch(file.signedUrl);
      if (!res.ok) {
        throw new Error(`Failed to fetch ${file.name}: ${res.statusText}`);
      }
      const blob = await res.blob();
      zip.file(file.name, blob);
    } catch (error) {
      console.error(`Error processing file ${file.name}:`, error);
    }
  });

  await Promise.all(filePromises);

  const zipBlob = await zip.generateAsync({
    type: "blob",
    compression: "DEFLATE",
    compressionOptions: {
      level: 9,
    },
  });

  saveAs(zipBlob, `download-${Date.now()}.zip`);
}

export function useDownloadZip() {
  const trpc = useTRPC();

  const { mutateAsync, isPending, error } = useMutation(
    trpc.documents.signedUrls.mutationOptions(),
  );

  const handleDownloadZip = async (filePaths: string[]) => {
    const data = await mutateAsync(filePaths);
    await zipAndDownloadFiles(data, filePaths);
  };

  return {
    handleDownloadZip,
    isPending,
    error,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-export-status.ts">
import { useRealtimeRun } from "@trigger.dev/react-hooks";
import { useEffect, useState } from "react";

type UseExportStatusProps = {
  runId?: string;
  accessToken?: string;
};

export function useExportStatus({
  runId: initialRunId,
  accessToken: initialAccessToken,
}: UseExportStatusProps = {}) {
  const [accessToken, setAccessToken] = useState<string | undefined>(
    initialAccessToken,
  );
  const [runId, setRunId] = useState<string | undefined>(initialRunId);
  const [status, setStatus] = useState<
    "FAILED" | "IN_PROGRESS" | "COMPLETED" | null
  >(null);

  const [_, setProgress] = useState<number>(0);

  const [result, setResult] = useState<any>(null);

  const { run, error } = useRealtimeRun(runId, {
    enabled: !!runId && !!accessToken,
    accessToken,
  });

  useEffect(() => {
    if (initialRunId && initialAccessToken) {
      setAccessToken(initialAccessToken);
      setRunId(initialRunId);
      setStatus("IN_PROGRESS");
    }
  }, [initialRunId, initialAccessToken]);

  useEffect(() => {
    if (error || run?.status === "FAILED") {
      setStatus("FAILED");
      setProgress(0);
    }

    if (run?.status === "COMPLETED") {
      setStatus("COMPLETED");
      setProgress(100);
    }
  }, [error, run]);

  useEffect(() => {
    if (run?.output) {
      setResult(run.output);
    }
  }, [run]);

  return {
    status,
    setStatus,
    progress: run?.metadata?.progress ?? 0,
    result,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-global-timer-status.ts">
"use client";

import { useTRPC } from "@/trpc/client";
import { useQuery } from "@tanstack/react-query";
import { useEffect, useRef, useState } from "react";

export function useGlobalTimerStatus() {
  const trpc = useTRPC();
  const originalTitleRef = useRef<string | undefined>(undefined);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const [localElapsedSeconds, setLocalElapsedSeconds] = useState(0);

  // Add throttling for title updates to reduce DOM manipulation
  const lastTitleUpdateRef = useRef<string>("");

  // Get current timer status (only initial fetch, no automatic refetching)
  const { data: timerStatus } = useQuery({
    ...trpc.trackerEntries.getTimerStatus.queryOptions(),
    refetchInterval: false, // Don't refetch automatically
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
  });

  // Store original title on mount
  useEffect(() => {
    if (typeof window === "undefined") return;

    // Store original title
    if (!originalTitleRef.current) {
      originalTitleRef.current = document.title;
    }
  }, []);

  // Manage local timer interval
  useEffect(() => {
    const isRunning = timerStatus?.isRunning;

    if (isRunning) {
      // Reset local counter when timer status changes
      setLocalElapsedSeconds(0);

      // Start local interval to increment every second
      intervalRef.current = setInterval(() => {
        setLocalElapsedSeconds((prev) => prev + 1);
      }, 1000);
    } else {
      // Clear interval and reset local counter when not running
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
      setLocalElapsedSeconds(0);
    }

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [timerStatus?.isRunning, timerStatus?.elapsedTime]);

  // Update title based on timer status
  useEffect(() => {
    if (typeof window === "undefined") return;

    const isRunning = timerStatus?.isRunning;
    const serverElapsedTime = timerStatus?.elapsedTime || 0;
    const totalElapsedTime = serverElapsedTime + localElapsedSeconds;
    const projectName = timerStatus?.currentEntry?.trackerProject?.name;

    if (isRunning && projectName) {
      // Format time as HH:MM:SS for document title
      const hours = Math.floor(totalElapsedTime / 3600);
      const minutes = Math.floor((totalElapsedTime % 3600) / 60);
      const seconds = totalElapsedTime % 60;
      const timeDisplay = `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
      const newTitle = `${timeDisplay} • ${projectName} | Midday`;

      // Only update title if it actually changed to reduce DOM operations
      if (lastTitleUpdateRef.current !== newTitle) {
        document.title = newTitle;
        lastTitleUpdateRef.current = newTitle;
      }
    } else {
      // Restore original title
      if (
        originalTitleRef.current &&
        lastTitleUpdateRef.current !== originalTitleRef.current
      ) {
        document.title = originalTitleRef.current;
        lastTitleUpdateRef.current = originalTitleRef.current;
      }
    }
  }, [
    timerStatus?.isRunning,
    timerStatus?.elapsedTime,
    timerStatus?.currentEntry?.trackerProject?.name,
    localElapsedSeconds,
  ]);

  const serverElapsedTime = timerStatus?.elapsedTime || 0;
  const totalElapsedTime = serverElapsedTime + localElapsedSeconds;

  return {
    isRunning: timerStatus?.isRunning || false,
    elapsedTime: totalElapsedTime,
    currentProject: timerStatus?.currentEntry?.trackerProject?.name,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-inbox-filter-params.ts">
import { useQueryStates } from "nuqs";
import { createLoader, parseAsString, parseAsStringLiteral } from "nuqs/server";

export const inboxFilterParamsSchema = {
  q: parseAsString,
  status: parseAsStringLiteral(["done", "pending", "suggested_match"]),
};

export function useInboxFilterParams() {
  const [params, setParams] = useQueryStates(inboxFilterParamsSchema);

  return {
    params,
    setParams,
    hasFilter: Object.values(params).some((value) => value !== null),
  };
}

export const loadInboxFilterParams = createLoader(inboxFilterParamsSchema);
</file>

<file path="apps/dashboard/src/hooks/use-inbox-params.ts">
import { useQueryStates } from "nuqs";
import {
  createLoader,
  parseAsBoolean,
  parseAsString,
  parseAsStringLiteral,
} from "nuqs/server";

export const inboxParamsSchema = {
  inboxId: parseAsString,
  type: parseAsStringLiteral(["list", "details"]),
  order: parseAsStringLiteral(["asc", "desc"]).withDefault("asc"),
  connected: parseAsBoolean,
};

export function useInboxParams() {
  const [params, setParams] = useQueryStates(inboxParamsSchema);

  return {
    params,
    setParams,
  };
}

export const loadInboxParams = createLoader(inboxParamsSchema);
</file>

<file path="apps/dashboard/src/hooks/use-initial-connection-status.ts">
import { useRealtimeRun } from "@trigger.dev/react-hooks";
import { useEffect, useState } from "react";

type UseInitialConnectionStatusProps = {
  runId?: string;
  accessToken?: string;
};

export function useInitialConnectionStatus({
  runId: initialRunId,
  accessToken: initialAccessToken,
}: UseInitialConnectionStatusProps) {
  const [accessToken, setAccessToken] = useState<string | undefined>(
    initialAccessToken,
  );
  const [runId, setRunId] = useState<string | undefined>(initialRunId);
  const [status, setStatus] = useState<
    "FAILED" | "SYNCING" | "COMPLETED" | null
  >(null);

  const { run, error } = useRealtimeRun(runId, {
    enabled: !!runId && !!accessToken,
    accessToken,
  });

  useEffect(() => {
    if (initialRunId && initialAccessToken) {
      setAccessToken(initialAccessToken);
      setRunId(initialRunId);
      setStatus("SYNCING");
    }
  }, [initialRunId, initialAccessToken]);

  useEffect(() => {
    if (error || run?.status === "FAILED") {
      setStatus("FAILED");
    }

    if (run?.status === "COMPLETED") {
      setStatus("COMPLETED");
    }
  }, [error, run]);

  return {
    status,
    setStatus,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-invoice-filter-params.ts">
import { useQueryStates } from "nuqs";
import { createLoader, parseAsArrayOf, parseAsString } from "nuqs/server";

const invoiceFilterParamsSchema = {
  q: parseAsString,
  statuses: parseAsArrayOf(parseAsString),
  customers: parseAsArrayOf(parseAsString),
  start: parseAsString,
  end: parseAsString,
};

export function useInvoiceFilterParams() {
  const [filter, setFilter] = useQueryStates(invoiceFilterParamsSchema);

  return {
    filter,
    setFilter,
    hasFilters: Object.values(filter).some((value) => value !== null),
  };
}

export const loadInvoiceFilterParams = createLoader(invoiceFilterParamsSchema);
</file>

<file path="apps/dashboard/src/hooks/use-invoice-params.ts">
import { useQueryStates } from "nuqs";
import { createLoader, parseAsString, parseAsStringEnum } from "nuqs/server";

const invoiceParamsSchema = {
  selectedCustomerId: parseAsString,
  type: parseAsStringEnum(["edit", "create", "details", "success"]),
  invoiceId: parseAsString,
};

export function useInvoiceParams() {
  const [params, setParams] = useQueryStates(invoiceParamsSchema);

  return {
    ...params,
    setParams,
  };
}

export const loadInvoiceParams = createLoader(invoiceParamsSchema);
</file>

<file path="apps/dashboard/src/hooks/use-latest-project-id.ts">
import { useLocalStorage } from "./use-local-storage";

export function useLatestProjectId() {
  const [latestProjectId, setLatestProjectId] = useLocalStorage<string | null>(
    "latest-project-id",
    null,
  );

  return {
    latestProjectId,
    setLatestProjectId,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-local-storage.ts">
"use client";

import { useCallback, useEffect, useState } from "react";

// Original useLocalStorage hook (useState-like API)
export function useLocalStorage<T>(
  key: string,
  initialValue: T,
): [T, (value: T | ((val: T) => T)) => void] {
  // Initialize state with a function to handle SSR
  const [localState, setLocalState] = useState<T>(() => {
    // Check if we're in a browser environment
    if (typeof window === "undefined") {
      return initialValue;
    }

    try {
      // Get from local storage by key
      const item = window.localStorage.getItem(key);
      // Parse stored json or if none return initialValue
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const handleSetState = useCallback(
    (value: T | ((val: T) => T)) => {
      try {
        // Allow value to be a function so we have same API as useState
        const valueToStore =
          value instanceof Function ? value(localState) : value;
        // Save state
        setLocalState(valueToStore);
        // Save to local storage
        if (typeof window !== "undefined") {
          window.localStorage.setItem(key, JSON.stringify(valueToStore));
        }
      } catch (error) {
        console.warn(`Error setting localStorage key "${key}":`, error);
      }
    },
    [key, localState],
  );

  useEffect(() => {
    // Handle storage changes in other tabs/windows
    function handleStorageChange(event: StorageEvent) {
      if (event.key === key && event.newValue) {
        setLocalState(JSON.parse(event.newValue));
      }
    }

    // Subscribe to storage changes
    if (typeof window !== "undefined") {
      window.addEventListener("storage", handleStorageChange);
    }

    // Cleanup the event listener on component unmount
    return () => {
      if (typeof window !== "undefined") {
        window.removeEventListener("storage", handleStorageChange);
      }
    };
  }, [key]);

  return [localState, handleSetState];
}
</file>

<file path="apps/dashboard/src/hooks/use-notifications.ts">
"use client";

import { useRealtime } from "@/hooks/use-realtime";
import { useUserQuery } from "@/hooks/use-user";
import { useTRPC } from "@/trpc/client";
import type { AppRouter } from "@midday/api/trpc/routers/_app";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import type { inferRouterInputs, inferRouterOutputs } from "@trpc/server";
import { useCallback, useMemo } from "react";

// Infer types from tRPC router
type RouterOutputs = inferRouterOutputs<AppRouter>;
type RouterInputs = inferRouterInputs<AppRouter>;
type NotificationsList = RouterOutputs["notifications"]["list"];
type NotificationsData = NotificationsList["data"];

// Use the natural tRPC types without modification
export type Activity = NotificationsData[number];

type UpdateStatusInput = RouterInputs["notifications"]["updateStatus"];
type UpdateAllStatusInput = RouterInputs["notifications"]["updateAllStatus"];

// Utility functions to safely handle metadata without excessive casting
export function getMetadata(activity: Activity): Record<string, any> {
  return (activity.metadata as Record<string, any>) || {};
}

export function getMetadataProperty(activity: Activity, key: string): any {
  const metadata = getMetadata(activity);
  return metadata[key];
}

export function useNotifications() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const { data: user } = useUserQuery();

  const {
    data: activitiesData,
    isLoading,
    error,
  } = useQuery(
    trpc.notifications.list.queryOptions({
      maxPriority: 3, // Only fetch notifications (priority <= 3)
      pageSize: 20,
      status: ["unread", "read"], // Exclude archived notifications from query
    }),
  );

  // Separate query for archived notifications
  const { data: archivedActivitiesData, isLoading: archivedIsLoading } =
    useQuery(
      trpc.notifications.list.queryOptions({
        maxPriority: 3,
        pageSize: 20,
        status: "archived", // Only archived notifications
      }),
    );

  // Real-time subscription for activities filtered by user_id
  useRealtime({
    channelName: "user-notifications",
    event: "INSERT",
    table: "activities",
    filter: `user_id=eq.${user?.id}`,
    onEvent: (payload) => {
      // Only handle new notifications (priority <= 3), not archived updates
      const newRecord = payload?.new as any; // Supabase payload type
      if (newRecord?.priority && newRecord.priority <= 3) {
        // Invalidate both inbox and archived queries
        queryClient.invalidateQueries({
          queryKey: trpc.notifications.list.queryKey(),
        });
      }
    },
  });

  // Mutations
  const updateStatusMutation = useMutation(
    trpc.notifications.updateStatus.mutationOptions({
      onMutate: async (variables: UpdateStatusInput) => {
        // Cancel any outgoing refetches (so they don't overwrite our optimistic update)
        await queryClient.cancelQueries({
          queryKey: trpc.notifications.list.queryKey(),
        });

        // Define query keys for both inbox and archived
        const inboxQueryKey = trpc.notifications.list.queryKey({
          maxPriority: 3,
          pageSize: 20,
          status: ["unread", "read"],
        });

        const archivedQueryKey = trpc.notifications.list.queryKey({
          maxPriority: 3,
          pageSize: 20,
          status: "archived",
        });

        // Snapshot both query states
        const previousInboxData =
          queryClient.getQueryData<NotificationsList>(inboxQueryKey);
        const previousArchivedData =
          queryClient.getQueryData<NotificationsList>(archivedQueryKey);

        if (variables.status === "archived") {
          // Moving from inbox to archived
          let notificationToMove: Activity | null = null;

          // Remove from inbox
          queryClient.setQueryData<NotificationsList>(inboxQueryKey, (old) => {
            if (!old?.data) return old;

            const filteredData = old.data.filter((notification) => {
              if (notification.id === variables.activityId) {
                notificationToMove = { ...notification, status: "archived" };
                return false;
              }
              return true;
            });

            return { ...old, data: filteredData };
          });

          // Add to archived (if we found the notification)
          if (notificationToMove) {
            queryClient.setQueryData<NotificationsList>(
              archivedQueryKey,
              (old) => {
                if (!old?.data)
                  return {
                    data: [notificationToMove!],
                    meta: old?.meta || {
                      cursor: null,
                      hasPreviousPage: false,
                      hasNextPage: false,
                    },
                  };
                return { ...old, data: [notificationToMove!, ...old.data] };
              },
            );
          }
        } else {
          // For other status changes (like unread -> read), just update the inbox
          queryClient.setQueryData<NotificationsList>(inboxQueryKey, (old) => {
            if (!old?.data) return old;

            return {
              ...old,
              data: old.data.map((notification) =>
                notification.id === variables.activityId
                  ? { ...notification, status: variables.status }
                  : notification,
              ),
            };
          });
        }

        // Return context for rollback
        return {
          previousInboxData,
          previousArchivedData,
          inboxQueryKey,
          archivedQueryKey,
        };
      },
      onError: (_, __, context) => {
        // Rollback both queries if mutation fails
        if (context?.previousInboxData) {
          queryClient.setQueryData(
            context.inboxQueryKey,
            context.previousInboxData,
          );
        }
        if (context?.previousArchivedData) {
          queryClient.setQueryData(
            context.archivedQueryKey,
            context.previousArchivedData,
          );
        }
      },
    }),
  );

  const updateAllStatusMutation = useMutation(
    trpc.notifications.updateAllStatus.mutationOptions({
      onMutate: async (variables: UpdateAllStatusInput) => {
        // Cancel any outgoing refetches (so they don't overwrite our optimistic update)
        await queryClient.cancelQueries({
          queryKey: trpc.notifications.list.queryKey(),
        });

        // Define query keys for both inbox and archived
        const inboxQueryKey = trpc.notifications.list.queryKey({
          maxPriority: 3,
          pageSize: 20,
          status: ["unread", "read"],
        });

        const archivedQueryKey = trpc.notifications.list.queryKey({
          maxPriority: 3,
          pageSize: 20,
          status: "archived",
        });

        // Snapshot both query states
        const previousInboxData =
          queryClient.getQueryData<NotificationsList>(inboxQueryKey);
        const previousArchivedData =
          queryClient.getQueryData<NotificationsList>(archivedQueryKey);

        if (variables.status === "archived") {
          // Moving all inbox notifications to archived
          let notificationsToMove: Activity[] = [];

          // Clear inbox and collect notifications to move
          queryClient.setQueryData<NotificationsList>(inboxQueryKey, (old) => {
            if (!old?.data) return old;

            notificationsToMove = old.data.map((notification) => ({
              ...notification,
              status: "archived" as const,
            }));

            return { ...old, data: [] };
          });

          // Add all to archived
          if (notificationsToMove.length > 0) {
            queryClient.setQueryData<NotificationsList>(
              archivedQueryKey,
              (old) => {
                if (!old?.data)
                  return {
                    data: notificationsToMove,
                    meta: old?.meta || {
                      cursor: null,
                      hasPreviousPage: false,
                      hasNextPage: false,
                    },
                  };
                return { ...old, data: [...notificationsToMove, ...old.data] };
              },
            );
          }
        } else if (variables.status === "read") {
          // Update all unread to read in inbox (don't move between queries)
          queryClient.setQueryData<NotificationsList>(inboxQueryKey, (old) => {
            if (!old?.data) return old;

            return {
              ...old,
              data: old.data.map((notification) => ({
                ...notification,
                status: variables.status,
              })),
            };
          });
        }

        // Return context for rollback
        return {
          previousInboxData,
          previousArchivedData,
          inboxQueryKey,
          archivedQueryKey,
        };
      },
      onError: (_, __, context) => {
        // Rollback both queries if mutation fails
        if (context?.previousInboxData) {
          queryClient.setQueryData(
            context.inboxQueryKey,
            context.previousInboxData,
          );
        }
        if (context?.previousArchivedData) {
          queryClient.setQueryData(
            context.archivedQueryKey,
            context.previousArchivedData,
          );
        }
      },
    }),
  );

  // Return notification activities directly without transformation
  const notifications = activitiesData?.data || [];
  const archivedNotifications = archivedActivitiesData?.data || [];

  // Mark a single message as read (archived)
  const markMessageAsRead = useCallback(
    (messageId: string) => {
      updateStatusMutation.mutate({
        activityId: messageId,
        status: "archived",
      });
    },
    [updateStatusMutation],
  );

  // Mark all messages as read (archived)
  const markAllMessagesAsRead = useCallback(() => {
    updateAllStatusMutation.mutate({
      status: "archived",
    });
  }, [updateAllStatusMutation]);

  // Mark all messages as seen (read)
  const markAllMessagesAsSeen = useCallback(() => {
    updateAllStatusMutation.mutate({
      status: "read",
    });
  }, [updateAllStatusMutation]);

  const hasUnseenNotifications = useMemo(
    () =>
      notifications.some((notification) => notification.status === "unread"),
    [notifications],
  );

  return {
    isLoading: isLoading || archivedIsLoading,
    error,
    notifications, // Main notifications (unread/read) - already filtered by query
    archived: archivedNotifications, // Archived notifications from separate query
    hasUnseenNotifications,
    markMessageAsRead,
    markAllMessagesAsRead,
    markAllMessagesAsSeen,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-oauth-application-params.ts">
import { parseAsBoolean, parseAsString, useQueryStates } from "nuqs";

export function useOAuthApplicationParams() {
  const [params, setParams] = useQueryStates({
    applicationId: parseAsString,
    createApplication: parseAsBoolean,
    editApplication: parseAsBoolean,
  });

  return {
    ...params,
    setParams,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-oauth-params.ts">
import { useQueryStates } from "nuqs";
import { createLoader, parseAsString } from "nuqs/server";

export const oauthParamsSchema = {
  response_type: parseAsString,
  client_id: parseAsString,
  redirect_uri: parseAsString,
  scope: parseAsString,
  state: parseAsString,
  code_challenge: parseAsString,
};

export function useOAuthParams() {
  const [params, setParams] = useQueryStates(oauthParamsSchema);

  return {
    ...params,
    setParams,
  };
}

export const loadOAuthParams = createLoader(oauthParamsSchema);
</file>

<file path="apps/dashboard/src/hooks/use-realtime.ts">
"use client";

import { createClient } from "@midday/supabase/client";
import type { Database } from "@midday/supabase/types";
import type {
  RealtimePostgresChangesFilter,
  RealtimePostgresChangesPayload,
  SupabaseClient,
} from "@supabase/supabase-js";
import { useEffect } from "react";

type PublicSchema = Database[Extract<keyof Database, "public">];
type Tables = PublicSchema["Tables"];
type TableName = keyof Tables;

interface UseRealtimeProps<TN extends TableName> {
  channelName: string;
  event?: "INSERT" | "UPDATE" | "DELETE" | "*";
  table: TN;
  filter?: string;
  onEvent: (payload: RealtimePostgresChangesPayload<Tables[TN]["Row"]>) => void;
}

export function useRealtime<TN extends TableName>({
  channelName,
  event = "*",
  table,
  filter,
  onEvent,
}: UseRealtimeProps<TN>) {
  const supabase: SupabaseClient = createClient();

  useEffect(() => {
    const filterConfig: RealtimePostgresChangesFilter<"*"> = {
      event: event as RealtimePostgresChangesFilter<"*">["event"],
      schema: "public",
      table,
      filter,
    };

    const channel = supabase
      .channel(channelName)
      .on(
        "postgres_changes",
        filterConfig,
        (payload: RealtimePostgresChangesPayload<Tables[TN]["Row"]>) => {
          onEvent(payload);
        },
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [channelName]);
}
</file>

<file path="apps/dashboard/src/hooks/use-reports-params.ts">
import {
  format,
  startOfMonth,
  startOfYear,
  subMonths,
  subWeeks,
} from "date-fns";
import { useQueryStates } from "nuqs";
import { createLoader, parseAsString, parseAsStringLiteral } from "nuqs/server";

export const chartTypeOptions = [
  "revenue",
  "profit",
  "burn_rate",
  "expense",
] as const;

export const chartPeriodOptions = [
  {
    value: "4w",
    label: "Last 4 weeks",
    range: {
      from: subWeeks(new Date(), 4),
      to: new Date(),
    },
  },
  {
    value: "3m",
    label: "Last 3 months",
    range: {
      from: subMonths(new Date(), 3),
      to: new Date(),
    },
  },
  {
    value: "6m",
    label: "Last 6 months",
    range: {
      from: subMonths(new Date(), 6),
      to: new Date(),
    },
  },
  {
    value: "12m",
    label: "Last 12 months",
    range: {
      from: subMonths(new Date(), 12),
      to: new Date(),
    },
  },
  {
    value: "mtd",
    label: "Month to date",
    range: {
      from: startOfMonth(new Date()),
      to: new Date(),
    },
  },
  {
    value: "ytd",
    label: "Year to date",
    range: {
      from: startOfYear(new Date()),
      to: new Date(),
    },
  },
  {
    value: "all",
    label: "All time",
    range: {
      // Can't get older data than this
      from: new Date("2020-01-01"),
      to: new Date(),
    },
  },
];

export const reportsParamsSchema = {
  from: parseAsString.withDefault(
    format(subMonths(startOfMonth(new Date()), 12), "yyyy-MM-dd"),
  ),
  to: parseAsString.withDefault(format(new Date(), "yyyy-MM-dd")),
  period: parseAsStringLiteral(
    chartPeriodOptions.map((option) => option.value),
  ).withDefault("12m"),
  chart: parseAsStringLiteral(chartTypeOptions).withDefault("revenue"),
  currency: parseAsString,
};

export function useReportsParams() {
  const [params, setParams] = useQueryStates(reportsParamsSchema);

  return {
    params,
    setParams,
  };
}

export const loadReportsParams = createLoader(reportsParamsSchema);
</file>

<file path="apps/dashboard/src/hooks/use-scroll-to-bottom.ts">
import { type RefObject, useEffect, useRef } from "react";

export function useScrollToBottom<T extends HTMLElement>(): [
  RefObject<T | null>,
  RefObject<T | null>,
] {
  const containerRef = useRef<T>(null);
  const endRef = useRef<T>(null);

  useEffect(() => {
    const container = containerRef.current;
    const end = endRef.current;

    if (container && end) {
      const observer = new MutationObserver(() => {
        end.scrollIntoView({ behavior: "smooth", block: "end" });
      });

      observer.observe(container, {
        childList: true,
        subtree: true,
      });

      return () => observer.disconnect();
    }
  }, []);

  return [containerRef, endRef];
}
</file>

<file path="apps/dashboard/src/hooks/use-slider-with-input.ts">
import { useCallback, useState } from "react";

type UseSliderWithInputProps = {
  minValue?: number;
  maxValue?: number;
  initialValue?: number[];
  defaultValue?: number[];
};

export function useSliderWithInput({
  minValue = 0,
  maxValue = 100,
  initialValue = [minValue],
  defaultValue = [minValue],
}: UseSliderWithInputProps) {
  const [sliderValue, setSliderValue] = useState(initialValue);
  const [inputValues, setInputValues] = useState(
    initialValue.map((v) => v.toString()),
  );

  const setValues = useCallback((values: number[]) => {
    setSliderValue(values);
    setInputValues(values.map((v) => v.toString()));
  }, []);

  const validateAndUpdateValue = useCallback(
    (rawValue: string, index: number) => {
      if (rawValue === "" || rawValue === "-") {
        const newInputValues = [...inputValues];
        newInputValues[index] = "0";
        setInputValues(newInputValues);

        const newSliderValues = [...sliderValue];
        newSliderValues[index] = 0;
        setSliderValue(newSliderValues);
        return;
      }

      const numValue = Number.parseFloat(rawValue);

      if (Number.isNaN(numValue)) {
        const newInputValues = [...inputValues];
        newInputValues[index] = sliderValue?.[index]?.toString?.() ?? "0";
        setInputValues(newInputValues);
        return;
      }

      let clampedValue = Math.min(maxValue, Math.max(minValue, numValue));

      if (sliderValue.length > 1) {
        if (index === 0) {
          clampedValue = Math.min(
            clampedValue,
            typeof sliderValue[1] === "number" ? sliderValue[1] : clampedValue,
          );
        } else {
          clampedValue = Math.max(
            clampedValue,
            typeof sliderValue[0] === "number" ? sliderValue[0] : clampedValue,
          );
        }
      }

      const newSliderValues = [...sliderValue];
      newSliderValues[index] = clampedValue;
      setSliderValue(newSliderValues);

      const newInputValues = [...inputValues];
      newInputValues[index] = clampedValue.toString();
      setInputValues(newInputValues);
    },
    [sliderValue, inputValues, minValue, maxValue],
  );

  const handleInputChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>, index: number) => {
      const newValue = e.target.value;
      if (newValue === "" || /^-?\d*\.?\d*$/.test(newValue)) {
        const newInputValues = [...inputValues];
        newInputValues[index] = newValue;
        setInputValues(newInputValues);
      }
    },
    [inputValues],
  );

  const handleSliderChange = useCallback((newValue: number[]) => {
    setSliderValue(newValue);
    setInputValues(newValue.map((v) => v.toString()));
  }, []);

  const resetToDefault = useCallback(() => {
    setSliderValue(defaultValue);
    setInputValues(defaultValue.map((v) => v.toString()));
  }, [defaultValue]);

  return {
    sliderValue,
    inputValues,
    validateAndUpdateValue,
    handleInputChange,
    handleSliderChange,
    resetToDefault,
    setValues,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-sort-params.ts">
import { useQueryStates } from "nuqs";
import { createLoader, parseAsArrayOf, parseAsString } from "nuqs/server";

export const sortParamsSchema = {
  sort: parseAsArrayOf(parseAsString),
};

export function useSortParams() {
  const [params, setParams] = useQueryStates(sortParamsSchema);

  return { params, setParams };
}

export const loadSortParams = createLoader(sortParamsSchema);
</file>

<file path="apps/dashboard/src/hooks/use-sticky-columns.ts">
import { cn } from "@midday/ui/cn";
import type { VisibilityState } from "@tanstack/react-table";
import { useMemo } from "react";

interface TableColumn {
  id: string;
  getIsVisible: () => boolean;
}

interface TableInterface {
  getAllLeafColumns: () => TableColumn[];
}

interface UseStickyColumnsProps {
  columnVisibility?: VisibilityState;
  table?: TableInterface;
  loading?: boolean;
}

export function useStickyColumns({
  columnVisibility,
  table,
  loading,
}: UseStickyColumnsProps) {
  const isVisible = (id: string) =>
    loading ||
    table
      ?.getAllLeafColumns()
      .find((col) => col.id === id)
      ?.getIsVisible() ||
    (columnVisibility && columnVisibility[id] !== false);

  // Calculate dynamic sticky positions for transaction columns
  const stickyPositions = useMemo(() => {
    let position = 0;
    const positions: Record<string, number> = {};

    // Select column (always visible)
    positions.select = position;
    position += 50; // width of select column

    // Date column
    if (isVisible("date")) {
      positions.date = position;
      position += 110; // width of date column
    }

    // Description column
    if (isVisible("description")) {
      positions.description = position;
    }

    return positions;
  }, [isVisible]);

  // Function to get CSS custom properties for sticky columns
  const getStickyStyle = (columnId: string) => {
    const position = stickyPositions[columnId];
    return position !== undefined
      ? ({ "--stick-left": `${position}px` } as React.CSSProperties)
      : {};
  };

  // Function to get sticky class names
  const getStickyClassName = (columnId: string, baseClassName?: string) => {
    const stickyColumns = ["select", "date", "description"];
    const isSticky = stickyColumns.includes(columnId);
    return cn(
      baseClassName,
      isSticky && "md:sticky md:left-[var(--stick-left)]",
    );
  };

  return {
    stickyPositions,
    getStickyStyle,
    getStickyClassName,
    isVisible,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-sync-status.ts">
import { useRealtimeRun } from "@trigger.dev/react-hooks";
import { useEffect, useState } from "react";

type UseSyncStatusProps = {
  runId?: string;
  accessToken?: string;
};

export function useSyncStatus({
  runId: initialRunId,
  accessToken: initialAccessToken,
}: UseSyncStatusProps) {
  const [accessToken, setAccessToken] = useState<string | undefined>(
    initialAccessToken,
  );
  const [runId, setRunId] = useState<string | undefined>(initialRunId);
  const [status, setStatus] = useState<
    "FAILED" | "SYNCING" | "COMPLETED" | null
  >(null);
  const { run, error } = useRealtimeRun(runId, {
    enabled: !!runId && !!accessToken,
    accessToken,
  });

  useEffect(() => {
    if (initialRunId && initialAccessToken) {
      setAccessToken(initialAccessToken);
      setRunId(initialRunId);
      setStatus("SYNCING");
    }
  }, [initialRunId, initialAccessToken]);

  useEffect(() => {
    if (error || run?.status === "FAILED") {
      setStatus("FAILED");
    }

    if (run?.status === "COMPLETED") {
      setStatus("COMPLETED");
    }
  }, [error, run]);

  return {
    status,
    setStatus,
    result: run?.output,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-table-scroll.ts">
"use client";

import { useCallback, useEffect, useRef, useState } from "react";
import { useHotkeys } from "react-hotkeys-hook";

interface UseTableScrollOptions {
  scrollAmount?: number;
  useColumnWidths?: boolean;
  startFromColumn?: number;
}

export function useTableScroll(options: UseTableScrollOptions = {}) {
  const {
    scrollAmount = 120,
    useColumnWidths = false,
    startFromColumn = 0,
  } = options;
  const containerRef = useRef<HTMLDivElement>(null);
  const [canScrollLeft, setCanScrollLeft] = useState(false);
  const [canScrollRight, setCanScrollRight] = useState(false);
  const [isScrollable, setIsScrollable] = useState(false);
  const currentColumnIndex = useRef(startFromColumn);
  const isScrollingProgrammatically = useRef(false);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);

  const getColumnPositions = useCallback(() => {
    const container = containerRef.current;
    if (!container) return [];

    const table = container.querySelector("table");
    if (!table) return [];

    const headerRow = table.querySelector("thead tr");
    if (!headerRow) return [];

    const columns = Array.from(headerRow.querySelectorAll("th"));
    const positions: number[] = [];
    let currentPosition = 0;

    for (const column of columns) {
      positions.push(currentPosition);
      currentPosition += (column as HTMLElement).offsetWidth;
    }

    return positions;
  }, []);

  const syncColumnIndex = useCallback(() => {
    const container = containerRef.current;
    if (!container || !useColumnWidths || isScrollingProgrammatically.current)
      return;

    const allColumnPositions = getColumnPositions();
    if (allColumnPositions.length === 0) return;

    const currentScrollLeft = container.scrollLeft;
    const maxScrollLeft = container.scrollWidth - container.clientWidth;

    // Fast edge case detection
    if (currentScrollLeft <= 10) {
      currentColumnIndex.current = startFromColumn;
      return;
    }
    if (currentScrollLeft >= maxScrollLeft - 10) {
      currentColumnIndex.current = allColumnPositions.length - 1;
      return;
    }

    // Optimized column detection - find closest target position
    let accumulatedDistance = 0;
    let detectedColumn = startFromColumn;

    for (let i = startFromColumn; i < allColumnPositions.length - 1; i++) {
      const columnStart = allColumnPositions[i] ?? 0;
      const columnEnd = allColumnPositions[i + 1] ?? 0;
      const columnWidth = columnEnd - columnStart;
      const nextDistance = accumulatedDistance + columnWidth;

      if (
        Math.abs(currentScrollLeft - accumulatedDistance) <=
        Math.abs(currentScrollLeft - nextDistance)
      ) {
        detectedColumn = i;
        break;
      }

      accumulatedDistance = nextDistance;
      detectedColumn = i + 1;
    }

    currentColumnIndex.current = Math.max(
      startFromColumn,
      Math.min(detectedColumn, allColumnPositions.length - 1),
    );
  }, [useColumnWidths, startFromColumn, getColumnPositions]);

  const checkScrollability = useCallback(() => {
    const container = containerRef.current;
    if (!container) return;

    const { scrollWidth, clientWidth } = container;
    const isScrollableTable = scrollWidth > clientWidth;

    if (useColumnWidths) {
      syncColumnIndex();

      const allColumnPositions = getColumnPositions();
      const maxColumnIndex = allColumnPositions.length - 1;

      const newCanScrollLeft =
        currentColumnIndex.current > startFromColumn ||
        container.scrollLeft > 10;
      const newCanScrollRight = currentColumnIndex.current < maxColumnIndex;

      setIsScrollable(isScrollableTable);
      setCanScrollLeft(newCanScrollLeft);
      setCanScrollRight(newCanScrollRight);
    } else {
      const { scrollLeft } = container;
      setIsScrollable(isScrollableTable);
      setCanScrollLeft(scrollLeft > 0);
      setCanScrollRight(scrollLeft < scrollWidth - clientWidth - 1);
    }
  }, [useColumnWidths, startFromColumn, getColumnPositions, syncColumnIndex]);

  const scrollLeft = useCallback(
    (smooth = true) => {
      const container = containerRef.current;
      if (!container) return;

      if (useColumnWidths) {
        const allColumnPositions = getColumnPositions();
        if (allColumnPositions.length === 0) return;

        if (
          currentColumnIndex.current <= startFromColumn &&
          container.scrollLeft <= 0
        ) {
          return;
        }

        if (
          currentColumnIndex.current <= startFromColumn &&
          container.scrollLeft > 0
        ) {
          isScrollingProgrammatically.current = true;
          container.scrollTo({
            left: 0,
            behavior: "smooth",
          });

          setTimeout(() => {
            isScrollingProgrammatically.current = false;
            syncColumnIndex();
            checkScrollability();
          }, 500);
          return;
        }

        const originalColumnIndex = currentColumnIndex.current;
        currentColumnIndex.current = currentColumnIndex.current - 1;

        const currentScrollLeft = container.scrollLeft;
        const maxScrollLeft = container.scrollWidth - container.clientWidth;

        let targetScrollLeft: number;

        if (Math.abs(currentScrollLeft - maxScrollLeft) < 10) {
          const lastColumnStart = allColumnPositions[originalColumnIndex] ?? 0;
          const lastColumnEnd =
            allColumnPositions[originalColumnIndex + 1] ??
            lastColumnStart + 150;
          const lastColumnWidth = lastColumnEnd - lastColumnStart;

          targetScrollLeft = Math.max(0, currentScrollLeft - lastColumnWidth);
        } else {
          targetScrollLeft = 0;
          for (let i = startFromColumn; i < currentColumnIndex.current; i++) {
            const columnStart = allColumnPositions[i] ?? 0;
            const columnEnd = allColumnPositions[i + 1] ?? 0;
            const columnWidth = columnEnd - columnStart;
            targetScrollLeft += columnWidth;
          }
        }

        isScrollingProgrammatically.current = true;

        container.scrollTo({
          left: targetScrollLeft,
          behavior: "smooth",
        });

        setTimeout(() => {
          isScrollingProgrammatically.current = false;
          syncColumnIndex();
          checkScrollability();
        }, 500);
      } else {
        container.scrollBy({
          left: -scrollAmount,
          behavior: smooth ? "smooth" : "auto",
        });
      }
    },
    [scrollAmount, useColumnWidths, startFromColumn, getColumnPositions],
  );

  const scrollRight = useCallback(
    (smooth = true) => {
      const container = containerRef.current;
      if (!container) return;

      if (useColumnWidths) {
        const allColumnPositions = getColumnPositions();
        if (allColumnPositions.length === 0) return;
        const maxColumnIndex = allColumnPositions.length - 1;

        // Only proceed if we can scroll right
        if (currentColumnIndex.current >= maxColumnIndex) {
          return;
        }

        // Increment the column index
        currentColumnIndex.current = currentColumnIndex.current + 1;

        // Flag that we're scrolling programmatically
        isScrollingProgrammatically.current = true;

        // If this is the last column, scroll to the absolute end
        if (currentColumnIndex.current === maxColumnIndex) {
          container.scrollTo({
            left: container.scrollWidth - container.clientWidth,
            behavior: "smooth",
          });
        } else {
          // Calculate scroll position for this column
          let targetScrollLeft = 0;
          for (let i = startFromColumn; i < currentColumnIndex.current; i++) {
            const columnStart = allColumnPositions[i] ?? 0;
            const columnEnd = allColumnPositions[i + 1] ?? 0;
            targetScrollLeft += columnEnd - columnStart;
          }

          container.scrollTo({
            left: targetScrollLeft,
            behavior: "smooth",
          });
        }

        setTimeout(() => {
          isScrollingProgrammatically.current = false;
          syncColumnIndex();
          checkScrollability();
        }, 500);
      } else {
        container.scrollBy({
          left: scrollAmount,
          behavior: smooth ? "smooth" : "auto",
        });
      }
    },
    [scrollAmount, useColumnWidths, startFromColumn, getColumnPositions],
  );

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // Reset column index and check scrollability on mount and resize
    currentColumnIndex.current = startFromColumn;
    checkScrollability();

    // Debounced scroll handler to prevent excessive updates during manual scrolling
    const handleScroll = () => {
      // Ignore scroll events during programmatic scrolling to prevent conflicts
      if (isScrollingProgrammatically.current) return;

      // Clear previous timeout
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }

      // Debounce the scroll handling
      scrollTimeoutRef.current = setTimeout(() => {
        checkScrollability();
      }, 100);
    };

    const handleResize = () => {
      currentColumnIndex.current = startFromColumn;
      checkScrollability();
    };

    container.addEventListener("scroll", handleScroll);
    window.addEventListener("resize", handleResize);

    // Use ResizeObserver to detect table content changes
    const resizeObserver = new ResizeObserver(() => {
      currentColumnIndex.current = startFromColumn;
      checkScrollability();
    });

    resizeObserver.observe(container);

    return () => {
      container.removeEventListener("scroll", handleScroll);
      window.removeEventListener("resize", handleResize);
      resizeObserver.disconnect();

      // Clear any pending scroll timeout
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }
    };
  }, [checkScrollability, startFromColumn]);

  useHotkeys(
    "ArrowLeft, ArrowRight",
    (event) => {
      if (event.key === "ArrowLeft" && canScrollLeft) {
        scrollLeft();
      }
      if (event.key === "ArrowRight" && canScrollRight) {
        scrollRight();
      }
    },
    {
      enabled: isScrollable,
      preventDefault: true,
    },
  );

  return {
    containerRef,
    canScrollLeft,
    canScrollRight,
    isScrollable,
    scrollLeft,
    scrollRight,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-team.ts">
"use client";

import { useTRPC } from "@/trpc/client";
import {
  useMutation,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";

export function useTeamQuery() {
  const trpc = useTRPC();
  return useSuspenseQuery(trpc.team.current.queryOptions());
}

export function useTeamMutation() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  return useMutation(
    trpc.team.update.mutationOptions({
      onMutate: async (newData) => {
        // Cancel outgoing refetches
        await queryClient.cancelQueries({
          queryKey: trpc.team.current.queryKey(),
        });

        // Get current data
        const previousData = queryClient.getQueryData(
          trpc.team.current.queryKey(),
        );

        // Optimistically update
        queryClient.setQueryData(trpc.team.current.queryKey(), (old: any) => ({
          ...old,
          ...newData,
        }));

        return { previousData };
      },
      onError: (_, __, context) => {
        // Rollback on error
        queryClient.setQueryData(
          trpc.team.current.queryKey(),
          context?.previousData,
        );
      },
      onSettled: () => {
        // Refetch after error or success
        queryClient.invalidateQueries({
          queryKey: trpc.team.current.queryKey(),
        });
      },
    }),
  );
}
</file>

<file path="apps/dashboard/src/hooks/use-tracker-filter-params.ts">
import { useQueryStates } from "nuqs";
import {
  createLoader,
  parseAsArrayOf,
  parseAsString,
  parseAsStringLiteral,
} from "nuqs/server";

export const useTrackerFilterParamsSchema = {
  q: parseAsString,
  customers: parseAsArrayOf(parseAsString),
  status: parseAsStringLiteral(["in_progress", "completed"]),
  tags: parseAsArrayOf(parseAsString),
  start: parseAsString,
  end: parseAsString,
};

export function useTrackerFilterParams() {
  const [filter, setFilter] = useQueryStates(useTrackerFilterParamsSchema);

  return {
    filter,
    setFilter,
    hasFilters: Object.values(filter).some((value) => value !== null),
  };
}

export const loadTrackerFilterParams = createLoader(
  useTrackerFilterParamsSchema,
);
</file>

<file path="apps/dashboard/src/hooks/use-tracker-params.ts">
import { formatISO } from "date-fns";
import {
  parseAsArrayOf,
  parseAsBoolean,
  parseAsString,
  parseAsStringLiteral,
  useQueryStates,
} from "nuqs";

type Props = {
  initialDate?: string;
};

export function useTrackerParams({ initialDate }: Props = {}) {
  const [params, setParams] = useQueryStates({
    date: parseAsString.withDefault(
      initialDate ?? formatISO(new Date(), { representation: "date" }),
    ),
    create: parseAsBoolean,
    projectId: parseAsString,
    update: parseAsBoolean,
    selectedDate: parseAsString,
    eventId: parseAsString,
    range: parseAsArrayOf(parseAsString),
    statuses: parseAsArrayOf(
      parseAsStringLiteral(["completed", "in_progress"]),
    ),
    start: parseAsString,
    end: parseAsString,
    view: parseAsStringLiteral(["week", "month"]),
  });

  return {
    ...params,
    setParams,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-transaction-filter-params-with-persistence.ts">
"use client";

import {
  EMPTY_FILTER_STATE,
  type FilterHookReturn,
  type TransactionFilters,
} from "@/utils/transaction-filters";
import { useCallback } from "react";
import { useTransactionFilterParams } from "./use-transaction-filter-params";

export function useTransactionFilterParamsWithPersistence(): FilterHookReturn<TransactionFilters> {
  const { filter, setFilter, hasFilters } = useTransactionFilterParams();

  const clearAllFilters = useCallback(() => {
    setFilter(EMPTY_FILTER_STATE);
  }, [setFilter]);

  return {
    filter,
    setFilter,
    hasFilters,
    clearAllFilters,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-transaction-filter-params.ts">
import { useQueryStates } from "nuqs";
import {
  createLoader,
  parseAsArrayOf,
  parseAsInteger,
  parseAsString,
  parseAsStringLiteral,
} from "nuqs/server";

export const transactionFilterParamsSchema = {
  q: parseAsString,
  attachments: parseAsStringLiteral(["exclude", "include"] as const),
  start: parseAsString,
  end: parseAsString,
  categories: parseAsArrayOf(parseAsString),
  tags: parseAsArrayOf(parseAsString),
  accounts: parseAsArrayOf(parseAsString),
  assignees: parseAsArrayOf(parseAsString),
  amount_range: parseAsArrayOf(parseAsInteger),
  amount: parseAsArrayOf(parseAsString),
  recurring: parseAsArrayOf(
    parseAsStringLiteral(["all", "weekly", "monthly", "annually"] as const),
  ),
  statuses: parseAsArrayOf(
    parseAsStringLiteral([
      "completed",
      "uncompleted",
      "archived",
      "excluded",
    ] as const),
  ),
};

export function useTransactionFilterParams() {
  const [filter, setFilter] = useQueryStates(transactionFilterParamsSchema, {
    // Clear URL when values are null/default
    clearOnDefault: true,
  });

  return {
    filter,
    setFilter,
    hasFilters: Object.values(filter).some((value) => value !== null),
  };
}

export const loadTransactionFilterParams = createLoader(
  transactionFilterParamsSchema,
);
</file>

<file path="apps/dashboard/src/hooks/use-transaction-params.ts">
import { useQueryStates } from "nuqs";
import { parseAsBoolean, parseAsString } from "nuqs/server";

export function useTransactionParams() {
  const [params, setParams] = useQueryStates({
    transactionId: parseAsString,
    createTransaction: parseAsBoolean,
  });

  return {
    ...params,
    setParams,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-upload.ts">
import { createClient } from "@midday/supabase/client";
import { upload } from "@midday/supabase/storage";
import type { SupabaseClient } from "@supabase/supabase-js";
import { useState } from "react";

interface UploadParams {
  file: File;
  path: string[];
  bucket: string;
}

interface UploadResult {
  url: string;
  path: string[];
}

export function useUpload() {
  const supabase: SupabaseClient = createClient();
  const [isLoading, setLoading] = useState<boolean>(false);

  const uploadFile = async ({
    file,
    path,
    bucket,
  }: UploadParams): Promise<UploadResult> => {
    setLoading(true);

    try {
      const url = await upload(supabase, {
        path,
        file,
        bucket,
      });

      return {
        url,
        path,
      };
    } finally {
      setLoading(false);
    }
  };

  return {
    uploadFile,
    isLoading,
  };
}
</file>

<file path="apps/dashboard/src/hooks/use-user.ts">
"use client";

import { useTRPC } from "@/trpc/client";
import {
  useMutation,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";

export function useUserQuery() {
  const trpc = useTRPC();
  return useSuspenseQuery(trpc.user.me.queryOptions());
}

export function useUserMutation() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  return useMutation(
    trpc.user.update.mutationOptions({
      onMutate: async (newData) => {
        // Cancel outgoing refetches
        await queryClient.cancelQueries({
          queryKey: trpc.user.me.queryKey(),
        });

        // Get current data
        const previousData = queryClient.getQueryData(trpc.user.me.queryKey());

        // Optimistically update
        queryClient.setQueryData(trpc.user.me.queryKey(), (old: any) => ({
          ...old,
          ...newData,
        }));

        return { previousData };
      },
      onError: (_, __, context) => {
        // Rollback on error
        queryClient.setQueryData(
          trpc.user.me.queryKey(),
          context?.previousData,
        );
      },
      onSettled: () => {
        // Refetch after error or success
        queryClient.invalidateQueries({
          queryKey: trpc.user.me.queryKey(),
        });
      },
    }),
  );
}
</file>

<file path="apps/dashboard/src/hooks/use-zod-form.ts">
import { zodResolver } from "@hookform/resolvers/zod";
import { type UseFormProps, useForm } from "react-hook-form";
import type { z } from "zod";

export const useZodForm = <T extends z.ZodType<any, any>>(
  schema: T,
  options?: Omit<UseFormProps<z.infer<T>>, "resolver">,
) => {
  return useForm<z.infer<T>>({
    resolver: zodResolver(schema),
    ...options,
  });
};
</file>

<file path="apps/dashboard/src/lib/tools/get-burn-rate.ts">
import { getQueryClient, trpc } from "@/trpc/server";
import { calculateAvgBurnRate } from "@/utils/format";
import { tool } from "ai";
import { startOfMonth, subMonths } from "date-fns";
import { z } from "zod";

export type GetBurnRateResult = Awaited<ReturnType<typeof getBurnRate.execute>>;

export const getBurnRate = tool({
  description: "Get burn rate",
  parameters: z.object({
    from: z.coerce
      .date()
      .describe("The start date of the burn rate, in ISO-8601 format")
      // Default to 12 months ago
      .default(subMonths(new Date(), 12)),
    to: z.coerce
      .date()
      .describe("The end date of the burn rate, in ISO-8601 format")
      .default(new Date()),
    currency: z.string().describe("The currency for the burn rate").optional(),
  }),
  execute: async (params) => {
    const queryClient = getQueryClient();

    const [months, burnRateData] = await Promise.all([
      queryClient.fetchQuery(
        trpc.reports.runway.queryOptions({
          currency: params.currency,
          from: startOfMonth(new Date(params.from)).toISOString(),
          to: params.to.toISOString(),
        }),
      ),
      queryClient.fetchQuery(
        trpc.reports.burnRate.queryOptions({
          from: startOfMonth(new Date(params.from)).toISOString(),
          to: new Date(params.to).toISOString(),
          currency: params.currency,
        }),
      ),
    ]);

    const averageBurnRate = calculateAvgBurnRate(burnRateData);

    return {
      result: `The average burn rate is ${averageBurnRate} ${params.currency} per month and ${months} months of runway left`,
      params: {
        from: params.from.toISOString(),
        to: params.to.toISOString(),
        currency: params.currency,
      },
    };
  },
});
</file>

<file path="apps/dashboard/src/lib/tools/get-documents.tsx">
import { getQueryClient, trpc } from "@/trpc/server";
import { tool } from "ai";
import { z } from "zod";

export type GetDocumentResult = Awaited<
  ReturnType<typeof getDocuments.execute>
>;

export const getDocuments = tool({
  description: "Find documents",
  parameters: z.object({
    name: z.string().describe("The name of the document"),
  }),
  execute: async ({ name }) => {
    const queryClient = getQueryClient();

    const { data } = await queryClient.fetchQuery(
      trpc.documents.get.queryOptions({
        q: name,
      }),
    );

    return {
      params: {
        name,
      },
      result: `Found ${data.length} documents`,
    };
  },
});
</file>

<file path="apps/dashboard/src/lib/tools/get-forecast.ts">
import { getQueryClient, trpc } from "@/trpc/server";
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { tool } from "ai";
import { startOfMonth, subMonths } from "date-fns";
import { z } from "zod";

export const getForecast = tool({
  description: "Get forecast",
  parameters: z.object({
    name: z.string().describe("The name of the document"),
    startDate: z.coerce
      .date()
      .describe("The start date of the forecast, in ISO-8601 format")
      // Default to 12 months ago
      .default(subMonths(new Date(), 12)),
    endDate: z.coerce
      .date()
      .describe("The end date of the forecast, in ISO-8601 format")
      .default(new Date()),
    currency: z.string().describe("The currency for forecast").optional(),
    type: z.enum(["profit", "revenue"]).describe("The type of forecast"),
  }),
  execute: async ({ startDate, endDate, currency, type }) => {
    const queryClient = getQueryClient();

    let data:
      | RouterOutputs["reports"]["revenue"]
      | RouterOutputs["reports"]["profit"]
      | null = null;

    if (type === "revenue") {
      data = await queryClient.fetchQuery(
        trpc.reports.revenue.queryOptions({
          from: startOfMonth(new Date(startDate)).toISOString(),
          to: new Date(endDate).toISOString(),
          currency,
        }),
      );
    }

    if (type === "profit") {
      data = await queryClient.fetchQuery(
        trpc.reports.profit.queryOptions({
          from: startOfMonth(new Date(startDate)).toISOString(),
          to: new Date(endDate).toISOString(),
          currency,
        }),
      );
    }

    if (!data) {
      return "No data found";
    }

    const prev = data?.result?.map((d) => {
      return `${d.current.date}: ${Intl.NumberFormat("en", {
        style: "currency",
        currency: data.meta.currency,
      }).format(d.current.value)}\n`;
    });

    return `Based on the following historical ${type} data for the last 12 months:
${prev?.join("")}
Current date is: ${new Date().toISOString().split("T")[0]}

Please calculate and provide the forecasted ${type} for the next month. Only return the forecasted value and its currency.`;
  },
});
</file>

<file path="apps/dashboard/src/lib/tools/get-inbox.tsx">
import { getQueryClient, trpc } from "@/trpc/server";
import { tool } from "ai";
import { z } from "zod";

export type GetInboxResult = Awaited<ReturnType<typeof getInbox.execute>>;

export const getInbox = tool({
  description: "Find receipt or invoice from the user's inbox",
  parameters: z.object({
    name: z.string().describe("The name of the invoice or receipt"),
    amount: z
      .number()
      .optional()
      .describe("The amount of the invoice or receipt"),
  }),
  execute: async ({ name, amount }) => {
    const queryClient = getQueryClient();

    const { data } = await queryClient.fetchQuery(
      trpc.inbox.get.queryOptions({
        q: amount ? amount.toString() : name,
      }),
    );

    return {
      result: `Found ${data.length} invoices or receipts`,
      params: {
        name,
        amount,
      },
    };
  },
});
</file>

<file path="apps/dashboard/src/lib/tools/get-profit.ts">
import { getQueryClient, trpc } from "@/trpc/server";
import { tool } from "ai";
import { startOfMonth, subMonths } from "date-fns";
import { z } from "zod";

export type GetProfitResult = Awaited<ReturnType<typeof getProfit.execute>>;

export const getProfit = tool({
  description: "Get profit",
  parameters: z.object({
    from: z.coerce
      .date()
      .describe("The start date of the profit, in ISO-8601 format")
      // Default to 12 months ago
      .default(subMonths(new Date(), 12)),
    to: z.coerce
      .date()
      .describe("The end date of the profit, in ISO-8601 format")
      .default(new Date()),
    currency: z.string().describe("The currency for profit").optional(),
  }),
  execute: async ({ from, to, currency }) => {
    const queryClient = getQueryClient();

    const data = await queryClient.fetchQuery(
      trpc.reports.profit.queryOptions({
        from: startOfMonth(new Date(from)).toISOString(),
        to: new Date(to).toISOString(),
        currency,
      }),
    );

    return {
      result: `The profit is ${data.summary.currentTotal} ${data.summary.currency} for the period ${from.toISOString()} to ${to.toISOString()}`,
      params: {
        from: from.toISOString(),
        to: to.toISOString(),
        currency,
      },
    };
  },
});
</file>

<file path="apps/dashboard/src/lib/tools/get-revenue.ts">
import { getQueryClient, trpc } from "@/trpc/server";
import { tool } from "ai";
import { startOfMonth, subMonths } from "date-fns";
import { z } from "zod";

export type GetRevenueResult = Awaited<ReturnType<typeof getRevenue.execute>>;

export const getRevenue = tool({
  description: "Get revenue",
  parameters: z.object({
    from: z.coerce
      .date()
      .describe("The start date of the revenue, in ISO-8601 format")
      // Default to 12 months ago
      .default(subMonths(new Date(), 12)),
    to: z.coerce
      .date()
      .describe("The end date of the revenue, in ISO-8601 format")
      .default(new Date()),
    currency: z.string().describe("The currency for revenue").optional(),
  }),
  execute: async ({ from, to, currency }) => {
    const queryClient = getQueryClient();

    const data = await queryClient.fetchQuery(
      trpc.reports.revenue.queryOptions({
        from: startOfMonth(new Date(from)).toISOString(),
        to: new Date(to).toISOString(),
        currency,
      }),
    );

    return {
      result: `The revenue is ${data.summary.currentTotal} ${data.summary.currency} for the period ${from.toISOString()} to ${to.toISOString()}`,
      params: {
        from: from.toISOString(),
        to: to.toISOString(),
        currency,
      },
    };
  },
});
</file>

<file path="apps/dashboard/src/lib/tools/get-runway.ts">
import { getQueryClient } from "@/trpc/server";
import { trpc } from "@/trpc/server";
import { tool } from "ai";
import { startOfMonth, subMonths } from "date-fns";
import { z } from "zod";

export const getRunway = tool({
  description: "Get runway",
  parameters: z.object({
    startDate: z.coerce
      .date()
      .describe("The start date of the runway, in ISO-8601 format")
      // Default to 12 months ago
      .default(subMonths(new Date(), 12)),
    endDate: z.coerce
      .date()
      .describe("The end date of the runway, in ISO-8601 format")
      .default(new Date()),
    currency: z.string().describe("The currency for the runway").optional(),
  }),
  execute: async ({ startDate, endDate, currency }) => {
    const queryClient = getQueryClient();

    const months = await queryClient.fetchQuery(
      trpc.reports.runway.queryOptions({
        from: startOfMonth(new Date(startDate)).toISOString(),
        to: new Date(endDate).toISOString(),
        currency,
      }),
    );

    return `The runway is ${months} months`;
  },
});
</file>

<file path="apps/dashboard/src/lib/tools/get-spending.ts">
import { getQueryClient, trpc } from "@/trpc/server";
import { tool } from "ai";
import { startOfMonth, subMonths } from "date-fns";
import { z } from "zod";

export const getSpending = tool({
  description: "Get spending from category",
  parameters: z.object({
    currency: z.string().describe("The currency for spending").optional(),
    category: z.string().describe("The category for spending"),
    startDate: z.coerce
      .date()
      .describe("The start date of the spending, in ISO-8601 format")
      // Default to 12 months ago
      .default(subMonths(new Date(), 12)),
    endDate: z.coerce
      .date()
      .describe("The end date of the spending, in ISO-8601 format")
      .default(new Date()),
  }),
  execute: async ({ category, startDate, endDate, currency }) => {
    const queryClient = getQueryClient();

    const data = await queryClient.fetchQuery(
      trpc.reports.spending.queryOptions({
        from: startOfMonth(new Date(startDate)).toISOString(),
        to: new Date(endDate).toISOString(),
        currency,
      }),
    );

    const found = data?.find(
      (c) => category.toLowerCase() === c?.name?.toLowerCase(),
    );

    return `Found ${found?.amount} ${currency} in ${category} from ${startDate} to ${endDate}`;
  },
});
</file>

<file path="apps/dashboard/src/lib/tools/get-tax-summary.ts">
import { getQueryClient, trpc } from "@/trpc/server";
import { tool } from "ai";
import { startOfMonth, subMonths } from "date-fns";
import { z } from "zod";

export type GetTaxSummaryResult = Awaited<
  ReturnType<typeof getTaxSummary.execute>
>;

export const getTaxSummary = tool({
  description:
    "Get tax summary for paid or collected taxes, optionally filtered by category and tax type",
  parameters: z.object({
    from: z.coerce
      .date()
      .describe("The start date of the tax summary, in ISO-8601 format")
      // Default to 12 months ago
      .default(subMonths(new Date(), 12)),
    to: z.coerce
      .date()
      .describe("The end date of the tax summary, in ISO-8601 format")
      .default(new Date()),
    currency: z.string().describe("The currency for tax summary").optional(),
    type: z
      .enum(["paid", "collected"])
      .describe("Type of tax - paid (tax expenses) or collected (tax revenue)")
      .default("paid"),
    categorySlug: z
      .string()
      .describe("Filter by specific category slug")
      .optional(),
    taxType: z
      .string()
      .describe("Filter by specific tax type (e.g., 'vat', 'sales_tax')")
      .optional(),
  }),
  execute: async ({ from, to, currency, type, categorySlug, taxType }) => {
    const queryClient = getQueryClient();

    const data = await queryClient.fetchQuery(
      trpc.reports.taxSummary.queryOptions({
        from: startOfMonth(new Date(from)).toISOString(),
        to: new Date(to).toISOString(),
        currency,
        type,
        categorySlug,
        taxType,
      }),
    );

    const { summary, result } = data;

    return {
      summary: {
        totalTaxAmount: summary.totalTaxAmount,
        totalTransactionAmount: summary.totalTransactionAmount,
        totalTransactions: summary.totalTransactions,
        categoryCount: summary.categoryCount,
        currency: summary.currency,
        type: summary.type,
      },
      period: {
        from: from.toISOString(),
        to: to.toISOString(),
      },
      filters: {
        currency,
        categorySlug,
        taxType,
      },
      categories:
        result?.map((category) => ({
          name: category.category_name,
          slug: category.category_slug,
          taxAmount: category.total_tax_amount,
          transactionAmount: category.total_transaction_amount,
          transactionCount: category.transaction_count,
          averageTaxRate: category.avg_tax_rate,
          taxType: category.tax_type,
          currency: category.currency,
          dateRange: {
            from: category.earliest_date,
            to: category.latest_date,
          },
        })) || [],
    };
  },
});
</file>

<file path="apps/dashboard/src/lib/tools/get-transactions.ts">
import { getQueryClient, trpc } from "@/trpc/server";
import { tool } from "ai";
import { z } from "zod";

export type GetTransactionsResult = Awaited<
  ReturnType<typeof getTransactions.execute>
>;

export const getTransactions = tool({
  description: "Find transactions, if expense sort by amount descending",
  parameters: z.object({
    sort: z
      .array(
        z.enum([
          "date",
          "amount",
          "status",
          "category",
          "tags",
          "bank_account",
          "assigned",
        ]),
        z.enum(["asc", "desc"]),
      )
      .nullable()
      .optional()
      .describe("The sort order to filter by"),
    pageSize: z
      .number()
      .min(1)
      .max(25)
      .default(5)
      .describe("The number of transactions to return"),
    q: z.string().nullable().optional().describe("The query to search for"),
    categories: z
      .array(z.string())
      .nullable()
      .optional()
      .describe("The categories to filter by"),
    tags: z
      .array(z.string())
      .nullable()
      .optional()
      .describe("The tags to filter by"),
    start: z
      .string()
      .nullable()
      .optional()
      .describe("The start date to filter by"),
    end: z.string().nullable().optional().describe("The end date to filter by"),
    accounts: z
      .array(z.string())
      .nullable()
      .optional()
      .describe("The accounts to filter by"),
    assignees: z
      .array(z.string())
      .nullable()
      .optional()
      .describe("The assignees to filter by"),
    statuses: z
      .array(z.string())
      .nullable()
      .optional()
      .describe("The statuses to filter by"),
    recurring: z
      .array(z.enum(["all", "weekly", "monthly"]))
      .nullable()
      .optional()
      .describe("The recurring transactions to filter by"),
    attachments: z
      .enum(["include", "exclude"])
      .nullable()
      .optional()
      .describe("The attachments to filter by"),
    amount_range: z
      .array(z.number())
      .nullable()
      .optional()
      .describe("The amount range to filter by"),
    amount: z
      .array(z.string())
      .nullable()
      .optional()
      .describe("The amount to filter by"),
    type: z
      .enum(["income", "expense"])
      .nullable()
      .optional()
      .describe("The type of transactions to filter by"),
  }),
  execute: async (params) => {
    const queryClient = getQueryClient();

    const { data, meta } = await queryClient.fetchQuery(
      trpc.transactions.get.queryOptions(params),
    );

    return {
      params,
      result: `Found ${data.length} transactions`,
      meta: {
        hasNextPage: meta.hasNextPage,
      },
    };
  },
});
</file>

<file path="apps/dashboard/src/lib/download.ts">
import { invoke } from "@midday/desktop-client/core";
import { isDesktopApp } from "@midday/desktop-client/platform";

export async function downloadFile(url: string, filename: string) {
  if (!isDesktopApp()) {
    // Web mode - normal download
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    return;
  }

  try {
    // Desktop mode - open download URL in default browser
    // The browser will have access to user's authentication and handle the download
    console.log("📥 Opening download in browser:", { url, filename });

    const downloadUrl = `${window.location.origin}${url}`;

    // Use Tauri's opener plugin via invoke to open URL in default browser
    await invoke("plugin:opener|open_url", {
      url: downloadUrl,
    });

    console.log("✅ Download opened in browser:", downloadUrl);
  } catch (error) {
    console.error("❌ Failed to open download in browser:", error);
    throw error;
  }
}
</file>

<file path="apps/dashboard/src/locales/client.ts">
"use client";

import { createI18nClient } from "next-international/client";

// NOTE: Also update middleware.ts to support locale
export const languages = ["en"];

export const {
  useScopedI18n,
  I18nProviderClient,
  useCurrentLocale,
  useChangeLocale,
  useI18n,
} = createI18nClient({
  en: () => import("./en"),
  // sv: () => import("./sv"),
});
</file>

<file path="apps/dashboard/src/locales/en.ts">
export default {
  transaction_methods: {
    card_purchase: "Card Purchase",
    payment: "Payment",
    card_atm: "Card ATM",
    transfer: "Transfer",
    other: "Other",
    ach: "Ach",
    deposit: "Deposit",
    wire: "Wire",
    fee: "Fee",
    interest: "Interest",
  },
  language: {
    title: "Languages",
    description: "Change the language used in the user interface.",
    placeholder: "Select language",
  },
  locale: {
    title: "Locale",
    searchPlaceholder: "Search locale",
    description:
      "Sets the region and language preferences for currency, dates, and other locale-specific formats.",
    placeholder: "Select locale",
  },
  languages: {
    en: "English",
    sv: "Swedish",
  },
  timezone: {
    title: "Time Zone",
    searchPlaceholder: "Search timezone",
    description:
      "Defines the default time zone used for displaying times in the app.",
    placeholder: "Select timezone",
  },
  spending_period: {
    last_30d: "Last 30 days",
    this_month: "This month",
    last_month: "Last month",
    this_year: "This year",
    last_year: "Last year",
  },
  transactions_period: {
    all: "All",
    income: "Income",
    expense: "Expense",
  },
  transaction_frequency: {
    weekly: "Weekly recurring",
    monthly: "Monthly recurring",
    annually: "Annually recurring",
  },
  inbox_filter: {
    all: "All",
    todo: "Todo",
    done: "Done",
  },
  chart_type: {
    profit: "Profit",
    revenue: "Revenue",
    expense: "Expenses",
    burn_rate: "Burn rate",
  },
  folders: {
    all: "All",
    exports: "Exports",
    inbox: "Inbox",
    imports: "Imports",
    transactions: "Transactions",
    invoices: "Invoices",
  },
  mfa_status: {
    verified: "Verified",
    unverified: "Unverified",
  },
  roles: {
    owner: "Owner",
    member: "Member",
  },
  tracker_status: {
    in_progress: "In progress",
    completed: "Completed",
  },
  notifications: {
    categories: {
      transactions: "Transactions",
      invoices: "Invoices",
      inbox: "Inbox",
    },
    transactions_created: {
      name: "New Transactions",
      description: "Get notified when new transactions are imported",
      "title#one": "New transaction from {name} {amount} on {date}",
      "title#other": "{count} new transactions added",
      "title_many#other": "{count} transactions imported",
      single_transaction: "New transaction from {name} {amount} on {date}",
    },
    invoice_paid: {
      name: "Paid",
      description: "Get notified when invoices are paid",
      title: "Invoice payment received",
      subtitle: "Your invoice has been paid",
      manual_with_date:
        "Invoice {invoiceNumber} from {customerName} marked as paid on {date}",
      manual_with_date_no_customer:
        "Invoice {invoiceNumber} marked as paid on {date}",
      manual: "Invoice {invoiceNumber} from {customerName} marked as paid",
      manual_no_customer: "Invoice {invoiceNumber} marked as paid",
      automatic: "Payment received for invoice {invoiceNumber}",
    },
    invoice_overdue: {
      name: "Overdue",
      description: "Get notified when invoices become overdue",
      title: "Invoice is overdue",
      subtitle: "Payment is past due date",
      with_number: "Invoice {invoiceNumber} is now overdue",
    },
    invoice_scheduled: {
      name: "Scheduled",
      description: "Get notified when invoices are scheduled for sending",
      title: "Invoice scheduled",
      subtitle: "Invoice has been scheduled for automatic delivery",
      with_customer:
        "Invoice {invoiceNumber} scheduled to be sent to {customerName} on {date} at {time}",
      without_customer:
        "Invoice {invoiceNumber} scheduled for {date} at {time}",
      simple: "Invoice {invoiceNumber} has been scheduled",
    },
    invoice_sent: {
      name: "Sent",
      description: "Get notified when invoices are successfully sent",
      title: "Invoice sent",
      subtitle: "Invoice has been delivered to customer",
      with_customer: "Invoice {invoiceNumber} sent to {customerName}",
      without_customer: "Invoice {invoiceNumber} has been sent",
    },
    invoice_reminder_sent: {
      name: "Reminder Sent",
      description: "Get notified when invoice reminders are sent",
      title: "Invoice reminder sent",
      subtitle: "Payment reminder has been sent to customer",
      with_customer:
        "Payment reminder sent to {customerName} for invoice {invoiceNumber}",
      without_customer: "Payment reminder sent for invoice {invoiceNumber}",
    },

    invoice_cancelled: {
      name: "Cancelled",
      description: "Get notified when invoices are cancelled",
      title: "Invoice cancelled",
      subtitle: "Invoice has been cancelled",
      with_customer:
        "Invoice {invoiceNumber} for {customerName} has been cancelled",
      without_customer: "Invoice {invoiceNumber} has been cancelled",
    },
    invoice_created: {
      name: "Created",
      description: "Get notified when new invoices are created",
      title: "Invoice created",
      subtitle: "A new invoice has been created",
      with_customer_and_amount:
        "Invoice {invoiceNumber} created for {customerName} - {amount}",
      with_customer: "Invoice {invoiceNumber} created for {customerName}",
      without_customer: "Invoice {invoiceNumber} has been created",
    },
    inbox_new: {
      name: "New Inbox Items",
      description: "Get notified when new items arrive in your inbox",
      "type.email#one": "New document received via team inbox email",
      "type.email#other": "{count} new documents received via team inbox email",
      "type.sync#one": "New document synced from your {provider} account",
      "type.sync#other":
        "{count} new documents synced from your {provider} account",
      "type.slack#one": "New document shared via Slack",
      "type.slack#other": "{count} new documents shared via Slack",
      "type.upload#one": "New document uploaded to your inbox",
      "type.upload#other": "{count} new documents uploaded to your inbox",
      // Fallback titles (shouldn't be used with new implementation)
      "title#one": "We found a new document in your inbox",
      "title#other": "We found {count} new documents in your inbox",
      "upload_title#one": "A new document was uploaded to your inbox",
      "upload_title#other": "{count} new documents were uploaded to your inbox",
    },
    inbox_auto_matched: {
      name: "Auto-matched",
      description:
        "Get notified when documents are automatically matched with transactions",
      title: "Document automatically matched",
      with_details:
        '"{documentName}" ({amount}) was matched with "{transactionName}"',
      with_names: '"{documentName}" was matched with "{transactionName}"',
      cross_currency_details:
        '"{documentName}" ({documentAmount}) was matched with "{transactionName}" ({transactionAmount}) across currencies',
    },
    inbox_high_confidence: {
      name: "High Confidence Match",
      description:
        "Get notified when high-confidence matches are found that likely need confirmation",
      title: "Likely match found",
      with_details:
        '"{documentName}" ({amount}) looks like it matches "{transactionName}" — click to review',
      with_names:
        '"{documentName}" looks like it matches "{transactionName}" — click to review',
      cross_currency_details:
        '"{documentName}" ({documentAmount}) might match "{transactionName}" ({transactionAmount}) across currencies — click to review',
    },
    inbox_needs_review: {
      name: "Needs Review",
      description:
        "Get notified when potential matches are found that need your review",
      title: "Possible match found",
      with_details:
        '"{documentName}" ({amount}) might match "{transactionName}" — click to review',
      with_names:
        '"{documentName}" might match "{transactionName}" — click to review',
      high_confidence_details:
        '"{documentName}" ({amount}) looks like it matches "{transactionName}" — click to review',
      high_confidence_names:
        '"{documentName}" looks like it matches "{transactionName}" — click to review',
      cross_currency_high_confidence:
        '"{documentName}" ({documentAmount}) looks like it matches "{transactionName}" ({transactionAmount}) across currencies — click to review',
      cross_currency_suggested:
        '"{documentName}" ({documentAmount}) might match "{transactionName}" ({transactionAmount}) across currencies — click to review',
    },
    inbox_cross_currency_matched: {
      name: "Cross-currency Match",
      description:
        "Get notified when documents are matched with transactions in different currencies",
      title: "Cross-currency match found",
      with_details:
        '"{documentName}" ({documentAmount}) might match "{transactionName}" ({transactionAmount}) across currencies — click to review',
      with_names:
        '"{documentName}" might match "{transactionName}" across currencies — click to review',
      high_confidence_details:
        '"{documentName}" ({documentAmount}) looks like it matches "{transactionName}" ({transactionAmount}) across currencies — click to review',
      high_confidence_names:
        '"{documentName}" looks like it matches "{transactionName}" across currencies — click to review',
    },
    default: {
      title: "New activity detected",
    },
    archive_button: "Archive notification",
    time_ago: "{time} ago",
  },
  widgets: {
    insights: "Assistant",
    inbox: "Inbox",
    spending: "Spending",
    transactions: "Transactions",
    tracker: "Tracker",
  },
  bottom_bar: {
    "transactions#one": "1 Transaction",
    "transactions#other": "{count} Transactions",
    multi_currency: "Multi currency",
    description: "Includes transactions from all pages of results",
  },
  account_type: {
    depository: "Depository",
    credit: "Credit",
    other_asset: "Other Asset",
    loan: "Loan",
    other_liability: "Other Liability",
  },
  tags: {
    bylaws: "Bylaws",
    shareholder_agreements: "Shareholder Agreements",
    board_meeting: "Board Meeting",
    corporate_policies: "Corporate Policies",
    annual_reports: "Annual Reports",
    budget_reports: "Budget Reports",
    audit_reports: "Audit Reports",
    tax_returns: "Tax Returns",
    invoices_and_receipts: "Invoices & Receipts",
    employee_handbook: "Employee Handbook",
    payroll_records: "Payroll Records",
    performance_reviews: "Performance Reviews",
    employee_training_materials: "Employee Training Materials",
    benefits_documentation: "Benefits Documentation",
    termination_letters: "Termination Letters",
    patents: "Patents",
    trademarks: "Trademarks",
    copyrights: "Copyrights",
    client_contracts: "Client Contracts",
    financial_records: "Financial Records",
    compliance_reports: "Compliance Reports",
    regulatory_filings: "Regulatory Filings",
    advertising_copy: "Advertising Copy",
    press_releases: "Press Releases",
    branding_guidelines: "Branding Guidelines",
    market_research_reports: "Market Research Reports",
    campaign_performance_reports: "Campaign Performance Reports",
    customer_surveys: "Customer Surveys",
    quality_control_reports: "Quality Control Reports",
    inventory_reports: "Inventory Reports",
    maintenance_logs: "Maintenance Logs",
    production_schedules: "Production Schedules",
    vendor_agreements: "Vendor Agreements",
    supplier_agreements: "Supplier Agreements",
    sales_contracts: "Sales Contracts",
    sales_reports: "Sales Reports",
    client_proposals: "Client Proposals",
    customer_order_forms: "Customer Order Forms",
    sales_presentations: "Sales Presentations",
    data_security_plans: "Data Security Plans",
    system_architecture_diagrams: "System Architecture Diagrams",
    incident_response_plans: "Incident Response Plans",
    user_manuals: "User Manuals",
    software_licenses: "Software Licenses",
    data_backup_logs: "Data Backup Logs",
    project_plans: "Project Plans",
    task_lists: "Task Lists",
    risk_management_plans: "Risk Management Plans",
    project_status_reports: "Project Status Reports",
    meeting_agendas: "Meeting Agendas",
    lab_notebooks: "Lab Notebooks",
    experiment_results: "Experiment Results",
    product_design_documents: "Product Design Documents",
    prototypes_and_models: "Prototypes & Models",
    testing_reports: "Testing Reports",
    newsletters: "Newsletters",
    email_correspondence: "Email Correspondence",
    support_tickets: "Support Tickets",
    faqs_and_knowledge: "FAQs & Knowledge",
    user_guides: "User Guides",
    warranty_information: "Warranty Information",
    swot_analysis: "SWOT Analysis",
    strategic_objectives: "Strategic Objectives",
    roadmaps: "Roadmaps",
    competitive_analysis: "Competitive Analysis",
    safety_data_sheets: "Safety Data Sheets",
    compliance_certificates: "Compliance Certificates",
    incident_reports: "Incident Reports",
    emergency_response_plans: "Emergency Response Plans",
    certification_records: "Certification Records",
    training_schedules: "Training Schedules",
    e_learning_materials: "E-learning Materials",
    competency_assessment_forms: "Competency Assessment Forms",
  },
  invoice_status: {
    draft: "Draft",
    overdue: "Overdue",
    paid: "Paid",
    unpaid: "Unpaid",
    canceled: "Canceled",
    scheduled: "Scheduled",
  },
  payment_status: {
    none: "Unknown",
    good: "Good",
    average: "Average",
    bad: "Bad",
  },
  payment_status_description: {
    none: "No payment history yet.",
    good: "Consistently pay on time.",
    average: "Mostly on time.",
    bad: "Room for improvement.",
  },
  "invoice_count#zero": "No invoices",
  "invoice_count#one": "1 invoice",
  "invoice_count#other": "{count} invoices",
  account_balance: {
    total_balance: "Total balance",
  },
  transaction_categories: {
    // Parent Categories
    revenue: "Income and money received from business activities",
    "cost-of-goods-sold":
      "Direct costs associated with producing goods or services",
    "sales-marketing":
      "Expenses related to sales activities and marketing efforts",
    operations: "Day-to-day operational costs of running the business",
    "professional-services":
      "Fees paid to external professionals and service providers",
    "human-resources":
      "Employee-related costs including salaries, benefits, and training",
    "travel-entertainment":
      "Business travel, meals, and entertainment expenses",
    technology: "Software, hardware, and technology-related expenses",
    "banking-finance":
      "Banking fees, loan payments, and financial transactions",
    "assets-capex": "Capital expenditures and asset acquisitions",
    "liabilities-debt": "Debt obligations and deferred revenue",
    taxes: "Tax payments and government fees",
    "owner-equity": "Owner investments, draws, and equity transactions",
    system: "System-generated categories for uncategorized transactions",

    // Child Categories - Revenue
    income: "General business income from various sources",
    "product-sales": "Revenue from selling physical or digital products",
    "service-revenue": "Income from providing services to customers",
    "consulting-revenue": "Revenue from consulting and advisory services",
    "subscription-revenue": "Recurring income from subscription-based services",
    "interest-income": "Earnings from interest on investments or loans",
    "other-income": "Miscellaneous income not classified elsewhere",
    "customer-refunds": "Money returned to customers for refunds",
    "chargebacks-disputes": "Revenue adjustments from payment disputes",

    // Child Categories - Cost of Goods Sold
    inventory: "Cost of goods held for sale",
    manufacturing: "Production costs for manufacturing goods",
    "shipping-inbound": "Costs for receiving goods and materials",
    "duties-customs": "Import duties and customs fees",

    // Child Categories - Sales & Marketing
    marketing: "Marketing campaign and promotional expenses",
    advertising: "Paid advertising and media placement costs",
    website: "Website development, hosting, and maintenance",
    events: "Trade shows, conferences, and event expenses",
    "promotional-materials":
      "Brochures, business cards, and marketing materials",

    // Child Categories - Operations
    "office-supplies": "Office materials and stationery",
    rent: "Office, warehouse, or equipment rental costs",
    utilities: "Electricity, water, gas, and other utility bills",
    "facilities-expenses": "Building maintenance and facility costs",
    equipment: "Non-capital equipment purchases and maintenance",
    "internet-and-telephone": "Internet, phone, and communication services",
    shipping: "Outbound shipping and delivery costs",

    // Child Categories - Professional Services
    "professional-services-fees": "Legal, accounting, and consulting fees",
    contractors: "Payments to independent contractors and freelancers",
    insurance: "Business insurance premiums and coverage",

    // Child Categories - Human Resources
    salary: "Employee wages and salaries",
    training: "Employee training and development costs",
    "employer-taxes": "Payroll taxes and employer contributions",
    benefits: "Employee benefits and health insurance",

    // Child Categories - Travel & Entertainment
    travel: "Business travel expenses including transportation",
    meals: "Business meal and dining expenses",
    activity: "Entertainment and team building activities",

    // Child Categories - Technology
    software: "Software licenses and subscriptions",
    "non-software-subscriptions": "Non-software subscription services",

    // Child Categories - Banking & Finance
    transfer: "Bank transfers between accounts",
    "credit-card-payment": "Credit card payments and fees",
    "banking-fees": "Bank account maintenance and transaction fees",
    "loan-proceeds": "Money received from loans and financing",
    "loan-principal-repayment": "Principal payments on loans",
    "interest-expense": "Interest paid on loans and credit",
    payouts: "Payment platform payouts to business",
    "processor-fees": "Payment processing and transaction fees",
    fees: "General banking and financial fees",

    // Child Categories - Assets
    "fixed-assets": "Long-term assets like buildings and equipment",
    "prepaid-expenses": "Advance payments for future services",

    // Child Categories - Liabilities & Debt
    leases: "Equipment and property lease payments",
    "deferred-revenue": "Advance payments received for future services",

    // Child Categories - Taxes & Government
    "vat-gst-pst-qst-payments": "Value-added tax and sales tax payments",
    "sales-use-tax-payments": "Sales and use tax obligations",
    "income-tax-payments": "Income tax payments and installments",
    "payroll-tax-remittances": "Employee tax withholdings and remittances",
    "government-fees": "Government licensing and regulatory fees",

    // Child Categories - Owner / Equity
    "owner-draws": "Money withdrawn by business owners",
    "capital-investment": "Owner investments in the business",
    "charitable-donations": "Charitable contributions and donations",

    // Child Categories - System
    uncategorized: "Transactions that haven't been classified yet",
    other: "Miscellaneous transactions not fitting other categories",
  },
} as const;
</file>

<file path="apps/dashboard/src/locales/server.ts">
import { createI18nServer } from "next-international/server";

export const { getI18n, getScopedI18n, getStaticParams } = createI18nServer({
  en: () => import("./en"),
  // sv: () => import("./sv"),
});
</file>

<file path="apps/dashboard/src/locales/sv.ts">
export default {
  transaction_methods: {
    card_purchase: "Kortbetalning",
    payment: "Betalning",
    card_atm: "Kort bankomat",
    transfer: "Överföring",
    other: "Annan",
    ach: "Ach",
    deposit: "Deposition",
    wire: "Wire",
    fee: "Avgift",
    interest: "Ränta",
  },
  language: {
    title: "Språk",
    description: "Ändra språket som används i användargränssnittet.",
    placeholder: "Välj språk",
  },
  languages: {
    en: "Engelska",
    sv: "Svenska",
  },
  timezone: {
    title: "Tidzon",
    description: "Aktuell tidzoninställning.",
    placeholder: "Välj tidzon",
  },
  inbox_filter: {
    all: "Alla",
    todo: "Att göra",
    done: "Slutförda",
  },
  spending_period: {
    last_30d: "Senaste 30 dagarna",
    this_month: "Den här månaden",
    last_month: "Förra månaden",
    this_year: "Det här året",
    last_year: "Förra året",
  },
  transactions_period: {
    all: "All",
    income: "Inkomst",
    outcome: "Utgifter",
  },
  chart_type: {
    profit: "Vinst",
    revenue: "Omsättning",
    burn_rate: "Brännhastighet",
  },
  folders: {
    all: "Alla",
    exports: "Exporteringar",
    inbox: "Inkorg",
    imports: "Importer",
    transactions: "Transaktioner",
    invoices: "Fakturor",
  },
  mfa_status: {
    verified: "Verifierad",
    unverified: "Overifierad",
  },
  roles: {
    owner: "Ägare",
    member: "Medlem",
  },
  tracker_status: {
    in_progress: "Pågående",
    completed: "Färdig",
  },
  account_balance: {
    total_balance: "Total saldo",
  },
  transaction_categories: {
    // Parent Categories
    revenue: "Intäkter och pengar från verksamheten",
    "cost-of-goods-sold":
      "Direkta kostnader för att producera varor eller tjänster",
    "sales-marketing":
      "Kostnader relaterade till försäljning och marknadsföring",
    operations: "Dagliga driftskostnader för att driva verksamheten",
    "professional-services":
      "Avgifter till externa experter och tjänsteleverantörer",
    "human-resources":
      "Anställdrelaterade kostnader inklusive löner, förmåner och utbildning",
    "travel-entertainment": "Affärsresor, måltider och nöjeskostnader",
    technology: "Programvara, hårdvara och teknologirelaterade kostnader",
    "banking-finance":
      "Bankavgifter, lånebetalningar och finansiella transaktioner",
    "assets-capex": "Kapitalutgifter och tillgångsförvärv",
    "liabilities-debt": "Skuldförbindelser och uppskjuten intäkt",
    taxes: "Skattebetalningar och myndighetsavgifter",
    "owner-equity": "Ägareinvesteringar, uttag och eget kapital",
    system: "Systemgenererade kategorier för okategoriserade transaktioner",

    // Child Categories - Revenue
    income: "Allmänna affärsintäkter från olika källor",
    "product-sales":
      "Intäkter från försäljning av fysiska eller digitala produkter",
    "service-revenue": "Intäkter från att tillhandahålla tjänster till kunder",
    "consulting-revenue": "Intäkter från konsulttjänster och rådgivning",
    "subscription-revenue":
      "Återkommande intäkter från prenumerationsbaserade tjänster",
    "interest-income": "Intäkter från ränta på investeringar eller lån",
    "other-income": "Diverse intäkter som inte klassificeras annorstädes",
    "customer-refunds": "Pengar återbetalda till kunder för återbetalningar",
    "chargebacks-disputes": "Intäktsjusteringar från betalningsdispyt",

    // Child Categories - Cost of Goods Sold
    inventory: "Kostnad för varor som hålls för försäljning",
    manufacturing: "Produktionskostnader för tillverkning av varor",
    "shipping-inbound": "Kostnader för att ta emot varor och material",
    "duties-customs": "Importtullar och tullavgifter",

    // Child Categories - Sales & Marketing
    marketing: "Marknadsföringskampanjer och promotionskostnader",
    advertising: "Betalda annonser och mediaplaceringar",
    website: "Webbplatsutveckling, hosting och underhåll",
    events: "Mässor, konferenser och evenemangskostnader",
    "promotional-materials":
      "Broschyrer, visitkort och marknadsföringsmaterial",

    // Child Categories - Operations
    "office-supplies": "Kontorsmaterial och pappersvaror",
    rent: "Kontor, lager eller utrustningshyra",
    utilities: "El, vatten, gas och andra räkningar",
    "facilities-expenses": "Byggnadsunderhåll och anläggningskostnader",
    equipment: "Icke-kapitalutrustning och underhåll",
    "internet-and-telephone": "Internet, telefon och kommunikationstjänster",
    shipping: "Utgående frakt och leveranskostnader",

    // Child Categories - Professional Services
    "professional-services-fees": "Juridiska, redovisnings- och konsultarvoden",
    contractors: "Betalningar till oberoende entreprenörer och frilansare",
    insurance: "Företagsförsäkringspremier och täckning",

    // Child Categories - Human Resources
    salary: "Anställdas löner och arvoden",
    training: "Anställdas utbildning och utvecklingskostnader",
    "employer-taxes": "Arbetsgivaravgifter och bidrag",
    benefits: "Anställdas förmåner och sjukförsäkring",

    // Child Categories - Travel & Entertainment
    travel: "Affärsresekostnader inklusive transport",
    meals: "Affärsmåltider och middagskostnader",
    activity: "Nöjes- och teambuildingaktiviteter",

    // Child Categories - Technology
    software: "Programvarulicenser och prenumerationer",
    "non-software-subscriptions": "Icke-programvaruprenumerationer",

    // Child Categories - Banking & Finance
    transfer: "Banköverföringar mellan konton",
    "credit-card-payment": "Kreditkortsbetalningar och avgifter",
    "banking-fees": "Bankkontounderhåll och transaktionsavgifter",
    "loan-proceeds": "Pengar mottagna från lån och finansiering",
    "loan-principal-repayment": "Huvudstolsbetalningar på lån",
    "interest-expense": "Ränta betalad på lån och kredit",
    payouts: "Betalningsplattformsutbetalningar till företaget",
    "processor-fees": "Betalningsbehandling och transaktionsavgifter",
    fees: "Allmänna bank- och finansiella avgifter",

    // Child Categories - Assets
    "fixed-assets": "Långsiktiga tillgångar som byggnader och utrustning",
    "prepaid-expenses": "Förhandsbetalningar för framtida tjänster",

    // Child Categories - Liabilities & Debt
    leases: "Utrustnings- och fastighetsleasingsbetalningar",
    "deferred-revenue": "Förhandsbetalningar mottagna för framtida tjänster",

    // Child Categories - Taxes & Government
    "vat-gst-pst-qst-payments":
      "Mervärdesskatt och försäljningsskattebetalningar",
    "sales-use-tax-payments":
      "Försäljnings- och användningsskatteförpliktelser",
    "income-tax-payments": "Inkomstskattebetalningar och avbetalningar",
    "payroll-tax-remittances": "Anställdas skatteavdrag och remitteringar",
    "government-fees": "Myndighetslicensiering och regelverksavgifter",

    // Child Categories - Owner / Equity
    "owner-draws": "Pengar som dras av företagsägare",
    "capital-investment": "Ägareinvesteringar i företaget",
    "charitable-donations": "Välgörenhetsbidrag och donationer",

    // Child Categories - System
    uncategorized: "Transaktioner som inte har klassificerats ännu",
    other: "Diverse transaktioner som inte passar in i andra kategorier",
  },
} as const;
</file>

<file path="apps/dashboard/src/store/assistant.ts">
import { create } from "zustand";

interface AssistantState {
  isOpen: boolean;
  message?: string;
  setOpen: (message?: string) => void;
}

export const useAssistantStore = create<AssistantState>()((set) => ({
  isOpen: false,
  message: undefined,
  setOpen: (message) => set((state) => ({ isOpen: !state.isOpen, message })),
}));
</file>

<file path="apps/dashboard/src/store/export.ts">
import { create } from "zustand";

interface ExportState {
  exportData?: {
    runId?: string;
    accessToken?: string;
  };
  setExportData: (exportData?: {
    runId?: string;
    accessToken?: string;
  }) => void;
}

export const useExportStore = create<ExportState>()((set) => ({
  exportData: undefined,
  setExportData: (exportData) => set({ exportData }),
}));
</file>

<file path="apps/dashboard/src/store/invoice.ts">
import type { Column } from "@tanstack/react-table";
import { create } from "zustand";

interface InvoiceState {
  columns: Column<any, unknown>[];
  setColumns: (columns?: Column<any, unknown>[]) => void;
}

export const useInvoiceStore = create<InvoiceState>()((set) => ({
  columns: [],
  setColumns: (columns) => set({ columns: columns || [] }),
}));
</file>

<file path="apps/dashboard/src/store/oauth-secret-modal.ts">
import { create } from "zustand";

interface OAuthSecretModalState {
  isOpen: boolean;
  clientSecret?: string;
  applicationName?: string;
  setSecret: (secret: string, applicationName: string) => void;
  close: () => void;
}

export const useOAuthSecretModalStore = create<OAuthSecretModalState>()(
  (set) => ({
    isOpen: false,
    clientSecret: undefined,
    applicationName: undefined,
    setSecret: (secret, applicationName) =>
      set({
        isOpen: true,
        clientSecret: secret,
        applicationName,
      }),
    close: () =>
      set({
        isOpen: false,
        clientSecret: undefined,
        applicationName: undefined,
      }),
  }),
);
</file>

<file path="apps/dashboard/src/store/search.ts">
import { create } from "zustand";

interface SearchState {
  isOpen: boolean;
  setOpen: () => void;
}

export const useSearchStore = create<SearchState>()((set) => ({
  isOpen: false,
  setOpen: () => set((state) => ({ isOpen: !state.isOpen })),
}));
</file>

<file path="apps/dashboard/src/store/token-modal.ts">
import { create } from "zustand";

type Data = {
  id?: string;
  name?: string;
  scopes?: string[];
};

type Type = "create" | "edit" | "delete";

interface TokenModalState {
  type?: Type;
  data?: Data;
  createdKey?: string;
  setData: (data?: Data, type?: Type) => void;
  setCreatedKey: (key?: string) => void;
}

export const useTokenModalStore = create<TokenModalState>()((set) => ({
  type: undefined,
  data: undefined,
  createdKey: undefined,
  setData: (data, type) => set({ data, type }),
  setCreatedKey: (key) => set({ createdKey: key }),
}));
</file>

<file path="apps/dashboard/src/store/transactions.ts">
import type { Column, RowSelectionState, Updater } from "@tanstack/react-table";
import { create } from "zustand";

interface TransactionsState {
  canDelete?: boolean;
  columns: Column<any, unknown>[];
  setColumns: (columns?: Column<any, unknown>[]) => void;
  setCanDelete: (canDelete?: boolean) => void;
  setRowSelection: (updater: Updater<RowSelectionState>) => void;
  rowSelection: Record<string, boolean>;
}

export const useTransactionsStore = create<TransactionsState>()((set) => ({
  columns: [],
  canDelete: false,
  rowSelection: {},
  setCanDelete: (canDelete) => set({ canDelete }),
  setColumns: (columns) => set({ columns: columns || [] }),
  setRowSelection: (updater: Updater<RowSelectionState>) =>
    set((state) => {
      return {
        rowSelection:
          typeof updater === "function" ? updater(state.rowSelection) : updater,
      };
    }),
}));
</file>

<file path="apps/dashboard/src/store/vault.ts">
import type { RowSelectionState, Updater } from "@tanstack/react-table";
import { create } from "zustand";

interface DocumentsState {
  setRowSelection: (updater: Updater<RowSelectionState>) => void;
  rowSelection: Record<string, boolean>;
}

export const useDocumentsStore = create<DocumentsState>()((set) => ({
  rowSelection: {},
  setRowSelection: (updater: Updater<RowSelectionState>) =>
    set((state) => {
      return {
        rowSelection:
          typeof updater === "function" ? updater(state.rowSelection) : updater,
      };
    }),
}));
</file>

<file path="apps/dashboard/src/styles/globals.css">
html,
body {
  height: 100%;
}

*:focus {
  outline: none;
}

.skeleton-box {
  background-color: hsl(var(--border));
  color: hsl(var(--border)) !important;
  user-select: none !important;
  cursor: default !important;
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  border-color: transparent !important;
}

.skeleton-circle {
  background-color: hsl(var(--border));
  border-radius: 1000px !important;
  color: hsl(var(--border)) !important;
  user-select: none !important;
  cursor: default !important;
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  border-color: transparent !important;
}

.skeleton-circle > *,
.skeleton-box > *,
.skeleton-line > * {
  opacity: 0 !important;
}

.pin-field-container {
  display: grid;
  grid-auto-columns: max-content;
  grid-auto-flow: column;
  justify-content: center;
  margin: 4rem 0;
}

.pin-field {
  border: 1px solid hsl(var(--border));
  background-color: hsl(var(--accent));
  border-right: none;
  font-size: 2rem;
  height: 4rem;
  outline: none;
  text-align: center;
  transition-duration: 250ms;
  transition-property: color, border, box-shadow, transform;
  width: 4rem;
}

.pin-field:last-of-type {
  border-radius: 0 0.5rem 0.5rem 0;
  border-right: 1px solid hsl(var(--border));
}

.pin-field:focus {
  box-shadow: "0 0 0.25rem rgba(white, 0.5)";
  opacity: 0.9;
  outline: none;
}

.invalid {
  animation: shake 0.2s ease-in-out 0s 2;
}

.pin-field:first-of-type {
  border-radius: 0.5rem 0 0 0.5rem;
}

.pin-field[disabled] {
  cursor: not-allowed;
  opacity: 0.5;
}

@keyframes shake {
  0% {
    transform: translateX(0rem);
  }
  25% {
    transform: translateX(0.5rem);
  }
  75% {
    transform: translateX(-0.5rem);
  }
  100% {
    transform: translateX(0rem);
  }
}

/* Desktop App */
html.desktop {
  background: transparent !important;
  user-select: none;
  -webkit-user-select: none;
  overscroll-behavior: none !important;
  border-radius: 10px;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
  position: fixed;
  top: 0;
  left: 0;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}

html.desktop body {
  position: relative;
  background: hsl(var(--background)) !important;
  overscroll-behavior: none !important;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  height: 100vh;
  width: 100%;
  overflow: auto;
}

html.desktop body::before {
  content: "";
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: 0.5px solid rgba(0, 0, 0, 0.15);
  border-radius: 10px;
  z-index: 100;
  pointer-events: none;
}

html.desktop.dark body::before {
  border: 0.5px solid rgba(255, 255, 255, 0.15);
}

html.desktop .wrapper::-webkit-scrollbar,
html.desktop::-webkit-scrollbar,
html.desktop body::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
}

.desktop div,
.desktop a,
.desktop button {
  cursor: default !important;
}

.color-picker .react-colorful {
  height: 240px;
}
.color-picker .react-colorful__saturation {
  border-radius: 4px 4px 0 0;
}
.color-picker .react-colorful__hue {
  height: 40px;
  border-radius: 0 0 4px 4px;
}

.color-picker .react-colorful__hue-pointer {
  width: 8px;
  height: inherit;
}

.color-picker .react-colorful__pointer {
  width: 15px;
  height: 15px;
}

.color-picker .react-colorful__hue {
  height: 20px;
}

.remove-arrow::-webkit-inner-spin-button,
.remove-arrow::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.remove-arrow {
  appearance: textfield;
}

input[type="time"]::-webkit-clear-button {
  display: none;
}

input[type="time"]::-webkit-calendar-picker-indicator {
  display: none;
}

.invoice-editor,
.invoice-editor div[aria-expanded="false"],
.invoice-editor .ProseMirror,
.invoice-editor .is-empty {
  height: 100%;
}

.ProseMirror-focused p.is-editor-empty:first-child::before {
  content: attr(data-placeholder);
  float: left;
  color: #434343;
  pointer-events: none;
  height: 0;
}

.tiptap {
  font-size: 11px !important;
  line-height: 18px !important;
}

.dark .dotted-bg {
  background-image: radial-gradient(
    circle at 1px 1px,
    #232323 0.5px,
    transparent 0
  );
  background-size: 6px 6px;
}

.light .dotted-bg {
  background-size: 6px 6px;
  background-image: radial-gradient(
    circle at 1px 1px,
    #e0e0e0 0.5px,
    transparent 0
  );
}

.global-search-list {
  height: min(450px, var(--search-list-height));
  overscroll-behavior: contain;
  transition: 100ms ease;
  transition-property: height;
}

.desktop-search .global-search-list {
  height: 450px;
}

.desktop-search .search-container {
  border: none;
  border-bottom: 0.5px solid hsl(var(--border));
}

.desktop-search .search-footer {
  border-left: 0px;
  border-right: 0px;
  border-bottom: 0px;
  border-top: 1px;
}
</file>

<file path="apps/dashboard/src/trpc/client.tsx">
"use client";

import type { AppRouter } from "@midday/api/trpc/routers/_app";
import { createClient } from "@midday/supabase/client";
import type { QueryClient } from "@tanstack/react-query";
import { QueryClientProvider, isServer } from "@tanstack/react-query";
import { createTRPCClient, httpBatchLink, loggerLink } from "@trpc/client";
import { createTRPCContext } from "@trpc/tanstack-react-query";
import { useState } from "react";
import superjson from "superjson";
import { makeQueryClient } from "./query-client";

export const { TRPCProvider, useTRPC } = createTRPCContext<AppRouter>();

let browserQueryClient: QueryClient;

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient();
  }

  // Browser: make a new query client if we don't already have one
  // This is very important, so we don't re-make a new client if React
  // suspends during the initial render. This may not be needed if we
  // have a suspense boundary BELOW the creation of the query client
  if (!browserQueryClient) browserQueryClient = makeQueryClient();

  return browserQueryClient;
}

export function TRPCReactProvider(
  props: Readonly<{
    children: React.ReactNode;
  }>,
) {
  const queryClient = getQueryClient();
  const [trpcClient] = useState(() =>
    createTRPCClient<AppRouter>({
      links: [
        httpBatchLink({
          url: `${process.env.NEXT_PUBLIC_API_URL}/trpc`,
          transformer: superjson,
          async headers() {
            const supabase = createClient();

            const {
              data: { session },
            } = await supabase.auth.getSession();

            return {
              Authorization: `Bearer ${session?.access_token}`,
            };
          },
        }),
        loggerLink({
          enabled: (opts) =>
            process.env.NODE_ENV === "development" ||
            (opts.direction === "down" && opts.result instanceof Error),
        }),
      ],
    }),
  );

  return (
    <QueryClientProvider client={queryClient}>
      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>
        {props.children}
      </TRPCProvider>
    </QueryClientProvider>
  );
}
</file>

<file path="apps/dashboard/src/trpc/query-client.ts">
import {
  QueryClient,
  defaultShouldDehydrateQuery,
} from "@tanstack/react-query";
import superjson from "superjson";

export function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
      },
      dehydrate: {
        serializeData: superjson.serialize,
        shouldDehydrateQuery: (query) =>
          defaultShouldDehydrateQuery(query) ||
          query.state.status === "pending",
      },
      hydrate: {
        deserializeData: superjson.deserialize,
      },
    },
  });
}
</file>

<file path="apps/dashboard/src/trpc/server.tsx">
import "server-only";

import type { AppRouter } from "@midday/api/trpc/routers/_app";
import { getCountryCode, getLocale, getTimezone } from "@midday/location";
import { createClient } from "@midday/supabase/server";
import { HydrationBoundary } from "@tanstack/react-query";
import { dehydrate } from "@tanstack/react-query";
import { createTRPCClient, httpBatchLink, loggerLink } from "@trpc/client";
import {
  type TRPCQueryOptions,
  createTRPCOptionsProxy,
} from "@trpc/tanstack-react-query";
import { cache } from "react";
import superjson from "superjson";
import { makeQueryClient } from "./query-client";

// IMPORTANT: Create a stable getter for the query client that
//            will return the same client during the same request.
export const getQueryClient = cache(makeQueryClient);

export const trpc = createTRPCOptionsProxy<AppRouter>({
  queryClient: getQueryClient,
  client: createTRPCClient({
    links: [
      httpBatchLink({
        url: `${process.env.NEXT_PUBLIC_API_URL}/trpc`,
        transformer: superjson,
        async headers() {
          const supabase = await createClient();

          const {
            data: { session },
          } = await supabase.auth.getSession();

          return {
            Authorization: `Bearer ${session?.access_token}`,
            "x-user-timezone": await getTimezone(),
            "x-user-locale": await getLocale(),
            "x-user-country": await getCountryCode(),
          };
        },
      }),
      loggerLink({
        enabled: (opts) =>
          process.env.NODE_ENV === "development" ||
          (opts.direction === "down" && opts.result instanceof Error),
      }),
    ],
  }),
});

export function HydrateClient(props: { children: React.ReactNode }) {
  const queryClient = getQueryClient();

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      {props.children}
    </HydrationBoundary>
  );
}

export function prefetch<T extends ReturnType<TRPCQueryOptions<any>>>(
  queryOptions: T,
) {
  const queryClient = getQueryClient();

  if (queryOptions.queryKey[1]?.type === "infinite") {
    void queryClient.prefetchInfiniteQuery(queryOptions as any);
  } else {
    void queryClient.prefetchQuery(queryOptions);
  }
}

export function batchPrefetch<T extends ReturnType<TRPCQueryOptions<any>>>(
  queryOptionsArray: T[],
) {
  const queryClient = getQueryClient();

  for (const queryOptions of queryOptionsArray) {
    if (queryOptions.queryKey[1]?.type === "infinite") {
      void queryClient.prefetchInfiniteQuery(queryOptions as any);
    } else {
      void queryClient.prefetchQuery(queryOptions);
    }
  }
}
</file>

<file path="apps/dashboard/src/types/react-table.d.ts">
import type { RouterOutputs } from "@/trpc/client";

declare module "@tanstack/table-core" {
  interface TableMeta<TData extends RowData> {
    // Transaction table meta
    dateFormat?: string | null;
    timeFormat?: number | null;
    hasSorting?: boolean;
    setOpen?: (id: string) => void;
    copyUrl?: (id: string) => void;
    updateTransaction?: (data: { id: string; status: string }) => void;
    onDeleteTransaction?: (id: string) => void;

    // Vault table meta
    handleDelete?: (id: string) => void;
    handleShare?: (pathTokens: string[]) => void;

    // Categories table meta
    deleteCategory?: (id: string) => void;
    expandedCategories?: Set<string>;
    setExpandedCategories?: React.Dispatch<React.SetStateAction<Set<string>>>;

    // Customers table meta
    deleteCustomer?: (id: string) => void;

    // Members table meta
    currentUser?: RouterOutputs["team"]["members"][number];
    totalOwners?: number;
  }

  interface ColumnMeta<TData extends RowData, TValue> {
    className?: string;
  }
}
</file>

<file path="apps/dashboard/src/utils/canvas-factory.ts">
import {
  type Canvas,
  type CanvasRenderingContext2D,
  createCanvas,
} from "canvas";

/**
 * Factory for creating canvas elements in a Node.js environment.
 * This is required by pdfjs-dist when running outside a browser.
 */
export class NodeCanvasFactory {
  /**
   * Creates a canvas element and its 2D rendering context.
   * @param width - The width of the canvas.
   * @param height - The height of the canvas.
   * @returns An object containing the canvas and its context.
   */
  create(
    width: number,
    height: number,
  ): { canvas: Canvas; context: CanvasRenderingContext2D } {
    const canvas = createCanvas(width, height);
    const context = canvas.getContext("2d");
    return {
      canvas,
      context,
    };
  }

  /**
   * Resets the canvas and context for reuse.
   * @param canvasAndContext - The canvas and context object to reset.
   * @param width - The new width.
   * @param height - The new height.
   */
  reset(
    canvasAndContext: { canvas: Canvas; context: CanvasRenderingContext2D },
    width: number,
    height: number,
  ): void {
    if (canvasAndContext.canvas) {
      canvasAndContext.canvas.width = width;
      canvasAndContext.canvas.height = height;
    } else {
      // Handle case where canvas might not exist (though create should always provide one)
    }
    // Additional reset logic like clearing transforms might be needed depending on usage
    // canvasAndContext.context.setTransform(1, 0, 0, 1, 0, 0);
    // canvasAndContext.context.clearRect(0, 0, width, height);
  }

  /**
   * Destroys the canvas resources.
   * pdf.js specific interface method.
   * @param canvasAndContext - The canvas and context object to destroy.
   */
  destroy(canvasAndContext: {
    canvas: Canvas;
    context: CanvasRenderingContext2D;
  }): void {
    if (canvasAndContext.canvas) {
      // Zeroing the width and height is a way to release memory resources
      // associated with the canvas in the C++ backend of node-canvas.
      canvasAndContext.canvas.width = 0;
      canvasAndContext.canvas.height = 0;
      // canvasAndContext.canvas = null; // Not needed as per node-canvas recommendations
      // canvasAndContext.context = null;
    }
  }
}
</file>

<file path="apps/dashboard/src/utils/categories.ts">
export const colors = [
  "#FF6900", // Orange
  "#FCB900", // Yellow
  "#00D084", // Emerald
  "#8ED1FC", // Sky Blue
  "#0693E3", // Blue
  "#ABB8C3", // Gray
  "#EB144C", // Red
  "#F78DA7", // Pink
  "#9900EF", // Purple
  "#0079BF", // Dark Blue
  "#B6BBBF", // Light Gray
  "#FF5A5F", // Coral
  "#F7C59F", // Peach
  "#8492A6", // Slate
  "#4D5055", // Charcoal
  "#AF5A50", // Terracotta
  "#F9D6E7", // Pale Pink
  "#B5EAEA", // Pale Cyan
  "#B388EB", // Lavender
  "#B04632", // Rust
  "#FF78CB", // Pink
  "#4E5A65", // Gray
  "#01FF70", // Lime
  "#85144b", // Pink
  "#F012BE", // Purple
  "#7FDBFF", // Sky Blue
  "#3D9970", // Olive
  "#AAAAAA", // Silver
  "#111111", // Black
  "#0074D9", // Blue
  "#39CCCC", // Teal
  "#001f3f", // Navy
  "#FF9F1C", // Orange
  "#5E6A71", // Ash
  "#75D701", // Neon Green
  "#B6C8A9", // Lichen
  "#00A9FE", // Electric Blue
  "#EAE8E1", // Bone
  "#CD346C", // Raspberry
  "#FF6FA4", // Pink Sherbet
  "#D667FB", // Purple Mountain Majesty
  "#0080FF", // Azure
  "#656D78", // Dim Gray
  "#F8842C", // Tangerine
  "#FF8CFF", // Carnation Pink
  "#647F6A", // Feldgrau
  "#5E574E", // Field Drab
  "#EF5466", // KU Crimson
  "#B0E0E6", // Powder Blue
  "#EB5E7C", // Rose Pink
  "#8A2BE2", // Blue Violet
  "#6B7C85", // Slate Gray
  "#8C92AC", // Lavender Blue
  "#6C587A", // Eminence
  "#52A1FF", // Azureish White
  "#32CD32", // Lime Green
  "#E04F9F", // Orchid Pink
  "#915C83", // Lilac Bush
  "#4C6B88", // Air Force Blue
  "#587376", // Cadet Blue
  "#C46210", // Buff
  "#65B0D0", // Columbia Blue
  "#2F4F4F", // Dark Slate Gray
  "#528B8B", // Dark Cyan
  "#8B4513", // Saddle Brown
  "#4682B4", // Steel Blue
  "#CD853F", // Peru
  "#FFA07A", // Light Salmon
  "#CD5C5C", // Indian Red
  "#483D8B", // Dark Slate Blue
  "#696969", // Dim Gray
];

export function customHash(value: string) {
  let hash = 0;

  for (let i = 0; i < value.length; i++) {
    hash = (hash << 5) + value.charCodeAt(i);
    hash = hash & hash;
  }

  return Math.abs(hash);
}

export function getColor(value: string, arrayLength: number) {
  const hashValue = customHash(value);
  const index = hashValue % arrayLength;
  return index;
}

export function getColorFromName(value: string) {
  const index = getColor(value, colors.length);

  return colors[index];
}

export function getRandomColor() {
  const randomIndex = Math.floor(Math.random() * colors.length);
  return colors[randomIndex];
}
</file>

<file path="apps/dashboard/src/utils/check-team-eligibility.ts">
import { subDays } from "date-fns";

export interface TeamEligibilityData {
  plan: "trial" | "starter" | "pro";
  created_at: string;
}

/**
 * Checks if a team is eligible for sync operations based on:
 * 1. Teams with starter or pro plan (always eligible)
 * 2. Trial teams created during beta period (within 14 days of creation)
 */
export function isTeamEligibleForSync(team: TeamEligibilityData): boolean {
  // Pro and starter teams are always eligible
  if (team.plan === "pro" || team.plan === "starter") {
    return true;
  }

  // Trial teams are only eligible if created within the beta period (14 days)
  if (team.plan === "trial") {
    const teamCreatedAt = new Date(team.created_at);
    const fourteenDaysAgo = subDays(new Date(), 14);

    // Team is eligible if created within the last 14 days (inclusive)
    return teamCreatedAt >= fourteenDaysAgo;
  }

  // All other cases are not eligible
  return false;
}
</file>

<file path="apps/dashboard/src/utils/columns.ts">
import { cookies } from "next/headers";
import { Cookies } from "./constants";

export async function getInitialTransactionsColumnVisibility() {
  const cookieStore = await cookies();

  const columnsToHide = [
    "assigned",
    "tags",
    "method",
    "counterparty",
    "taxAmount",
  ];

  const savedColumns = cookieStore.get(Cookies.TransactionsColumns)?.value;

  return savedColumns
    ? JSON.parse(savedColumns)
    : columnsToHide.reduce(
        (acc, col) => {
          acc[col] = false;
          return acc;
        },
        {} as Record<string, boolean>,
      );
}

export async function getInitialInvoicesColumnVisibility() {
  const cookieStore = await cookies();

  const columnsToHide = [
    "sentAt",
    "exclVat",
    "exclTax",
    "vatAmount",
    "taxAmount",
    "vatRate",
    "taxRate",
    "internalNote",
  ];

  const savedColumns = cookieStore.get(Cookies.InvoicesColumns)?.value;
  return savedColumns
    ? JSON.parse(savedColumns)
    : columnsToHide.reduce(
        (acc, col) => {
          acc[col] = false;
          return acc;
        },
        {} as Record<string, boolean>,
      );
}
</file>

<file path="apps/dashboard/src/utils/connection-status.ts">
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { differenceInDays } from "date-fns";

const DISPLAY_DAYS = 30;
const WARNING_DAYS = 14;
const ERROR_DAYS = 7;

type Connection = NonNullable<RouterOutputs["bankConnections"]["get"]>[number];

export function getConnectionsStatus(connections: Connection[]) {
  const warning = connections?.some(
    (connection) =>
      connection.expiresAt &&
      differenceInDays(new Date(connection.expiresAt), new Date()) <=
        WARNING_DAYS,
  );

  const error = connections?.some(
    (connection) =>
      connection.expiresAt &&
      differenceInDays(new Date(connection.expiresAt), new Date()) <=
        ERROR_DAYS,
  );

  const expired = connections?.some(
    (connection) =>
      connection.expiresAt &&
      differenceInDays(new Date(connection.expiresAt), new Date()) <= 0,
  );

  const show = connections?.some(
    (connection) =>
      connection.expiresAt &&
      differenceInDays(new Date(connection.expiresAt), new Date()) <=
        DISPLAY_DAYS,
  );

  return {
    warning,
    expired,
    error,
    show,
  };
}

export function connectionStatus(connection: Connection) {
  const warning =
    connection.expiresAt &&
    differenceInDays(new Date(connection.expiresAt), new Date()) <=
      WARNING_DAYS;

  const error =
    connection.expiresAt &&
    differenceInDays(new Date(connection.expiresAt), new Date()) <= ERROR_DAYS;

  const expired =
    connection.expiresAt &&
    differenceInDays(new Date(connection.expiresAt), new Date()) <= 0;

  const show =
    connection.expiresAt &&
    differenceInDays(new Date(connection.expiresAt), new Date()) <=
      DISPLAY_DAYS;

  return {
    warning,
    error,
    expired,
    show,
  };
}
</file>

<file path="apps/dashboard/src/utils/constants.ts">
export const Cookies = {
  PreferredSignInProvider: "preferred-signin-provider",
  TransactionsColumns: "transactions-columns",
  InvoicesColumns: "invoices-columns",
  MfaSetupVisited: "mfa-setup-visited",
  InboxFilter: "inbox-filter-v2",
  TrackingConsent: "tracking-consent",
  InboxOrder: "inbox-order",
  HideConnectFlow: "hide-connect-flow",
  LastProject: "last-project",
  WeeklyCalendar: "weekly-calendar",
};

export const LocalStorageKeys = {
  MatchLearningToastSeen: "match-learning-toast-seen",
};
</file>

<file path="apps/dashboard/src/utils/desktop.ts">
import { headers } from "next/headers";

export async function isDesktopApp() {
  const headersList = await headers();
  const userAgent = headersList.get("user-agent");
  return userAgent?.includes("Midday Desktop App");
}
</file>

<file path="apps/dashboard/src/utils/environment.ts">
export function getUrl() {
  if (process.env.NEXT_PUBLIC_URL) {
    return process.env.NEXT_PUBLIC_URL;
  }

  if (process.env.VERCEL_TARGET_ENV === "preview") {
    return `https://${process.env.VERCEL_URL}`;
  }

  return "http://localhost:3001";
}
</file>

<file path="apps/dashboard/src/utils/format.ts">
import type { TZDate } from "@date-fns/tz";
import {
  differenceInDays,
  differenceInMonths,
  format,
  isSameYear,
  startOfDay,
} from "date-fns";

export function formatSize(bytes: number): string {
  const units = ["byte", "kilobyte", "megabyte", "gigabyte", "terabyte"];

  const unitIndex = Math.max(
    0,
    Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1),
  );

  return Intl.NumberFormat("en-US", {
    style: "unit",
    unit: units[unitIndex],
  }).format(+Math.round(bytes / 1024 ** unitIndex));
}

type FormatAmountParams = {
  currency: string;
  amount: number;
  locale?: string | null;
  maximumFractionDigits?: number;
  minimumFractionDigits?: number;
};

export function formatAmount({
  currency,
  amount,
  locale = "en-US",
  minimumFractionDigits,
  maximumFractionDigits,
}: FormatAmountParams) {
  if (!currency) {
    return;
  }

  // Fix: locale can be null, but Intl.NumberFormat expects string | string[] | undefined
  // So, if locale is null, pass undefined instead
  const safeLocale = locale ?? undefined;

  return Intl.NumberFormat(safeLocale, {
    style: "currency",
    currency,
    minimumFractionDigits,
    maximumFractionDigits,
  }).format(amount);
}

export function secondsToHoursAndMinutes(seconds: number) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);

  if (hours && minutes) {
    return `${hours}h ${minutes}m`;
  }

  if (hours) {
    return `${hours}h`;
  }

  if (minutes) {
    return `${minutes}m`;
  }

  return "0m";
}

type BurnRateData = {
  value: number;
  date: string;
};

export function calculateAvgBurnRate(data: BurnRateData[] | null) {
  if (!data) {
    return 0;
  }

  return data?.reduce((acc, curr) => acc + curr.value, 0) / data?.length;
}

export function formatDate(
  date: string,
  dateFormat?: string | null,
  checkYear = true,
) {
  if (checkYear && isSameYear(new Date(), new Date(date))) {
    return format(new Date(date), "MMM d");
  }

  return format(new Date(date), dateFormat ?? "P");
}

export function getInitials(value: string) {
  const formatted = value.toUpperCase().replace(/[\s.-]/g, "");

  if (formatted.split(" ").length > 1) {
    return `${formatted.charAt(0)}${formatted.charAt(1)}`;
  }

  if (value.length > 1) {
    return formatted.charAt(0) + formatted.charAt(1);
  }

  return formatted.charAt(0);
}

export function formatAccountName({
  name = "",
  currency,
}: { name?: string; currency?: string | null }) {
  if (currency) {
    return `${name} (${currency})`;
  }

  return name;
}

export function formatDateRange(dates: TZDate[]): string {
  if (!dates.length) return "";

  const formatFullDate = (date: TZDate) => format(date, "MMM d");
  const formatDay = (date: TZDate) => format(date, "d");

  const startDate = dates[0];
  const endDate = dates[1];

  if (!startDate) return "";

  if (
    dates.length === 1 ||
    !endDate ||
    startDate.getTime() === endDate.getTime()
  ) {
    return formatFullDate(startDate);
  }

  if (startDate.getMonth() === endDate.getMonth()) {
    // Same month
    return `${format(startDate, "MMM")} ${formatDay(startDate)} - ${formatDay(endDate)}`;
  }
  // Different months
  return `${formatFullDate(startDate)} - ${formatFullDate(endDate)}`;
}

export function getDueDateStatus(dueDate: string): string {
  const now = new Date();
  const due = new Date(dueDate);

  // Set both dates to the start of their respective days
  const nowDay = startOfDay(now);
  const dueDay = startOfDay(due);

  const diffDays = differenceInDays(dueDay, nowDay);
  const diffMonths = differenceInMonths(dueDay, nowDay);

  if (diffDays === 0) return "Today";
  if (diffDays === 1) return "Tomorrow";
  if (diffDays === -1) return "Yesterday";

  if (diffDays > 0) {
    if (diffMonths < 1) return `in ${diffDays} days`;
    return `in ${diffMonths} month${diffMonths === 1 ? "" : "s"}`;
  }

  if (diffMonths < 1)
    return `${Math.abs(diffDays)} day${Math.abs(diffDays) === 1 ? "" : "s"} ago`;
  return `${diffMonths} month${diffMonths === 1 ? "" : "s"} ago`;
}

export function formatRelativeTime(date: Date): string {
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

  if (diffInSeconds < 60) {
    return "just now";
  }

  const intervals = [
    { label: "y", seconds: 31536000 },
    { label: "mo", seconds: 2592000 },
    { label: "d", seconds: 86400 },
    { label: "h", seconds: 3600 },
    { label: "m", seconds: 60 },
  ] as const;

  for (const interval of intervals) {
    const count = Math.floor(diffInSeconds / interval.seconds);
    if (count > 0) {
      return `${count}${interval.label} ago`;
    }
  }

  return "just now";
}
</file>

<file path="apps/dashboard/src/utils/logger.ts">
export const logger = (message: string, params?: unknown) => {
  console.log(message, params);
};
</file>

<file path="apps/dashboard/src/utils/logos.ts">
export function getWebsiteLogo(website?: string | null) {
  if (!website) return "";

  return `https://img.logo.dev/${website}?token=pk_X-1ZO13GSgeOoUrIuJ6GMQ&size=180&retina=true`;
}
</file>

<file path="apps/dashboard/src/utils/notification-definitions.ts">
import type { useI18n } from "@/locales/client";

// Frontend notification definitions with i18n support
export interface NotificationDisplayInfo {
  type: string;
  name: string;
  description: string;
}

// Helper function to get display info for a notification type using i18n
export function getNotificationDisplayInfo(
  type: string,
  t: ReturnType<typeof useI18n>,
): NotificationDisplayInfo | undefined {
  // Check if the notification type exists in translations
  try {
    // @ts-expect-error - next-international typing might be strict
    const name = t(`notifications.${type}.name`);
    // @ts-expect-error - next-international typing might be strict
    const description = t(`notifications.${type}.description`);

    // If the translation keys don't exist, t() will return the key itself
    // Check if we got actual translations or just the keys back
    if (
      name.includes("notifications.") ||
      description.includes("notifications.")
    ) {
      return undefined;
    }

    return {
      type,
      name,
      description,
    };
  } catch {
    // If translation doesn't exist, return undefined
    return undefined;
  }
}

// Helper function to get display info with fallback
export function getNotificationDisplayInfoWithFallback(
  type: string,
  t: ReturnType<typeof useI18n>,
): NotificationDisplayInfo {
  const displayInfo = getNotificationDisplayInfo(type, t);

  if (displayInfo) {
    return displayInfo;
  }

  // Fallback for unknown notification types
  return {
    type,
    name: type.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase()),
    description: `Notifications for ${type.replace(/_/g, " ")}`,
  };
}

// Helper function to get category display title from i18n
export function getCategoryDisplayTitle(
  category: string,
  t: ReturnType<typeof useI18n>,
): string {
  try {
    // @ts-expect-error - next-international typing might be strict
    const categoryTitle = t(`notifications.categories.${category}`);

    // If the translation key doesn't exist, t() will return the key itself
    // Check if we got actual translation or just the key back
    if (categoryTitle.includes("notifications.categories.")) {
      // Fallback: capitalize first letter and replace underscores with spaces
      return (
        category.charAt(0).toUpperCase() + category.slice(1).replace(/_/g, " ")
      );
    }

    return categoryTitle;
  } catch {
    // Fallback for unknown categories
    return (
      category.charAt(0).toUpperCase() + category.slice(1).replace(/_/g, " ")
    );
  }
}
</file>

<file path="apps/dashboard/src/utils/oauth-utils.ts">
import type { OAuthErrorType } from "@/components/oauth/oauth-error-message";

// Helper function to parse and categorize errors
export function categorizeOAuthError(error: unknown): {
  errorType: OAuthErrorType;
  customMessage?: string;
  details?: string;
} {
  if (!(error instanceof Error)) {
    return {
      errorType: "server_error",
      customMessage: "An unknown error occurred",
    };
  }

  const errorMessage = error.message.toLowerCase();

  // Check for specific error patterns
  if (
    errorMessage.includes("invalid client_id") ||
    errorMessage.includes("client_id")
  ) {
    return { errorType: "invalid_client_id", details: error.message };
  }

  if (
    errorMessage.includes("invalid redirect_uri") ||
    errorMessage.includes("redirect_uri")
  ) {
    return { errorType: "invalid_redirect_uri", details: error.message };
  }

  if (
    errorMessage.includes("invalid scopes") ||
    errorMessage.includes("scopes")
  ) {
    return {
      errorType: "invalid_scopes",
      customMessage: error.message,
      details: error.message,
    };
  }

  if (errorMessage.includes("expired") || errorMessage.includes("expire")) {
    if (errorMessage.includes("authorization code")) {
      return {
        errorType: "authorization_code_expired",
        details: error.message,
      };
    }
    if (errorMessage.includes("refresh token")) {
      return { errorType: "refresh_token_expired", details: error.message };
    }
    return { errorType: "expired", details: error.message };
  }

  if (errorMessage.includes("already used") || errorMessage.includes("used")) {
    return { errorType: "authorization_code_used", details: error.message };
  }

  if (
    errorMessage.includes("not authenticated") ||
    errorMessage.includes("authentication")
  ) {
    return { errorType: "user_not_authenticated", details: error.message };
  }

  if (
    errorMessage.includes("inactive") ||
    errorMessage.includes("not active")
  ) {
    return { errorType: "application_inactive", details: error.message };
  }

  if (
    errorMessage.includes("client credentials") ||
    errorMessage.includes("client_secret")
  ) {
    return {
      errorType: "invalid_client_credentials",
      details: error.message,
    };
  }

  if (errorMessage.includes("code verifier") || errorMessage.includes("pkce")) {
    return { errorType: "invalid_code_verifier", details: error.message };
  }

  if (errorMessage.includes("code challenge method")) {
    return {
      errorType: "invalid_code_challenge_method",
      details: error.message,
    };
  }

  if (
    errorMessage.includes("refresh token revoked") ||
    errorMessage.includes("revoked")
  ) {
    return { errorType: "refresh_token_revoked", details: error.message };
  }

  if (
    errorMessage.includes("invalid refresh token") ||
    errorMessage.includes("refresh token")
  ) {
    return { errorType: "invalid_refresh_token", details: error.message };
  }

  if (
    errorMessage.includes("grant type") ||
    errorMessage.includes("unsupported")
  ) {
    return { errorType: "grant_type_not_supported", details: error.message };
  }

  if (
    errorMessage.includes("failed to create") ||
    errorMessage.includes("create authorization code")
  ) {
    return {
      errorType: "failed_to_create_authorization_code",
      details: error.message,
    };
  }

  if (
    errorMessage.includes("invalid authorization code") ||
    errorMessage.includes("authorization code")
  ) {
    return {
      errorType: "invalid_authorization_code",
      details: error.message,
    };
  }

  if (
    errorMessage.includes("invalid url") ||
    errorMessage.includes("malformed url")
  ) {
    return { errorType: "invalid_url_format", details: error.message };
  }

  if (
    errorMessage.includes("empty scopes") ||
    errorMessage.includes("no scopes")
  ) {
    return { errorType: "empty_scopes", details: error.message };
  }

  if (
    errorMessage.includes("unauthorized") ||
    errorMessage.includes("permission") ||
    errorMessage.includes("team")
  ) {
    return { errorType: "unauthorized_team_access", details: error.message };
  }

  // Default to server error for unrecognized errors
  return {
    errorType: "server_error",
    customMessage: error.message,
    details: error.message,
  };
}

// Helper function to validate OAuth parameters
export function validateOAuthParams(params: {
  response_type?: string;
  client_id?: string;
  redirect_uri?: string;
  scope?: string;
}): { isValid: boolean; errorType?: OAuthErrorType } {
  const { response_type, client_id, redirect_uri, scope } = params;

  // Validate required parameters
  if (!client_id || !redirect_uri || !scope) {
    return { isValid: false, errorType: "missing_params" };
  }

  // Validate response_type
  if (response_type !== "code") {
    return { isValid: false, errorType: "invalid_response_type" };
  }

  // Validate URL format for redirect_uri
  try {
    new URL(redirect_uri);
  } catch {
    return { isValid: false, errorType: "invalid_url_format" };
  }

  // Validate scopes are not empty
  if (!scope.trim()) {
    return { isValid: false, errorType: "empty_scopes" };
  }

  return { isValid: true };
}
</file>

<file path="apps/dashboard/src/utils/pdf-to-img.ts">
import path from "node:path";
import { getDocument } from "pdfjs-dist/legacy/build/pdf.mjs";
import { NodeCanvasFactory } from "./canvas-factory";
import "pdfjs-dist/build/pdf.worker.mjs";

const pdfjsPath = path.join(process.cwd(), "node_modules/pdfjs-dist");

export async function getPdfImage(data: ArrayBuffer) {
  const canvasFactory = new NodeCanvasFactory();
  const loadingTask = getDocument({
    data,
    cMapPacked: true,
    isEvalSupported: false,
    cMapUrl: path.join(pdfjsPath, `cmaps${path.sep}`),
    standardFontDataUrl: path.join(pdfjsPath, `standard_fonts${path.sep}`),
  });

  try {
    const pdfDocument = await loadingTask.promise;

    // Use page 1 for the image
    const page = await pdfDocument.getPage(1);

    const viewport = page.getViewport({ scale: 2.0 });

    const canvasAndContext = canvasFactory.create(
      viewport.width,
      viewport.height,
    );

    const renderContext = {
      canvasContext: canvasAndContext.context,
      viewport,
      canvasFactory,
    };

    // @ts-expect-error
    const renderTask = page.render(renderContext);
    await renderTask.promise;

    // Return image as PNG buffer
    const canvas = canvasAndContext.canvas;
    return canvas.toBuffer("image/png");
  } catch (error) {
    return null;
  }
}
</file>

<file path="apps/dashboard/src/utils/plans.ts">
const POLAR_ENVIRONMENT = process.env.POLAR_ENVIRONMENT;

export const PLANS = {
  production: {
    starter: {
      id: "ac17601d-29a9-4530-ab9d-9f6ea39f7e32",
      name: "Starter",
      key: "starter",
    },
    pro: {
      id: "0a0a36b1-38d3-4082-85ca-f46cec9d8b1a",
      name: "Pro",
      key: "pro",
    },
  },
  sandbox: {
    starter: {
      id: "265b6845-4fca-4813-86b7-70fb606626dd",
      name: "Starter",
      key: "starter",
    },
    pro: {
      id: "dc9e75d2-c1ef-4265-9265-f599e54eb172",
      name: "Pro",
      key: "pro",
    },
  },
};

export const DISCOUNTS = {
  production: {
    public_beta: {
      id: "ced3af53-fb27-41f5-abdd-070f382995b8",
      name: "Public Beta",
    },
  },
  sandbox: {
    public_beta: {
      id: "fb5e65fc-39b2-4212-a51a-fa6d1bd813e6",
      name: "Public Beta",
    },
  },
};

export const getDiscount = (planType?: string | null) => {
  // Starter plan doesn't have a discount
  if (!planType || planType === "starter") {
    return null;
  }

  const discounts = DISCOUNTS[POLAR_ENVIRONMENT as keyof typeof DISCOUNTS];

  // Change this to null after the public beta
  return discounts.public_beta;
};

export const getPlans = () => {
  return PLANS[POLAR_ENVIRONMENT as keyof typeof PLANS];
};

export function getPlanByProductId(productId: string) {
  const plan = Object.values(getPlans()).find((plan) => plan.id === productId);

  if (!plan) {
    throw new Error("Plan not found");
  }

  return plan.key;
}

export function getPlanLimits(plan: string) {
  switch (plan) {
    case "starter":
      return {
        users: 1,
        bankConnections: 1,
        storage: 10 * 1024 * 1024 * 1024, // 10GB in bytes
        inbox: 50,
        invoices: 10,
      };
    case "trial":
    case "pro":
      return {
        users: 10,
        bankConnections: 10,
        storage: 100, // 100GB in bytes
        inbox: 500,
        invoices: 30,
      };
    default:
      return {
        users: 1,
        bankConnections: 1,
        storage: 10 * 1024 * 1024 * 1024, // 10GB in bytes
        inbox: 50,
        invoices: 10,
      };
  }
}
</file>

<file path="apps/dashboard/src/utils/polar.ts">
import { Polar } from "@polar-sh/sdk";

export const api = new Polar({
  accessToken: process.env.POLAR_ACCESS_TOKEN!,
  server: process.env.POLAR_ENVIRONMENT as "production" | "sandbox",
});
</file>

<file path="apps/dashboard/src/utils/process.ts">
// @ts-nocheck

export async function processPromisesBatch(items: any, limit: number, fn) {
  const batches = [];
  let result: any = [];

  // Split the items into batches
  for (let i = 0; i < items?.length; i += limit) {
    batches.push(items.slice(i, i + limit));
  }

  // Process batches serially
  for (const batch of batches) {
    const processedBatch = await fn(batch);
    result = result.concat(processedBatch);
  }

  return result;
}
</file>

<file path="apps/dashboard/src/utils/resend.ts">
import { Resend } from "resend";

export const resend = new Resend(process.env.RESEND_API_KEY!);
</file>

<file path="apps/dashboard/src/utils/scopes.ts">
export const RESOURCES = [
  {
    key: "bank-accounts",
    name: "Bank Accounts",
    description: "Access to bank account data",
    scopes: [
      { scope: "bank-accounts.read", type: "read", label: "Read" },
      { scope: "bank-accounts.write", type: "write", label: "Write" },
    ],
  },
  {
    key: "customers",
    name: "Customers",
    description: "Access to customer data",
    scopes: [
      { scope: "customers.read", type: "read", label: "Read" },
      { scope: "customers.write", type: "write", label: "Write" },
    ],
  },
  {
    key: "documents",
    name: "Documents",
    description: "Access to document data",
    scopes: [
      { scope: "documents.read", type: "read", label: "Read" },
      { scope: "documents.write", type: "write", label: "Write" },
    ],
  },
  {
    key: "inbox",
    name: "Inbox",
    description: "Access to inbox data",
    scopes: [
      { scope: "inbox.read", type: "read", label: "Read" },
      { scope: "inbox.write", type: "write", label: "Write" },
    ],
  },
  {
    key: "invoices",
    name: "Invoices",
    description: "Access to invoice data",
    scopes: [
      { scope: "invoices.read", type: "read", label: "Read" },
      { scope: "invoices.write", type: "write", label: "Write" },
    ],
  },
  {
    key: "transactions",
    name: "Transactions",
    description: "Access to transaction data",
    scopes: [
      { scope: "transactions.read", type: "read", label: "Read" },
      { scope: "transactions.write", type: "write", label: "Write" },
    ],
  },
  {
    key: "teams",
    name: "Teams",
    description: "Access to team data",
    scopes: [
      { scope: "teams.read", type: "read", label: "Read" },
      { scope: "teams.write", type: "write", label: "Write" },
    ],
  },
  {
    key: "users",
    name: "Users",
    description: "Access to user data",
    scopes: [
      { scope: "users.read", type: "read", label: "Read" },
      { scope: "users.write", type: "write", label: "Write" },
    ],
  },
  {
    key: "tracker-entries",
    name: "Tracker Entries",
    description: "Access to tracker entry data",
    scopes: [
      { scope: "tracker-entries.read", type: "read", label: "Read" },
      {
        scope: "tracker-entries.write",
        type: "write",
        label: "Write",
      },
    ],
  },
  {
    key: "tracker-projects",
    name: "Tracker Projects",
    description: "Access to tracker project data",
    scopes: [
      { scope: "tracker-projects.read", type: "read", label: "Read" },
      {
        scope: "tracker-projects.write",
        type: "write",
        label: "Write",
      },
    ],
  },
  {
    key: "tags",
    name: "Tags",
    description: "Access to tag data",
    scopes: [
      { scope: "tags.read", type: "read", label: "Read" },
      { scope: "tags.write", type: "write", label: "Write" },
    ],
  },
  {
    key: "reports",
    name: "Reports",
    description: "Access to reports data",
    scopes: [{ scope: "reports.read", type: "read", label: "Read" }],
  },
  {
    key: "search",
    name: "Search",
    description: "Access to search functionality",
    scopes: [{ scope: "search.read", type: "read", label: "Read" }],
  },
  {
    key: "notifications",
    name: "Notifications",
    description: "Access to notifications data",
    scopes: [
      { scope: "notifications.read", type: "read", label: "Read" },
      { scope: "notifications.write", type: "write", label: "Write" },
    ],
  },
] as const;

export const getScopeDescription = (scope: string) => {
  // Handle special API-level scopes
  if (scope === "apis.all") {
    return {
      label: "Full access to all resources",
    };
  }

  if (scope === "apis.read") {
    return {
      label: "Read-only access to all resources",
    };
  }

  // Find the resource and scope
  for (const resource of RESOURCES) {
    const foundScope = resource.scopes.find((s) => s.scope === scope);
    if (foundScope) {
      return {
        label: `${foundScope.label} access to ${resource.name}`,
      };
    }
  }

  // Fallback for unknown scopes
  return {
    label: scope,
  };
};
</file>

<file path="apps/dashboard/src/utils/teller.ts">
import crypto from "node:crypto";

// https://teller.io/docs/api/webhooks#verifying-messages
export const validateTellerSignature = (params: {
  signatureHeader: string | null;
  text: string;
}): boolean => {
  if (!params.signatureHeader) {
    return false;
  }

  const { timestamp, signatures } = parseTellerSignatureHeader(
    params.signatureHeader,
  );

  const threeMinutesAgo = Math.floor(Date.now() / 1000) - 3 * 60;

  if (Number.parseInt(timestamp) < threeMinutesAgo) {
    return false;
  }

  // Ensure the text is used as a raw string
  const signedMessage = `${timestamp}.${params.text}`;
  const calculatedSignature = crypto
    .createHmac("sha256", process.env.TELLER_SIGNING_SECRET!)
    .update(signedMessage)
    .digest("hex");

  // Compare calculated signature with provided signatures
  return signatures.includes(calculatedSignature);
};

export const parseTellerSignatureHeader = (
  header: string,
): { timestamp: string; signatures: string[] } => {
  const parts = header.split(",");
  const timestampPart = parts.find((p) => p.startsWith("t="));
  const signatureParts = parts.filter((p) => p.startsWith("v1="));

  if (!timestampPart) {
    throw new Error("No timestamp in Teller-Signature header");
  }

  const timestamp = timestampPart.split("=")[1];
  const signatures = signatureParts
    .map((p) => p.split("=")[1])
    .filter((sig): sig is string => sig !== undefined);

  if (!timestamp || signatures.some((sig) => !sig)) {
    throw new Error("Invalid Teller-Signature header format");
  }

  return { timestamp, signatures };
};
</file>

<file path="apps/dashboard/src/utils/tracker.ts">
import type { RouterOutputs } from "@api/trpc/routers/_app";
import { tz } from "@date-fns/tz";
import { UTCDate, utc } from "@date-fns/utc";
import {
  addDays,
  addMinutes,
  addSeconds,
  differenceInSeconds,
  eachDayOfInterval,
  format,
  isValid,
  parse,
  parseISO,
  setHours,
  setMinutes,
} from "date-fns";

export const NEW_EVENT_ID = "new-event";

// API Response type from the router
type ApiTrackerRecord =
  RouterOutputs["trackerEntries"]["byDate"]["data"][number];

// Internal tracker record type with consistent Date handling
export interface TrackerRecord {
  id: string;
  date: string | null;
  description: string | null;
  duration: number | null;
  start: Date;
  stop: Date;
  user: {
    id: string;
    fullName: string | null;
    avatarUrl: string | null;
  } | null;
  trackerProject: {
    id: string;
    name: string;
    currency: string | null;
    rate: number | null;
    customer: {
      id: string;
      name: string;
    } | null;
  } | null;
}

/**
 * Creates a safe Date using UTCDate for better UTC handling
 */
export const createSafeDate = (
  dateInput: string | Date | null | undefined,
  fallback?: Date,
): Date => {
  if (!dateInput) return fallback || new UTCDate();

  if (typeof dateInput === "string") {
    // Try parseISO first (handles ISO 8601 formats)
    const date = parseISO(dateInput);
    if (isValid(date)) {
      return date;
    }

    // Try UTCDate constructor as final fallback
    try {
      const utcDate = utc(dateInput);
      if (isValid(utcDate)) {
        return new Date(utcDate.getTime());
      }
    } catch (error) {
      console.warn("Date parsing failed:", error);
    }

    return fallback || new UTCDate();
  }

  return isValid(dateInput) ? dateInput : fallback || new UTCDate();
};

/**
 * Format time from date with optional timezone support
 */
export const formatTimeFromDate = (
  date: Date | string | null,
  timezone?: string,
): string => {
  const safeDate = createSafeDate(date);

  if (timezone && timezone !== "UTC") {
    try {
      const createTZDate = tz(timezone);
      const tzDate = createTZDate(safeDate);
      return format(tzDate, "HH:mm");
    } catch (error) {
      console.warn("Timezone formatting failed:", error);
    }
  }

  return format(safeDate, "HH:mm");
};

/**
 * Parse time with midnight crossing support using timezone-aware parsing
 */
export const parseTimeWithMidnightCrossing = (
  startTime: string,
  stopTime: string,
  baseDate: Date,
  timezone?: string,
): { start: Date; stop: Date; duration: number } => {
  if (timezone && timezone !== "UTC") {
    try {
      const createTZDate = tz(timezone);

      // Create timezone-aware base date
      const tzBaseDate = createTZDate(baseDate);

      // Parse times in the timezone context
      const startDate = parse(startTime, "HH:mm", tzBaseDate);
      let stopDate = parse(stopTime, "HH:mm", tzBaseDate);

      // If stop time is before start time, assume it's on the next day
      if (stopDate < startDate) {
        stopDate = addDays(stopDate, 1);
      }

      const duration = differenceInSeconds(stopDate, startDate);

      return {
        start: new Date(startDate.getTime()),
        stop: new Date(stopDate.getTime()),
        duration,
      };
    } catch (error) {
      console.warn("Timezone time parsing failed:", error);
    }
  }

  // Fallback to UTC parsing
  const startDate = parse(startTime, "HH:mm", baseDate);
  let stopDate = parse(stopTime, "HH:mm", baseDate);

  // If stop time is before start time, assume it's on the next day
  if (stopDate < startDate) {
    stopDate = addDays(stopDate, 1);
  }

  const duration = differenceInSeconds(stopDate, startDate);

  return { start: startDate, stop: stopDate, duration };
};

/**
 * Get slot from date with timezone support (already updated)
 */
export const getSlotFromDate = (
  date: Date | string | null,
  timezone?: string,
): number => {
  const safeDate = createSafeDate(date);

  if (timezone && timezone !== "UTC") {
    try {
      // Use tz() function to create timezone-aware date
      const createTZDate = tz(timezone);
      const tzDate = createTZDate(safeDate);

      return tzDate.getHours() * 4 + Math.floor(tzDate.getMinutes() / 15);
    } catch (error) {
      console.warn("TZDate slot calculation failed:", error);
      // Fallback to browser timezone
    }
  }

  // Fallback to browser timezone (for backward compatibility)
  return safeDate.getHours() * 4 + Math.floor(safeDate.getMinutes() / 15);
};

/**
 * Calculate duration between dates with timezone support
 */
export const calculateDuration = (
  start: Date | string | null,
  stop: Date | string | null,
): number => {
  const startDate = createSafeDate(start);
  const stopDate = createSafeDate(stop);

  // If stop is before start, assume stop is on the next day
  if (stopDate < startDate) {
    const nextDayStop = addDays(stopDate, 1);
    return differenceInSeconds(nextDayStop, startDate);
  }

  return differenceInSeconds(stopDate, startDate);
};

/**
 * Format hour with timezone support
 */
export const formatHour = (
  hour: number,
  timeFormat?: number | null,
  timezone?: string,
) => {
  // Create a simple date with the hour - no timezone conversion needed for labels
  const date = new Date(2024, 0, 1, hour, 0, 0, 0); // Use arbitrary date, just set the hour
  return format(date, timeFormat === 12 ? "hh:mm a" : "HH:mm");
};

/**
 * Create new event with timezone-aware time creation
 */
export const createNewEvent = (
  slot: number,
  selectedProjectId: string | null,
  selectedDate?: string | null,
  timezone?: string,
): TrackerRecord => {
  const baseDate = selectedDate ? parseISO(selectedDate) : new UTCDate();

  if (timezone && timezone !== "UTC") {
    try {
      const createTZDate = tz(timezone);
      const tzBaseDate = createTZDate(baseDate);

      const startDate = setMinutes(
        setHours(tzBaseDate, Math.floor(slot / 4)),
        (slot % 4) * 15,
      );
      const endDate = addMinutes(startDate, 15);

      return {
        id: NEW_EVENT_ID,
        date: format(tzBaseDate, "yyyy-MM-dd"),
        description: null,
        duration: 15 * 60, // 15 minutes in seconds
        start: new Date(startDate.getTime()),
        stop: new Date(endDate.getTime()),
        user: null,
        trackerProject: selectedProjectId
          ? {
              id: selectedProjectId,
              name: "",
              currency: null,
              rate: null,
              customer: null,
            }
          : null,
      };
    } catch (error) {
      console.warn("Timezone event creation failed:", error);
    }
  }

  // Fallback to UTC creation
  const startDate = setMinutes(
    setHours(baseDate, Math.floor(slot / 4)),
    (slot % 4) * 15,
  );
  const endDate = addMinutes(startDate, 15);

  return {
    id: NEW_EVENT_ID,
    date: format(startDate, "yyyy-MM-dd"),
    description: null,
    duration: 15 * 60, // 15 minutes in seconds
    start: startDate,
    stop: endDate,
    user: null,
    trackerProject: selectedProjectId
      ? {
          id: selectedProjectId,
          name: "",
          currency: null,
          rate: null,
          customer: null,
        }
      : null,
  };
};

// Tracker record transformation
export const transformApiRecord = (
  apiRecord: ApiTrackerRecord,
  selectedDate: string | null,
): TrackerRecord => {
  const start = apiRecord.start
    ? parseISO(apiRecord.start)
    : parseISO(`${apiRecord.date || selectedDate}T09:00:00`);

  const stop = apiRecord.stop
    ? parseISO(apiRecord.stop)
    : addSeconds(start, apiRecord.duration || 0);

  return {
    id: apiRecord.id,
    date: apiRecord.date,
    description: apiRecord.description,
    duration: apiRecord.duration,
    start: isValid(start) ? start : new Date(),
    stop: isValid(stop)
      ? stop
      : addMinutes(isValid(start) ? start : new Date(), 15),
    user: apiRecord.user,
    trackerProject: apiRecord.trackerProject
      ? {
          id: apiRecord.trackerProject.id,
          name: apiRecord.trackerProject.name || "",
          currency: apiRecord.trackerProject.currency,
          rate: apiRecord.trackerProject.rate,
          customer: apiRecord.trackerProject.customer,
        }
      : null,
  };
};

export const updateEventTime = (
  event: TrackerRecord,
  start: Date,
  stop: Date,
): TrackerRecord => {
  return {
    ...event,
    start: isValid(start) ? start : event.start,
    stop: isValid(stop) ? stop : event.stop,
    duration: calculateDuration(start, stop),
  };
};

// Date range utilities
export function sortDates(dates: string[]) {
  return dates.sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
}

export function getTrackerDates(
  range: string[] | null,
  selectedDate: string | null,
): Date[] {
  if (range) {
    return sortDates(range).map((dateString) => new Date(dateString));
  }

  if (selectedDate) {
    return [new Date(selectedDate)];
  }

  return [new Date()];
}

export const getDates = (
  selectedDate: string | null,
  sortedRange: string[] | null,
): string[] => {
  if (selectedDate) return [selectedDate];
  if (sortedRange && sortedRange.length === 2) {
    const [start, end] = sortedRange;
    if (start && end) {
      return eachDayOfInterval({
        start: parseISO(start),
        end: parseISO(end),
      }).map((date) => format(date, "yyyy-MM-dd"));
    }
  }
  return [];
};

// Validation utilities
export const isValidTimeSlot = (slot: number): boolean => {
  return slot >= 0 && slot < 96; // 24 hours * 4 slots per hour
};

export const isValidDateString = (dateStr: string): boolean => {
  return isValid(parseISO(dateStr));
};

// Form data conversion utilities
export const convertToFormData = (record: TrackerRecord) => {
  return {
    id: record.id === NEW_EVENT_ID ? undefined : record.id,
    start: formatTimeFromDate(record.start),
    stop: formatTimeFromDate(record.stop),
    projectId: record.trackerProject?.id || "",
    description: record.description || "",
    duration: calculateDuration(record.start, record.stop),
  };
};

export const convertFromFormData = (
  formData: {
    id?: string;
    start: string;
    stop: string;
    projectId: string;
    assignedId?: string;
    description?: string;
    duration: number;
  },
  baseDate: Date,
  dates: string[],
  timezone?: string, // Add timezone parameter
): {
  id?: string;
  start: string;
  stop: string;
  dates: string[];
  assignedId: string | null;
  projectId: string;
  description: string | null;
  duration: number;
} => {
  const {
    start: startDate,
    stop: stopDate,
    duration,
  } = parseTimeWithMidnightCrossing(
    formData.start,
    formData.stop,
    baseDate,
    timezone,
  );

  return {
    id: formData.id === NEW_EVENT_ID ? undefined : formData.id,
    start: startDate.toISOString(),
    stop: stopDate.toISOString(),
    dates,
    assignedId: formData.assignedId || null,
    projectId: formData.projectId,
    description: formData.description || null,
    duration: duration,
  };
};
</file>

<file path="apps/dashboard/src/utils/transaction-filters.ts">
// Type for transaction filters based on the schema
export type TransactionFilters = {
  q?: string | null;
  attachments?: "exclude" | "include" | null;
  start?: string | null;
  end?: string | null;
  categories?: string[] | null;
  tags?: string[] | null;
  accounts?: string[] | null;
  assignees?: string[] | null;
  amount_range?: number[] | null;
  amount?: string[] | null;
  recurring?: ("all" | "weekly" | "monthly" | "annually")[] | null;
  statuses?: ("completed" | "uncompleted" | "archived" | "excluded")[] | null;
};

// Generic filter state type
export type FilterState = Record<string, any>;

// Hook return type for consistency across all filter hooks
export type FilterHookReturn<T = FilterState> = {
  filter: T;
  setFilter: (filters: T) => void;
  hasFilters: boolean;
  clearAllFilters: () => void;
};

// Default empty filter state
export const EMPTY_FILTER_STATE: TransactionFilters = {
  q: null,
  attachments: null,
  start: null,
  end: null,
  categories: null,
  tags: null,
  accounts: null,
  assignees: null,
  amount_range: null,
  amount: null,
  recurring: null,
  statuses: null,
};

/**
 * Check if a single filter value is active (has meaningful content)
 */
export function isFilterValueActive(value: any): boolean {
  if (value === null || value === undefined || value === "") return false;
  if (Array.isArray(value)) return value.length > 0;
  return true;
}

/**
 * Check if a filter object has any active filters
 */
export function hasActiveFilters(filters: Record<string, any>): boolean {
  return Object.values(filters).some(isFilterValueActive);
}

/**
 * Clean filters by removing null/undefined/empty values
 */
export function cleanFilters(
  filters: Record<string, any>,
): Record<string, any> {
  return Object.fromEntries(
    Object.entries(filters).filter(([_, value]) => isFilterValueActive(value)),
  );
}

/**
 * Compare two filter objects for equality
 */
export function areFiltersEqual(
  filters1: Record<string, any>,
  filters2: Record<string, any>,
): boolean {
  const normalize = (filters: Record<string, any>) => {
    const cleaned = cleanFilters(filters);
    return JSON.stringify(cleaned, Object.keys(cleaned).sort());
  };

  return normalize(filters1) === normalize(filters2);
}

/**
 * Check if URL params contain any active filters
 */
export function hasActiveUrlFilters(urlFilters: Record<string, any>): boolean {
  return hasActiveFilters(urlFilters);
}

/**
 * Create an empty filter state for any entity
 */
export function createEmptyFilterState<T extends Record<string, any>>(
  keys: (keyof T)[],
): T {
  return keys.reduce((acc, key) => {
    (acc as any)[key] = null;
    return acc;
  }, {} as T);
}
</file>

<file path="apps/dashboard/src/utils/upload.ts">
import { stripSpecialCharacters } from "@midday/utils";
import type { SupabaseClient } from "@supabase/supabase-js";
import * as tus from "tus-js-client";

type ResumableUploadParmas = {
  file: File;
  path: string[];
  bucket: string;
  onProgress?: (bytesUploaded: number, bytesTotal: number) => void;
};

export async function resumableUpload(
  client: SupabaseClient,
  { file, path, bucket, onProgress }: ResumableUploadParmas,
) {
  const {
    data: { session },
  } = await client.auth.getSession();

  const filename = stripSpecialCharacters(file.name);

  const fullPath = decodeURIComponent([...path, filename].join("/"));

  return new Promise((resolve, reject) => {
    const upload = new tus.Upload(file, {
      endpoint: `https://${process.env.NEXT_PUBLIC_SUPABASE_ID}.supabase.co/storage/v1/upload/resumable`,
      retryDelays: [0, 3000, 5000, 10000],
      headers: {
        authorization: `Bearer ${session?.access_token}`,
        // optionally set upsert to true to overwrite existing files
        "x-upsert": "true",
      },
      uploadDataDuringCreation: true,
      // Important if you want to allow re-uploading the same file https://github.com/tus/tus-js-client/blob/main/docs/api.md#removefingerprintonsuccess
      removeFingerprintOnSuccess: true,
      metadata: {
        bucketName: bucket,
        objectName: fullPath,
        contentType: file.type,
        cacheControl: "3600",
      },
      // NOTE: it must be set to 6MB (for now) do not change it
      chunkSize: 6 * 1024 * 1024,
      onError: (error) => {
        reject(error);
      },
      onProgress,
      onSuccess: () => {
        resolve({
          ...upload,
          filename,
        });
      },
    });

    // Check if there are any previous uploads to continue.
    return upload.findPreviousUploads().then((previousUploads) => {
      // Found previous uploads so we select the first one.
      if (previousUploads.length) {
        // @ts-expect-error
        upload.resumeFromPreviousUpload(previousUploads[0]);
      }

      upload.start();
    });
  });
}
</file>

<file path="apps/dashboard/src/instrumentation-client.ts">
// This file configures the initialization of Sentry on the client.
// The added config here will be used whenever a users loads a page in their browser.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

// Only import and initialize Sentry in production
let onRouterTransitionStart: () => void;

if (process.env.NODE_ENV === "production") {
  const Sentry = require("@sentry/nextjs");

  Sentry.init({
    dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
    environment: process.env.NODE_ENV,

    // Lower trace sampling to save quota
    tracesSampleRate: 0.1,

    // Enable logs
    enableLogs: true,

    // Disable debug
    debug: false,
  });

  onRouterTransitionStart = Sentry.captureRouterTransitionStart;
} else {
  onRouterTransitionStart = () => {};
}

export { onRouterTransitionStart };
</file>

<file path="apps/dashboard/src/instrumentation.ts">
export async function register() {
  // Only load Sentry configs in production
  if (process.env.NODE_ENV === "production") {
    if (process.env.NEXT_RUNTIME === "nodejs") {
      await import("../sentry.server.config");
    }

    if (process.env.NEXT_RUNTIME === "edge") {
      await import("../sentry.edge.config");
    }
  }
}

// Only export Sentry function in production
export const onRequestError =
  process.env.NODE_ENV === "production"
    ? require("@sentry/nextjs").captureRequestError
    : () => {};
</file>

<file path="apps/dashboard/src/middleware.ts">
import { updateSession } from "@midday/supabase/middleware";
import { createClient } from "@midday/supabase/server";
import { createI18nMiddleware } from "next-international/middleware";
import { type NextRequest, NextResponse } from "next/server";

const I18nMiddleware = createI18nMiddleware({
  locales: ["en"],
  defaultLocale: "en",
  urlMappingStrategy: "rewrite",
});

export async function middleware(request: NextRequest) {
  const response = await updateSession(request, I18nMiddleware(request));
  const supabase = await createClient();
  const url = new URL("/", request.url);
  const nextUrl = request.nextUrl;

  const pathnameLocale = nextUrl.pathname.split("/", 2)?.[1];

  // Remove the locale from the pathname
  const pathnameWithoutLocale = pathnameLocale
    ? nextUrl.pathname.slice(pathnameLocale.length + 1)
    : nextUrl.pathname;

  // Create a new URL without the locale in the pathname
  const newUrl = new URL(pathnameWithoutLocale || "/", request.url);

  const encodedSearchParams = `${newUrl?.pathname?.substring(1)}${
    newUrl.search
  }`;

  const {
    data: { session },
  } = await supabase.auth.getSession();

  // 1. Not authenticated
  if (
    !session &&
    newUrl.pathname !== "/login" &&
    !newUrl.pathname.includes("/i/") &&
    !newUrl.pathname.includes("/s/") &&
    !newUrl.pathname.includes("/verify") &&
    !newUrl.pathname.includes("/all-done") &&
    !newUrl.pathname.includes("/desktop/search")
  ) {
    const url = new URL("/login", request.url);

    if (encodedSearchParams) {
      url.searchParams.append("return_to", encodedSearchParams);
    }

    return NextResponse.redirect(url);
  }

  // If authenticated, proceed with other checks
  if (session) {
    if (newUrl.pathname !== "/teams/create" && newUrl.pathname !== "/teams") {
      // Check if the URL contains an invite code
      const inviteCodeMatch = newUrl.pathname.startsWith("/teams/invite/");

      if (inviteCodeMatch) {
        // Allow proceeding to invite page even without setup
        // Redirecting with the original path including locale if present
        return NextResponse.redirect(
          `${url.origin}${request.nextUrl.pathname}`,
        );
      }
    }

    // 3. Check MFA Verification
    const { data: mfaData } =
      await supabase.auth.mfa.getAuthenticatorAssuranceLevel();
    if (
      mfaData &&
      mfaData.nextLevel === "aal2" &&
      mfaData.nextLevel !== mfaData.currentLevel &&
      newUrl.pathname !== "/mfa/verify"
    ) {
      const url = new URL("/mfa/verify", request.url);

      if (encodedSearchParams) {
        url.searchParams.append("return_to", encodedSearchParams);
      }

      // Redirect to MFA verification if needed and not already there
      return NextResponse.redirect(url);
    }
  }

  // If all checks pass, return the original or updated response
  return response;
}

export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico|api).*)"],
};
</file>

<file path="apps/dashboard/.env-example">
# Supabase
NEXT_PUBLIC_SUPABASE_URL=http://localhost:54321
NEXT_PUBLIC_SUPABASE_ANON_KEY=
NEXT_PUBLIC_SUPABASE_ID=
NEXT_PUBLIC_URL=http://localhost:3001
NEXT_PUBLIC_API_URL=http://localhost:3003
SUPABASE_SERVICE_KEY=

# Resend
RESEND_API_KEY=
RESEND_AUDIENCE_ID=

# GoCardLess
GOCARDLESS_SECRET_ID=
GOCARDLESS_SECRET_KEY=

# Upstash
UPSTASH_REDIS_REST_URL=
UPSTASH_REDIS_REST_TOKEN=

# Trigger
TRIGGER_SECRET_KEY=
TRIGGER_PROJECT_ID=

# Teller (Base 64 encoded certificate)
TELLER_CERTIFICATE=
TELLER_CERTIFICATE_PRIVATE_KEY=
NEXT_PUBLIC_TELLER_APPLICATION_ID=
NEXT_PUBLIC_TELLER_ENVIRONMENT=
TELLER_SIGNING_SECRET=

# Plaid
PLAID_CLIENT_ID=
PLAID_SECRET=
NEXT_PUBLIC_PLAID_ENVIRONMENT=

# Github
GITHUB_TOKEN=

# Plain
PLAIN_API_KEY=

# OpenAI
OPENAI_API_KEY=

# Mistral AI
MISTRAL_API_KEY=

# OpenPanel
NEXT_PUBLIC_OPENPANEL_CLIENT_ID=
OPENPANEL_SECRET_KEY=

# Webhook
WEBHOOK_SECRET_KEY=6c369443-1a88-444e-b459-7e662c1fff9e

# Engine
ENGINE_API_KEY=secret
ENGINE_API_URL=http://localhost:3002

# Azure
AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT=
AZURE_DOCUMENT_INTELLIGENCE_KEY=

# Google Maps
NEXT_PUBLIC_GOOGLE_API_KEY=

# VatCheckAPI
VATCHECKAPI_API_KEY=

# Invoice
INVOICE_JWT_SECRET=secret

# Midday Cache
MIDDAY_CACHE_API_SECRET=

# Polar
POLAR_ACCESS_TOKEN=
POLAR_ENVIRONMENT=sandbox
POLAR_WEBHOOK_SECRET=

# Sentry
NEXT_PUBLIC_SENTRY_DSN=
</file>

<file path="apps/dashboard/image-loader.ts">
interface ImageLoaderParams {
  src: string;
  width: number;
  quality?: number;
}

const CDN_URL = "https://midday.ai";

export default function imageLoader({
  src,
  width,
  quality = 80,
}: ImageLoaderParams): string {
  if (src.startsWith("/_next")) {
    return `${CDN_URL}/cdn-cgi/image/width=${width},quality=${quality}/https://app.midday.ai${src}`;
  }
  return `${CDN_URL}/cdn-cgi/image/width=${width},quality=${quality}/${src}`;
}
</file>

<file path="apps/dashboard/next.config.mjs">
import { withSentryConfig } from "@sentry/nextjs";

/** @type {import("next").NextConfig} */
const config = {
  poweredByHeader: false,
  reactStrictMode: true,
  images: {
    loader: "custom",
    loaderFile: "./image-loader.ts",
    qualities: [80, 100],
    remotePatterns: [
      {
        protocol: "https",
        hostname: "**",
      },
    ],
  },
  transpilePackages: [
    "@midday/ui",
    "@midday/tailwind",
    "@midday/invoice",
    "@midday/api",
  ],
  serverExternalPackages: ["@react-pdf/renderer", "pdfjs-dist"],
  eslint: {
    ignoreDuringBuilds: true,
  },
  typescript: {
    ignoreBuildErrors: true,
  },
  devIndicators: false,
  async headers() {
    return [
      {
        source: "/((?!api/proxy).*)",
        headers: [
          {
            key: "X-Frame-Options",
            value: "DENY",
          },
        ],
      },
    ];
  },
};

// Only apply Sentry configuration in production
const isProduction = process.env.NODE_ENV === "production";

export default isProduction
  ? withSentryConfig(config, {
      org: process.env.SENTRY_ORG,
      project: process.env.SENTRY_PROJECT,
      authToken: process.env.SENTRY_AUTH_TOKEN,
      telemetry: false,

      // Only print logs for uploading source maps in CI
      silent: !process.env.CI,

      // Upload source maps for better stack traces
      widenClientFileUpload: true,

      // Tree-shake Sentry logger statements to reduce bundle size
      disableLogger: true,
    })
  : config;
</file>

<file path="apps/dashboard/package.json">
{
  "name": "@midday/dashboard",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "build": "NODE_ENV=production next build",
    "clean": "git clean -xdf .next .turbo node_modules",
    "dev": "TZ=UTC next dev -p 3001 --turbopack",
    "lint": "biome check .",
    "lint:fix": "biome check --write .",
    "format": "biome format --write .",
    "start": "next start",
    "typecheck": "tsc --noEmit",
    "test": "bun test",
    "test:watch": "bun test --watch"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.3.22",
    "@date-fns/tz": "^1.2.0",
    "@date-fns/utc": "^2.1.0",
    "@hookform/resolvers": "^5.1.1",
    "@midday/api": "workspace:*",
    "@midday/app-store": "workspace:*",
    "@midday/desktop-client": "workspace:*",
    "@midday/engine": "workspace:*",
    "@midday/events": "workspace:*",
    "@midday/inbox": "workspace:*",
    "@midday/invoice": "workspace:*",
    "@midday/location": "workspace:*",
    "@midday/supabase": "workspace:*",
    "@midday/ui": "workspace:*",
    "@midday/utils": "workspace:*",
    "@number-flow/react": "^0.5.10",
    "@polar-sh/nextjs": "^0.4.0",
    "@polar-sh/sdk": "^0.33.1",
    "@react-google-maps/api": "^2.20.6",
    "@react-pdf/renderer": "^4.3.0",
    "@sentry/nextjs": "^10",
    "@tanstack/react-query": "^5.85.5",
    "@tanstack/react-table": "^8.21.3",
    "@team-plain/typescript-sdk": "^5.9.0",
    "@trigger.dev/react-hooks": "4.0.1",
    "@trigger.dev/sdk": "4.0.1",
    "@trpc/client": "^11.5.0",
    "@trpc/tanstack-react-query": "^11.5.0",
    "ai": "^4.3.19",
    "change-case": "^5.4.4",
    "date-fns": "^4.1.0",
    "file-saver": "^2.0.5",
    "framer-motion": "^12.18.1",
    "geist": "^1.4.2",
    "little-date": "^1.0.0",
    "lottie-react": "^2.4.1",
    "next": "15.5.2",
    "next-international": "1.3.1",
    "next-safe-action": "^7.10.8",
    "next-themes": "^0.4.6",
    "nuqs": "^2.4.3",
    "papaparse": "^5.5.3",
    "pdfjs-dist": "4.8.69",
    "react": "19.1.1",
    "react-dom": "19.1.1",
    "react-colorful": "^5.6.1",
    "react-dropzone": "^14.3.8",
    "react-hook-form": "^7.57.0",
    "react-hotkeys-hook": "^5.1.0",
    "react-intersection-observer": "^9.16.0",
    "react-markdown": "^10.1.0",
    "react-pdf": "^9.2.1",
    "react-plaid-link": "^4.0.1",
    "react-use-draggable-scroll": "^0.4.7",
    "recharts": "^2.15.3",
    "resend": "^4.6.0",
    "server-only": "^0.0.1",
    "sharp": "0.34.1",
    "tus-js-client": "4.3.1",
    "use-places-autocomplete": "^4.0.1",
    "usehooks-ts": "^3.1.1",
    "zod": "3.25.64",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@midday/tsconfig": "workspace:*",
    "@types/file-saver": "^2.0.7",
    "@types/node": "^24.0.1",
    "@types/papaparse": "^5.3.16",
    "@types/react": "19.1.8",
    "@types/react-dom": "19.1.6",
    "typescript": "^5.9.2"
  }
}
</file>

<file path="apps/dashboard/postcss.config.cjs">
// @ts-expect-error - No types for postcss
module.exports = require("@midday/ui/postcss");
</file>

<file path="apps/dashboard/README.md">
## Dashboard
</file>

<file path="apps/dashboard/sentry.edge.config.ts">
// This file configures the initialization of Sentry for edge features (middleware, edge routes, and so on).
// The config you add here will be used whenever one of the edge features is loaded.
// Note that this config is unrelated to the Vercel Edge Runtime and is also required when running locally.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

// Only import and initialize Sentry in production
if (process.env.NODE_ENV === "production") {
  const Sentry = require("@sentry/nextjs");

  Sentry.init({
    dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
    environment: process.env.NODE_ENV,

    // Lower trace sampling to save quota
    tracesSampleRate: 0.1,

    // Enable logs
    enableLogs: true,

    // Disable debug
    debug: false,
  });
}
</file>

<file path="apps/dashboard/sentry.server.config.ts">
// This file configures the initialization of Sentry on the server.
// The config you add here will be used whenever the server handles a request.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

// Only import and initialize Sentry in production
if (process.env.NODE_ENV === "production") {
  const Sentry = require("@sentry/nextjs");

  Sentry.init({
    dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
    environment: process.env.NODE_ENV,

    // Lower trace sampling in production to save quota
    tracesSampleRate: 0.1,

    // Enable logs to be sent to Sentry
    enableLogs: true,

    // Setting this option to true will print useful information to the console while you're setting up Sentry.
    debug: false,
  });
}
</file>

<file path="apps/dashboard/tailwind.config.ts">
import desktopPlugin from "@midday/desktop-client/desktop-variants";
import baseConfig from "@midday/ui/tailwind.config";
import type { Config } from "tailwindcss";

export default {
  content: [
    "./src/**/*.{ts,tsx}",
    "../../packages/ui/src/**/*.{ts,tsx}",
    "../../packages/invoice/src/**/*.{ts,tsx}",
  ],
  presets: [baseConfig],
  plugins: [desktopPlugin],
} satisfies Config;
</file>

<file path="apps/dashboard/tsconfig.json">
{
  "extends": "@midday/tsconfig/nextjs.json",
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@api/*": ["../api/src/*"],
      "@engine/*": ["../engine/src/*"],
      "@jobs/*": ["../../packages/jobs/src/*"],
      "@db/*": ["../../packages/db/src/*"]
    },
    "strict": true
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "../../types",
    "next-env.d.ts",
    "next.config.js",
    "tailwind.config.ts",
    ".next/types/**/*.ts"
  ],
  "exclude": ["node_modules", ".next"]
}
</file>

<file path="apps/dashboard/vercel.json">
{
  "version": 2,
  "public": false,
  "github": {
    "enabled": false
  },
  "regions": ["fra1", "iad1", "sfo1"]
}
</file>

</files>
